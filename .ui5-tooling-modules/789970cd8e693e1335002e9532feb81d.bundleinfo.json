{
  "_entries": [
    {
      "name": "@langchain/core/messages",
      "path": "/Users/fuaddaniels/workspaces/sandbox/chatapp/node_modules/@langchain/core/messages.cjs",
      "lastModified": 1727346566153,
      "type": "module",
      "code": "sap.ui.define(['za/co/fuad/chatapp/resources/messages2'], (function (messages) { 'use strict';\n\n\ttry { Object.defineProperty(messages.messages, \"__\" + \"esModule\", { value: true }); messages.messages.default = messages.messages; } catch (ex) {}\n\n\treturn messages.messages;\n\n}));\n"
    },
    {
      "name": "@langchain/openai",
      "path": "/Users/fuaddaniels/workspaces/sandbox/chatapp/node_modules/@langchain/openai/index.cjs",
      "lastModified": 1727346566109,
      "type": "module",
      "code": "sap.ui.define(['za/co/fuad/chatapp/resources/messages2'], (function (messages$1) { 'use strict';\n\n  var dist = {};\n\n  var openai$2 = {exports: {}};\n\n  var error = {};\n\n  var lookup$1 = [];\n  var revLookup$1 = [];\n  var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n  var inited = false;\n  function init () {\n    inited = true;\n    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    for (var i = 0, len = code.length; i < len; ++i) {\n      lookup$1[i] = code[i];\n      revLookup$1[code.charCodeAt(i)] = i;\n    }\n\n    revLookup$1['-'.charCodeAt(0)] = 62;\n    revLookup$1['_'.charCodeAt(0)] = 63;\n  }\n\n  function toByteArray$1 (b64) {\n    if (!inited) {\n      init();\n    }\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n\n    if (len % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr$1(len * 3 / 4 - placeHolders);\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len;\n\n    var L = 0;\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];\n      arr[L++] = (tmp >> 16) & 0xFF;\n      arr[L++] = (tmp >> 8) & 0xFF;\n      arr[L++] = tmp & 0xFF;\n    }\n\n    if (placeHolders === 2) {\n      tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);\n      arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n      tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);\n      arr[L++] = (tmp >> 8) & 0xFF;\n      arr[L++] = tmp & 0xFF;\n    }\n\n    return arr\n  }\n\n  function tripletToBase64$1 (num) {\n    return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F]\n  }\n\n  function encodeChunk$1 (uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n      output.push(tripletToBase64$1(tmp));\n    }\n    return output.join('')\n  }\n\n  function fromByteArray$1 (uint8) {\n    if (!inited) {\n      init();\n    }\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var output = '';\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n      parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n      tmp = uint8[len - 1];\n      output += lookup$1[tmp >> 2];\n      output += lookup$1[(tmp << 4) & 0x3F];\n      output += '==';\n    } else if (extraBytes === 2) {\n      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n      output += lookup$1[tmp >> 10];\n      output += lookup$1[(tmp >> 4) & 0x3F];\n      output += lookup$1[(tmp << 2) & 0x3F];\n      output += '=';\n    }\n\n    parts.push(output);\n\n    return parts.join('')\n  }\n\n  function read (buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? (nBytes - 1) : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n\n    i += d;\n\n    e = s & ((1 << (-nBits)) - 1);\n    s >>= (-nBits);\n    nBits += eLen;\n    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    m = e & ((1 << (-nBits)) - 1);\n    e >>= (-nBits);\n    nBits += mLen;\n    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    if (e === 0) {\n      e = 1 - eBias;\n    } else if (e === eMax) {\n      return m ? NaN : ((s ? -1 : 1) * Infinity)\n    } else {\n      m = m + Math.pow(2, mLen);\n      e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n  }\n\n  function write (buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n    var i = isLE ? 0 : (nBytes - 1);\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n    value = Math.abs(value);\n\n    if (isNaN(value) || value === Infinity) {\n      m = isNaN(value) ? 1 : 0;\n      e = eMax;\n    } else {\n      e = Math.floor(Math.log(value) / Math.LN2);\n      if (value * (c = Math.pow(2, -e)) < 1) {\n        e--;\n        c *= 2;\n      }\n      if (e + eBias >= 1) {\n        value += rt / c;\n      } else {\n        value += rt * Math.pow(2, 1 - eBias);\n      }\n      if (value * c >= 2) {\n        e++;\n        c /= 2;\n      }\n\n      if (e + eBias >= eMax) {\n        m = 0;\n        e = eMax;\n      } else if (e + eBias >= 1) {\n        m = (value * c - 1) * Math.pow(2, mLen);\n        e = e + eBias;\n      } else {\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n        e = 0;\n      }\n    }\n\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n    e = (e << mLen) | m;\n    eLen += mLen;\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n    buffer[offset + i - d] |= s * 128;\n  }\n\n  var toString = {}.toString;\n\n  var isArray$1 = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n  };\n\n  /*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n   * @license  MIT\n   */\n  /* eslint-disable no-proto */\n\n\n  var INSPECT_MAX_BYTES = 50;\n\n  /**\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\n   *   === true    Use Uint8Array implementation (fastest)\n   *   === false   Use Object implementation (most compatible, even IE6)\n   *\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n   * Opera 11.6+, iOS 4.2+.\n   *\n   * Due to various browser bugs, sometimes the Object implementation will be used even\n   * when the browser supports typed arrays.\n   *\n   * Note:\n   *\n   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n   *\n   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n   *\n   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n   *     incorrect length in some situations.\n\n   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n   * get the Object implementation, which is slower but behaves correctly.\n   */\n  Buffer.TYPED_ARRAY_SUPPORT = messages$1.global.TYPED_ARRAY_SUPPORT !== undefined\n    ? messages$1.global.TYPED_ARRAY_SUPPORT\n    : true;\n\n  /*\n   * Export kMaxLength after typed array support is determined.\n   */\n  kMaxLength();\n\n  function kMaxLength () {\n    return Buffer.TYPED_ARRAY_SUPPORT\n      ? 0x7fffffff\n      : 0x3fffffff\n  }\n\n  function createBuffer (that, length) {\n    if (kMaxLength() < length) {\n      throw new RangeError('Invalid typed array length')\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      // Return an augmented `Uint8Array` instance, for best performance\n      that = new Uint8Array(length);\n      that.__proto__ = Buffer.prototype;\n    } else {\n      // Fallback: Return an object instance of the Buffer class\n      if (that === null) {\n        that = new Buffer(length);\n      }\n      that.length = length;\n    }\n\n    return that\n  }\n\n  /**\n   * The Buffer constructor returns instances of `Uint8Array` that have their\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n   * returns a single octet.\n   *\n   * The `Uint8Array` prototype remains unmodified.\n   */\n\n  function Buffer (arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n      return new Buffer(arg, encodingOrOffset, length)\n    }\n\n    // Common case.\n    if (typeof arg === 'number') {\n      if (typeof encodingOrOffset === 'string') {\n        throw new Error(\n          'If encoding is specified then the first argument must be a string'\n        )\n      }\n      return allocUnsafe(this, arg)\n    }\n    return from(this, arg, encodingOrOffset, length)\n  }\n\n  Buffer.poolSize = 8192; // not used by this implementation\n\n  // TODO: Legacy, not needed anymore. Remove in next major version.\n  Buffer._augment = function (arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr\n  };\n\n  function from (that, value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('\"value\" argument must not be a number')\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, value, encodingOrOffset, length)\n    }\n\n    if (typeof value === 'string') {\n      return fromString(that, value, encodingOrOffset)\n    }\n\n    return fromObject(that, value)\n  }\n\n  /**\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n   * if value is a number.\n   * Buffer.from(str[, encoding])\n   * Buffer.from(array)\n   * Buffer.from(buffer)\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\n   **/\n  Buffer.from = function (value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length)\n  };\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== 'undefined' && Symbol.species &&\n        Buffer[Symbol.species] === Buffer) ;\n  }\n\n  function assertSize (size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('\"size\" argument must be a number')\n    } else if (size < 0) {\n      throw new RangeError('\"size\" argument must not be negative')\n    }\n  }\n\n  function alloc (that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n      return createBuffer(that, size)\n    }\n    if (fill !== undefined) {\n      // Only pay attention to encoding if it's a string. This\n      // prevents accidentally sending in a number that would\n      // be interpretted as a start offset.\n      return typeof encoding === 'string'\n        ? createBuffer(that, size).fill(fill, encoding)\n        : createBuffer(that, size).fill(fill)\n    }\n    return createBuffer(that, size)\n  }\n\n  /**\n   * Creates a new filled Buffer instance.\n   * alloc(size[, fill[, encoding]])\n   **/\n  Buffer.alloc = function (size, fill, encoding) {\n    return alloc(null, size, fill, encoding)\n  };\n\n  function allocUnsafe (that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n      for (var i = 0; i < size; ++i) {\n        that[i] = 0;\n      }\n    }\n    return that\n  }\n\n  /**\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n   * */\n  Buffer.allocUnsafe = function (size) {\n    return allocUnsafe(null, size)\n  };\n  /**\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n   */\n  Buffer.allocUnsafeSlow = function (size) {\n    return allocUnsafe(null, size)\n  };\n\n  function fromString (that, string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n      encoding = 'utf8';\n    }\n\n    if (!Buffer.isEncoding(encoding)) {\n      throw new TypeError('\"encoding\" must be a valid string encoding')\n    }\n\n    var length = byteLength$1(string, encoding) | 0;\n    that = createBuffer(that, length);\n\n    var actual = that.write(string, encoding);\n\n    if (actual !== length) {\n      // Writing a hex string, for example, that contains invalid characters will\n      // cause everything after the first invalid character to be ignored. (e.g.\n      // 'abxxcd' will be treated as 'ab')\n      that = that.slice(0, actual);\n    }\n\n    return that\n  }\n\n  function fromArrayLike (that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n      that[i] = array[i] & 255;\n    }\n    return that\n  }\n\n  function fromArrayBuffer (that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n      throw new RangeError('\\'offset\\' is out of bounds')\n    }\n\n    if (array.byteLength < byteOffset + (length || 0)) {\n      throw new RangeError('\\'length\\' is out of bounds')\n    }\n\n    if (byteOffset === undefined && length === undefined) {\n      array = new Uint8Array(array);\n    } else if (length === undefined) {\n      array = new Uint8Array(array, byteOffset);\n    } else {\n      array = new Uint8Array(array, byteOffset, length);\n    }\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      // Return an augmented `Uint8Array` instance, for best performance\n      that = array;\n      that.__proto__ = Buffer.prototype;\n    } else {\n      // Fallback: Return an object instance of the Buffer class\n      that = fromArrayLike(that, array);\n    }\n    return that\n  }\n\n  function fromObject (that, obj) {\n    if (internalIsBuffer(obj)) {\n      var len = checked(obj.length) | 0;\n      that = createBuffer(that, len);\n\n      if (that.length === 0) {\n        return that\n      }\n\n      obj.copy(that, 0, 0, len);\n      return that\n    }\n\n    if (obj) {\n      if ((typeof ArrayBuffer !== 'undefined' &&\n          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n        if (typeof obj.length !== 'number' || isnan(obj.length)) {\n          return createBuffer(that, 0)\n        }\n        return fromArrayLike(that, obj)\n      }\n\n      if (obj.type === 'Buffer' && isArray$1(obj.data)) {\n        return fromArrayLike(that, obj.data)\n      }\n    }\n\n    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n  }\n\n  function checked (length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                           'size: 0x' + kMaxLength().toString(16) + ' bytes')\n    }\n    return length | 0\n  }\n  Buffer.isBuffer = isBuffer;\n  function internalIsBuffer (b) {\n    return !!(b != null && b._isBuffer)\n  }\n\n  Buffer.compare = function compare (a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n      throw new TypeError('Arguments must be Buffers')\n    }\n\n    if (a === b) return 0\n\n    var x = a.length;\n    var y = b.length;\n\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n      if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break\n      }\n    }\n\n    if (x < y) return -1\n    if (y < x) return 1\n    return 0\n  };\n\n  Buffer.isEncoding = function isEncoding (encoding) {\n    switch (String(encoding).toLowerCase()) {\n      case 'hex':\n      case 'utf8':\n      case 'utf-8':\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n      case 'base64':\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return true\n      default:\n        return false\n    }\n  };\n\n  Buffer.concat = function concat (list, length) {\n    if (!isArray$1(list)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n\n    if (list.length === 0) {\n      return Buffer.alloc(0)\n    }\n\n    var i;\n    if (length === undefined) {\n      length = 0;\n      for (i = 0; i < list.length; ++i) {\n        length += list[i].length;\n      }\n    }\n\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n      var buf = list[i];\n      if (!internalIsBuffer(buf)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\n      }\n      buf.copy(buffer, pos);\n      pos += buf.length;\n    }\n    return buffer\n  };\n\n  function byteLength$1 (string, encoding) {\n    if (internalIsBuffer(string)) {\n      return string.length\n    }\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n      return string.byteLength\n    }\n    if (typeof string !== 'string') {\n      string = '' + string;\n    }\n\n    var len = string.length;\n    if (len === 0) return 0\n\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for (;;) {\n      switch (encoding) {\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n          return len\n        case 'utf8':\n        case 'utf-8':\n        case undefined:\n          return utf8ToBytes(string).length\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return len * 2\n        case 'hex':\n          return len >>> 1\n        case 'base64':\n          return base64ToBytes(string).length\n        default:\n          if (loweredCase) return utf8ToBytes(string).length // assume utf8\n          encoding = ('' + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n  Buffer.byteLength = byteLength$1;\n\n  function slowToString (encoding, start, end) {\n    var loweredCase = false;\n\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n      start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n      return ''\n    }\n\n    if (end === undefined || end > this.length) {\n      end = this.length;\n    }\n\n    if (end <= 0) {\n      return ''\n    }\n\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n\n    if (end <= start) {\n      return ''\n    }\n\n    if (!encoding) encoding = 'utf8';\n\n    while (true) {\n      switch (encoding) {\n        case 'hex':\n          return hexSlice(this, start, end)\n\n        case 'utf8':\n        case 'utf-8':\n          return utf8Slice(this, start, end)\n\n        case 'ascii':\n          return asciiSlice(this, start, end)\n\n        case 'latin1':\n        case 'binary':\n          return latin1Slice(this, start, end)\n\n        case 'base64':\n          return base64Slice(this, start, end)\n\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return utf16leSlice(this, start, end)\n\n        default:\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n          encoding = (encoding + '').toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n\n  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n  // Buffer instances.\n  Buffer.prototype._isBuffer = true;\n\n  function swap (b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n  }\n\n  Buffer.prototype.swap16 = function swap16 () {\n    var len = this.length;\n    if (len % 2 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 16-bits')\n    }\n    for (var i = 0; i < len; i += 2) {\n      swap(this, i, i + 1);\n    }\n    return this\n  };\n\n  Buffer.prototype.swap32 = function swap32 () {\n    var len = this.length;\n    if (len % 4 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 32-bits')\n    }\n    for (var i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this\n  };\n\n  Buffer.prototype.swap64 = function swap64 () {\n    var len = this.length;\n    if (len % 8 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 64-bits')\n    }\n    for (var i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this\n  };\n\n  Buffer.prototype.toString = function toString () {\n    var length = this.length | 0;\n    if (length === 0) return ''\n    if (arguments.length === 0) return utf8Slice(this, 0, length)\n    return slowToString.apply(this, arguments)\n  };\n\n  Buffer.prototype.equals = function equals (b) {\n    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n    if (this === b) return true\n    return Buffer.compare(this, b) === 0\n  };\n\n  Buffer.prototype.inspect = function inspect () {\n    var str = '';\n    var max = INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n      if (this.length > max) str += ' ... ';\n    }\n    return '<Buffer ' + str + '>'\n  };\n\n  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n      throw new TypeError('Argument must be a Buffer')\n    }\n\n    if (start === undefined) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n      thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n      thisEnd = this.length;\n    }\n\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n      throw new RangeError('out of range index')\n    }\n\n    if (thisStart >= thisEnd && start >= end) {\n      return 0\n    }\n    if (thisStart >= thisEnd) {\n      return -1\n    }\n    if (start >= end) {\n      return 1\n    }\n\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n\n    if (this === target) return 0\n\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n\n    for (var i = 0; i < len; ++i) {\n      if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break\n      }\n    }\n\n    if (x < y) return -1\n    if (y < x) return 1\n    return 0\n  };\n\n  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n  //\n  // Arguments:\n  // - buffer - a Buffer to search\n  // - val - a string, Buffer, or number\n  // - byteOffset - an index into `buffer`; will be clamped to an int32\n  // - encoding - an optional encoding, relevant is val is a string\n  // - dir - true for indexOf, false for lastIndexOf\n  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1\n\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n      encoding = byteOffset;\n      byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n      byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n      byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset;  // Coerce to Number.\n    if (isNaN(byteOffset)) {\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n      byteOffset = dir ? 0 : (buffer.length - 1);\n    }\n\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n      if (dir) return -1\n      else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n      if (dir) byteOffset = 0;\n      else return -1\n    }\n\n    // Normalize val\n    if (typeof val === 'string') {\n      val = Buffer.from(val, encoding);\n    }\n\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n      // Special case: looking for empty string/buffer always fails\n      if (val.length === 0) {\n        return -1\n      }\n      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n    } else if (typeof val === 'number') {\n      val = val & 0xFF; // Search for a byte value [0-255]\n      if (Buffer.TYPED_ARRAY_SUPPORT &&\n          typeof Uint8Array.prototype.indexOf === 'function') {\n        if (dir) {\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n        } else {\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n        }\n      }\n      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n    }\n\n    throw new TypeError('val must be string, number or Buffer')\n  }\n\n  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n\n    if (encoding !== undefined) {\n      encoding = String(encoding).toLowerCase();\n      if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n          encoding === 'utf16le' || encoding === 'utf-16le') {\n        if (arr.length < 2 || val.length < 2) {\n          return -1\n        }\n        indexSize = 2;\n        arrLength /= 2;\n        valLength /= 2;\n        byteOffset /= 2;\n      }\n    }\n\n    function read (buf, i) {\n      if (indexSize === 1) {\n        return buf[i]\n      } else {\n        return buf.readUInt16BE(i * indexSize)\n      }\n    }\n\n    var i;\n    if (dir) {\n      var foundIndex = -1;\n      for (i = byteOffset; i < arrLength; i++) {\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n          if (foundIndex === -1) foundIndex = i;\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n        } else {\n          if (foundIndex !== -1) i -= i - foundIndex;\n          foundIndex = -1;\n        }\n      }\n    } else {\n      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n      for (i = byteOffset; i >= 0; i--) {\n        var found = true;\n        for (var j = 0; j < valLength; j++) {\n          if (read(arr, i + j) !== read(val, j)) {\n            found = false;\n            break\n          }\n        }\n        if (found) return i\n      }\n    }\n\n    return -1\n  }\n\n  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1\n  };\n\n  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n  };\n\n  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n  };\n\n  function hexWrite (buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n      length = remaining;\n    } else {\n      length = Number(length);\n      if (length > remaining) {\n        length = remaining;\n      }\n    }\n\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n    if (length > strLen / 2) {\n      length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n      var parsed = parseInt(string.substr(i * 2, 2), 16);\n      if (isNaN(parsed)) return i\n      buf[offset + i] = parsed;\n    }\n    return i\n  }\n\n  function utf8Write (buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n  }\n\n  function asciiWrite (buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\n  }\n\n  function latin1Write (buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length)\n  }\n\n  function base64Write (buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length)\n  }\n\n  function ucs2Write (buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n  }\n\n  Buffer.prototype.write = function write (string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n      encoding = 'utf8';\n      length = this.length;\n      offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n      encoding = offset;\n      length = this.length;\n      offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n      offset = offset | 0;\n      if (isFinite(length)) {\n        length = length | 0;\n        if (encoding === undefined) encoding = 'utf8';\n      } else {\n        encoding = length;\n        length = undefined;\n      }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n      throw new Error(\n        'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n      )\n    }\n\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n      throw new RangeError('Attempt to write outside buffer bounds')\n    }\n\n    if (!encoding) encoding = 'utf8';\n\n    var loweredCase = false;\n    for (;;) {\n      switch (encoding) {\n        case 'hex':\n          return hexWrite(this, string, offset, length)\n\n        case 'utf8':\n        case 'utf-8':\n          return utf8Write(this, string, offset, length)\n\n        case 'ascii':\n          return asciiWrite(this, string, offset, length)\n\n        case 'latin1':\n        case 'binary':\n          return latin1Write(this, string, offset, length)\n\n        case 'base64':\n          // Warning: maxLength not taken into account in base64Write\n          return base64Write(this, string, offset, length)\n\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return ucs2Write(this, string, offset, length)\n\n        default:\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n          encoding = ('' + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  };\n\n  Buffer.prototype.toJSON = function toJSON () {\n    return {\n      type: 'Buffer',\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    }\n  };\n\n  function base64Slice (buf, start, end) {\n    if (start === 0 && end === buf.length) {\n      return fromByteArray$1(buf)\n    } else {\n      return fromByteArray$1(buf.slice(start, end))\n    }\n  }\n\n  function utf8Slice (buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n\n    var i = start;\n    while (i < end) {\n      var firstByte = buf[i];\n      var codePoint = null;\n      var bytesPerSequence = (firstByte > 0xEF) ? 4\n        : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n        : 1;\n\n      if (i + bytesPerSequence <= end) {\n        var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n        switch (bytesPerSequence) {\n          case 1:\n            if (firstByte < 0x80) {\n              codePoint = firstByte;\n            }\n            break\n          case 2:\n            secondByte = buf[i + 1];\n            if ((secondByte & 0xC0) === 0x80) {\n              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n              if (tempCodePoint > 0x7F) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break\n          case 3:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break\n          case 4:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            fourthByte = buf[i + 3];\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                codePoint = tempCodePoint;\n              }\n            }\n        }\n      }\n\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xFFFD;\n        bytesPerSequence = 1;\n      } else if (codePoint > 0xFFFF) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000;\n        res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n        codePoint = 0xDC00 | codePoint & 0x3FF;\n      }\n\n      res.push(codePoint);\n      i += bytesPerSequence;\n    }\n\n    return decodeCodePointsArray(res)\n  }\n\n  // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n  // the lowest limit is Chrome, with 0x10000 args.\n  // We go 1 magnitude less, for safety\n  var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n  function decodeCodePointsArray (codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    }\n\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = '';\n    var i = 0;\n    while (i < len) {\n      res += String.fromCharCode.apply(\n        String,\n        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n      );\n    }\n    return res\n  }\n\n  function asciiSlice (buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret\n  }\n\n  function latin1Slice (buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i]);\n    }\n    return ret\n  }\n\n  function hexSlice (buf, start, end) {\n    var len = buf.length;\n\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n\n    var out = '';\n    for (var i = start; i < end; ++i) {\n      out += toHex(buf[i]);\n    }\n    return out\n  }\n\n  function utf16leSlice (buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = '';\n    for (var i = 0; i < bytes.length; i += 2) {\n      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res\n  }\n\n  Buffer.prototype.slice = function slice (start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n\n    if (start < 0) {\n      start += len;\n      if (start < 0) start = 0;\n    } else if (start > len) {\n      start = len;\n    }\n\n    if (end < 0) {\n      end += len;\n      if (end < 0) end = 0;\n    } else if (end > len) {\n      end = len;\n    }\n\n    if (end < start) end = start;\n\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      newBuf = this.subarray(start, end);\n      newBuf.__proto__ = Buffer.prototype;\n    } else {\n      var sliceLen = end - start;\n      newBuf = new Buffer(sliceLen, undefined);\n      for (var i = 0; i < sliceLen; ++i) {\n        newBuf[i] = this[i + start];\n      }\n    }\n\n    return newBuf\n  };\n\n  /*\n   * Need to make sure that buffer isn't trying to write out of bounds.\n   */\n  function checkOffset (offset, ext, length) {\n    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n  }\n\n  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n      val += this[offset + i] * mul;\n    }\n\n    return val\n  };\n\n  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n      checkOffset(offset, byteLength, this.length);\n    }\n\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while (byteLength > 0 && (mul *= 0x100)) {\n      val += this[offset + --byteLength] * mul;\n    }\n\n    return val\n  };\n\n  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset]\n  };\n\n  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | (this[offset + 1] << 8)\n  };\n\n  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return (this[offset] << 8) | this[offset + 1]\n  };\n\n  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n\n    return ((this[offset]) |\n        (this[offset + 1] << 8) |\n        (this[offset + 2] << 16)) +\n        (this[offset + 3] * 0x1000000)\n  };\n\n  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n\n    return (this[offset] * 0x1000000) +\n      ((this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      this[offset + 3])\n  };\n\n  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n      val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n    return val\n  };\n\n  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while (i > 0 && (mul *= 0x100)) {\n      val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n    return val\n  };\n\n  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return (this[offset])\n    return ((0xff - this[offset] + 1) * -1)\n  };\n\n  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | (this[offset + 1] << 8);\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\n  };\n\n  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | (this[offset] << 8);\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\n  };\n\n  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n\n    return (this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16) |\n      (this[offset + 3] << 24)\n  };\n\n  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n\n    return (this[offset] << 24) |\n      (this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      (this[offset + 3])\n  };\n\n  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4)\n  };\n\n  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4)\n  };\n\n  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8)\n  };\n\n  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8)\n  };\n\n  function checkInt (buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  }\n\n  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n      this[offset + i] = (value / mul) & 0xFF;\n    }\n\n    return offset + byteLength\n  };\n\n  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n      this[offset + i] = (value / mul) & 0xFF;\n    }\n\n    return offset + byteLength\n  };\n\n  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = (value & 0xff);\n    return offset + 1\n  };\n\n  function objectWriteUInt16 (buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n        (littleEndian ? i : 1 - i) * 8;\n    }\n  }\n\n  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = (value & 0xff);\n      this[offset + 1] = (value >>> 8);\n    } else {\n      objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2\n  };\n\n  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = (value >>> 8);\n      this[offset + 1] = (value & 0xff);\n    } else {\n      objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2\n  };\n\n  function objectWriteUInt32 (buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n    }\n  }\n\n  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset + 3] = (value >>> 24);\n      this[offset + 2] = (value >>> 16);\n      this[offset + 1] = (value >>> 8);\n      this[offset] = (value & 0xff);\n    } else {\n      objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4\n  };\n\n  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = (value >>> 24);\n      this[offset + 1] = (value >>> 16);\n      this[offset + 2] = (value >>> 8);\n      this[offset + 3] = (value & 0xff);\n    } else {\n      objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4\n  };\n\n  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength - 1);\n\n      checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n        sub = 1;\n      }\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n\n    return offset + byteLength\n  };\n\n  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength - 1);\n\n      checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n        sub = 1;\n      }\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n\n    return offset + byteLength\n  };\n\n  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = (value & 0xff);\n    return offset + 1\n  };\n\n  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = (value & 0xff);\n      this[offset + 1] = (value >>> 8);\n    } else {\n      objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2\n  };\n\n  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = (value >>> 8);\n      this[offset + 1] = (value & 0xff);\n    } else {\n      objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2\n  };\n\n  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = (value & 0xff);\n      this[offset + 1] = (value >>> 8);\n      this[offset + 2] = (value >>> 16);\n      this[offset + 3] = (value >>> 24);\n    } else {\n      objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4\n  };\n\n  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = (value >>> 24);\n      this[offset + 1] = (value >>> 16);\n      this[offset + 2] = (value >>> 8);\n      this[offset + 3] = (value & 0xff);\n    } else {\n      objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4\n  };\n\n  function checkIEEE754 (buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\n    if (offset < 0) throw new RangeError('Index out of range')\n  }\n\n  function writeFloat (buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 4);\n    }\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4\n  }\n\n  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert)\n  };\n\n  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert)\n  };\n\n  function writeDouble (buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 8);\n    }\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8\n  }\n\n  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert)\n  };\n\n  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert)\n  };\n\n  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n  Buffer.prototype.copy = function copy (target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n\n    // Copy 0 bytes; we're done\n    if (end === start) return 0\n    if (target.length === 0 || this.length === 0) return 0\n\n    // Fatal error conditions\n    if (targetStart < 0) {\n      throw new RangeError('targetStart out of bounds')\n    }\n    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n      end = target.length - targetStart + start;\n    }\n\n    var len = end - start;\n    var i;\n\n    if (this === target && start < targetStart && targetStart < end) {\n      // descending copy from end\n      for (i = len - 1; i >= 0; --i) {\n        target[i + targetStart] = this[i + start];\n      }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n      // ascending copy from start\n      for (i = 0; i < len; ++i) {\n        target[i + targetStart] = this[i + start];\n      }\n    } else {\n      Uint8Array.prototype.set.call(\n        target,\n        this.subarray(start, start + len),\n        targetStart\n      );\n    }\n\n    return len\n  };\n\n  // Usage:\n  //    buffer.fill(number[, offset[, end]])\n  //    buffer.fill(buffer[, offset[, end]])\n  //    buffer.fill(string[, offset[, end]][, encoding])\n  Buffer.prototype.fill = function fill (val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n      if (typeof start === 'string') {\n        encoding = start;\n        start = 0;\n        end = this.length;\n      } else if (typeof end === 'string') {\n        encoding = end;\n        end = this.length;\n      }\n      if (val.length === 1) {\n        var code = val.charCodeAt(0);\n        if (code < 256) {\n          val = code;\n        }\n      }\n      if (encoding !== undefined && typeof encoding !== 'string') {\n        throw new TypeError('encoding must be a string')\n      }\n      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n        throw new TypeError('Unknown encoding: ' + encoding)\n      }\n    } else if (typeof val === 'number') {\n      val = val & 255;\n    }\n\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n      throw new RangeError('Out of range index')\n    }\n\n    if (end <= start) {\n      return this\n    }\n\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n\n    if (!val) val = 0;\n\n    var i;\n    if (typeof val === 'number') {\n      for (i = start; i < end; ++i) {\n        this[i] = val;\n      }\n    } else {\n      var bytes = internalIsBuffer(val)\n        ? val\n        : utf8ToBytes(new Buffer(val, encoding).toString());\n      var len = bytes.length;\n      for (i = 0; i < end - start; ++i) {\n        this[i + start] = bytes[i % len];\n      }\n    }\n\n    return this\n  };\n\n  // HELPER FUNCTIONS\n  // ================\n\n  var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n  function base64clean (str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return ''\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while (str.length % 4 !== 0) {\n      str = str + '=';\n    }\n    return str\n  }\n\n  function stringtrim (str) {\n    if (str.trim) return str.trim()\n    return str.replace(/^\\s+|\\s+$/g, '')\n  }\n\n  function toHex (n) {\n    if (n < 16) return '0' + n.toString(16)\n    return n.toString(16)\n  }\n\n  function utf8ToBytes (string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n\n    for (var i = 0; i < length; ++i) {\n      codePoint = string.charCodeAt(i);\n\n      // is surrogate component\n      if (codePoint > 0xD7FF && codePoint < 0xE000) {\n        // last char was a lead\n        if (!leadSurrogate) {\n          // no lead yet\n          if (codePoint > 0xDBFF) {\n            // unexpected trail\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            continue\n          } else if (i + 1 === length) {\n            // unpaired lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            continue\n          }\n\n          // valid lead\n          leadSurrogate = codePoint;\n\n          continue\n        }\n\n        // 2 leads in a row\n        if (codePoint < 0xDC00) {\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          leadSurrogate = codePoint;\n          continue\n        }\n\n        // valid surrogate pair\n        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n      } else if (leadSurrogate) {\n        // valid bmp char, but last char was a lead\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n      }\n\n      leadSurrogate = null;\n\n      // encode utf8\n      if (codePoint < 0x80) {\n        if ((units -= 1) < 0) break\n        bytes.push(codePoint);\n      } else if (codePoint < 0x800) {\n        if ((units -= 2) < 0) break\n        bytes.push(\n          codePoint >> 0x6 | 0xC0,\n          codePoint & 0x3F | 0x80\n        );\n      } else if (codePoint < 0x10000) {\n        if ((units -= 3) < 0) break\n        bytes.push(\n          codePoint >> 0xC | 0xE0,\n          codePoint >> 0x6 & 0x3F | 0x80,\n          codePoint & 0x3F | 0x80\n        );\n      } else if (codePoint < 0x110000) {\n        if ((units -= 4) < 0) break\n        bytes.push(\n          codePoint >> 0x12 | 0xF0,\n          codePoint >> 0xC & 0x3F | 0x80,\n          codePoint >> 0x6 & 0x3F | 0x80,\n          codePoint & 0x3F | 0x80\n        );\n      } else {\n        throw new Error('Invalid code point')\n      }\n    }\n\n    return bytes\n  }\n\n  function asciiToBytes (str) {\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      // Node's code seems to be doing this and not & 0x7F..\n      byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray\n  }\n\n  function utf16leToBytes (str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      if ((units -= 2) < 0) break\n\n      c = str.charCodeAt(i);\n      hi = c >> 8;\n      lo = c % 256;\n      byteArray.push(lo);\n      byteArray.push(hi);\n    }\n\n    return byteArray\n  }\n\n\n  function base64ToBytes (str) {\n    return toByteArray$1(base64clean(str))\n  }\n\n  function blitBuffer (src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n      if ((i + offset >= dst.length) || (i >= src.length)) break\n      dst[i + offset] = src[i];\n    }\n    return i\n  }\n\n  function isnan (val) {\n    return val !== val // eslint-disable-line no-self-compare\n  }\n\n\n  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n  // The _isBuffer check is for Safari 5-7 support, because it's missing\n  // Object.prototype.constructor. Remove this eventually\n  function isBuffer(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n  }\n\n  function isFastBuffer (obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n  }\n\n  // For Node v0.10 support. Remove this eventually.\n  function isSlowBuffer (obj) {\n    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n  }\n\n  var core = {};\n\n  var version = {};\n\n  Object.defineProperty(version, \"__esModule\", { value: true });\n  version.VERSION = void 0;\n  version.VERSION = '4.64.0'; // x-release-please-version\n\n  var streaming = {};\n\n  var _shims = {};\n\n  var registry = {};\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.setShims = exports.isFsReadStream = exports.fileFromPath = exports.getDefaultAgent = exports.getMultipartRequestOptions = exports.ReadableStream = exports.File = exports.Blob = exports.FormData = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.kind = exports.auto = void 0;\n  \texports.auto = false;\n  \texports.kind = undefined;\n  \texports.fetch = undefined;\n  \texports.Request = undefined;\n  \texports.Response = undefined;\n  \texports.Headers = undefined;\n  \texports.FormData = undefined;\n  \texports.Blob = undefined;\n  \texports.File = undefined;\n  \texports.ReadableStream = undefined;\n  \texports.getMultipartRequestOptions = undefined;\n  \texports.getDefaultAgent = undefined;\n  \texports.fileFromPath = undefined;\n  \texports.isFsReadStream = undefined;\n  \tfunction setShims(shims, options = { auto: false }) {\n  \t    if (exports.auto) {\n  \t        throw new Error(`you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`);\n  \t    }\n  \t    if (exports.kind) {\n  \t        throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${exports.kind}'\\``);\n  \t    }\n  \t    exports.auto = options.auto;\n  \t    exports.kind = shims.kind;\n  \t    exports.fetch = shims.fetch;\n  \t    exports.Request = shims.Request;\n  \t    exports.Response = shims.Response;\n  \t    exports.Headers = shims.Headers;\n  \t    exports.FormData = shims.FormData;\n  \t    exports.Blob = shims.Blob;\n  \t    exports.File = shims.File;\n  \t    exports.ReadableStream = shims.ReadableStream;\n  \t    exports.getMultipartRequestOptions = shims.getMultipartRequestOptions;\n  \t    exports.getDefaultAgent = shims.getDefaultAgent;\n  \t    exports.fileFromPath = shims.fileFromPath;\n  \t    exports.isFsReadStream = shims.isFsReadStream;\n  \t}\n  \texports.setShims = setShims;\n  \t\n  } (registry));\n\n  var runtimeNode = {};\n\n  var nodeRuntime = {};\n\n  var browser$3 = {exports: {}};\n\n  (function (module, exports) {\n\n  \t// ref: https://github.com/tc39/proposal-global\n  \tvar getGlobal = function () {\n  \t\t// the only reliable means to get the global object is\n  \t\t// `Function('return this')()`\n  \t\t// However, this causes CSP violations in Chrome apps.\n  \t\tif (typeof self !== 'undefined') { return self; }\n  \t\tif (typeof window !== 'undefined') { return window; }\n  \t\tif (typeof messages$1.commonjsGlobal !== 'undefined') { return messages$1.commonjsGlobal; }\n  \t\tthrow new Error('unable to locate global object');\n  \t};\n\n  \tvar globalObject = getGlobal();\n\n  \tmodule.exports = exports = globalObject.fetch;\n\n  \t// Needed for TypeScript and Webpack.\n  \tif (globalObject.fetch) {\n  \t\texports.default = globalObject.fetch.bind(globalObject);\n  \t}\n\n  \texports.Headers = globalObject.Headers;\n  \texports.Request = globalObject.Request;\n  \texports.Response = globalObject.Response; \n  } (browser$3, browser$3.exports));\n\n  var browserExports$2 = browser$3.exports;\n\n  const globalObject = (function () {\n      if (typeof globalThis !== \"undefined\") {\n          return globalThis;\n      }\n      if (typeof self !== \"undefined\") {\n          return self;\n      }\n      return window;\n  }());\n  const { FormData, Blob: Blob$1, File: File$1 } = globalObject;\n\n  var browser$2 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Blob: Blob$1,\n    File: File$1,\n    FormData: FormData\n  });\n\n  var require$$1$1 = /*@__PURE__*/messages$1.getAugmentedNamespace(browser$2);\n\n  var browser$1 = {exports: {}};\n\n  browser$1.exports = noop;\n  browser$1.exports.HttpsAgent = noop;\n\n  // Noop function for browser since native api's don't use agents.\n  function noop () {}\n\n  var browserExports$1 = browser$1.exports;\n\n  var browser = {exports: {}};\n\n  /*globals self, window */\n\n  /*eslint-disable @mysticatea/prettier */\n  const { AbortController: AbortController$1, AbortSignal } =\n      typeof self !== \"undefined\" ? self :\n      typeof window !== \"undefined\" ? window :\n      /* otherwise */ undefined;\n  /*eslint-enable @mysticatea/prettier */\n\n  browser.exports = AbortController$1;\n  browser.exports.AbortSignal = AbortSignal;\n  browser.exports.default = AbortController$1;\n\n  var browserExports = browser.exports;\n\n  var _polyfillNode_fs = {};\n\n  var _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    default: _polyfillNode_fs\n  });\n\n  var require$$4 = /*@__PURE__*/messages$1.getAugmentedNamespace(_polyfillNode_fs$1);\n\n  var cjs = {};\n\n  var FormDataEncoder$1 = {};\n\n  var createBoundary$1 = {};\n\n  Object.defineProperty(createBoundary$1, \"__esModule\", { value: true });\n  const alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n  function createBoundary() {\n      let size = 16;\n      let res = \"\";\n      while (size--) {\n          res += alphabet[(Math.random() * alphabet.length) << 0];\n      }\n      return res;\n  }\n  createBoundary$1.default = createBoundary;\n\n  var isPlainObject$2 = {};\n\n  Object.defineProperty(isPlainObject$2, \"__esModule\", { value: true });\n  const getType = (value) => (Object.prototype.toString.call(value).slice(8, -1).toLowerCase());\n  function isPlainObject$1(value) {\n      if (getType(value) !== \"object\") {\n          return false;\n      }\n      const pp = Object.getPrototypeOf(value);\n      if (pp === null || pp === undefined) {\n          return true;\n      }\n      const Ctor = pp.constructor && pp.constructor.toString();\n      return Ctor === Object.toString();\n  }\n  isPlainObject$2.default = isPlainObject$1;\n\n  var normalizeValue$1 = {};\n\n  Object.defineProperty(normalizeValue$1, \"__esModule\", { value: true });\n  const normalizeValue = (value) => String(value)\n      .replace(/\\r|\\n/g, (match, i, str) => {\n      if ((match === \"\\r\" && str[i + 1] !== \"\\n\")\n          || (match === \"\\n\" && str[i - 1] !== \"\\r\")) {\n          return \"\\r\\n\";\n      }\n      return match;\n  });\n  normalizeValue$1.default = normalizeValue;\n\n  var escapeName$1 = {};\n\n  Object.defineProperty(escapeName$1, \"__esModule\", { value: true });\n  const escapeName = (name) => String(name)\n      .replace(/\\r/g, \"%0D\")\n      .replace(/\\n/g, \"%0A\")\n      .replace(/\"/g, \"%22\");\n  escapeName$1.default = escapeName;\n\n  var isFileLike$1 = {};\n\n  var isFunction$3 = {};\n\n  Object.defineProperty(isFunction$3, \"__esModule\", { value: true });\n  const isFunction$2 = (value) => (typeof value === \"function\");\n  isFunction$3.default = isFunction$2;\n\n  var __importDefault$2 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importDefault) || function (mod) {\n      return (mod && mod.__esModule) ? mod : { \"default\": mod };\n  };\n  Object.defineProperty(isFileLike$1, \"__esModule\", { value: true });\n  isFileLike$1.isFileLike = void 0;\n  const isFunction_1 = __importDefault$2(isFunction$3);\n  const isFileLike = (value) => Boolean(value\n      && typeof value === \"object\"\n      && (0, isFunction_1.default)(value.constructor)\n      && value[Symbol.toStringTag] === \"File\"\n      && (0, isFunction_1.default)(value.stream)\n      && value.name != null\n      && value.size != null\n      && value.lastModified != null);\n  isFileLike$1.isFileLike = isFileLike;\n\n  var isFormData = {};\n\n  (function (exports) {\n  \tvar __importDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importDefault) || function (mod) {\n  \t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.isFormDataLike = exports.isFormData = void 0;\n  \tconst isFunction_1 = __importDefault(isFunction$3);\n  \tconst isFormData = (value) => Boolean(value\n  \t    && (0, isFunction_1.default)(value.constructor)\n  \t    && value[Symbol.toStringTag] === \"FormData\"\n  \t    && (0, isFunction_1.default)(value.append)\n  \t    && (0, isFunction_1.default)(value.getAll)\n  \t    && (0, isFunction_1.default)(value.entries)\n  \t    && (0, isFunction_1.default)(value[Symbol.iterator]));\n  \texports.isFormData = isFormData;\n  \texports.isFormDataLike = exports.isFormData; \n  } (isFormData));\n\n  var __classPrivateFieldSet$3 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n      if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n      return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  };\n  var __classPrivateFieldGet$4 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n      return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  };\n  var __importDefault$1 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importDefault) || function (mod) {\n      return (mod && mod.__esModule) ? mod : { \"default\": mod };\n  };\n  var _FormDataEncoder_instances, _FormDataEncoder_CRLF, _FormDataEncoder_CRLF_BYTES, _FormDataEncoder_CRLF_BYTES_LENGTH, _FormDataEncoder_DASHES, _FormDataEncoder_encoder, _FormDataEncoder_footer, _FormDataEncoder_form, _FormDataEncoder_options, _FormDataEncoder_getFieldHeader;\n  Object.defineProperty(FormDataEncoder$1, \"__esModule\", { value: true });\n  FormDataEncoder$1.Encoder = FormDataEncoder$1.FormDataEncoder = void 0;\n  const createBoundary_1 = __importDefault$1(createBoundary$1);\n  const isPlainObject_1 = __importDefault$1(isPlainObject$2);\n  const normalizeValue_1 = __importDefault$1(normalizeValue$1);\n  const escapeName_1 = __importDefault$1(escapeName$1);\n  const isFileLike_1 = isFileLike$1;\n  const isFormData_1 = isFormData;\n  const defaultOptions$1 = {\n      enableAdditionalHeaders: false\n  };\n  class FormDataEncoder {\n      constructor(form, boundaryOrOptions, options) {\n          _FormDataEncoder_instances.add(this);\n          _FormDataEncoder_CRLF.set(this, \"\\r\\n\");\n          _FormDataEncoder_CRLF_BYTES.set(this, void 0);\n          _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);\n          _FormDataEncoder_DASHES.set(this, \"-\".repeat(2));\n          _FormDataEncoder_encoder.set(this, new TextEncoder());\n          _FormDataEncoder_footer.set(this, void 0);\n          _FormDataEncoder_form.set(this, void 0);\n          _FormDataEncoder_options.set(this, void 0);\n          if (!(0, isFormData_1.isFormData)(form)) {\n              throw new TypeError(\"Expected first argument to be a FormData instance.\");\n          }\n          let boundary;\n          if ((0, isPlainObject_1.default)(boundaryOrOptions)) {\n              options = boundaryOrOptions;\n          }\n          else {\n              boundary = boundaryOrOptions;\n          }\n          if (!boundary) {\n              boundary = (0, createBoundary_1.default)();\n          }\n          if (typeof boundary !== \"string\") {\n              throw new TypeError(\"Expected boundary argument to be a string.\");\n          }\n          if (options && !(0, isPlainObject_1.default)(options)) {\n              throw new TypeError(\"Expected options argument to be an object.\");\n          }\n          __classPrivateFieldSet$3(this, _FormDataEncoder_form, form, \"f\");\n          __classPrivateFieldSet$3(this, _FormDataEncoder_options, { ...defaultOptions$1, ...options }, \"f\");\n          __classPrivateFieldSet$3(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet$4(this, _FormDataEncoder_encoder, \"f\").encode(__classPrivateFieldGet$4(this, _FormDataEncoder_CRLF, \"f\")), \"f\");\n          __classPrivateFieldSet$3(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet$4(this, _FormDataEncoder_CRLF_BYTES, \"f\").byteLength, \"f\");\n          this.boundary = `form-data-boundary-${boundary}`;\n          this.contentType = `multipart/form-data; boundary=${this.boundary}`;\n          __classPrivateFieldSet$3(this, _FormDataEncoder_footer, __classPrivateFieldGet$4(this, _FormDataEncoder_encoder, \"f\").encode(`${__classPrivateFieldGet$4(this, _FormDataEncoder_DASHES, \"f\")}${this.boundary}${__classPrivateFieldGet$4(this, _FormDataEncoder_DASHES, \"f\")}${__classPrivateFieldGet$4(this, _FormDataEncoder_CRLF, \"f\").repeat(2)}`), \"f\");\n          this.contentLength = String(this.getContentLength());\n          this.headers = Object.freeze({\n              \"Content-Type\": this.contentType,\n              \"Content-Length\": this.contentLength\n          });\n          Object.defineProperties(this, {\n              boundary: { writable: false, configurable: false },\n              contentType: { writable: false, configurable: false },\n              contentLength: { writable: false, configurable: false },\n              headers: { writable: false, configurable: false }\n          });\n      }\n      getContentLength() {\n          let length = 0;\n          for (const [name, raw] of __classPrivateFieldGet$4(this, _FormDataEncoder_form, \"f\")) {\n              const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet$4(this, _FormDataEncoder_encoder, \"f\").encode((0, normalizeValue_1.default)(raw));\n              length += __classPrivateFieldGet$4(this, _FormDataEncoder_instances, \"m\", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;\n              length += (0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength;\n              length += __classPrivateFieldGet$4(this, _FormDataEncoder_CRLF_BYTES_LENGTH, \"f\");\n          }\n          return length + __classPrivateFieldGet$4(this, _FormDataEncoder_footer, \"f\").byteLength;\n      }\n      *values() {\n          for (const [name, raw] of __classPrivateFieldGet$4(this, _FormDataEncoder_form, \"f\").entries()) {\n              const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet$4(this, _FormDataEncoder_encoder, \"f\").encode((0, normalizeValue_1.default)(raw));\n              yield __classPrivateFieldGet$4(this, _FormDataEncoder_instances, \"m\", _FormDataEncoder_getFieldHeader).call(this, name, value);\n              yield value;\n              yield __classPrivateFieldGet$4(this, _FormDataEncoder_CRLF_BYTES, \"f\");\n          }\n          yield __classPrivateFieldGet$4(this, _FormDataEncoder_footer, \"f\");\n      }\n      async *encode() {\n          for (const part of this.values()) {\n              if ((0, isFileLike_1.isFileLike)(part)) {\n                  yield* part.stream();\n              }\n              else {\n                  yield part;\n              }\n          }\n      }\n      [(_FormDataEncoder_CRLF = new WeakMap(), _FormDataEncoder_CRLF_BYTES = new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap(), _FormDataEncoder_DASHES = new WeakMap(), _FormDataEncoder_encoder = new WeakMap(), _FormDataEncoder_footer = new WeakMap(), _FormDataEncoder_form = new WeakMap(), _FormDataEncoder_options = new WeakMap(), _FormDataEncoder_instances = new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {\n          let header = \"\";\n          header += `${__classPrivateFieldGet$4(this, _FormDataEncoder_DASHES, \"f\")}${this.boundary}${__classPrivateFieldGet$4(this, _FormDataEncoder_CRLF, \"f\")}`;\n          header += `Content-Disposition: form-data; name=\"${(0, escapeName_1.default)(name)}\"`;\n          if ((0, isFileLike_1.isFileLike)(value)) {\n              header += `; filename=\"${(0, escapeName_1.default)(value.name)}\"${__classPrivateFieldGet$4(this, _FormDataEncoder_CRLF, \"f\")}`;\n              header += `Content-Type: ${value.type || \"application/octet-stream\"}`;\n          }\n          if (__classPrivateFieldGet$4(this, _FormDataEncoder_options, \"f\").enableAdditionalHeaders === true) {\n              header += `${__classPrivateFieldGet$4(this, _FormDataEncoder_CRLF, \"f\")}Content-Length: ${(0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength}`;\n          }\n          return __classPrivateFieldGet$4(this, _FormDataEncoder_encoder, \"f\").encode(`${header}${__classPrivateFieldGet$4(this, _FormDataEncoder_CRLF, \"f\").repeat(2)}`);\n      }, Symbol.iterator)]() {\n          return this.values();\n      }\n      [Symbol.asyncIterator]() {\n          return this.encode();\n      }\n  }\n  FormDataEncoder$1.FormDataEncoder = FormDataEncoder;\n  FormDataEncoder$1.Encoder = FormDataEncoder;\n\n  var FileLike = {};\n\n  Object.defineProperty(FileLike, \"__esModule\", { value: true });\n\n  var FormDataLike = {};\n\n  Object.defineProperty(FormDataLike, \"__esModule\", { value: true });\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t__exportStar(FormDataEncoder$1, exports);\n  \t__exportStar(FileLike, exports);\n  \t__exportStar(FormDataLike, exports);\n  \t__exportStar(isFileLike$1, exports);\n  \t__exportStar(isFormData, exports); \n  } (cjs));\n\n  var domain;\n\n  // This constructor is used to store event handlers. Instantiating this is\n  // faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n  // object (tested with v8 v4.9).\n  function EventHandlers() {}\n  EventHandlers.prototype = Object.create(null);\n\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  }\n\n  // nodejs oddity\n  // require('events') === require('events').EventEmitter\n  EventEmitter.EventEmitter = EventEmitter;\n\n  EventEmitter.usingDomains = false;\n\n  EventEmitter.prototype.domain = undefined;\n  EventEmitter.prototype._events = undefined;\n  EventEmitter.prototype._maxListeners = undefined;\n\n  // By default EventEmitters will print a warning if more than 10 listeners are\n  // added to it. This is a useful default which helps finding memory leaks.\n  EventEmitter.defaultMaxListeners = 10;\n\n  EventEmitter.init = function() {\n    this.domain = null;\n    if (EventEmitter.usingDomains) {\n      // if there is an active domain, then attach to it.\n      if (domain.active) ;\n    }\n\n    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n    }\n\n    this._maxListeners = this._maxListeners || undefined;\n  };\n\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || isNaN(n))\n      throw new TypeError('\"n\" argument must be a positive number');\n    this._maxListeners = n;\n    return this;\n  };\n\n  function $getMaxListeners(that) {\n    if (that._maxListeners === undefined)\n      return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n  }\n\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return $getMaxListeners(this);\n  };\n\n  // These standalone emit* functions are used to optimize calling of event\n  // handlers for fast cases because emit() itself often has a variable number of\n  // arguments and can be deoptimized because of that. These functions always have\n  // the same number of arguments and thus do not get deoptimized, so the code\n  // inside them can execute faster.\n  function emitNone(handler, isFn, self) {\n    if (isFn)\n      handler.call(self);\n    else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i)\n        listeners[i].call(self);\n    }\n  }\n  function emitOne(handler, isFn, self, arg1) {\n    if (isFn)\n      handler.call(self, arg1);\n    else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i)\n        listeners[i].call(self, arg1);\n    }\n  }\n  function emitTwo(handler, isFn, self, arg1, arg2) {\n    if (isFn)\n      handler.call(self, arg1, arg2);\n    else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i)\n        listeners[i].call(self, arg1, arg2);\n    }\n  }\n  function emitThree(handler, isFn, self, arg1, arg2, arg3) {\n    if (isFn)\n      handler.call(self, arg1, arg2, arg3);\n    else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i)\n        listeners[i].call(self, arg1, arg2, arg3);\n    }\n  }\n\n  function emitMany(handler, isFn, self, args) {\n    if (isFn)\n      handler.apply(self, args);\n    else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i)\n        listeners[i].apply(self, args);\n    }\n  }\n\n  EventEmitter.prototype.emit = function emit(type) {\n    var er, handler, len, args, i, events, domain;\n    var doError = (type === 'error');\n\n    events = this._events;\n    if (events)\n      doError = (doError && events.error == null);\n    else if (!doError)\n      return false;\n\n    domain = this.domain;\n\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n      er = arguments[1];\n      if (domain) {\n        if (!er)\n          er = new Error('Uncaught, unspecified \"error\" event');\n        er.domainEmitter = this;\n        er.domain = domain;\n        er.domainThrown = false;\n        domain.emit('error', er);\n      } else if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n      return false;\n    }\n\n    handler = events[type];\n\n    if (!handler)\n      return false;\n\n    var isFn = typeof handler === 'function';\n    len = arguments.length;\n    switch (len) {\n      // fast cases\n      case 1:\n        emitNone(handler, isFn, this);\n        break;\n      case 2:\n        emitOne(handler, isFn, this, arguments[1]);\n        break;\n      case 3:\n        emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n        break;\n      case 4:\n        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n        break;\n      // slower\n      default:\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        emitMany(handler, isFn, this, args);\n    }\n\n    return true;\n  };\n\n  function _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n\n    if (typeof listener !== 'function')\n      throw new TypeError('\"listener\" argument must be a function');\n\n    events = target._events;\n    if (!events) {\n      events = target._events = new EventHandlers();\n      target._eventsCount = 0;\n    } else {\n      // To avoid recursion in the case that type === \"newListener\"! Before\n      // adding it to the listeners, first emit \"newListener\".\n      if (events.newListener) {\n        target.emit('newListener', type,\n                    listener.listener ? listener.listener : listener);\n\n        // Re-assign `events` because a newListener handler could have caused the\n        // this._events to be assigned to a new object\n        events = target._events;\n      }\n      existing = events[type];\n    }\n\n    if (!existing) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      existing = events[type] = listener;\n      ++target._eventsCount;\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [listener, existing] :\n                                            [existing, listener];\n      } else {\n        // If we've already got an array, just append.\n        if (prepend) {\n          existing.unshift(listener);\n        } else {\n          existing.push(listener);\n        }\n      }\n\n      // Check for listener leak\n      if (!existing.warned) {\n        m = $getMaxListeners(target);\n        if (m && m > 0 && existing.length > m) {\n          existing.warned = true;\n          var w = new Error('Possible EventEmitter memory leak detected. ' +\n                              existing.length + ' ' + type + ' listeners added. ' +\n                              'Use emitter.setMaxListeners() to increase limit');\n          w.name = 'MaxListenersExceededWarning';\n          w.emitter = target;\n          w.type = type;\n          w.count = existing.length;\n          emitWarning(w);\n        }\n      }\n    }\n\n    return target;\n  }\n  function emitWarning(e) {\n    typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n  }\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  };\n\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n  EventEmitter.prototype.prependListener =\n      function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n      };\n\n  function _onceWrap(target, type, listener) {\n    var fired = false;\n    function g() {\n      target.removeListener(type, g);\n      if (!fired) {\n        fired = true;\n        listener.apply(target, arguments);\n      }\n    }\n    g.listener = listener;\n    return g;\n  }\n\n  EventEmitter.prototype.once = function once(type, listener) {\n    if (typeof listener !== 'function')\n      throw new TypeError('\"listener\" argument must be a function');\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n  };\n\n  EventEmitter.prototype.prependOnceListener =\n      function prependOnceListener(type, listener) {\n        if (typeof listener !== 'function')\n          throw new TypeError('\"listener\" argument must be a function');\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n  // emits a 'removeListener' event iff the listener was removed\n  EventEmitter.prototype.removeListener =\n      function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n\n        if (typeof listener !== 'function')\n          throw new TypeError('\"listener\" argument must be a function');\n\n        events = this._events;\n        if (!events)\n          return this;\n\n        list = events[type];\n        if (!list)\n          return this;\n\n        if (list === listener || (list.listener && list.listener === listener)) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else {\n            delete events[type];\n            if (events.removeListener)\n              this.emit('removeListener', type, list.listener || listener);\n          }\n        } else if (typeof list !== 'function') {\n          position = -1;\n\n          for (i = list.length; i-- > 0;) {\n            if (list[i] === listener ||\n                (list[i].listener && list[i].listener === listener)) {\n              originalListener = list[i].listener;\n              position = i;\n              break;\n            }\n          }\n\n          if (position < 0)\n            return this;\n\n          if (list.length === 1) {\n            list[0] = undefined;\n            if (--this._eventsCount === 0) {\n              this._events = new EventHandlers();\n              return this;\n            } else {\n              delete events[type];\n            }\n          } else {\n            spliceOne(list, position);\n          }\n\n          if (events.removeListener)\n            this.emit('removeListener', type, originalListener || listener);\n        }\n\n        return this;\n      };\n      \n  // Alias for removeListener added in NodeJS 10.0\n  // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\n  EventEmitter.prototype.off = function(type, listener){\n      return this.removeListener(type, listener);\n  };\n\n  EventEmitter.prototype.removeAllListeners =\n      function removeAllListeners(type) {\n        var listeners, events;\n\n        events = this._events;\n        if (!events)\n          return this;\n\n        // not listening for removeListener, no need to emit\n        if (!events.removeListener) {\n          if (arguments.length === 0) {\n            this._events = new EventHandlers();\n            this._eventsCount = 0;\n          } else if (events[type]) {\n            if (--this._eventsCount === 0)\n              this._events = new EventHandlers();\n            else\n              delete events[type];\n          }\n          return this;\n        }\n\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n          var keys = Object.keys(events);\n          for (var i = 0, key; i < keys.length; ++i) {\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n          }\n          this.removeAllListeners('removeListener');\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n          return this;\n        }\n\n        listeners = events[type];\n\n        if (typeof listeners === 'function') {\n          this.removeListener(type, listeners);\n        } else if (listeners) {\n          // LIFO order\n          do {\n            this.removeListener(type, listeners[listeners.length - 1]);\n          } while (listeners[0]);\n        }\n\n        return this;\n      };\n\n  EventEmitter.prototype.listeners = function listeners(type) {\n    var evlistener;\n    var ret;\n    var events = this._events;\n\n    if (!events)\n      ret = [];\n    else {\n      evlistener = events[type];\n      if (!evlistener)\n        ret = [];\n      else if (typeof evlistener === 'function')\n        ret = [evlistener.listener || evlistener];\n      else\n        ret = unwrapListeners(evlistener);\n    }\n\n    return ret;\n  };\n\n  EventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === 'function') {\n      return emitter.listenerCount(type);\n    } else {\n      return listenerCount$1.call(emitter, type);\n    }\n  };\n\n  EventEmitter.prototype.listenerCount = listenerCount$1;\n  function listenerCount$1(type) {\n    var events = this._events;\n\n    if (events) {\n      var evlistener = events[type];\n\n      if (typeof evlistener === 'function') {\n        return 1;\n      } else if (evlistener) {\n        return evlistener.length;\n      }\n    }\n\n    return 0;\n  }\n\n  EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n  };\n\n  // About 1.5x faster than the two-arg version of Array#splice().\n  function spliceOne(list, index) {\n    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n      list[i] = list[k];\n    list.pop();\n  }\n\n  function arrayClone(arr, i) {\n    var copy = new Array(i);\n    while (i--)\n      copy[i] = arr[i];\n    return copy;\n  }\n\n  function unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for (var i = 0; i < ret.length; ++i) {\n      ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n  }\n\n  var inherits;\n  if (typeof Object.create === 'function'){\n    inherits = function inherits(ctor, superCtor) {\n      // implementation from standard node.js 'util' module\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    };\n  } else {\n    inherits = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    };\n  }\n\n  var formatRegExp = /%[sdj%]/g;\n  function format$1(f) {\n    if (!isString(f)) {\n      var objects = [];\n      for (var i = 0; i < arguments.length; i++) {\n        objects.push(inspect(arguments[i]));\n      }\n      return objects.join(' ');\n    }\n\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function(x) {\n      if (x === '%%') return '%';\n      if (i >= len) return x;\n      switch (x) {\n        case '%s': return String(args[i++]);\n        case '%d': return Number(args[i++]);\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n        default:\n          return x;\n      }\n    });\n    for (var x = args[i]; i < len; x = args[++i]) {\n      if (isNull(x) || !isObject(x)) {\n        str += ' ' + x;\n      } else {\n        str += ' ' + inspect(x);\n      }\n    }\n    return str;\n  }\n\n  // Mark that a method should not be used.\n  // Returns a modified function which warns once by default.\n  // If --no-deprecation is set, then it is a no-op.\n  function deprecate(fn, msg) {\n    // Allow for deprecating things in the process of starting up.\n    if (isUndefined(messages$1.global.process)) {\n      return function() {\n        return deprecate(fn, msg).apply(this, arguments);\n      };\n    }\n\n    if (messages$1.browser$1.noDeprecation === true) {\n      return fn;\n    }\n\n    var warned = false;\n    function deprecated() {\n      if (!warned) {\n        if (messages$1.browser$1.throwDeprecation) {\n          throw new Error(msg);\n        } else if (messages$1.browser$1.traceDeprecation) {\n          console.trace(msg);\n        } else {\n          console.error(msg);\n        }\n        warned = true;\n      }\n      return fn.apply(this, arguments);\n    }\n\n    return deprecated;\n  }\n\n  var debugs = {};\n  var debugEnviron;\n  function debuglog(set) {\n    if (isUndefined(debugEnviron))\n      debugEnviron = messages$1.browser$1.env.NODE_DEBUG || '';\n    set = set.toUpperCase();\n    if (!debugs[set]) {\n      if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n        var pid = 0;\n        debugs[set] = function() {\n          var msg = format$1.apply(null, arguments);\n          console.error('%s %d: %s', set, pid, msg);\n        };\n      } else {\n        debugs[set] = function() {};\n      }\n    }\n    return debugs[set];\n  }\n\n  /**\n   * Echos the value of a value. Trys to print the value out\n   * in the best way possible given the different types.\n   *\n   * @param {Object} obj The object to print out.\n   * @param {Object} opts Optional options object that alters the output.\n   */\n  /* legacy: obj, showHidden, depth, colors*/\n  function inspect(obj, opts) {\n    // default options\n    var ctx = {\n      seen: [],\n      stylize: stylizeNoColor\n    };\n    // legacy...\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n      // legacy...\n      ctx.showHidden = opts;\n    } else if (opts) {\n      // got an \"options\" object\n      _extend(ctx, opts);\n    }\n    // set default options\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n  }\n\n  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n  inspect.colors = {\n    'bold' : [1, 22],\n    'italic' : [3, 23],\n    'underline' : [4, 24],\n    'inverse' : [7, 27],\n    'white' : [37, 39],\n    'grey' : [90, 39],\n    'black' : [30, 39],\n    'blue' : [34, 39],\n    'cyan' : [36, 39],\n    'green' : [32, 39],\n    'magenta' : [35, 39],\n    'red' : [31, 39],\n    'yellow' : [33, 39]\n  };\n\n  // Don't use 'blue' not visible on cmd.exe\n  inspect.styles = {\n    'special': 'cyan',\n    'number': 'yellow',\n    'boolean': 'yellow',\n    'undefined': 'grey',\n    'null': 'bold',\n    'string': 'green',\n    'date': 'magenta',\n    // \"name\": intentionally not styling\n    'regexp': 'red'\n  };\n\n\n  function stylizeWithColor(str, styleType) {\n    var style = inspect.styles[styleType];\n\n    if (style) {\n      return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n             '\\u001b[' + inspect.colors[style][1] + 'm';\n    } else {\n      return str;\n    }\n  }\n\n\n  function stylizeNoColor(str, styleType) {\n    return str;\n  }\n\n\n  function arrayToHash(array) {\n    var hash = {};\n\n    array.forEach(function(val, idx) {\n      hash[val] = true;\n    });\n\n    return hash;\n  }\n\n\n  function formatValue(ctx, value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (ctx.customInspect &&\n        value &&\n        isFunction$1(value.inspect) &&\n        // Filter out the util module, it's inspect function is special\n        value.inspect !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      var ret = value.inspect(recurseTimes, ctx);\n      if (!isString(ret)) {\n        ret = formatValue(ctx, ret, recurseTimes);\n      }\n      return ret;\n    }\n\n    // Primitive types cannot have properties\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n      return primitive;\n    }\n\n    // Look up the keys of the object.\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    if (ctx.showHidden) {\n      keys = Object.getOwnPropertyNames(value);\n    }\n\n    // IE doesn't make error fields non-enumerable\n    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n    if (isError(value)\n        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n      return formatError(value);\n    }\n\n    // Some type of object without properties can be shortcutted.\n    if (keys.length === 0) {\n      if (isFunction$1(value)) {\n        var name = value.name ? ': ' + value.name : '';\n        return ctx.stylize('[Function' + name + ']', 'special');\n      }\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      }\n      if (isDate(value)) {\n        return ctx.stylize(Date.prototype.toString.call(value), 'date');\n      }\n      if (isError(value)) {\n        return formatError(value);\n      }\n    }\n\n    var base = '', array = false, braces = ['{', '}'];\n\n    // Make Array say that they are Array\n    if (isArray(value)) {\n      array = true;\n      braces = ['[', ']'];\n    }\n\n    // Make functions say that they are functions\n    if (isFunction$1(value)) {\n      var n = value.name ? ': ' + value.name : '';\n      base = ' [Function' + n + ']';\n    }\n\n    // Make RegExps say that they are RegExps\n    if (isRegExp(value)) {\n      base = ' ' + RegExp.prototype.toString.call(value);\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + Date.prototype.toUTCString.call(value);\n    }\n\n    // Make error with message first say the error\n    if (isError(value)) {\n      base = ' ' + formatError(value);\n    }\n\n    if (keys.length === 0 && (!array || value.length == 0)) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      } else {\n        return ctx.stylize('[Object]', 'special');\n      }\n    }\n\n    ctx.seen.push(value);\n\n    var output;\n    if (array) {\n      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n      output = keys.map(function(key) {\n        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n      });\n    }\n\n    ctx.seen.pop();\n\n    return reduceToSingleString(output, base, braces);\n  }\n\n\n  function formatPrimitive(ctx, value) {\n    if (isUndefined(value))\n      return ctx.stylize('undefined', 'undefined');\n    if (isString(value)) {\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n    }\n    if (isNumber(value))\n      return ctx.stylize('' + value, 'number');\n    if (isBoolean(value))\n      return ctx.stylize('' + value, 'boolean');\n    // For some reason typeof null is \"object\", so special case here.\n    if (isNull(value))\n      return ctx.stylize('null', 'null');\n  }\n\n\n  function formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n  }\n\n\n  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n      if (hasOwnProperty(value, String(i))) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n            String(i), true));\n      } else {\n        output.push('');\n      }\n    }\n    keys.forEach(function(key) {\n      if (!key.match(/^\\d+$/)) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n            key, true));\n      }\n    });\n    return output;\n  }\n\n\n  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n    if (desc.get) {\n      if (desc.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (desc.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n      name = '[' + key + ']';\n    }\n    if (!str) {\n      if (ctx.seen.indexOf(desc.value) < 0) {\n        if (isNull(recurseTimes)) {\n          str = formatValue(ctx, desc.value, null);\n        } else {\n          str = formatValue(ctx, desc.value, recurseTimes - 1);\n        }\n        if (str.indexOf('\\n') > -1) {\n          if (array) {\n            str = str.split('\\n').map(function(line) {\n              return '  ' + line;\n            }).join('\\n').substr(2);\n          } else {\n            str = '\\n' + str.split('\\n').map(function(line) {\n              return '   ' + line;\n            }).join('\\n');\n          }\n        }\n      } else {\n        str = ctx.stylize('[Circular]', 'special');\n      }\n    }\n    if (isUndefined(name)) {\n      if (array && key.match(/^\\d+$/)) {\n        return str;\n      }\n      name = JSON.stringify('' + key);\n      if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n        name = name.substr(1, name.length - 2);\n        name = ctx.stylize(name, 'name');\n      } else {\n        name = name.replace(/'/g, \"\\\\'\")\n                   .replace(/\\\\\"/g, '\"')\n                   .replace(/(^\"|\"$)/g, \"'\");\n        name = ctx.stylize(name, 'string');\n      }\n    }\n\n    return name + ': ' + str;\n  }\n\n\n  function reduceToSingleString(output, base, braces) {\n    var length = output.reduce(function(prev, cur) {\n      if (cur.indexOf('\\n') >= 0) ;\n      return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n    }, 0);\n\n    if (length > 60) {\n      return braces[0] +\n             (base === '' ? '' : base + '\\n ') +\n             ' ' +\n             output.join(',\\n  ') +\n             ' ' +\n             braces[1];\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n  }\n\n\n  // NOTE: These type checking functions intentionally don't use `instanceof`\n  // because it is fragile and can be easily faked with `Object.create()`.\n  function isArray(ar) {\n    return Array.isArray(ar);\n  }\n\n  function isBoolean(arg) {\n    return typeof arg === 'boolean';\n  }\n\n  function isNull(arg) {\n    return arg === null;\n  }\n\n  function isNumber(arg) {\n    return typeof arg === 'number';\n  }\n\n  function isString(arg) {\n    return typeof arg === 'string';\n  }\n\n  function isUndefined(arg) {\n    return arg === void 0;\n  }\n\n  function isRegExp(re) {\n    return isObject(re) && objectToString(re) === '[object RegExp]';\n  }\n\n  function isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n  }\n\n  function isDate(d) {\n    return isObject(d) && objectToString(d) === '[object Date]';\n  }\n\n  function isError(e) {\n    return isObject(e) &&\n        (objectToString(e) === '[object Error]' || e instanceof Error);\n  }\n\n  function isFunction$1(arg) {\n    return typeof arg === 'function';\n  }\n\n  function objectToString(o) {\n    return Object.prototype.toString.call(o);\n  }\n\n  function _extend(origin, add) {\n    // Don't do anything if add isn't an object\n    if (!add || !isObject(add)) return origin;\n\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n  }\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  function BufferList() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function (v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function (v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function () {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function () {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function (s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function (n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      p.data.copy(ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  var isBufferEncoding = Buffer.isEncoding\n    || function(encoding) {\n         switch (encoding && encoding.toLowerCase()) {\n           case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n           default: return false;\n         }\n       };\n\n\n  function assertEncoding(encoding) {\n    if (encoding && !isBufferEncoding(encoding)) {\n      throw new Error('Unknown encoding: ' + encoding);\n    }\n  }\n\n  // StringDecoder provides an interface for efficiently splitting a series of\n  // buffers into a series of JS strings without breaking apart multi-byte\n  // characters. CESU-8 is handled as part of the UTF-8 encoding.\n  //\n  // @TODO Handling all encodings inside a single object makes it very difficult\n  // to reason about this code, so it should be split up in the future.\n  // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n  // points as used by CESU-8.\n  function StringDecoder(encoding) {\n    this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n    assertEncoding(encoding);\n    switch (this.encoding) {\n      case 'utf8':\n        // CESU-8 represents each of Surrogate Pair by 3-bytes\n        this.surrogateSize = 3;\n        break;\n      case 'ucs2':\n      case 'utf16le':\n        // UTF-16 represents each of Surrogate Pair by 2-bytes\n        this.surrogateSize = 2;\n        this.detectIncompleteChar = utf16DetectIncompleteChar;\n        break;\n      case 'base64':\n        // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n        this.surrogateSize = 3;\n        this.detectIncompleteChar = base64DetectIncompleteChar;\n        break;\n      default:\n        this.write = passThroughWrite;\n        return;\n    }\n\n    // Enough space to store all bytes of a single character. UTF-8 needs 4\n    // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n    this.charBuffer = new Buffer(6);\n    // Number of bytes received for the current incomplete multi-byte character.\n    this.charReceived = 0;\n    // Number of bytes expected for the current incomplete multi-byte character.\n    this.charLength = 0;\n  }\n\n  // write decodes the given buffer and returns it as JS string that is\n  // guaranteed to not contain any partial multi-byte characters. Any partial\n  // character found at the end of the buffer is buffered up, and will be\n  // returned when calling write again with the remaining bytes.\n  //\n  // Note: Converting a Buffer containing an orphan surrogate to a String\n  // currently works, but converting a String to a Buffer (via `new Buffer`, or\n  // Buffer#write) will replace incomplete surrogates with the unicode\n  // replacement character. See https://codereview.chromium.org/121173009/ .\n  StringDecoder.prototype.write = function(buffer) {\n    var charStr = '';\n    // if our last write ended with an incomplete multibyte character\n    while (this.charLength) {\n      // determine how many remaining bytes this buffer has to offer for this char\n      var available = (buffer.length >= this.charLength - this.charReceived) ?\n          this.charLength - this.charReceived :\n          buffer.length;\n\n      // add the new bytes to the char buffer\n      buffer.copy(this.charBuffer, this.charReceived, 0, available);\n      this.charReceived += available;\n\n      if (this.charReceived < this.charLength) {\n        // still not enough chars in this buffer? wait for more ...\n        return '';\n      }\n\n      // remove bytes belonging to the current character from the buffer\n      buffer = buffer.slice(available, buffer.length);\n\n      // get the character that was split\n      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n      var charCode = charStr.charCodeAt(charStr.length - 1);\n      if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n        this.charLength += this.surrogateSize;\n        charStr = '';\n        continue;\n      }\n      this.charReceived = this.charLength = 0;\n\n      // if there are no more bytes in this buffer, just emit our char\n      if (buffer.length === 0) {\n        return charStr;\n      }\n      break;\n    }\n\n    // determine and set charLength / charReceived\n    this.detectIncompleteChar(buffer);\n\n    var end = buffer.length;\n    if (this.charLength) {\n      // buffer the incomplete character bytes we got\n      buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n      end -= this.charReceived;\n    }\n\n    charStr += buffer.toString(this.encoding, 0, end);\n\n    var end = charStr.length - 1;\n    var charCode = charStr.charCodeAt(end);\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      var size = this.surrogateSize;\n      this.charLength += size;\n      this.charReceived += size;\n      this.charBuffer.copy(this.charBuffer, size, 0, size);\n      buffer.copy(this.charBuffer, 0, 0, size);\n      return charStr.substring(0, end);\n    }\n\n    // or just emit the charStr\n    return charStr;\n  };\n\n  // detectIncompleteChar determines if there is an incomplete UTF-8 character at\n  // the end of the given buffer. If so, it sets this.charLength to the byte\n  // length that character, and sets this.charReceived to the number of bytes\n  // that are available for this character.\n  StringDecoder.prototype.detectIncompleteChar = function(buffer) {\n    // determine how many bytes we have to check at the end of this buffer\n    var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n    // Figure out if one of the last i bytes of our buffer announces an\n    // incomplete char.\n    for (; i > 0; i--) {\n      var c = buffer[buffer.length - i];\n\n      // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n      // 110XXXXX\n      if (i == 1 && c >> 5 == 0x06) {\n        this.charLength = 2;\n        break;\n      }\n\n      // 1110XXXX\n      if (i <= 2 && c >> 4 == 0x0E) {\n        this.charLength = 3;\n        break;\n      }\n\n      // 11110XXX\n      if (i <= 3 && c >> 3 == 0x1E) {\n        this.charLength = 4;\n        break;\n      }\n    }\n    this.charReceived = i;\n  };\n\n  StringDecoder.prototype.end = function(buffer) {\n    var res = '';\n    if (buffer && buffer.length)\n      res = this.write(buffer);\n\n    if (this.charReceived) {\n      var cr = this.charReceived;\n      var buf = this.charBuffer;\n      var enc = this.encoding;\n      res += buf.slice(0, cr).toString(enc);\n    }\n\n    return res;\n  };\n\n  function passThroughWrite(buffer) {\n    return buffer.toString(this.encoding);\n  }\n\n  function utf16DetectIncompleteChar(buffer) {\n    this.charReceived = buffer.length % 2;\n    this.charLength = this.charReceived ? 2 : 0;\n  }\n\n  function base64DetectIncompleteChar(buffer) {\n    this.charReceived = buffer.length % 3;\n    this.charLength = this.charReceived ? 3 : 0;\n  }\n\n  Readable.ReadableState = ReadableState;\n\n  var debug = debuglog('stream');\n  inherits(Readable, EventEmitter);\n\n  function prependListener(emitter, event, fn) {\n    // Sadly this is not cacheable as some libraries bundle their own\n    // event emitter implementation with them.\n    if (typeof emitter.prependListener === 'function') {\n      return emitter.prependListener(event, fn);\n    } else {\n      // This is a hack to make sure that our error handler is attached before any\n      // userland ones.  NEVER DO THIS. This is here only because this code needs\n      // to continue to work with older versions of Node.js that do not include\n      // the prependListener() method. The goal is to eventually remove this hack.\n      if (!emitter._events || !emitter._events[event])\n        emitter.on(event, fn);\n      else if (Array.isArray(emitter._events[event]))\n        emitter._events[event].unshift(fn);\n      else\n        emitter._events[event] = [fn, emitter._events[event]];\n    }\n  }\n  function listenerCount (emitter, type) {\n    return emitter.listeners(type).length;\n  }\n  function ReadableState(options, stream) {\n\n    options = options || {};\n\n    // object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away\n    this.objectMode = !!options.objectMode;\n\n    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n    // the point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    var hwm = options.highWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n    // cast to ints.\n    this.highWaterMark = ~ ~this.highWaterMark;\n\n    // A linked list is used to store data chunks instead of an array because the\n    // linked list can remove elements from the beginning faster than\n    // array.shift()\n    this.buffer = new BufferList();\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n\n    // whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    this.resumeScheduled = false;\n\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n    // when piping, we only care about 'readable' events that happen\n    // after read()ing all the bytes and not getting any pushback.\n    this.ranOut = false;\n\n    // the number of writers that are awaiting a drain event in .pipe()s\n    this.awaitDrain = 0;\n\n    // if true, a maybeReadMore has been scheduled\n    this.readingMore = false;\n\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n      this.decoder = new StringDecoder(options.encoding);\n      this.encoding = options.encoding;\n    }\n  }\n  function Readable(options) {\n\n    if (!(this instanceof Readable)) return new Readable(options);\n\n    this._readableState = new ReadableState(options, this);\n\n    // legacy\n    this.readable = true;\n\n    if (options && typeof options.read === 'function') this._read = options.read;\n\n    EventEmitter.call(this);\n  }\n\n  // Manually shove something into the read() buffer.\n  // This returns true if the highWaterMark has not been hit yet,\n  // similar to how Writable.write() returns true if you should\n  // write() some more.\n  Readable.prototype.push = function (chunk, encoding) {\n    var state = this._readableState;\n\n    if (!state.objectMode && typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n    }\n\n    return readableAddChunk(this, state, chunk, encoding, false);\n  };\n\n  // Unshift should *always* be something directly out of read()\n  Readable.prototype.unshift = function (chunk) {\n    var state = this._readableState;\n    return readableAddChunk(this, state, chunk, '', true);\n  };\n\n  Readable.prototype.isPaused = function () {\n    return this._readableState.flowing === false;\n  };\n\n  function readableAddChunk(stream, state, chunk, encoding, addToFront) {\n    var er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (chunk === null) {\n      state.reading = false;\n      onEofChunk(stream, state);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (state.ended && !addToFront) {\n        var e = new Error('stream.push() after EOF');\n        stream.emit('error', e);\n      } else if (state.endEmitted && addToFront) {\n        var _e = new Error('stream.unshift() after end event');\n        stream.emit('error', _e);\n      } else {\n        var skipAdd;\n        if (state.decoder && !addToFront && !encoding) {\n          chunk = state.decoder.write(chunk);\n          skipAdd = !state.objectMode && chunk.length === 0;\n        }\n\n        if (!addToFront) state.reading = false;\n\n        // Don't add to the buffer if we've decoded to an empty string chunk and\n        // we're not in object mode\n        if (!skipAdd) {\n          // if we want the data now, just emit it.\n          if (state.flowing && state.length === 0 && !state.sync) {\n            stream.emit('data', chunk);\n            stream.read(0);\n          } else {\n            // update the buffer info.\n            state.length += state.objectMode ? 1 : chunk.length;\n            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n            if (state.needReadable) emitReadable(stream);\n          }\n        }\n\n        maybeReadMore(stream, state);\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n\n    return needMoreData(state);\n  }\n\n  // if it's past the high water mark, we can push in some more.\n  // Also, if we have no data yet, we can stand some\n  // more bytes.  This is to work around cases where hwm=0,\n  // such as the repl.  Also, if the push() triggered a\n  // readable event, and the user called read(largeNumber) such that\n  // needReadable was set, then we ought to push more, so that another\n  // 'readable' event will be triggered.\n  function needMoreData(state) {\n    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n  }\n\n  // backwards compatibility.\n  Readable.prototype.setEncoding = function (enc) {\n    this._readableState.decoder = new StringDecoder(enc);\n    this._readableState.encoding = enc;\n    return this;\n  };\n\n  // Don't raise the hwm > 8MB\n  var MAX_HWM = 0x800000;\n  function computeNewHighWaterMark(n) {\n    if (n >= MAX_HWM) {\n      n = MAX_HWM;\n    } else {\n      // Get the next highest power of 2 to prevent increasing hwm excessively in\n      // tiny amounts\n      n--;\n      n |= n >>> 1;\n      n |= n >>> 2;\n      n |= n >>> 4;\n      n |= n >>> 8;\n      n |= n >>> 16;\n      n++;\n    }\n    return n;\n  }\n\n  // This function is designed to be inlinable, so please take care when making\n  // changes to the function body.\n  function howMuchToRead(n, state) {\n    if (n <= 0 || state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return 1;\n    if (n !== n) {\n      // Only flow one buffer at a time\n      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n    }\n    // If we're asking for more than the current hwm, then raise the hwm.\n    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n    if (n <= state.length) return n;\n    // Don't have enough\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    }\n    return state.length;\n  }\n\n  // you can override either this method, or the async _read(n) below.\n  Readable.prototype.read = function (n) {\n    debug('read', n);\n    n = parseInt(n, 10);\n    var state = this._readableState;\n    var nOrig = n;\n\n    if (n !== 0) state.emittedReadable = false;\n\n    // if we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n      debug('read: emitReadable', state.length, state.ended);\n      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n      return null;\n    }\n\n    n = howMuchToRead(n, state);\n\n    // if we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n      if (state.length === 0) endReadable(this);\n      return null;\n    }\n\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n\n    // if we need a readable event, then we need to do some reading.\n    var doRead = state.needReadable;\n    debug('need readable', doRead);\n\n    // if we currently have less than the highWaterMark, then also read some\n    if (state.length === 0 || state.length - n < state.highWaterMark) {\n      doRead = true;\n      debug('length less than watermark', doRead);\n    }\n\n    // however, if we've ended, then there's no point, and if we're already\n    // reading, then it's unnecessary.\n    if (state.ended || state.reading) {\n      doRead = false;\n      debug('reading or ended', doRead);\n    } else if (doRead) {\n      debug('do read');\n      state.reading = true;\n      state.sync = true;\n      // if the length is currently zero, then we *need* a readable event.\n      if (state.length === 0) state.needReadable = true;\n      // call internal read method\n      this._read(state.highWaterMark);\n      state.sync = false;\n      // If _read pushed data synchronously, then `reading` will be false,\n      // and we need to re-evaluate how much data we can return to the user.\n      if (!state.reading) n = howMuchToRead(nOrig, state);\n    }\n\n    var ret;\n    if (n > 0) ret = fromList(n, state);else ret = null;\n\n    if (ret === null) {\n      state.needReadable = true;\n      n = 0;\n    } else {\n      state.length -= n;\n    }\n\n    if (state.length === 0) {\n      // If we have nothing in the buffer, then we want to know\n      // as soon as we *do* get something into the buffer.\n      if (!state.ended) state.needReadable = true;\n\n      // If we tried to read() past the EOF, then emit end on the next tick.\n      if (nOrig !== n && state.ended) endReadable(this);\n    }\n\n    if (ret !== null) this.emit('data', ret);\n\n    return ret;\n  };\n\n  function chunkInvalid(state, chunk) {\n    var er = null;\n    if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n      er = new TypeError('Invalid non-string/buffer chunk');\n    }\n    return er;\n  }\n\n  function onEofChunk(stream, state) {\n    if (state.ended) return;\n    if (state.decoder) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) {\n        state.buffer.push(chunk);\n        state.length += state.objectMode ? 1 : chunk.length;\n      }\n    }\n    state.ended = true;\n\n    // emit 'readable' now to make sure it gets picked up.\n    emitReadable(stream);\n  }\n\n  // Don't emit readable right away in sync mode, because this can trigger\n  // another read() call => stack overflow.  This way, it might trigger\n  // a nextTick recursion warning, but that's not so bad.\n  function emitReadable(stream) {\n    var state = stream._readableState;\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      debug('emitReadable', state.flowing);\n      state.emittedReadable = true;\n      if (state.sync) messages$1.nextTick(emitReadable_, stream);else emitReadable_(stream);\n    }\n  }\n\n  function emitReadable_(stream) {\n    debug('emit readable');\n    stream.emit('readable');\n    flow(stream);\n  }\n\n  // at this point, the user has presumably seen the 'readable' event,\n  // and called read() to consume some data.  that may have triggered\n  // in turn another _read(n) call, in which case reading = true if\n  // it's in progress.\n  // However, if we're not ended, or reading, and the length < hwm,\n  // then go ahead and try to read some more preemptively.\n  function maybeReadMore(stream, state) {\n    if (!state.readingMore) {\n      state.readingMore = true;\n      messages$1.nextTick(maybeReadMore_, stream, state);\n    }\n  }\n\n  function maybeReadMore_(stream, state) {\n    var len = state.length;\n    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n      debug('maybeReadMore read 0');\n      stream.read(0);\n      if (len === state.length)\n        // didn't get any data, stop spinning.\n        break;else len = state.length;\n    }\n    state.readingMore = false;\n  }\n\n  // abstract method.  to be overridden in specific implementation classes.\n  // call cb(er, data) where data is <= n in length.\n  // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n  // arbitrary, and perhaps not very meaningful.\n  Readable.prototype._read = function (n) {\n    this.emit('error', new Error('not implemented'));\n  };\n\n  Readable.prototype.pipe = function (dest, pipeOpts) {\n    var src = this;\n    var state = this._readableState;\n\n    switch (state.pipesCount) {\n      case 0:\n        state.pipes = dest;\n        break;\n      case 1:\n        state.pipes = [state.pipes, dest];\n        break;\n      default:\n        state.pipes.push(dest);\n        break;\n    }\n    state.pipesCount += 1;\n    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n    var doEnd = (!pipeOpts || pipeOpts.end !== false);\n\n    var endFn = doEnd ? onend : cleanup;\n    if (state.endEmitted) messages$1.nextTick(endFn);else src.once('end', endFn);\n\n    dest.on('unpipe', onunpipe);\n    function onunpipe(readable) {\n      debug('onunpipe');\n      if (readable === src) {\n        cleanup();\n      }\n    }\n\n    function onend() {\n      debug('onend');\n      dest.end();\n    }\n\n    // when the dest drains, it reduces the awaitDrain counter\n    // on the source.  This would be more elegant with a .once()\n    // handler in flow(), but adding and removing repeatedly is\n    // too slow.\n    var ondrain = pipeOnDrain(src);\n    dest.on('drain', ondrain);\n\n    var cleanedUp = false;\n    function cleanup() {\n      debug('cleanup');\n      // cleanup event handlers once the pipe is broken\n      dest.removeListener('close', onclose);\n      dest.removeListener('finish', onfinish);\n      dest.removeListener('drain', ondrain);\n      dest.removeListener('error', onerror);\n      dest.removeListener('unpipe', onunpipe);\n      src.removeListener('end', onend);\n      src.removeListener('end', cleanup);\n      src.removeListener('data', ondata);\n\n      cleanedUp = true;\n\n      // if the reader is waiting for a drain event from this\n      // specific writer, then it would cause it to never start\n      // flowing again.\n      // So, if this is awaiting a drain, then we just call it now.\n      // If we don't know, then assume that we are waiting for one.\n      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n    }\n\n    // If the user pushes more data while we're writing to dest then we'll end up\n    // in ondata again. However, we only want to increase awaitDrain once because\n    // dest will only emit one 'drain' event for the multiple writes.\n    // => Introduce a guard on increasing awaitDrain.\n    var increasedAwaitDrain = false;\n    src.on('data', ondata);\n    function ondata(chunk) {\n      debug('ondata');\n      increasedAwaitDrain = false;\n      var ret = dest.write(chunk);\n      if (false === ret && !increasedAwaitDrain) {\n        // If the user unpiped during `dest.write()`, it is possible\n        // to get stuck in a permanently paused state if that write\n        // also returned false.\n        // => Check whether `dest` is still a piping destination.\n        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n          debug('false write response, pause', src._readableState.awaitDrain);\n          src._readableState.awaitDrain++;\n          increasedAwaitDrain = true;\n        }\n        src.pause();\n      }\n    }\n\n    // if the dest has an error, then stop piping into it.\n    // however, don't suppress the throwing behavior for this.\n    function onerror(er) {\n      debug('onerror', er);\n      unpipe();\n      dest.removeListener('error', onerror);\n      if (listenerCount(dest, 'error') === 0) dest.emit('error', er);\n    }\n\n    // Make sure our error handler is attached before userland ones.\n    prependListener(dest, 'error', onerror);\n\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n      dest.removeListener('finish', onfinish);\n      unpipe();\n    }\n    dest.once('close', onclose);\n    function onfinish() {\n      debug('onfinish');\n      dest.removeListener('close', onclose);\n      unpipe();\n    }\n    dest.once('finish', onfinish);\n\n    function unpipe() {\n      debug('unpipe');\n      src.unpipe(dest);\n    }\n\n    // tell the dest that it's being piped to\n    dest.emit('pipe', src);\n\n    // start the flow if it hasn't been started already.\n    if (!state.flowing) {\n      debug('pipe resume');\n      src.resume();\n    }\n\n    return dest;\n  };\n\n  function pipeOnDrain(src) {\n    return function () {\n      var state = src._readableState;\n      debug('pipeOnDrain', state.awaitDrain);\n      if (state.awaitDrain) state.awaitDrain--;\n      if (state.awaitDrain === 0 && src.listeners('data').length) {\n        state.flowing = true;\n        flow(src);\n      }\n    };\n  }\n\n  Readable.prototype.unpipe = function (dest) {\n    var state = this._readableState;\n\n    // if we're not piping anywhere, then do nothing.\n    if (state.pipesCount === 0) return this;\n\n    // just one destination.  most common case.\n    if (state.pipesCount === 1) {\n      // passed in one, but it's not the right one.\n      if (dest && dest !== state.pipes) return this;\n\n      if (!dest) dest = state.pipes;\n\n      // got a match.\n      state.pipes = null;\n      state.pipesCount = 0;\n      state.flowing = false;\n      if (dest) dest.emit('unpipe', this);\n      return this;\n    }\n\n    // slow case. multiple pipe destinations.\n\n    if (!dest) {\n      // remove all.\n      var dests = state.pipes;\n      var len = state.pipesCount;\n      state.pipes = null;\n      state.pipesCount = 0;\n      state.flowing = false;\n\n      for (var _i = 0; _i < len; _i++) {\n        dests[_i].emit('unpipe', this);\n      }return this;\n    }\n\n    // try to find the right one.\n    var i = indexOf(state.pipes, dest);\n    if (i === -1) return this;\n\n    state.pipes.splice(i, 1);\n    state.pipesCount -= 1;\n    if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n    dest.emit('unpipe', this);\n\n    return this;\n  };\n\n  // set up data events if they are asked for\n  // Ensure readable listeners eventually get something\n  Readable.prototype.on = function (ev, fn) {\n    var res = EventEmitter.prototype.on.call(this, ev, fn);\n\n    if (ev === 'data') {\n      // Start flowing on next tick if stream isn't explicitly paused\n      if (this._readableState.flowing !== false) this.resume();\n    } else if (ev === 'readable') {\n      var state = this._readableState;\n      if (!state.endEmitted && !state.readableListening) {\n        state.readableListening = state.needReadable = true;\n        state.emittedReadable = false;\n        if (!state.reading) {\n          messages$1.nextTick(nReadingNextTick, this);\n        } else if (state.length) {\n          emitReadable(this);\n        }\n      }\n    }\n\n    return res;\n  };\n  Readable.prototype.addListener = Readable.prototype.on;\n\n  function nReadingNextTick(self) {\n    debug('readable nexttick read 0');\n    self.read(0);\n  }\n\n  // pause() and resume() are remnants of the legacy readable stream API\n  // If the user uses them, then switch into old mode.\n  Readable.prototype.resume = function () {\n    var state = this._readableState;\n    if (!state.flowing) {\n      debug('resume');\n      state.flowing = true;\n      resume(this, state);\n    }\n    return this;\n  };\n\n  function resume(stream, state) {\n    if (!state.resumeScheduled) {\n      state.resumeScheduled = true;\n      messages$1.nextTick(resume_, stream, state);\n    }\n  }\n\n  function resume_(stream, state) {\n    if (!state.reading) {\n      debug('resume read 0');\n      stream.read(0);\n    }\n\n    state.resumeScheduled = false;\n    state.awaitDrain = 0;\n    stream.emit('resume');\n    flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n  }\n\n  Readable.prototype.pause = function () {\n    debug('call pause flowing=%j', this._readableState.flowing);\n    if (false !== this._readableState.flowing) {\n      debug('pause');\n      this._readableState.flowing = false;\n      this.emit('pause');\n    }\n    return this;\n  };\n\n  function flow(stream) {\n    var state = stream._readableState;\n    debug('flow', state.flowing);\n    while (state.flowing && stream.read() !== null) {}\n  }\n\n  // wrap an old-style stream as the async data source.\n  // This is *not* part of the readable stream interface.\n  // It is an ugly unfortunate mess of history.\n  Readable.prototype.wrap = function (stream) {\n    var state = this._readableState;\n    var paused = false;\n\n    var self = this;\n    stream.on('end', function () {\n      debug('wrapped end');\n      if (state.decoder && !state.ended) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) self.push(chunk);\n      }\n\n      self.push(null);\n    });\n\n    stream.on('data', function (chunk) {\n      debug('wrapped data');\n      if (state.decoder) chunk = state.decoder.write(chunk);\n\n      // don't skip over falsy values in objectMode\n      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n      var ret = self.push(chunk);\n      if (!ret) {\n        paused = true;\n        stream.pause();\n      }\n    });\n\n    // proxy all the other methods.\n    // important when wrapping filters and duplexes.\n    for (var i in stream) {\n      if (this[i] === undefined && typeof stream[i] === 'function') {\n        this[i] = function (method) {\n          return function () {\n            return stream[method].apply(stream, arguments);\n          };\n        }(i);\n      }\n    }\n\n    // proxy certain important events.\n    var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n    forEach(events, function (ev) {\n      stream.on(ev, self.emit.bind(self, ev));\n    });\n\n    // when we try to consume some more bytes, simply unpause the\n    // underlying stream.\n    self._read = function (n) {\n      debug('wrapped _read', n);\n      if (paused) {\n        paused = false;\n        stream.resume();\n      }\n    };\n\n    return self;\n  };\n\n  // exposed for testing purposes only.\n  Readable._fromList = fromList;\n\n  // Pluck off n bytes from an array of buffers.\n  // Length is the combined lengths of all the buffers in the list.\n  // This function is designed to be inlinable, so please take care when making\n  // changes to the function body.\n  function fromList(n, state) {\n    // nothing buffered\n    if (state.length === 0) return null;\n\n    var ret;\n    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n      // read it all, truncate the list\n      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n      state.buffer.clear();\n    } else {\n      // read part of list\n      ret = fromListPartial(n, state.buffer, state.decoder);\n    }\n\n    return ret;\n  }\n\n  // Extracts only enough buffered data to satisfy the amount requested.\n  // This function is designed to be inlinable, so please take care when making\n  // changes to the function body.\n  function fromListPartial(n, list, hasStrings) {\n    var ret;\n    if (n < list.head.data.length) {\n      // slice is the same for buffers and strings\n      ret = list.head.data.slice(0, n);\n      list.head.data = list.head.data.slice(n);\n    } else if (n === list.head.data.length) {\n      // first chunk is a perfect match\n      ret = list.shift();\n    } else {\n      // result spans more than one buffer\n      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n    }\n    return ret;\n  }\n\n  // Copies a specified amount of characters from the list of buffered data\n  // chunks.\n  // This function is designed to be inlinable, so please take care when making\n  // changes to the function body.\n  function copyFromBufferString(n, list) {\n    var p = list.head;\n    var c = 1;\n    var ret = p.data;\n    n -= ret.length;\n    while (p = p.next) {\n      var str = p.data;\n      var nb = n > str.length ? str.length : n;\n      if (nb === str.length) ret += str;else ret += str.slice(0, n);\n      n -= nb;\n      if (n === 0) {\n        if (nb === str.length) {\n          ++c;\n          if (p.next) list.head = p.next;else list.head = list.tail = null;\n        } else {\n          list.head = p;\n          p.data = str.slice(nb);\n        }\n        break;\n      }\n      ++c;\n    }\n    list.length -= c;\n    return ret;\n  }\n\n  // Copies a specified amount of bytes from the list of buffered data chunks.\n  // This function is designed to be inlinable, so please take care when making\n  // changes to the function body.\n  function copyFromBuffer(n, list) {\n    var ret = Buffer.allocUnsafe(n);\n    var p = list.head;\n    var c = 1;\n    p.data.copy(ret);\n    n -= p.data.length;\n    while (p = p.next) {\n      var buf = p.data;\n      var nb = n > buf.length ? buf.length : n;\n      buf.copy(ret, ret.length - n, 0, nb);\n      n -= nb;\n      if (n === 0) {\n        if (nb === buf.length) {\n          ++c;\n          if (p.next) list.head = p.next;else list.head = list.tail = null;\n        } else {\n          list.head = p;\n          p.data = buf.slice(nb);\n        }\n        break;\n      }\n      ++c;\n    }\n    list.length -= c;\n    return ret;\n  }\n\n  function endReadable(stream) {\n    var state = stream._readableState;\n\n    // If we get here before consuming all the bytes, then that is a\n    // bug in node.  Should never happen.\n    if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n    if (!state.endEmitted) {\n      state.ended = true;\n      messages$1.nextTick(endReadableNT, state, stream);\n    }\n  }\n\n  function endReadableNT(state, stream) {\n    // Check that we didn't get one last unshift.\n    if (!state.endEmitted && state.length === 0) {\n      state.endEmitted = true;\n      stream.readable = false;\n      stream.emit('end');\n    }\n  }\n\n  function forEach(xs, f) {\n    for (var i = 0, l = xs.length; i < l; i++) {\n      f(xs[i], i);\n    }\n  }\n\n  function indexOf(xs, x) {\n    for (var i = 0, l = xs.length; i < l; i++) {\n      if (xs[i] === x) return i;\n    }\n    return -1;\n  }\n\n  // A bit simpler than readable streams.\n  // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n  // the drain event emission and buffering.\n\n  Writable.WritableState = WritableState;\n  inherits(Writable, EventEmitter);\n\n  function nop() {}\n\n  function WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n    this.next = null;\n  }\n\n  function WritableState(options, stream) {\n    Object.defineProperty(this, 'buffer', {\n      get: deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n    options = options || {};\n\n    // object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!options.objectMode;\n\n    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n    // the point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write()\n    var hwm = options.highWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n    // cast to ints.\n    this.highWaterMark = ~ ~this.highWaterMark;\n\n    this.needDrain = false;\n    // at the start of calling end()\n    this.ending = false;\n    // when end() has been called, and returned\n    this.ended = false;\n    // when 'finish' is emitted\n    this.finished = false;\n\n    // should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n    // not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n\n    // a flag to see when we're in the middle of a write.\n    this.writing = false;\n\n    // when true all writes will be buffered until .uncork() call\n    this.corked = 0;\n\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n\n    // a flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n\n    // the callback that's passed to _write(chunk,cb)\n    this.onwrite = function (er) {\n      onwrite(stream, er);\n    };\n\n    // the callback that the user supplies to write(chunk,encoding,cb)\n    this.writecb = null;\n\n    // the amount that is being written when _write is called.\n    this.writelen = 0;\n\n    this.bufferedRequest = null;\n    this.lastBufferedRequest = null;\n\n    // number of pending user-supplied write callbacks\n    // this must be 0 before 'finish' can be emitted\n    this.pendingcb = 0;\n\n    // emit prefinish if the only thing we're waiting for is _write cbs\n    // This is relevant for synchronous Transform streams\n    this.prefinished = false;\n\n    // True if the error was already emitted and should not be thrown again\n    this.errorEmitted = false;\n\n    // count buffered requests\n    this.bufferedRequestCount = 0;\n\n    // allocate the first CorkedRequest, there is always\n    // one allocated and free to use, and we maintain at most two\n    this.corkedRequestsFree = new CorkedRequest(this);\n  }\n\n  WritableState.prototype.getBuffer = function writableStateGetBuffer() {\n    var current = this.bufferedRequest;\n    var out = [];\n    while (current) {\n      out.push(current);\n      current = current.next;\n    }\n    return out;\n  };\n  function Writable(options) {\n\n    // Writable ctor is applied to Duplexes, though they're not\n    // instanceof Writable, they're instanceof Readable.\n    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n    this._writableState = new WritableState(options, this);\n\n    // legacy.\n    this.writable = true;\n\n    if (options) {\n      if (typeof options.write === 'function') this._write = options.write;\n\n      if (typeof options.writev === 'function') this._writev = options.writev;\n    }\n\n    EventEmitter.call(this);\n  }\n\n  // Otherwise people can pipe Writable streams, which is just wrong.\n  Writable.prototype.pipe = function () {\n    this.emit('error', new Error('Cannot pipe, not readable'));\n  };\n\n  function writeAfterEnd(stream, cb) {\n    var er = new Error('write after end');\n    // TODO: defer error events consistently everywhere, not just the cb\n    stream.emit('error', er);\n    messages$1.nextTick(cb, er);\n  }\n\n  // If we get something that is not a buffer, string, null, or undefined,\n  // and we're not in objectMode, then that's an error.\n  // Otherwise stream chunks are all considered to be of length=1, and the\n  // watermarks determine how many objects to keep in the buffer, rather than\n  // how many bytes or characters.\n  function validChunk(stream, state, chunk, cb) {\n    var valid = true;\n    var er = false;\n    // Always throw error if a null is written\n    // if we are not in object mode then throw\n    // if it is not a buffer, string, or undefined.\n    if (chunk === null) {\n      er = new TypeError('May not write null values to stream');\n    } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n      er = new TypeError('Invalid non-string/buffer chunk');\n    }\n    if (er) {\n      stream.emit('error', er);\n      messages$1.nextTick(cb, er);\n      valid = false;\n    }\n    return valid;\n  }\n\n  Writable.prototype.write = function (chunk, encoding, cb) {\n    var state = this._writableState;\n    var ret = false;\n\n    if (typeof encoding === 'function') {\n      cb = encoding;\n      encoding = null;\n    }\n\n    if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n    if (typeof cb !== 'function') cb = nop;\n\n    if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n      state.pendingcb++;\n      ret = writeOrBuffer(this, state, chunk, encoding, cb);\n    }\n\n    return ret;\n  };\n\n  Writable.prototype.cork = function () {\n    var state = this._writableState;\n\n    state.corked++;\n  };\n\n  Writable.prototype.uncork = function () {\n    var state = this._writableState;\n\n    if (state.corked) {\n      state.corked--;\n\n      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n    }\n  };\n\n  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n    // node::ParseEncoding() requires lower case.\n    if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n    this._writableState.defaultEncoding = encoding;\n    return this;\n  };\n\n  function decodeChunk(state, chunk, encoding) {\n    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    return chunk;\n  }\n\n  // if we're already writing something, then just put this\n  // in the queue, and wait our turn.  Otherwise, call _write\n  // If we return false, then we need a drain event, so set that flag.\n  function writeOrBuffer(stream, state, chunk, encoding, cb) {\n    chunk = decodeChunk(state, chunk, encoding);\n\n    if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n    var len = state.objectMode ? 1 : chunk.length;\n\n    state.length += len;\n\n    var ret = state.length < state.highWaterMark;\n    // we must ensure that previous needDrain will not be reset to false.\n    if (!ret) state.needDrain = true;\n\n    if (state.writing || state.corked) {\n      var last = state.lastBufferedRequest;\n      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n      if (last) {\n        last.next = state.lastBufferedRequest;\n      } else {\n        state.bufferedRequest = state.lastBufferedRequest;\n      }\n      state.bufferedRequestCount += 1;\n    } else {\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n    }\n\n    return ret;\n  }\n\n  function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n  }\n\n  function onwriteError(stream, state, sync, er, cb) {\n    --state.pendingcb;\n    if (sync) messages$1.nextTick(cb, er);else cb(er);\n\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  }\n\n  function onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n  }\n\n  function onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n\n    onwriteStateUpdate(state);\n\n    if (er) onwriteError(stream, state, sync, er, cb);else {\n      // Check if we're actually ready to finish, but don't emit yet\n      var finished = needFinish(state);\n\n      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n        clearBuffer(stream, state);\n      }\n\n      if (sync) {\n        /*<replacement>*/\n          messages$1.nextTick(afterWrite, stream, state, finished, cb);\n        /*</replacement>*/\n      } else {\n          afterWrite(stream, state, finished, cb);\n        }\n    }\n  }\n\n  function afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    state.pendingcb--;\n    cb();\n    finishMaybe(stream, state);\n  }\n\n  // Must force callback to be called on nextTick, so that we don't\n  // emit 'drain' before the write() consumer gets the 'false' return\n  // value, and has a chance to attach a 'drain' listener.\n  function onwriteDrain(stream, state) {\n    if (state.length === 0 && state.needDrain) {\n      state.needDrain = false;\n      stream.emit('drain');\n    }\n  }\n\n  // if there's something in the buffer waiting, then process it\n  function clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    var entry = state.bufferedRequest;\n\n    if (stream._writev && entry && entry.next) {\n      // Fast case, write everything using _writev()\n      var l = state.bufferedRequestCount;\n      var buffer = new Array(l);\n      var holder = state.corkedRequestsFree;\n      holder.entry = entry;\n\n      var count = 0;\n      while (entry) {\n        buffer[count] = entry;\n        entry = entry.next;\n        count += 1;\n      }\n\n      doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n      // doWrite is almost always async, defer these to save a bit of time\n      // as the hot path ends with doWrite\n      state.pendingcb++;\n      state.lastBufferedRequest = null;\n      if (holder.next) {\n        state.corkedRequestsFree = holder.next;\n        holder.next = null;\n      } else {\n        state.corkedRequestsFree = new CorkedRequest(state);\n      }\n    } else {\n      // Slow case, write chunks one-by-one\n      while (entry) {\n        var chunk = entry.chunk;\n        var encoding = entry.encoding;\n        var cb = entry.callback;\n        var len = state.objectMode ? 1 : chunk.length;\n\n        doWrite(stream, state, false, len, chunk, encoding, cb);\n        entry = entry.next;\n        // if we didn't call the onwrite immediately, then\n        // it means that we need to wait until it does.\n        // also, that means that the chunk and cb are currently\n        // being processed, so move the buffer counter past them.\n        if (state.writing) {\n          break;\n        }\n      }\n\n      if (entry === null) state.lastBufferedRequest = null;\n    }\n\n    state.bufferedRequestCount = 0;\n    state.bufferedRequest = entry;\n    state.bufferProcessing = false;\n  }\n\n  Writable.prototype._write = function (chunk, encoding, cb) {\n    cb(new Error('not implemented'));\n  };\n\n  Writable.prototype._writev = null;\n\n  Writable.prototype.end = function (chunk, encoding, cb) {\n    var state = this._writableState;\n\n    if (typeof chunk === 'function') {\n      cb = chunk;\n      chunk = null;\n      encoding = null;\n    } else if (typeof encoding === 'function') {\n      cb = encoding;\n      encoding = null;\n    }\n\n    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n    // .end() fully uncorks\n    if (state.corked) {\n      state.corked = 1;\n      this.uncork();\n    }\n\n    // ignore unnecessary end() calls.\n    if (!state.ending && !state.finished) endWritable(this, state, cb);\n  };\n\n  function needFinish(state) {\n    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n  }\n\n  function prefinish(stream, state) {\n    if (!state.prefinished) {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n\n  function finishMaybe(stream, state) {\n    var need = needFinish(state);\n    if (need) {\n      if (state.pendingcb === 0) {\n        prefinish(stream, state);\n        state.finished = true;\n        stream.emit('finish');\n      } else {\n        prefinish(stream, state);\n      }\n    }\n    return need;\n  }\n\n  function endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n      if (state.finished) messages$1.nextTick(cb);else stream.once('finish', cb);\n    }\n    state.ended = true;\n    stream.writable = false;\n  }\n\n  // It seems a linked list but it is not\n  // there will be only 2 of these for each stream\n  function CorkedRequest(state) {\n    var _this = this;\n\n    this.next = null;\n    this.entry = null;\n\n    this.finish = function (err) {\n      var entry = _this.entry;\n      _this.entry = null;\n      while (entry) {\n        var cb = entry.callback;\n        state.pendingcb--;\n        cb(err);\n        entry = entry.next;\n      }\n      if (state.corkedRequestsFree) {\n        state.corkedRequestsFree.next = _this;\n      } else {\n        state.corkedRequestsFree = _this;\n      }\n    };\n  }\n\n  inherits(Duplex, Readable);\n\n  var keys = Object.keys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n  function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n\n    Readable.call(this, options);\n    Writable.call(this, options);\n\n    if (options && options.readable === false) this.readable = false;\n\n    if (options && options.writable === false) this.writable = false;\n\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n    this.once('end', onend);\n  }\n\n  // the no-half-open enforcer\n  function onend() {\n    // if we allow half-open state, or if the writable side ended,\n    // then we're ok.\n    if (this.allowHalfOpen || this._writableState.ended) return;\n\n    // no more data can be written.\n    // But allow more writes to happen in this tick.\n    messages$1.nextTick(onEndNT, this);\n  }\n\n  function onEndNT(self) {\n    self.end();\n  }\n\n  // a transform stream is a readable/writable stream where you do\n  // something with the data.  Sometimes it's called a \"filter\",\n  // but that's not a great name for it, since that implies a thing where\n  // some bits pass through, and others are simply ignored.  (That would\n  // be a valid example of a transform, of course.)\n  //\n  // While the output is causally related to the input, it's not a\n  // necessarily symmetric or synchronous transformation.  For example,\n  // a zlib stream might take multiple plain-text writes(), and then\n  // emit a single compressed chunk some time in the future.\n  //\n  // Here's how this works:\n  //\n  // The Transform stream has all the aspects of the readable and writable\n  // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n  // internally, and returns false if there's a lot of pending writes\n  // buffered up.  When you call read(), that calls _read(n) until\n  // there's enough pending readable data buffered up.\n  //\n  // In a transform stream, the written data is placed in a buffer.  When\n  // _read(n) is called, it transforms the queued up data, calling the\n  // buffered _write cb's as it consumes chunks.  If consuming a single\n  // written chunk would result in multiple output chunks, then the first\n  // outputted bit calls the readcb, and subsequent chunks just go into\n  // the read buffer, and will cause it to emit 'readable' if necessary.\n  //\n  // This way, back-pressure is actually determined by the reading side,\n  // since _read has to be called to start processing a new chunk.  However,\n  // a pathological inflate type of transform can cause excessive buffering\n  // here.  For example, imagine a stream where every byte of input is\n  // interpreted as an integer from 0-255, and then results in that many\n  // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n  // 1kb of data being output.  In this case, you could write a very small\n  // amount of input, and end up with a very large amount of output.  In\n  // such a pathological inflating mechanism, there'd be no way to tell\n  // the system to stop doing the transform.  A single 4MB write could\n  // cause the system to run out of memory.\n  //\n  // However, even in such a pathological case, only a single written chunk\n  // would be consumed, and then the rest would wait (un-transformed) until\n  // the results of the previous transformed chunk were consumed.\n\n  inherits(Transform, Duplex);\n\n  function TransformState(stream) {\n    this.afterTransform = function (er, data) {\n      return afterTransform(stream, er, data);\n    };\n\n    this.needTransform = false;\n    this.transforming = false;\n    this.writecb = null;\n    this.writechunk = null;\n    this.writeencoding = null;\n  }\n\n  function afterTransform(stream, er, data) {\n    var ts = stream._transformState;\n    ts.transforming = false;\n\n    var cb = ts.writecb;\n\n    if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n    ts.writechunk = null;\n    ts.writecb = null;\n\n    if (data !== null && data !== undefined) stream.push(data);\n\n    cb(er);\n\n    var rs = stream._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n      stream._read(rs.highWaterMark);\n    }\n  }\n  function Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n\n    Duplex.call(this, options);\n\n    this._transformState = new TransformState(this);\n\n    // when the writable side finishes, then flush out anything remaining.\n    var stream = this;\n\n    // start out asking for a readable event once data is transformed.\n    this._readableState.needReadable = true;\n\n    // we have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n\n    if (options) {\n      if (typeof options.transform === 'function') this._transform = options.transform;\n\n      if (typeof options.flush === 'function') this._flush = options.flush;\n    }\n\n    this.once('prefinish', function () {\n      if (typeof this._flush === 'function') this._flush(function (er) {\n        done(stream, er);\n      });else done(stream);\n    });\n  }\n\n  Transform.prototype.push = function (chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n  };\n\n  // This is the part where you do stuff!\n  // override this function in implementation classes.\n  // 'chunk' is an input chunk.\n  //\n  // Call `push(newChunk)` to pass along transformed output\n  // to the readable side.  You may call 'push' zero or more times.\n  //\n  // Call `cb(err)` when you are done with this chunk.  If you pass\n  // an error, then that'll put the hurt on the whole operation.  If you\n  // never call cb(), then you'll never get another chunk.\n  Transform.prototype._transform = function (chunk, encoding, cb) {\n    throw new Error('Not implemented');\n  };\n\n  Transform.prototype._write = function (chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n    if (!ts.transforming) {\n      var rs = this._readableState;\n      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n    }\n  };\n\n  // Doesn't matter what the args are here.\n  // _transform does all the work.\n  // That we got here means that the readable side wants more data.\n  Transform.prototype._read = function (n) {\n    var ts = this._transformState;\n\n    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n      ts.transforming = true;\n      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n      // mark that we need a transform, so that any data that comes in\n      // will get processed, now that we've asked for it.\n      ts.needTransform = true;\n    }\n  };\n\n  function done(stream, er) {\n    if (er) return stream.emit('error', er);\n\n    // if there's nothing in the write buffer, then that means\n    // that nothing more will ever be provided\n    var ws = stream._writableState;\n    var ts = stream._transformState;\n\n    if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n    if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n    return stream.push(null);\n  }\n\n  inherits(PassThrough, Transform);\n  function PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n    Transform.call(this, options);\n  }\n\n  PassThrough.prototype._transform = function (chunk, encoding, cb) {\n    cb(null, chunk);\n  };\n\n  inherits(Stream, EventEmitter);\n  Stream.Readable = Readable;\n  Stream.Writable = Writable;\n  Stream.Duplex = Duplex;\n  Stream.Transform = Transform;\n  Stream.PassThrough = PassThrough;\n\n  // Backwards-compat with node 0.4.x\n  Stream.Stream = Stream;\n\n  // old-style streams.  Note that the pipe method (the only relevant\n  // part of this class) is overridden in the Readable class.\n\n  function Stream() {\n    EventEmitter.call(this);\n  }\n\n  Stream.prototype.pipe = function(dest, options) {\n    var source = this;\n\n    function ondata(chunk) {\n      if (dest.writable) {\n        if (false === dest.write(chunk) && source.pause) {\n          source.pause();\n        }\n      }\n    }\n\n    source.on('data', ondata);\n\n    function ondrain() {\n      if (source.readable && source.resume) {\n        source.resume();\n      }\n    }\n\n    dest.on('drain', ondrain);\n\n    // If the 'end' option is not supplied, dest.end() will be called when\n    // source gets the 'end' or 'close' events.  Only dest.end() once.\n    if (!dest._isStdio && (!options || options.end !== false)) {\n      source.on('end', onend);\n      source.on('close', onclose);\n    }\n\n    var didOnEnd = false;\n    function onend() {\n      if (didOnEnd) return;\n      didOnEnd = true;\n\n      dest.end();\n    }\n\n\n    function onclose() {\n      if (didOnEnd) return;\n      didOnEnd = true;\n\n      if (typeof dest.destroy === 'function') dest.destroy();\n    }\n\n    // don't leave dangling pipes when there are errors.\n    function onerror(er) {\n      cleanup();\n      if (EventEmitter.listenerCount(this, 'error') === 0) {\n        throw er; // Unhandled stream error in pipe.\n      }\n    }\n\n    source.on('error', onerror);\n    dest.on('error', onerror);\n\n    // remove all the event listeners that were added.\n    function cleanup() {\n      source.removeListener('data', ondata);\n      dest.removeListener('drain', ondrain);\n\n      source.removeListener('end', onend);\n      source.removeListener('close', onclose);\n\n      source.removeListener('error', onerror);\n      dest.removeListener('error', onerror);\n\n      source.removeListener('end', cleanup);\n      source.removeListener('close', cleanup);\n\n      dest.removeListener('close', cleanup);\n    }\n\n    source.on('end', cleanup);\n    source.on('close', cleanup);\n\n    dest.on('close', cleanup);\n\n    dest.emit('pipe', source);\n\n    // Allow for unix-like usage: A.pipe(B).pipe(C)\n    return dest;\n  };\n\n  var _polyfillNode_stream = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Duplex: Duplex,\n    PassThrough: PassThrough,\n    Readable: Readable,\n    Stream: Stream,\n    Transform: Transform,\n    Writable: Writable,\n    default: Stream\n  });\n\n  var require$$6 = /*@__PURE__*/messages$1.getAugmentedNamespace(_polyfillNode_stream);\n\n  var MultipartBody$1 = {};\n\n  Object.defineProperty(MultipartBody$1, \"__esModule\", { value: true });\n  MultipartBody$1.MultipartBody = void 0;\n  /**\n   * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n   */\n  class MultipartBody {\n      constructor(body) {\n          this.body = body;\n      }\n      get [Symbol.toStringTag]() {\n          return 'MultipartBody';\n      }\n  }\n  MultipartBody$1.MultipartBody = MultipartBody;\n\n  var web_polyfillNodeIgnore = /*#__PURE__*/Object.freeze({\n    __proto__: null\n  });\n\n  var require$$8 = /*@__PURE__*/messages$1.getAugmentedNamespace(web_polyfillNodeIgnore);\n\n  var fileFromPath$1 = {};\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  // resolves . and .. elements in a path array with directory names there\n  // must be no slashes, empty elements, or device names (c:\\) in the array\n  // (so also no leading and trailing slashes - it does not distinguish\n  // relative and absolute paths)\n  function normalizeArray(parts, allowAboveRoot) {\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = parts.length - 1; i >= 0; i--) {\n      var last = parts[i];\n      if (last === '.') {\n        parts.splice(i, 1);\n      } else if (last === '..') {\n        parts.splice(i, 1);\n        up++;\n      } else if (up) {\n        parts.splice(i, 1);\n        up--;\n      }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (allowAboveRoot) {\n      for (; up--; up) {\n        parts.unshift('..');\n      }\n    }\n\n    return parts;\n  }\n\n  // Split a filename into [root, dir, basename, ext], unix version\n  // 'root' is just a slash, or nothing.\n  var splitPathRe =\n      /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  var splitPath = function(filename) {\n    return splitPathRe.exec(filename).slice(1);\n  };\n\n  // path.resolve([from ...], to)\n  // posix version\n  function resolve() {\n    var resolvedPath = '',\n        resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = (i >= 0) ? arguments[i] : '/';\n\n      // Skip empty and invalid entries\n      if (typeof path !== 'string') {\n        throw new TypeError('Arguments to path.resolve must be strings');\n      } else if (!path) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charAt(0) === '/';\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n      return !!p;\n    }), !resolvedAbsolute).join('/');\n\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n  }\n  // path.normalize(path)\n  // posix version\n  function normalize(path) {\n    var isPathAbsolute = isAbsolute(path),\n        trailingSlash = substr(path, -1) === '/';\n\n    // Normalize the path\n    path = normalizeArray(filter(path.split('/'), function(p) {\n      return !!p;\n    }), !isPathAbsolute).join('/');\n\n    if (!path && !isPathAbsolute) {\n      path = '.';\n    }\n    if (path && trailingSlash) {\n      path += '/';\n    }\n\n    return (isPathAbsolute ? '/' : '') + path;\n  }\n  // posix version\n  function isAbsolute(path) {\n    return path.charAt(0) === '/';\n  }\n\n  // posix version\n  function join() {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    return normalize(filter(paths, function(p, index) {\n      if (typeof p !== 'string') {\n        throw new TypeError('Arguments to path.join must be strings');\n      }\n      return p;\n    }).join('/'));\n  }\n\n\n  // path.relative(from, to)\n  // posix version\n  function relative(from, to) {\n    from = resolve(from).substr(1);\n    to = resolve(to).substr(1);\n\n    function trim(arr) {\n      var start = 0;\n      for (; start < arr.length; start++) {\n        if (arr[start] !== '') break;\n      }\n\n      var end = arr.length - 1;\n      for (; end >= 0; end--) {\n        if (arr[end] !== '') break;\n      }\n\n      if (start > end) return [];\n      return arr.slice(start, end - start + 1);\n    }\n\n    var fromParts = trim(from.split('/'));\n    var toParts = trim(to.split('/'));\n\n    var length = Math.min(fromParts.length, toParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n      if (fromParts[i] !== toParts[i]) {\n        samePartsLength = i;\n        break;\n      }\n    }\n\n    var outputParts = [];\n    for (var i = samePartsLength; i < fromParts.length; i++) {\n      outputParts.push('..');\n    }\n\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n    return outputParts.join('/');\n  }\n\n  var sep = '/';\n  var delimiter = ':';\n\n  function dirname(path) {\n    var result = splitPath(path),\n        root = result[0],\n        dir = result[1];\n\n    if (!root && !dir) {\n      // No dirname whatsoever\n      return '.';\n    }\n\n    if (dir) {\n      // It has a dirname, strip trailing slash\n      dir = dir.substr(0, dir.length - 1);\n    }\n\n    return root + dir;\n  }\n\n  function basename(path, ext) {\n    var f = splitPath(path)[2];\n    // TODO: make this comparison case-insensitive on windows?\n    if (ext && f.substr(-1 * ext.length) === ext) {\n      f = f.substr(0, f.length - ext.length);\n    }\n    return f;\n  }\n\n\n  function extname(path) {\n    return splitPath(path)[3];\n  }\n  var _polyfillNode_path = {\n    extname: extname,\n    basename: basename,\n    dirname: dirname,\n    sep: sep,\n    delimiter: delimiter,\n    relative: relative,\n    join: join,\n    isAbsolute: isAbsolute,\n    normalize: normalize,\n    resolve: resolve\n  };\n  function filter (xs, f) {\n      if (xs.filter) return xs.filter(f);\n      var res = [];\n      for (var i = 0; i < xs.length; i++) {\n          if (f(xs[i], i, xs)) res.push(xs[i]);\n      }\n      return res;\n  }\n\n  // String.prototype.substr - negative index don't work in IE8\n  var substr = 'ab'.substr(-1) === 'b' ?\n      function (str, start, len) { return str.substr(start, len) } :\n      function (str, start, len) {\n          if (start < 0) start = str.length + start;\n          return str.substr(start, len);\n      }\n  ;\n\n  var _polyfillNode_path$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    basename: basename,\n    default: _polyfillNode_path,\n    delimiter: delimiter,\n    dirname: dirname,\n    extname: extname,\n    isAbsolute: isAbsolute,\n    join: join,\n    normalize: normalize,\n    relative: relative,\n    resolve: resolve,\n    sep: sep\n  });\n\n  var require$$1 = /*@__PURE__*/messages$1.getAugmentedNamespace(_polyfillNode_path$1);\n\n  var worker_threads_polyfillNodeIgnore = /*#__PURE__*/Object.freeze({\n    __proto__: null\n  });\n\n  var require$$0 = /*@__PURE__*/messages$1.getAugmentedNamespace(worker_threads_polyfillNodeIgnore);\n\n  /*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n\n  var nodeDomexception;\n  var hasRequiredNodeDomexception;\n\n  function requireNodeDomexception () {\n  \tif (hasRequiredNodeDomexception) return nodeDomexception;\n  \thasRequiredNodeDomexception = 1;\n  \tif (!globalThis.DOMException) {\n  \t  try {\n  \t    const { MessageChannel } = require$$0,\n  \t    port = new MessageChannel().port1,\n  \t    ab = new ArrayBuffer();\n  \t    port.postMessage(ab, [ab, ab]);\n  \t  } catch (err) {\n  \t    err.constructor.name === 'DOMException' && (\n  \t      globalThis.DOMException = err.constructor\n  \t    );\n  \t  }\n  \t}\n\n  \tnodeDomexception = globalThis.DOMException;\n  \treturn nodeDomexception;\n  }\n\n  var File = {};\n\n  var Blob = {};\n\n  var ponyfill = {exports: {}};\n\n  /**\n   * @license\n   * web-streams-polyfill v4.0.0-beta.3\n   * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.\n   * This code is released under the MIT license.\n   * SPDX-License-Identifier: MIT\n   */\n\n  var hasRequiredPonyfill;\n\n  function requirePonyfill () {\n  \tif (hasRequiredPonyfill) return ponyfill.exports;\n  \thasRequiredPonyfill = 1;\n  \t(function (module, exports) {\n  \t\t!function(e,t){t(exports);}(messages$1.commonjsGlobal,(function(e){const t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function r(){}function o(e){return \"object\"==typeof e&&null!==e||\"function\"==typeof e}const n=r;function a(e,t){try{Object.defineProperty(e,\"name\",{value:t,configurable:!0});}catch(e){}}const i=Promise,l=Promise.prototype.then,s=Promise.resolve.bind(i),u=Promise.reject.bind(i);function c(e){return new i(e)}function d(e){return s(e)}function f(e){return u(e)}function b(e,t,r){return l.call(e,t,r)}function h(e,t,r){b(b(e,t,r),void 0,n);}function _(e,t){h(e,t);}function p(e,t){h(e,void 0,t);}function m(e,t,r){return b(e,t,r)}function y(e){b(e,void 0,n);}let g=e=>{if(\"function\"==typeof queueMicrotask)g=queueMicrotask;else {const e=d(void 0);g=t=>b(e,t);}return g(e)};function S(e,t,r){if(\"function\"!=typeof e)throw new TypeError(\"Argument is not a function\");return Function.prototype.apply.call(e,t,r)}function w(e,t,r){try{return d(S(e,t,r))}catch(e){return f(e)}}class v{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0;}get length(){return this._size}push(e){const t=this._back;let r=t;16383===t._elements.length&&(r={_elements:[],_next:void 0}),t._elements.push(e),r!==t&&(this._back=r,t._next=r),++this._size;}shift(){const e=this._front;let t=e;const r=this._cursor;let o=r+1;const n=e._elements,a=n[r];return 16384===o&&(t=e._next,o=0),--this._size,this._cursor=o,e!==t&&(this._front=t),n[r]=void 0,a}forEach(e){let t=this._cursor,r=this._front,o=r._elements;for(;!(t===o.length&&void 0===r._next||t===o.length&&(r=r._next,o=r._elements,t=0,0===o.length));)e(o[t]),++t;}peek(){const e=this._front,t=this._cursor;return e._elements[t]}}const R=t(\"[[AbortSteps]]\"),T=t(\"[[ErrorSteps]]\"),q=t(\"[[CancelSteps]]\"),C=t(\"[[PullSteps]]\"),P=t(\"[[ReleaseSteps]]\");function E(e,t){e._ownerReadableStream=t,t._reader=e,\"readable\"===t._state?B(e):\"closed\"===t._state?function(e){B(e),z(e);}(e):A(e,t._storedError);}function W(e,t){return Xt(e._ownerReadableStream,t)}function O(e){const t=e._ownerReadableStream;\"readable\"===t._state?j(e,new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")):function(e,t){A(e,t);}(e,new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")),t._readableStreamController[P](),t._reader=void 0,e._ownerReadableStream=void 0;}function k(e){return new TypeError(\"Cannot \"+e+\" a stream using a released reader\")}function B(e){e._closedPromise=c(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r;}));}function A(e,t){B(e),j(e,t);}function j(e,t){void 0!==e._closedPromise_reject&&(y(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0);}function z(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0);}const L=Number.isFinite||function(e){return \"number\"==typeof e&&isFinite(e)},F=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function D(e,t){if(void 0!==e&&(\"object\"!=typeof(r=e)&&\"function\"!=typeof r))throw new TypeError(`${t} is not an object.`);var r;}function I(e,t){if(\"function\"!=typeof e)throw new TypeError(`${t} is not a function.`)}function $(e,t){if(!function(e){return \"object\"==typeof e&&null!==e||\"function\"==typeof e}(e))throw new TypeError(`${t} is not an object.`)}function M(e,t,r){if(void 0===e)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function Y(e,t,r){if(void 0===e)throw new TypeError(`${t} is required in '${r}'.`)}function Q(e){return Number(e)}function N(e){return 0===e?0:e}function x(e,t){const r=Number.MAX_SAFE_INTEGER;let o=Number(e);if(o=N(o),!L(o))throw new TypeError(`${t} is not a finite number`);if(o=function(e){return N(F(e))}(o),o<0||o>r)throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);return L(o)&&0!==o?o:0}function H(e){if(!o(e))return !1;if(\"function\"!=typeof e.getReader)return !1;try{return \"boolean\"==typeof e.locked}catch(e){return !1}}function V(e){if(!o(e))return !1;if(\"function\"!=typeof e.getWriter)return !1;try{return \"boolean\"==typeof e.locked}catch(e){return !1}}function U(e,t){if(!Ut(e))throw new TypeError(`${t} is not a ReadableStream.`)}function G(e,t){e._reader._readRequests.push(t);}function X(e,t,r){const o=e._reader._readRequests.shift();r?o._closeSteps():o._chunkSteps(t);}function J(e){return e._reader._readRequests.length}function K(e){const t=e._reader;return void 0!==t&&!!Z(t)}class ReadableStreamDefaultReader{constructor(e){if(M(e,1,\"ReadableStreamDefaultReader\"),U(e,\"First parameter\"),Gt(e))throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");E(this,e),this._readRequests=new v;}get closed(){return Z(this)?this._closedPromise:f(te(\"closed\"))}cancel(e){return Z(this)?void 0===this._ownerReadableStream?f(k(\"cancel\")):W(this,e):f(te(\"cancel\"))}read(){if(!Z(this))return f(te(\"read\"));if(void 0===this._ownerReadableStream)return f(k(\"read from\"));let e,t;const r=c(((r,o)=>{e=r,t=o;}));return function(e,t){const r=e._ownerReadableStream;r._disturbed=!0,\"closed\"===r._state?t._closeSteps():\"errored\"===r._state?t._errorSteps(r._storedError):r._readableStreamController[C](t);}(this,{_chunkSteps:t=>e({value:t,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:e=>t(e)}),r}releaseLock(){if(!Z(this))throw te(\"releaseLock\");void 0!==this._ownerReadableStream&&function(e){O(e);const t=new TypeError(\"Reader was released\");ee(e,t);}(this);}}function Z(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_readRequests\")&&e instanceof ReadableStreamDefaultReader)}function ee(e,t){const r=e._readRequests;e._readRequests=new v,r.forEach((e=>{e._errorSteps(t);}));}function te(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),a(ReadableStreamDefaultReader.prototype.cancel,\"cancel\"),a(ReadableStreamDefaultReader.prototype.read,\"read\"),a(ReadableStreamDefaultReader.prototype.releaseLock,\"releaseLock\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamDefaultReader.prototype,t.toStringTag,{value:\"ReadableStreamDefaultReader\",configurable:!0});class re{constructor(e,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=t;}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?m(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const t=()=>this._returnSteps(e);return this._ongoingPromise?m(this._ongoingPromise,t,t):t()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;return void 0===e?f(k(\"iterate\")):b(e.read(),(e=>{var t;return this._ongoingPromise=void 0,e.done&&(this._isFinished=!0,null===(t=this._reader)||void 0===t||t.releaseLock(),this._reader=void 0),e}),(e=>{var t;throw this._ongoingPromise=void 0,this._isFinished=!0,null===(t=this._reader)||void 0===t||t.releaseLock(),this._reader=void 0,e}))}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const t=this._reader;if(void 0===t)return f(k(\"finish iterating\"));if(this._reader=void 0,!this._preventCancel){const r=t.cancel(e);return t.releaseLock(),m(r,(()=>({value:e,done:!0})))}return t.releaseLock(),d({value:e,done:!0})}}const oe={next(){return ne(this)?this._asyncIteratorImpl.next():f(ae(\"next\"))},return(e){return ne(this)?this._asyncIteratorImpl.return(e):f(ae(\"return\"))}};function ne(e){if(!o(e))return !1;if(!Object.prototype.hasOwnProperty.call(e,\"_asyncIteratorImpl\"))return !1;try{return e._asyncIteratorImpl instanceof re}catch(e){return !1}}function ae(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}\"symbol\"==typeof t.asyncIterator&&Object.defineProperty(oe,t.asyncIterator,{value(){return this},writable:!0,configurable:!0});const ie=Number.isNaN||function(e){return e!=e};function le(e,t,r,o,n){new Uint8Array(e).set(new Uint8Array(r,o,n),t);}function se(e){const t=function(e,t,r){if(e.slice)return e.slice(t,r);const o=r-t,n=new ArrayBuffer(o);return le(n,0,e,t,o),n}(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(t)}function ue(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function ce(e,t,r){if(\"number\"!=typeof(o=r)||ie(o)||o<0||r===1/0)throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");var o;e._queue.push({value:t,size:r}),e._queueTotalSize+=r;}function de(e){e._queue=new v,e._queueTotalSize=0;}class ReadableStreamBYOBRequest{constructor(){throw new TypeError(\"Illegal constructor\")}get view(){if(!be(this))throw Ae(\"view\");return this._view}respond(e){if(!be(this))throw Ae(\"respond\");if(M(e,1,\"respond\"),e=x(e,\"First parameter\"),void 0===this._associatedReadableByteStreamController)throw new TypeError(\"This BYOB request has been invalidated\");this._view.buffer,function(e,t){const r=e._pendingPullIntos.peek();if(\"closed\"===e._controlledReadableByteStream._state){if(0!==t)throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\")}else {if(0===t)throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");if(r.bytesFilled+t>r.byteLength)throw new RangeError(\"bytesWritten out of range\")}r.buffer=r.buffer,Ce(e,t);}(this._associatedReadableByteStreamController,e);}respondWithNewView(e){if(!be(this))throw Ae(\"respondWithNewView\");if(M(e,1,\"respondWithNewView\"),!ArrayBuffer.isView(e))throw new TypeError(\"You can only respond with array buffer views\");if(void 0===this._associatedReadableByteStreamController)throw new TypeError(\"This BYOB request has been invalidated\");e.buffer,function(e,t){const r=e._pendingPullIntos.peek();if(\"closed\"===e._controlledReadableByteStream._state){if(0!==t.byteLength)throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\")}else if(0===t.byteLength)throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");if(r.byteOffset+r.bytesFilled!==t.byteOffset)throw new RangeError(\"The region specified by view does not match byobRequest\");if(r.bufferByteLength!==t.buffer.byteLength)throw new RangeError(\"The buffer of view has different capacity than byobRequest\");if(r.bytesFilled+t.byteLength>r.byteLength)throw new RangeError(\"The region specified by view is larger than byobRequest\");const o=t.byteLength;r.buffer=t.buffer,Ce(e,o);}(this._associatedReadableByteStreamController,e);}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),a(ReadableStreamBYOBRequest.prototype.respond,\"respond\"),a(ReadableStreamBYOBRequest.prototype.respondWithNewView,\"respondWithNewView\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamBYOBRequest.prototype,t.toStringTag,{value:\"ReadableStreamBYOBRequest\",configurable:!0});class ReadableByteStreamController{constructor(){throw new TypeError(\"Illegal constructor\")}get byobRequest(){if(!fe(this))throw je(\"byobRequest\");return function(e){if(null===e._byobRequest&&e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),o=Object.create(ReadableStreamBYOBRequest.prototype);!function(e,t,r){e._associatedReadableByteStreamController=t,e._view=r;}(o,e,r),e._byobRequest=o;}return e._byobRequest}(this)}get desiredSize(){if(!fe(this))throw je(\"desiredSize\");return ke(this)}close(){if(!fe(this))throw je(\"close\");if(this._closeRequested)throw new TypeError(\"The stream has already been closed; do not close it again!\");const e=this._controlledReadableByteStream._state;if(\"readable\"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);!function(e){const t=e._controlledReadableByteStream;if(e._closeRequested||\"readable\"!==t._state)return;if(e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0){if(e._pendingPullIntos.peek().bytesFilled>0){const t=new TypeError(\"Insufficient bytes to fill elements in the given buffer\");throw We(e,t),t}}Ee(e),Jt(t);}(this);}enqueue(e){if(!fe(this))throw je(\"enqueue\");if(M(e,1,\"enqueue\"),!ArrayBuffer.isView(e))throw new TypeError(\"chunk must be an array buffer view\");if(0===e.byteLength)throw new TypeError(\"chunk must have non-zero byteLength\");if(0===e.buffer.byteLength)throw new TypeError(\"chunk's buffer must have non-zero byteLength\");if(this._closeRequested)throw new TypeError(\"stream is closed or draining\");const t=this._controlledReadableByteStream._state;if(\"readable\"!==t)throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);!function(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||\"readable\"!==r._state)return;const o=t.buffer,n=t.byteOffset,a=t.byteLength,i=o;if(e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek();t.buffer,Te(e),t.buffer=t.buffer,\"none\"===t.readerType&&Se(e,t);}if(K(r))if(function(e){const t=e._controlledReadableByteStream._reader;for(;t._readRequests.length>0;){if(0===e._queueTotalSize)return;Oe(e,t._readRequests.shift());}}(e),0===J(r))ye(e,i,n,a);else {e._pendingPullIntos.length>0&&Pe(e);X(r,new Uint8Array(i,n,a),!1);}else Fe(r)?(ye(e,i,n,a),qe(e)):ye(e,i,n,a);he(e);}(this,e);}error(e){if(!fe(this))throw je(\"error\");We(this,e);}[q](e){_e(this),de(this);const t=this._cancelAlgorithm(e);return Ee(this),t}[C](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0)return void Oe(this,e);const r=this._autoAllocateChunkSize;if(void 0!==r){let t;try{t=new ArrayBuffer(r);}catch(t){return void e._errorSteps(t)}const o={buffer:t,bufferByteLength:r,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:\"default\"};this._pendingPullIntos.push(o);}G(t,e),he(this);}[P](){if(this._pendingPullIntos.length>0){const e=this._pendingPullIntos.peek();e.readerType=\"none\",this._pendingPullIntos=new v,this._pendingPullIntos.push(e);}}}function fe(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledReadableByteStream\")&&e instanceof ReadableByteStreamController)}function be(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_associatedReadableByteStreamController\")&&e instanceof ReadableStreamBYOBRequest)}function he(e){const t=function(e){const t=e._controlledReadableByteStream;if(\"readable\"!==t._state)return !1;if(e._closeRequested)return !1;if(!e._started)return !1;if(K(t)&&J(t)>0)return !0;if(Fe(t)&&Le(t)>0)return !0;if(ke(e)>0)return !0;return !1}(e);if(!t)return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;h(e._pullAlgorithm(),(()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,he(e)),null)),(t=>(We(e,t),null)));}function _e(e){Te(e),e._pendingPullIntos=new v;}function pe(e,t){let r=!1;\"closed\"===e._state&&(r=!0);const o=me(t);\"default\"===t.readerType?X(e,o,r):function(e,t,r){const o=e._reader._readIntoRequests.shift();r?o._closeSteps(t):o._chunkSteps(t);}(e,o,r);}function me(e){const t=e.bytesFilled,r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}function ye(e,t,r,o){e._queue.push({buffer:t,byteOffset:r,byteLength:o}),e._queueTotalSize+=o;}function ge(e,t,r,o){let n;try{n=t.slice(r,r+o);}catch(t){throw We(e,t),t}ye(e,n,0,o);}function Se(e,t){t.bytesFilled>0&&ge(e,t.buffer,t.byteOffset,t.bytesFilled),Pe(e);}function we(e,t){const r=t.elementSize,o=t.bytesFilled-t.bytesFilled%r,n=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),a=t.bytesFilled+n,i=a-a%r;let l=n,s=!1;i>o&&(l=i-t.bytesFilled,s=!0);const u=e._queue;for(;l>0;){const r=u.peek(),o=Math.min(l,r.byteLength),n=t.byteOffset+t.bytesFilled;le(t.buffer,n,r.buffer,r.byteOffset,o),r.byteLength===o?u.shift():(r.byteOffset+=o,r.byteLength-=o),e._queueTotalSize-=o,ve(e,o,t),l-=o;}return s}function ve(e,t,r){r.bytesFilled+=t;}function Re(e){0===e._queueTotalSize&&e._closeRequested?(Ee(e),Jt(e._controlledReadableByteStream)):he(e);}function Te(e){null!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null);}function qe(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const t=e._pendingPullIntos.peek();we(e,t)&&(Pe(e),pe(e._controlledReadableByteStream,t));}}function Ce(e,t){const r=e._pendingPullIntos.peek();Te(e);\"closed\"===e._controlledReadableByteStream._state?function(e,t){\"none\"===t.readerType&&Pe(e);const r=e._controlledReadableByteStream;if(Fe(r))for(;Le(r)>0;)pe(r,Pe(e));}(e,r):function(e,t,r){if(ve(0,t,r),\"none\"===r.readerType)return Se(e,r),void qe(e);if(r.bytesFilled<r.elementSize)return;Pe(e);const o=r.bytesFilled%r.elementSize;if(o>0){const t=r.byteOffset+r.bytesFilled;ge(e,r.buffer,t-o,o);}r.bytesFilled-=o,pe(e._controlledReadableByteStream,r),qe(e);}(e,t,r),he(e);}function Pe(e){return e._pendingPullIntos.shift()}function Ee(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0;}function We(e,t){const r=e._controlledReadableByteStream;\"readable\"===r._state&&(_e(e),de(e),Ee(e),Kt(r,t));}function Oe(e,t){const r=e._queue.shift();e._queueTotalSize-=r.byteLength,Re(e);const o=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);t._chunkSteps(o);}function ke(e){const t=e._controlledReadableByteStream._state;return \"errored\"===t?null:\"closed\"===t?0:e._strategyHWM-e._queueTotalSize}function Be(e,t,r){const o=Object.create(ReadableByteStreamController.prototype);let n,a,i;n=void 0!==t.start?()=>t.start(o):()=>{},a=void 0!==t.pull?()=>t.pull(o):()=>d(void 0),i=void 0!==t.cancel?e=>t.cancel(e):()=>d(void 0);const l=t.autoAllocateChunkSize;if(0===l)throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");!function(e,t,r,o,n,a,i){t._controlledReadableByteStream=e,t._pullAgain=!1,t._pulling=!1,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,de(t),t._closeRequested=!1,t._started=!1,t._strategyHWM=a,t._pullAlgorithm=o,t._cancelAlgorithm=n,t._autoAllocateChunkSize=i,t._pendingPullIntos=new v,e._readableStreamController=t,h(d(r()),(()=>(t._started=!0,he(t),null)),(e=>(We(t,e),null)));}(e,o,n,a,i,r,l);}function Ae(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function je(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function ze(e,t){e._reader._readIntoRequests.push(t);}function Le(e){return e._reader._readIntoRequests.length}function Fe(e){const t=e._reader;return void 0!==t&&!!De(t)}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),a(ReadableByteStreamController.prototype.close,\"close\"),a(ReadableByteStreamController.prototype.enqueue,\"enqueue\"),a(ReadableByteStreamController.prototype.error,\"error\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(ReadableByteStreamController.prototype,t.toStringTag,{value:\"ReadableByteStreamController\",configurable:!0});class ReadableStreamBYOBReader{constructor(e){if(M(e,1,\"ReadableStreamBYOBReader\"),U(e,\"First parameter\"),Gt(e))throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");if(!fe(e._readableStreamController))throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");E(this,e),this._readIntoRequests=new v;}get closed(){return De(this)?this._closedPromise:f($e(\"closed\"))}cancel(e){return De(this)?void 0===this._ownerReadableStream?f(k(\"cancel\")):W(this,e):f($e(\"cancel\"))}read(e){if(!De(this))return f($e(\"read\"));if(!ArrayBuffer.isView(e))return f(new TypeError(\"view must be an array buffer view\"));if(0===e.byteLength)return f(new TypeError(\"view must have non-zero byteLength\"));if(0===e.buffer.byteLength)return f(new TypeError(\"view's buffer must have non-zero byteLength\"));if(e.buffer,void 0===this._ownerReadableStream)return f(k(\"read from\"));let t,r;const o=c(((e,o)=>{t=e,r=o;}));return function(e,t,r){const o=e._ownerReadableStream;o._disturbed=!0,\"errored\"===o._state?r._errorSteps(o._storedError):function(e,t,r){const o=e._controlledReadableByteStream;let n=1;t.constructor!==DataView&&(n=t.constructor.BYTES_PER_ELEMENT);const a=t.constructor,i=t.buffer,l={buffer:i,bufferByteLength:i.byteLength,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:n,viewConstructor:a,readerType:\"byob\"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(l),void ze(o,r);if(\"closed\"!==o._state){if(e._queueTotalSize>0){if(we(e,l)){const t=me(l);return Re(e),void r._chunkSteps(t)}if(e._closeRequested){const t=new TypeError(\"Insufficient bytes to fill elements in the given buffer\");return We(e,t),void r._errorSteps(t)}}e._pendingPullIntos.push(l),ze(o,r),he(e);}else {const e=new a(l.buffer,l.byteOffset,0);r._closeSteps(e);}}(o._readableStreamController,t,r);}(this,e,{_chunkSteps:e=>t({value:e,done:!1}),_closeSteps:e=>t({value:e,done:!0}),_errorSteps:e=>r(e)}),o}releaseLock(){if(!De(this))throw $e(\"releaseLock\");void 0!==this._ownerReadableStream&&function(e){O(e);const t=new TypeError(\"Reader was released\");Ie(e,t);}(this);}}function De(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_readIntoRequests\")&&e instanceof ReadableStreamBYOBReader)}function Ie(e,t){const r=e._readIntoRequests;e._readIntoRequests=new v,r.forEach((e=>{e._errorSteps(t);}));}function $e(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function Me(e,t){const{highWaterMark:r}=e;if(void 0===r)return t;if(ie(r)||r<0)throw new RangeError(\"Invalid highWaterMark\");return r}function Ye(e){const{size:t}=e;return t||(()=>1)}function Qe(e,t){D(e,t);const r=null==e?void 0:e.highWaterMark,o=null==e?void 0:e.size;return {highWaterMark:void 0===r?void 0:Q(r),size:void 0===o?void 0:Ne(o,`${t} has member 'size' that`)}}function Ne(e,t){return I(e,t),t=>Q(e(t))}function xe(e,t,r){return I(e,r),r=>w(e,t,[r])}function He(e,t,r){return I(e,r),()=>w(e,t,[])}function Ve(e,t,r){return I(e,r),r=>S(e,t,[r])}function Ue(e,t,r){return I(e,r),(r,o)=>w(e,t,[r,o])}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),a(ReadableStreamBYOBReader.prototype.cancel,\"cancel\"),a(ReadableStreamBYOBReader.prototype.read,\"read\"),a(ReadableStreamBYOBReader.prototype.releaseLock,\"releaseLock\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamBYOBReader.prototype,t.toStringTag,{value:\"ReadableStreamBYOBReader\",configurable:!0});const Ge=\"function\"==typeof AbortController;class WritableStream{constructor(e={},t={}){void 0===e?e=null:$(e,\"First parameter\");const r=Qe(t,\"Second parameter\"),o=function(e,t){D(e,t);const r=null==e?void 0:e.abort,o=null==e?void 0:e.close,n=null==e?void 0:e.start,a=null==e?void 0:e.type,i=null==e?void 0:e.write;return {abort:void 0===r?void 0:xe(r,e,`${t} has member 'abort' that`),close:void 0===o?void 0:He(o,e,`${t} has member 'close' that`),start:void 0===n?void 0:Ve(n,e,`${t} has member 'start' that`),write:void 0===i?void 0:Ue(i,e,`${t} has member 'write' that`),type:a}}(e,\"First parameter\");var n;(n=this)._state=\"writable\",n._storedError=void 0,n._writer=void 0,n._writableStreamController=void 0,n._writeRequests=new v,n._inFlightWriteRequest=void 0,n._closeRequest=void 0,n._inFlightCloseRequest=void 0,n._pendingAbortRequest=void 0,n._backpressure=!1;if(void 0!==o.type)throw new RangeError(\"Invalid type is specified\");const a=Ye(r);!function(e,t,r,o){const n=Object.create(WritableStreamDefaultController.prototype);let a,i,l,s;a=void 0!==t.start?()=>t.start(n):()=>{};i=void 0!==t.write?e=>t.write(e,n):()=>d(void 0);l=void 0!==t.close?()=>t.close():()=>d(void 0);s=void 0!==t.abort?e=>t.abort(e):()=>d(void 0);!function(e,t,r,o,n,a,i,l){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,de(t),t._abortReason=void 0,t._abortController=function(){if(Ge)return new AbortController}(),t._started=!1,t._strategySizeAlgorithm=l,t._strategyHWM=i,t._writeAlgorithm=o,t._closeAlgorithm=n,t._abortAlgorithm=a;const s=ht(t);at(e,s);const u=r();h(d(u),(()=>(t._started=!0,ft(t),null)),(r=>(t._started=!0,et(e,r),null)));}(e,n,a,i,l,s,r,o);}(this,o,Me(r,1),a);}get locked(){if(!Xe(this))throw pt(\"locked\");return Je(this)}abort(e){return Xe(this)?Je(this)?f(new TypeError(\"Cannot abort a stream that already has a writer\")):Ke(this,e):f(pt(\"abort\"))}close(){return Xe(this)?Je(this)?f(new TypeError(\"Cannot close a stream that already has a writer\")):ot(this)?f(new TypeError(\"Cannot close an already-closing stream\")):Ze(this):f(pt(\"close\"))}getWriter(){if(!Xe(this))throw pt(\"getWriter\");return new WritableStreamDefaultWriter(this)}}function Xe(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_writableStreamController\")&&e instanceof WritableStream)}function Je(e){return void 0!==e._writer}function Ke(e,t){var r;if(\"closed\"===e._state||\"errored\"===e._state)return d(void 0);e._writableStreamController._abortReason=t,null===(r=e._writableStreamController._abortController)||void 0===r||r.abort(t);const o=e._state;if(\"closed\"===o||\"errored\"===o)return d(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let n=!1;\"erroring\"===o&&(n=!0,t=void 0);const a=c(((r,o)=>{e._pendingAbortRequest={_promise:void 0,_resolve:r,_reject:o,_reason:t,_wasAlreadyErroring:n};}));return e._pendingAbortRequest._promise=a,n||tt(e,t),a}function Ze(e){const t=e._state;if(\"closed\"===t||\"errored\"===t)return f(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=c(((t,r)=>{const o={_resolve:t,_reject:r};e._closeRequest=o;})),o=e._writer;var n;return void 0!==o&&e._backpressure&&\"writable\"===t&&Et(o),ce(n=e._writableStreamController,st,0),ft(n),r}function et(e,t){\"writable\"!==e._state?rt(e):tt(e,t);}function tt(e,t){const r=e._writableStreamController;e._state=\"erroring\",e._storedError=t;const o=e._writer;void 0!==o&&lt(o,t),!function(e){if(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)return !1;return !0}(e)&&r._started&&rt(e);}function rt(e){e._state=\"errored\",e._writableStreamController[T]();const t=e._storedError;if(e._writeRequests.forEach((e=>{e._reject(t);})),e._writeRequests=new v,void 0===e._pendingAbortRequest)return void nt(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void nt(e);h(e._writableStreamController[R](r._reason),(()=>(r._resolve(),nt(e),null)),(t=>(r._reject(t),nt(e),null)));}function ot(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function nt(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;void 0!==t&&vt(t,e._storedError);}function at(e,t){const r=e._writer;void 0!==r&&t!==e._backpressure&&(t?function(e){Tt(e);}(r):Et(r)),e._backpressure=t;}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),a(WritableStream.prototype.abort,\"abort\"),a(WritableStream.prototype.close,\"close\"),a(WritableStream.prototype.getWriter,\"getWriter\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(WritableStream.prototype,t.toStringTag,{value:\"WritableStream\",configurable:!0});class WritableStreamDefaultWriter{constructor(e){if(M(e,1,\"WritableStreamDefaultWriter\"),function(e,t){if(!Xe(e))throw new TypeError(`${t} is not a WritableStream.`)}(e,\"First parameter\"),Je(e))throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");this._ownerWritableStream=e,e._writer=this;const t=e._state;if(\"writable\"===t)!ot(e)&&e._backpressure?Tt(this):Ct(this),St(this);else if(\"erroring\"===t)qt(this,e._storedError),St(this);else if(\"closed\"===t)Ct(this),St(r=this),Rt(r);else {const t=e._storedError;qt(this,t),wt(this,t);}var r;}get closed(){return it(this)?this._closedPromise:f(yt(\"closed\"))}get desiredSize(){if(!it(this))throw yt(\"desiredSize\");if(void 0===this._ownerWritableStream)throw gt(\"desiredSize\");return function(e){const t=e._ownerWritableStream,r=t._state;if(\"errored\"===r||\"erroring\"===r)return null;if(\"closed\"===r)return 0;return dt(t._writableStreamController)}(this)}get ready(){return it(this)?this._readyPromise:f(yt(\"ready\"))}abort(e){return it(this)?void 0===this._ownerWritableStream?f(gt(\"abort\")):function(e,t){return Ke(e._ownerWritableStream,t)}(this,e):f(yt(\"abort\"))}close(){if(!it(this))return f(yt(\"close\"));const e=this._ownerWritableStream;return void 0===e?f(gt(\"close\")):ot(e)?f(new TypeError(\"Cannot close an already-closing stream\")):Ze(this._ownerWritableStream)}releaseLock(){if(!it(this))throw yt(\"releaseLock\");void 0!==this._ownerWritableStream&&function(e){const t=e._ownerWritableStream,r=new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");lt(e,r),function(e,t){\"pending\"===e._closedPromiseState?vt(e,t):function(e,t){wt(e,t);}(e,t);}(e,r),t._writer=void 0,e._ownerWritableStream=void 0;}(this);}write(e){return it(this)?void 0===this._ownerWritableStream?f(gt(\"write to\")):function(e,t){const r=e._ownerWritableStream,o=r._writableStreamController,n=function(e,t){try{return e._strategySizeAlgorithm(t)}catch(t){return bt(e,t),1}}(o,t);if(r!==e._ownerWritableStream)return f(gt(\"write to\"));const a=r._state;if(\"errored\"===a)return f(r._storedError);if(ot(r)||\"closed\"===a)return f(new TypeError(\"The stream is closing or closed and cannot be written to\"));if(\"erroring\"===a)return f(r._storedError);const i=function(e){return c(((t,r)=>{const o={_resolve:t,_reject:r};e._writeRequests.push(o);}))}(r);return function(e,t,r){try{ce(e,t,r);}catch(t){return void bt(e,t)}const o=e._controlledWritableStream;if(!ot(o)&&\"writable\"===o._state){at(o,ht(e));}ft(e);}(o,t,n),i}(this,e):f(yt(\"write\"))}}function it(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_ownerWritableStream\")&&e instanceof WritableStreamDefaultWriter)}function lt(e,t){\"pending\"===e._readyPromiseState?Pt(e,t):function(e,t){qt(e,t);}(e,t);}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),a(WritableStreamDefaultWriter.prototype.abort,\"abort\"),a(WritableStreamDefaultWriter.prototype.close,\"close\"),a(WritableStreamDefaultWriter.prototype.releaseLock,\"releaseLock\"),a(WritableStreamDefaultWriter.prototype.write,\"write\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(WritableStreamDefaultWriter.prototype,t.toStringTag,{value:\"WritableStreamDefaultWriter\",configurable:!0});const st={};class WritableStreamDefaultController{constructor(){throw new TypeError(\"Illegal constructor\")}get abortReason(){if(!ut(this))throw mt(\"abortReason\");return this._abortReason}get signal(){if(!ut(this))throw mt(\"signal\");if(void 0===this._abortController)throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");return this._abortController.signal}error(e){if(!ut(this))throw mt(\"error\");\"writable\"===this._controlledWritableStream._state&&_t(this,e);}[R](e){const t=this._abortAlgorithm(e);return ct(this),t}[T](){de(this);}}function ut(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledWritableStream\")&&e instanceof WritableStreamDefaultController)}function ct(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0;}function dt(e){return e._strategyHWM-e._queueTotalSize}function ft(e){const t=e._controlledWritableStream;if(!e._started)return;if(void 0!==t._inFlightWriteRequest)return;if(\"erroring\"===t._state)return void rt(t);if(0===e._queue.length)return;const r=e._queue.peek().value;r===st?function(e){const t=e._controlledWritableStream;((function(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0;}))(t),ue(e);const r=e._closeAlgorithm();ct(e),h(r,(()=>(function(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,\"erroring\"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state=\"closed\";const t=e._writer;void 0!==t&&Rt(t);}(t),null)),(e=>(function(e,t){e._inFlightCloseRequest._reject(t),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(t),e._pendingAbortRequest=void 0),et(e,t);}(t,e),null)));}(e):function(e,t){const r=e._controlledWritableStream;!function(e){e._inFlightWriteRequest=e._writeRequests.shift();}(r);h(e._writeAlgorithm(t),(()=>{!function(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0;}(r);const t=r._state;if(ue(e),!ot(r)&&\"writable\"===t){const t=ht(e);at(r,t);}return ft(e),null}),(t=>(\"writable\"===r._state&&ct(e),function(e,t){e._inFlightWriteRequest._reject(t),e._inFlightWriteRequest=void 0,et(e,t);}(r,t),null)));}(e,r);}function bt(e,t){\"writable\"===e._controlledWritableStream._state&&_t(e,t);}function ht(e){return dt(e)<=0}function _t(e,t){const r=e._controlledWritableStream;ct(e),tt(r,t);}function pt(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function mt(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}function yt(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function gt(e){return new TypeError(\"Cannot \"+e+\" a stream using a released writer\")}function St(e){e._closedPromise=c(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState=\"pending\";}));}function wt(e,t){St(e),vt(e,t);}function vt(e,t){void 0!==e._closedPromise_reject&&(y(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState=\"rejected\");}function Rt(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState=\"resolved\");}function Tt(e){e._readyPromise=c(((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r;})),e._readyPromiseState=\"pending\";}function qt(e,t){Tt(e),Pt(e,t);}function Ct(e){Tt(e),Et(e);}function Pt(e,t){void 0!==e._readyPromise_reject&&(y(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState=\"rejected\");}function Et(e){void 0!==e._readyPromise_resolve&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState=\"fulfilled\");}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(WritableStreamDefaultController.prototype,t.toStringTag,{value:\"WritableStreamDefaultController\",configurable:!0});const Wt=\"undefined\"!=typeof DOMException?DOMException:void 0;const Ot=function(e){if(\"function\"!=typeof e&&\"object\"!=typeof e)return !1;try{return new e,!0}catch(e){return !1}}(Wt)?Wt:function(){const e=function(e,t){this.message=e||\"\",this.name=t||\"Error\",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor);};return e.prototype=Object.create(Error.prototype),Object.defineProperty(e.prototype,\"constructor\",{value:e,writable:!0,configurable:!0}),e}();function kt(e,t,r,o,n,a){const i=e.getReader(),l=t.getWriter();Ut(e)&&(e._disturbed=!0);let s,u,p,S=!1,w=!1,v=\"readable\",R=\"writable\",T=!1,q=!1;const C=c((e=>{p=e;}));let P=Promise.resolve(void 0);return c(((E,W)=>{let O;function k(){if(S)return;const e=c(((e,t)=>{!function r(o){o?e():b(function(){if(S)return d(!0);return b(l.ready,(()=>b(i.read(),(e=>!!e.done||(P=l.write(e.value),y(P),!1)))))}(),r,t);}(!1);}));y(e);}function B(){return v=\"closed\",r?L():z((()=>(Xe(t)&&(T=ot(t),R=t._state),T||\"closed\"===R?d(void 0):\"erroring\"===R||\"errored\"===R?f(u):(T=!0,l.close()))),!1,void 0),null}function A(e){return S||(v=\"errored\",s=e,o?L(!0,e):z((()=>l.abort(e)),!0,e)),null}function j(e){return w||(R=\"errored\",u=e,n?L(!0,e):z((()=>i.cancel(e)),!0,e)),null}if(void 0!==a&&(O=()=>{const e=void 0!==a.reason?a.reason:new Ot(\"Aborted\",\"AbortError\"),t=[];o||t.push((()=>\"writable\"===R?l.abort(e):d(void 0))),n||t.push((()=>\"readable\"===v?i.cancel(e):d(void 0))),z((()=>Promise.all(t.map((e=>e())))),!0,e);},a.aborted?O():a.addEventListener(\"abort\",O)),Ut(e)&&(v=e._state,s=e._storedError),Xe(t)&&(R=t._state,u=t._storedError,T=ot(t)),Ut(e)&&Xe(t)&&(q=!0,p()),\"errored\"===v)A(s);else if(\"erroring\"===R||\"errored\"===R)j(u);else if(\"closed\"===v)B();else if(T||\"closed\"===R){const e=new TypeError(\"the destination writable stream closed before all data could be piped to it\");n?L(!0,e):z((()=>i.cancel(e)),!0,e);}function z(e,t,r){function o(){return \"writable\"!==R||T?n():_(function(){let e;return d(function t(){if(e!==P)return e=P,m(P,t,t)}())}(),n),null}function n(){return e?h(e(),(()=>F(t,r)),(e=>F(!0,e))):F(t,r),null}S||(S=!0,q?o():_(C,o));}function L(e,t){z(void 0,e,t);}function F(e,t){return w=!0,l.releaseLock(),i.releaseLock(),void 0!==a&&a.removeEventListener(\"abort\",O),e?W(t):E(void 0),null}S||(h(i.closed,B,A),h(l.closed,(function(){return w||(R=\"closed\"),null}),j)),q?k():g((()=>{q=!0,p(),k();}));}))}function Bt(e,t){return function(e){try{return e.getReader({mode:\"byob\"}).releaseLock(),!0}catch(e){return !1}}(e)?function(e){let t,r,o,n,a,i=e.getReader(),l=!1,s=!1,u=!1,f=!1,b=!1,_=!1;const m=c((e=>{a=e;}));function y(e){p(e.closed,(t=>(e!==i||(o.error(t),n.error(t),b&&_||a(void 0)),null)));}function g(){l&&(i.releaseLock(),i=e.getReader(),y(i),l=!1),h(i.read(),(e=>{var t,r;if(u=!1,f=!1,e.done)return b||o.close(),_||n.close(),null===(t=o.byobRequest)||void 0===t||t.respond(0),null===(r=n.byobRequest)||void 0===r||r.respond(0),b&&_||a(void 0),null;const l=e.value,c=l;let d=l;if(!b&&!_)try{d=se(l);}catch(e){return o.error(e),n.error(e),a(i.cancel(e)),null}return b||o.enqueue(c),_||n.enqueue(d),s=!1,u?w():f&&v(),null}),(()=>(s=!1,null)));}function S(t,r){l||(i.releaseLock(),i=e.getReader({mode:\"byob\"}),y(i),l=!0);const c=r?n:o,d=r?o:n;h(i.read(t),(e=>{var t;u=!1,f=!1;const o=r?_:b,n=r?b:_;if(e.done){o||c.close(),n||d.close();const r=e.value;return void 0!==r&&(o||c.byobRequest.respondWithNewView(r),n||null===(t=d.byobRequest)||void 0===t||t.respond(0)),o&&n||a(void 0),null}const l=e.value;if(n)o||c.byobRequest.respondWithNewView(l);else {let e;try{e=se(l);}catch(e){return c.error(e),d.error(e),a(i.cancel(e)),null}o||c.byobRequest.respondWithNewView(l),d.enqueue(e);}return s=!1,u?w():f&&v(),null}),(()=>(s=!1,null)));}function w(){if(s)return u=!0,d(void 0);s=!0;const e=o.byobRequest;return null===e?g():S(e.view,!1),d(void 0)}function v(){if(s)return f=!0,d(void 0);s=!0;const e=n.byobRequest;return null===e?g():S(e.view,!0),d(void 0)}function R(e){if(b=!0,t=e,_){const e=[t,r],o=i.cancel(e);a(o);}return m}function T(e){if(_=!0,r=e,b){const e=[t,r],o=i.cancel(e);a(o);}return m}const q=new ReadableStream({type:\"bytes\",start(e){o=e;},pull:w,cancel:R}),C=new ReadableStream({type:\"bytes\",start(e){n=e;},pull:v,cancel:T});return y(i),[q,C]}(e):function(e,t){const r=e.getReader();let o,n,a,i,l,s=!1,u=!1,f=!1,b=!1;const _=c((e=>{l=e;}));function m(){return s?(u=!0,d(void 0)):(s=!0,h(r.read(),(e=>{if(u=!1,e.done)return f||a.close(),b||i.close(),f&&b||l(void 0),null;const t=e.value,r=t,o=t;return f||a.enqueue(r),b||i.enqueue(o),s=!1,u&&m(),null}),(()=>(s=!1,null))),d(void 0))}function y(e){if(f=!0,o=e,b){const e=[o,n],t=r.cancel(e);l(t);}return _}function g(e){if(b=!0,n=e,f){const e=[o,n],t=r.cancel(e);l(t);}return _}const S=new ReadableStream({start(e){a=e;},pull:m,cancel:y}),w=new ReadableStream({start(e){i=e;},pull:m,cancel:g});return p(r.closed,(e=>(a.error(e),i.error(e),f&&b||l(void 0),null))),[S,w]}(e)}class ReadableStreamDefaultController{constructor(){throw new TypeError(\"Illegal constructor\")}get desiredSize(){if(!At(this))throw $t(\"desiredSize\");return Ft(this)}close(){if(!At(this))throw $t(\"close\");if(!Dt(this))throw new TypeError(\"The stream is not in a state that permits close\");!function(e){if(!Dt(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(zt(e),Jt(t));}(this);}enqueue(e){if(!At(this))throw $t(\"enqueue\");if(!Dt(this))throw new TypeError(\"The stream is not in a state that permits enqueue\");return function(e,t){if(!Dt(e))return;const r=e._controlledReadableStream;if(Gt(r)&&J(r)>0)X(r,t,!1);else {let r;try{r=e._strategySizeAlgorithm(t);}catch(t){throw Lt(e,t),t}try{ce(e,t,r);}catch(t){throw Lt(e,t),t}}jt(e);}(this,e)}error(e){if(!At(this))throw $t(\"error\");Lt(this,e);}[q](e){de(this);const t=this._cancelAlgorithm(e);return zt(this),t}[C](e){const t=this._controlledReadableStream;if(this._queue.length>0){const r=ue(this);this._closeRequested&&0===this._queue.length?(zt(this),Jt(t)):jt(this),e._chunkSteps(r);}else G(t,e),jt(this);}[P](){}}function At(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledReadableStream\")&&e instanceof ReadableStreamDefaultController)}function jt(e){const t=function(e){const t=e._controlledReadableStream;if(!Dt(e))return !1;if(!e._started)return !1;if(Gt(t)&&J(t)>0)return !0;if(Ft(e)>0)return !0;return !1}(e);if(!t)return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;h(e._pullAlgorithm(),(()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,jt(e)),null)),(t=>(Lt(e,t),null)));}function zt(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0;}function Lt(e,t){const r=e._controlledReadableStream;\"readable\"===r._state&&(de(e),zt(e),Kt(r,t));}function Ft(e){const t=e._controlledReadableStream._state;return \"errored\"===t?null:\"closed\"===t?0:e._strategyHWM-e._queueTotalSize}function Dt(e){return !e._closeRequested&&\"readable\"===e._controlledReadableStream._state}function It(e,t,r,o){const n=Object.create(ReadableStreamDefaultController.prototype);let a,i,l;a=void 0!==t.start?()=>t.start(n):()=>{},i=void 0!==t.pull?()=>t.pull(n):()=>d(void 0),l=void 0!==t.cancel?e=>t.cancel(e):()=>d(void 0),function(e,t,r,o,n,a,i){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,de(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=i,t._strategyHWM=a,t._pullAlgorithm=o,t._cancelAlgorithm=n,e._readableStreamController=t,h(d(r()),(()=>(t._started=!0,jt(t),null)),(e=>(Lt(t,e),null)));}(e,n,a,i,l,r,o);}function $t(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function Mt(e,t,r){return I(e,r),r=>w(e,t,[r])}function Yt(e,t,r){return I(e,r),r=>w(e,t,[r])}function Qt(e,t,r){return I(e,r),r=>S(e,t,[r])}function Nt(e,t){if(\"bytes\"!==(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function xt(e,t){if(\"byob\"!==(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function Ht(e,t){D(e,t);const r=null==e?void 0:e.preventAbort,o=null==e?void 0:e.preventCancel,n=null==e?void 0:e.preventClose,a=null==e?void 0:e.signal;return void 0!==a&&function(e,t){if(!function(e){if(\"object\"!=typeof e||null===e)return !1;try{return \"boolean\"==typeof e.aborted}catch(e){return !1}}(e))throw new TypeError(`${t} is not an AbortSignal.`)}(a,`${t} has member 'signal' that`),{preventAbort:Boolean(r),preventCancel:Boolean(o),preventClose:Boolean(n),signal:a}}function Vt(e,t){D(e,t);const r=null==e?void 0:e.readable;Y(r,\"readable\",\"ReadableWritablePair\"),function(e,t){if(!H(e))throw new TypeError(`${t} is not a ReadableStream.`)}(r,`${t} has member 'readable' that`);const o=null==e?void 0:e.writable;return Y(o,\"writable\",\"ReadableWritablePair\"),function(e,t){if(!V(e))throw new TypeError(`${t} is not a WritableStream.`)}(o,`${t} has member 'writable' that`),{readable:r,writable:o}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),a(ReadableStreamDefaultController.prototype.close,\"close\"),a(ReadableStreamDefaultController.prototype.enqueue,\"enqueue\"),a(ReadableStreamDefaultController.prototype.error,\"error\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamDefaultController.prototype,t.toStringTag,{value:\"ReadableStreamDefaultController\",configurable:!0});class ReadableStream{constructor(e={},t={}){void 0===e?e=null:$(e,\"First parameter\");const r=Qe(t,\"Second parameter\"),o=function(e,t){D(e,t);const r=e,o=null==r?void 0:r.autoAllocateChunkSize,n=null==r?void 0:r.cancel,a=null==r?void 0:r.pull,i=null==r?void 0:r.start,l=null==r?void 0:r.type;return {autoAllocateChunkSize:void 0===o?void 0:x(o,`${t} has member 'autoAllocateChunkSize' that`),cancel:void 0===n?void 0:Mt(n,r,`${t} has member 'cancel' that`),pull:void 0===a?void 0:Yt(a,r,`${t} has member 'pull' that`),start:void 0===i?void 0:Qt(i,r,`${t} has member 'start' that`),type:void 0===l?void 0:Nt(l,`${t} has member 'type' that`)}}(e,\"First parameter\");var n;if((n=this)._state=\"readable\",n._reader=void 0,n._storedError=void 0,n._disturbed=!1,\"bytes\"===o.type){if(void 0!==r.size)throw new RangeError(\"The strategy for a byte stream cannot have a size function\");Be(this,o,Me(r,0));}else {const e=Ye(r);It(this,o,Me(r,1),e);}}get locked(){if(!Ut(this))throw Zt(\"locked\");return Gt(this)}cancel(e){return Ut(this)?Gt(this)?f(new TypeError(\"Cannot cancel a stream that already has a reader\")):Xt(this,e):f(Zt(\"cancel\"))}getReader(e){if(!Ut(this))throw Zt(\"getReader\");return void 0===function(e,t){D(e,t);const r=null==e?void 0:e.mode;return {mode:void 0===r?void 0:xt(r,`${t} has member 'mode' that`)}}(e,\"First parameter\").mode?new ReadableStreamDefaultReader(this):function(e){return new ReadableStreamBYOBReader(e)}(this)}pipeThrough(e,t={}){if(!H(this))throw Zt(\"pipeThrough\");M(e,1,\"pipeThrough\");const r=Vt(e,\"First parameter\"),o=Ht(t,\"Second parameter\");if(this.locked)throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");if(r.writable.locked)throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");return y(kt(this,r.writable,o.preventClose,o.preventAbort,o.preventCancel,o.signal)),r.readable}pipeTo(e,t={}){if(!H(this))return f(Zt(\"pipeTo\"));if(void 0===e)return f(\"Parameter 1 is required in 'pipeTo'.\");if(!V(e))return f(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));let r;try{r=Ht(t,\"Second parameter\");}catch(e){return f(e)}return this.locked?f(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")):e.locked?f(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")):kt(this,e,r.preventClose,r.preventAbort,r.preventCancel,r.signal)}tee(){if(!H(this))throw Zt(\"tee\");if(this.locked)throw new TypeError(\"Cannot tee a stream that already has a reader\");return Bt(this)}values(e){if(!H(this))throw Zt(\"values\");return function(e,t){const r=e.getReader(),o=new re(r,t),n=Object.create(oe);return n._asyncIteratorImpl=o,n}(this,function(e,t){D(e,t);const r=null==e?void 0:e.preventCancel;return {preventCancel:Boolean(r)}}(e,\"First parameter\").preventCancel)}}function Ut(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_readableStreamController\")&&e instanceof ReadableStream)}function Gt(e){return void 0!==e._reader}function Xt(e,t){if(e._disturbed=!0,\"closed\"===e._state)return d(void 0);if(\"errored\"===e._state)return f(e._storedError);Jt(e);const o=e._reader;if(void 0!==o&&De(o)){const e=o._readIntoRequests;o._readIntoRequests=new v,e.forEach((e=>{e._closeSteps(void 0);}));}return m(e._readableStreamController[q](t),r)}function Jt(e){e._state=\"closed\";const t=e._reader;if(void 0!==t&&(z(t),Z(t))){const e=t._readRequests;t._readRequests=new v,e.forEach((e=>{e._closeSteps();}));}}function Kt(e,t){e._state=\"errored\",e._storedError=t;const r=e._reader;void 0!==r&&(j(r,t),Z(r)?ee(r,t):Ie(r,t));}function Zt(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function er(e,t){D(e,t);const r=null==e?void 0:e.highWaterMark;return Y(r,\"highWaterMark\",\"QueuingStrategyInit\"),{highWaterMark:Q(r)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),a(ReadableStream.prototype.cancel,\"cancel\"),a(ReadableStream.prototype.getReader,\"getReader\"),a(ReadableStream.prototype.pipeThrough,\"pipeThrough\"),a(ReadableStream.prototype.pipeTo,\"pipeTo\"),a(ReadableStream.prototype.tee,\"tee\"),a(ReadableStream.prototype.values,\"values\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(ReadableStream.prototype,t.toStringTag,{value:\"ReadableStream\",configurable:!0}),\"symbol\"==typeof t.asyncIterator&&Object.defineProperty(ReadableStream.prototype,t.asyncIterator,{value:ReadableStream.prototype.values,writable:!0,configurable:!0});const tr=e=>e.byteLength;a(tr,\"size\");class ByteLengthQueuingStrategy{constructor(e){M(e,1,\"ByteLengthQueuingStrategy\"),e=er(e,\"First parameter\"),this._byteLengthQueuingStrategyHighWaterMark=e.highWaterMark;}get highWaterMark(){if(!or(this))throw rr(\"highWaterMark\");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!or(this))throw rr(\"size\");return tr}}function rr(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function or(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_byteLengthQueuingStrategyHighWaterMark\")&&e instanceof ByteLengthQueuingStrategy)}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(ByteLengthQueuingStrategy.prototype,t.toStringTag,{value:\"ByteLengthQueuingStrategy\",configurable:!0});const nr=()=>1;a(nr,\"size\");class CountQueuingStrategy{constructor(e){M(e,1,\"CountQueuingStrategy\"),e=er(e,\"First parameter\"),this._countQueuingStrategyHighWaterMark=e.highWaterMark;}get highWaterMark(){if(!ir(this))throw ar(\"highWaterMark\");return this._countQueuingStrategyHighWaterMark}get size(){if(!ir(this))throw ar(\"size\");return nr}}function ar(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function ir(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_countQueuingStrategyHighWaterMark\")&&e instanceof CountQueuingStrategy)}function lr(e,t,r){return I(e,r),r=>w(e,t,[r])}function sr(e,t,r){return I(e,r),r=>S(e,t,[r])}function ur(e,t,r){return I(e,r),(r,o)=>w(e,t,[r,o])}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(CountQueuingStrategy.prototype,t.toStringTag,{value:\"CountQueuingStrategy\",configurable:!0});class TransformStream{constructor(e={},t={},r={}){void 0===e&&(e=null);const o=Qe(t,\"Second parameter\"),n=Qe(r,\"Third parameter\"),a=function(e,t){D(e,t);const r=null==e?void 0:e.flush,o=null==e?void 0:e.readableType,n=null==e?void 0:e.start,a=null==e?void 0:e.transform,i=null==e?void 0:e.writableType;return {flush:void 0===r?void 0:lr(r,e,`${t} has member 'flush' that`),readableType:o,start:void 0===n?void 0:sr(n,e,`${t} has member 'start' that`),transform:void 0===a?void 0:ur(a,e,`${t} has member 'transform' that`),writableType:i}}(e,\"First parameter\");if(void 0!==a.readableType)throw new RangeError(\"Invalid readableType specified\");if(void 0!==a.writableType)throw new RangeError(\"Invalid writableType specified\");const i=Me(n,0),l=Ye(n),s=Me(o,1),u=Ye(o);let b;!function(e,t,r,o,n,a){function i(){return t}function l(t){return function(e,t){const r=e._transformStreamController;if(e._backpressure){return m(e._backpressureChangePromise,(()=>{if(\"erroring\"===(Xe(e._writable)?e._writable._state:e._writableState))throw Xe(e._writable)?e._writable._storedError:e._writableStoredError;return mr(r,t)}))}return mr(r,t)}(e,t)}function s(t){return function(e,t){return dr(e,t),d(void 0)}(e,t)}function u(){return function(e){const t=e._transformStreamController,r=t._flushAlgorithm();return _r(t),m(r,(()=>{if(\"errored\"===e._readableState)throw e._readableStoredError;Sr(e)&&wr(e);}),(t=>{throw dr(e,t),e._readableStoredError}))}(e)}function c(){return function(e){return br(e,!1),e._backpressureChangePromise}(e)}function f(t){return fr(e,t),d(void 0)}e._writableState=\"writable\",e._writableStoredError=void 0,e._writableHasInFlightOperation=!1,e._writableStarted=!1,e._writable=function(e,t,r,o,n,a,i){return new WritableStream({start(r){e._writableController=r;try{const t=r.signal;void 0!==t&&t.addEventListener(\"abort\",(()=>{\"writable\"===e._writableState&&(e._writableState=\"erroring\",t.reason&&(e._writableStoredError=t.reason));}));}catch(e){}return m(t(),(()=>(e._writableStarted=!0,Pr(e),null)),(t=>{throw e._writableStarted=!0,Tr(e,t),t}))},write:t=>(function(e){e._writableHasInFlightOperation=!0;}(e),m(r(t),(()=>(function(e){e._writableHasInFlightOperation=!1;}(e),Pr(e),null)),(t=>{throw function(e,t){e._writableHasInFlightOperation=!1,Tr(e,t);}(e,t),t}))),close:()=>(function(e){e._writableHasInFlightOperation=!0;}(e),m(o(),(()=>(function(e){e._writableHasInFlightOperation=!1;\"erroring\"===e._writableState&&(e._writableStoredError=void 0);e._writableState=\"closed\";}(e),null)),(t=>{throw function(e,t){e._writableHasInFlightOperation=!1,e._writableState,Tr(e,t);}(e,t),t}))),abort:t=>(e._writableState=\"errored\",e._writableStoredError=t,n(t))},{highWaterMark:a,size:i})}(e,i,l,u,s,r,o),e._readableState=\"readable\",e._readableStoredError=void 0,e._readableCloseRequested=!1,e._readablePulling=!1,e._readable=function(e,t,r,o,n,a){return new ReadableStream({start:r=>(e._readableController=r,t().catch((t=>{vr(e,t);}))),pull:()=>(e._readablePulling=!0,r().catch((t=>{vr(e,t);}))),cancel:t=>(e._readableState=\"closed\",o(t))},{highWaterMark:n,size:a})}(e,i,c,f,n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,br(e,!0),e._transformStreamController=void 0;}(this,c((e=>{b=e;})),s,u,i,l),function(e,t){const r=Object.create(TransformStreamDefaultController.prototype);let o,n;o=void 0!==t.transform?e=>t.transform(e,r):e=>{try{return pr(r,e),d(void 0)}catch(e){return f(e)}};n=void 0!==t.flush?()=>t.flush(r):()=>d(void 0);!function(e,t,r,o){t._controlledTransformStream=e,e._transformStreamController=t,t._transformAlgorithm=r,t._flushAlgorithm=o;}(e,r,o,n);}(this,a),void 0!==a.start?b(a.start(this._transformStreamController)):b(void 0);}get readable(){if(!cr(this))throw gr(\"readable\");return this._readable}get writable(){if(!cr(this))throw gr(\"writable\");return this._writable}}function cr(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_transformStreamController\")&&e instanceof TransformStream)}function dr(e,t){vr(e,t),fr(e,t);}function fr(e,t){_r(e._transformStreamController),function(e,t){e._writableController.error(t);\"writable\"===e._writableState&&qr(e,t);}(e,t),e._backpressure&&br(e,!1);}function br(e,t){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=c((t=>{e._backpressureChangePromise_resolve=t;})),e._backpressure=t;}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(TransformStream.prototype,t.toStringTag,{value:\"TransformStream\",configurable:!0});class TransformStreamDefaultController{constructor(){throw new TypeError(\"Illegal constructor\")}get desiredSize(){if(!hr(this))throw yr(\"desiredSize\");return Rr(this._controlledTransformStream)}enqueue(e){if(!hr(this))throw yr(\"enqueue\");pr(this,e);}error(e){if(!hr(this))throw yr(\"error\");var t;t=e,dr(this._controlledTransformStream,t);}terminate(){if(!hr(this))throw yr(\"terminate\");!function(e){const t=e._controlledTransformStream;Sr(t)&&wr(t);const r=new TypeError(\"TransformStream terminated\");fr(t,r);}(this);}}function hr(e){return !!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,\"_controlledTransformStream\")&&e instanceof TransformStreamDefaultController)}function _r(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0;}function pr(e,t){const r=e._controlledTransformStream;if(!Sr(r))throw new TypeError(\"Readable side is not in a state that permits enqueue\");try{!function(e,t){e._readablePulling=!1;try{e._readableController.enqueue(t);}catch(t){throw vr(e,t),t}}(r,t);}catch(e){throw fr(r,e),r._readableStoredError}const o=function(e){return !function(e){if(!Sr(e))return !1;if(e._readablePulling)return !0;if(Rr(e)>0)return !0;return !1}(e)}(r);o!==r._backpressure&&br(r,!0);}function mr(e,t){return m(e._transformAlgorithm(t),void 0,(t=>{throw dr(e._controlledTransformStream,t),t}))}function yr(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function gr(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}function Sr(e){return !e._readableCloseRequested&&\"readable\"===e._readableState}function wr(e){e._readableState=\"closed\",e._readableCloseRequested=!0,e._readableController.close();}function vr(e,t){\"readable\"===e._readableState&&(e._readableState=\"errored\",e._readableStoredError=t),e._readableController.error(t);}function Rr(e){return e._readableController.desiredSize}function Tr(e,t){\"writable\"!==e._writableState?Cr(e):qr(e,t);}function qr(e,t){e._writableState=\"erroring\",e._writableStoredError=t,!function(e){return e._writableHasInFlightOperation}(e)&&e._writableStarted&&Cr(e);}function Cr(e){e._writableState=\"errored\";}function Pr(e){\"erroring\"===e._writableState&&Cr(e);}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),a(TransformStreamDefaultController.prototype.enqueue,\"enqueue\"),a(TransformStreamDefaultController.prototype.error,\"error\"),a(TransformStreamDefaultController.prototype.terminate,\"terminate\"),\"symbol\"==typeof t.toStringTag&&Object.defineProperty(TransformStreamDefaultController.prototype,t.toStringTag,{value:\"TransformStreamDefaultController\",configurable:!0}),e.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,e.CountQueuingStrategy=CountQueuingStrategy,e.ReadableByteStreamController=ReadableByteStreamController,e.ReadableStream=ReadableStream,e.ReadableStreamBYOBReader=ReadableStreamBYOBReader,e.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest,e.ReadableStreamDefaultController=ReadableStreamDefaultController,e.ReadableStreamDefaultReader=ReadableStreamDefaultReader,e.TransformStream=TransformStream,e.TransformStreamDefaultController=TransformStreamDefaultController,e.WritableStream=WritableStream,e.WritableStreamDefaultController=WritableStreamDefaultController,e.WritableStreamDefaultWriter=WritableStreamDefaultWriter,Object.defineProperty(e,\"__esModule\",{value:!0});})); \n  \t} (ponyfill, ponyfill.exports));\n  \treturn ponyfill.exports;\n  }\n\n  var isFunction = {};\n\n  var hasRequiredIsFunction;\n\n  function requireIsFunction () {\n  \tif (hasRequiredIsFunction) return isFunction;\n  \thasRequiredIsFunction = 1;\n  \tObject.defineProperty(isFunction, \"__esModule\", { value: true });\n  \tisFunction.isFunction = void 0;\n  \tconst isFunction$1 = (value) => (typeof value === \"function\");\n  \tisFunction.isFunction = isFunction$1;\n  \treturn isFunction;\n  }\n\n  var blobHelpers = {};\n\n  var hasRequiredBlobHelpers;\n\n  function requireBlobHelpers () {\n  \tif (hasRequiredBlobHelpers) return blobHelpers;\n  \thasRequiredBlobHelpers = 1;\n  \t/*! Based on fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> & David Frank */\n  \tObject.defineProperty(blobHelpers, \"__esModule\", { value: true });\n  \tblobHelpers.sliceBlob = blobHelpers.consumeBlobParts = void 0;\n  \tconst isFunction_1 = requireIsFunction();\n  \tconst CHUNK_SIZE = 65536;\n  \tasync function* clonePart(part) {\n  \t    const end = part.byteOffset + part.byteLength;\n  \t    let position = part.byteOffset;\n  \t    while (position !== end) {\n  \t        const size = Math.min(end - position, CHUNK_SIZE);\n  \t        const chunk = part.buffer.slice(position, position + size);\n  \t        position += chunk.byteLength;\n  \t        yield new Uint8Array(chunk);\n  \t    }\n  \t}\n  \tasync function* consumeNodeBlob(blob) {\n  \t    let position = 0;\n  \t    while (position !== blob.size) {\n  \t        const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));\n  \t        const buffer = await chunk.arrayBuffer();\n  \t        position += buffer.byteLength;\n  \t        yield new Uint8Array(buffer);\n  \t    }\n  \t}\n  \tasync function* consumeBlobParts(parts, clone = false) {\n  \t    for (const part of parts) {\n  \t        if (ArrayBuffer.isView(part)) {\n  \t            if (clone) {\n  \t                yield* clonePart(part);\n  \t            }\n  \t            else {\n  \t                yield part;\n  \t            }\n  \t        }\n  \t        else if ((0, isFunction_1.isFunction)(part.stream)) {\n  \t            yield* part.stream();\n  \t        }\n  \t        else {\n  \t            yield* consumeNodeBlob(part);\n  \t        }\n  \t    }\n  \t}\n  \tblobHelpers.consumeBlobParts = consumeBlobParts;\n  \tfunction* sliceBlob(blobParts, blobSize, start = 0, end) {\n  \t    end !== null && end !== void 0 ? end : (end = blobSize);\n  \t    let relativeStart = start < 0\n  \t        ? Math.max(blobSize + start, 0)\n  \t        : Math.min(start, blobSize);\n  \t    let relativeEnd = end < 0\n  \t        ? Math.max(blobSize + end, 0)\n  \t        : Math.min(end, blobSize);\n  \t    const span = Math.max(relativeEnd - relativeStart, 0);\n  \t    let added = 0;\n  \t    for (const part of blobParts) {\n  \t        if (added >= span) {\n  \t            break;\n  \t        }\n  \t        const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n  \t        if (relativeStart && partSize <= relativeStart) {\n  \t            relativeStart -= partSize;\n  \t            relativeEnd -= partSize;\n  \t        }\n  \t        else {\n  \t            let chunk;\n  \t            if (ArrayBuffer.isView(part)) {\n  \t                chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));\n  \t                added += chunk.byteLength;\n  \t            }\n  \t            else {\n  \t                chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));\n  \t                added += chunk.size;\n  \t            }\n  \t            relativeEnd -= partSize;\n  \t            relativeStart = 0;\n  \t            yield chunk;\n  \t        }\n  \t    }\n  \t}\n  \tblobHelpers.sliceBlob = sliceBlob;\n  \treturn blobHelpers;\n  }\n\n  var hasRequiredBlob;\n\n  function requireBlob () {\n  \tif (hasRequiredBlob) return Blob;\n  \thasRequiredBlob = 1;\n  \t/*! Based on fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> & David Frank */\n  \tvar __classPrivateFieldGet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n  \t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  \t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  \t    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  \t};\n  \tvar __classPrivateFieldSet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n  \t    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  \t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  \t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  \t    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  \t};\n  \tvar _Blob_parts, _Blob_type, _Blob_size;\n  \tObject.defineProperty(Blob, \"__esModule\", { value: true });\n  \tBlob.Blob = void 0;\n  \tconst web_streams_polyfill_1 = requirePonyfill();\n  \tconst isFunction_1 = requireIsFunction();\n  \tconst blobHelpers_1 = requireBlobHelpers();\n  \tlet Blob$1 = class Blob {\n  \t    constructor(blobParts = [], options = {}) {\n  \t        _Blob_parts.set(this, []);\n  \t        _Blob_type.set(this, \"\");\n  \t        _Blob_size.set(this, 0);\n  \t        options !== null && options !== void 0 ? options : (options = {});\n  \t        if (typeof blobParts !== \"object\" || blobParts === null) {\n  \t            throw new TypeError(\"Failed to construct 'Blob': \"\n  \t                + \"The provided value cannot be converted to a sequence.\");\n  \t        }\n  \t        if (!(0, isFunction_1.isFunction)(blobParts[Symbol.iterator])) {\n  \t            throw new TypeError(\"Failed to construct 'Blob': \"\n  \t                + \"The object must have a callable @@iterator property.\");\n  \t        }\n  \t        if (typeof options !== \"object\" && !(0, isFunction_1.isFunction)(options)) {\n  \t            throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n  \t        }\n  \t        const encoder = new TextEncoder();\n  \t        for (const raw of blobParts) {\n  \t            let part;\n  \t            if (ArrayBuffer.isView(raw)) {\n  \t                part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));\n  \t            }\n  \t            else if (raw instanceof ArrayBuffer) {\n  \t                part = new Uint8Array(raw.slice(0));\n  \t            }\n  \t            else if (raw instanceof Blob) {\n  \t                part = raw;\n  \t            }\n  \t            else {\n  \t                part = encoder.encode(String(raw));\n  \t            }\n  \t            __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, \"f\") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), \"f\");\n  \t            __classPrivateFieldGet(this, _Blob_parts, \"f\").push(part);\n  \t        }\n  \t        const type = options.type === undefined ? \"\" : String(options.type);\n  \t        __classPrivateFieldSet(this, _Blob_type, /^[\\x20-\\x7E]*$/.test(type) ? type : \"\", \"f\");\n  \t    }\n  \t    static [(_Blob_parts = new WeakMap(), _Blob_type = new WeakMap(), _Blob_size = new WeakMap(), Symbol.hasInstance)](value) {\n  \t        return Boolean(value\n  \t            && typeof value === \"object\"\n  \t            && (0, isFunction_1.isFunction)(value.constructor)\n  \t            && ((0, isFunction_1.isFunction)(value.stream)\n  \t                || (0, isFunction_1.isFunction)(value.arrayBuffer))\n  \t            && /^(Blob|File)$/.test(value[Symbol.toStringTag]));\n  \t    }\n  \t    get type() {\n  \t        return __classPrivateFieldGet(this, _Blob_type, \"f\");\n  \t    }\n  \t    get size() {\n  \t        return __classPrivateFieldGet(this, _Blob_size, \"f\");\n  \t    }\n  \t    slice(start, end, contentType) {\n  \t        return new Blob((0, blobHelpers_1.sliceBlob)(__classPrivateFieldGet(this, _Blob_parts, \"f\"), this.size, start, end), {\n  \t            type: contentType\n  \t        });\n  \t    }\n  \t    async text() {\n  \t        const decoder = new TextDecoder();\n  \t        let result = \"\";\n  \t        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, \"f\"))) {\n  \t            result += decoder.decode(chunk, { stream: true });\n  \t        }\n  \t        result += decoder.decode();\n  \t        return result;\n  \t    }\n  \t    async arrayBuffer() {\n  \t        const view = new Uint8Array(this.size);\n  \t        let offset = 0;\n  \t        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, \"f\"))) {\n  \t            view.set(chunk, offset);\n  \t            offset += chunk.length;\n  \t        }\n  \t        return view.buffer;\n  \t    }\n  \t    stream() {\n  \t        const iterator = (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, \"f\"), true);\n  \t        return new web_streams_polyfill_1.ReadableStream({\n  \t            async pull(controller) {\n  \t                const { value, done } = await iterator.next();\n  \t                if (done) {\n  \t                    return queueMicrotask(() => controller.close());\n  \t                }\n  \t                controller.enqueue(value);\n  \t            },\n  \t            async cancel() {\n  \t                await iterator.return();\n  \t            }\n  \t        });\n  \t    }\n  \t    get [Symbol.toStringTag]() {\n  \t        return \"Blob\";\n  \t    }\n  \t};\n  \tBlob.Blob = Blob$1;\n  \tObject.defineProperties(Blob$1.prototype, {\n  \t    type: { enumerable: true },\n  \t    size: { enumerable: true },\n  \t    slice: { enumerable: true },\n  \t    stream: { enumerable: true },\n  \t    text: { enumerable: true },\n  \t    arrayBuffer: { enumerable: true }\n  \t});\n  \treturn Blob;\n  }\n\n  var hasRequiredFile;\n\n  function requireFile () {\n  \tif (hasRequiredFile) return File;\n  \thasRequiredFile = 1;\n  \tvar __classPrivateFieldSet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n  \t    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  \t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  \t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  \t    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  \t};\n  \tvar __classPrivateFieldGet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n  \t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  \t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  \t    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  \t};\n  \tvar _File_name, _File_lastModified;\n  \tObject.defineProperty(File, \"__esModule\", { value: true });\n  \tFile.File = void 0;\n  \tconst Blob_1 = requireBlob();\n  \tlet File$1 = class File extends Blob_1.Blob {\n  \t    constructor(fileBits, name, options = {}) {\n  \t        super(fileBits, options);\n  \t        _File_name.set(this, void 0);\n  \t        _File_lastModified.set(this, 0);\n  \t        if (arguments.length < 2) {\n  \t            throw new TypeError(\"Failed to construct 'File': 2 arguments required, \"\n  \t                + `but only ${arguments.length} present.`);\n  \t        }\n  \t        __classPrivateFieldSet(this, _File_name, String(name), \"f\");\n  \t        const lastModified = options.lastModified === undefined\n  \t            ? Date.now()\n  \t            : Number(options.lastModified);\n  \t        if (!Number.isNaN(lastModified)) {\n  \t            __classPrivateFieldSet(this, _File_lastModified, lastModified, \"f\");\n  \t        }\n  \t    }\n  \t    static [(_File_name = new WeakMap(), _File_lastModified = new WeakMap(), Symbol.hasInstance)](value) {\n  \t        return value instanceof Blob_1.Blob\n  \t            && value[Symbol.toStringTag] === \"File\"\n  \t            && typeof value.name === \"string\";\n  \t    }\n  \t    get name() {\n  \t        return __classPrivateFieldGet(this, _File_name, \"f\");\n  \t    }\n  \t    get lastModified() {\n  \t        return __classPrivateFieldGet(this, _File_lastModified, \"f\");\n  \t    }\n  \t    get webkitRelativePath() {\n  \t        return \"\";\n  \t    }\n  \t    get [Symbol.toStringTag]() {\n  \t        return \"File\";\n  \t    }\n  \t};\n  \tFile.File = File$1;\n  \treturn File;\n  }\n\n  var isPlainObject = {};\n\n  var hasRequiredIsPlainObject;\n\n  function requireIsPlainObject () {\n  \tif (hasRequiredIsPlainObject) return isPlainObject;\n  \thasRequiredIsPlainObject = 1;\n  \tObject.defineProperty(isPlainObject, \"__esModule\", { value: true });\n  \tconst getType = (value) => (Object.prototype.toString.call(value).slice(8, -1).toLowerCase());\n  \tfunction isPlainObject$1(value) {\n  \t    if (getType(value) !== \"object\") {\n  \t        return false;\n  \t    }\n  \t    const pp = Object.getPrototypeOf(value);\n  \t    if (pp === null || pp === undefined) {\n  \t        return true;\n  \t    }\n  \t    const Ctor = pp.constructor && pp.constructor.toString();\n  \t    return Ctor === Object.toString();\n  \t}\n  \tisPlainObject.default = isPlainObject$1;\n  \treturn isPlainObject;\n  }\n\n  var isFile = {};\n\n  var hasRequiredIsFile;\n\n  function requireIsFile () {\n  \tif (hasRequiredIsFile) return isFile;\n  \thasRequiredIsFile = 1;\n  \tObject.defineProperty(isFile, \"__esModule\", { value: true });\n  \tisFile.isFile = void 0;\n  \tconst File_1 = requireFile();\n  \tconst isFile$1 = (value) => value instanceof File_1.File;\n  \tisFile.isFile = isFile$1;\n  \treturn isFile;\n  }\n\n  var hasRequiredFileFromPath;\n\n  function requireFileFromPath () {\n  \tif (hasRequiredFileFromPath) return fileFromPath$1;\n  \thasRequiredFileFromPath = 1;\n  \t(function (exports) {\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t\t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t\t};\n  \t\tvar __classPrivateFieldSet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n  \t\t    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  \t\t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  \t\t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  \t\t    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  \t\t};\n  \t\tvar __classPrivateFieldGet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n  \t\t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  \t\t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  \t\t    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  \t\t};\n  \t\tvar __importDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importDefault) || function (mod) {\n  \t\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n  \t\t};\n  \t\tvar _FileFromPath_path, _FileFromPath_start;\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.fileFromPath = exports.fileFromPathSync = void 0;\n  \t\tconst fs_1 = require$$4;\n  \t\tconst path_1 = require$$1;\n  \t\tconst node_domexception_1 = __importDefault(requireNodeDomexception());\n  \t\tconst File_1 = requireFile();\n  \t\tconst isPlainObject_1 = __importDefault(requireIsPlainObject());\n  \t\t__exportStar(requireIsFile(), exports);\n  \t\tconst MESSAGE = \"The requested file could not be read, \"\n  \t\t    + \"typically due to permission problems that have occurred after a reference \"\n  \t\t    + \"to a file was acquired.\";\n  \t\tclass FileFromPath {\n  \t\t    constructor(input) {\n  \t\t        _FileFromPath_path.set(this, void 0);\n  \t\t        _FileFromPath_start.set(this, void 0);\n  \t\t        __classPrivateFieldSet(this, _FileFromPath_path, input.path, \"f\");\n  \t\t        __classPrivateFieldSet(this, _FileFromPath_start, input.start || 0, \"f\");\n  \t\t        this.name = (0, path_1.basename)(__classPrivateFieldGet(this, _FileFromPath_path, \"f\"));\n  \t\t        this.size = input.size;\n  \t\t        this.lastModified = input.lastModified;\n  \t\t    }\n  \t\t    slice(start, end) {\n  \t\t        return new FileFromPath({\n  \t\t            path: __classPrivateFieldGet(this, _FileFromPath_path, \"f\"),\n  \t\t            lastModified: this.lastModified,\n  \t\t            size: end - start,\n  \t\t            start\n  \t\t        });\n  \t\t    }\n  \t\t    async *stream() {\n  \t\t        const { mtimeMs } = await fs_1.promises.stat(__classPrivateFieldGet(this, _FileFromPath_path, \"f\"));\n  \t\t        if (mtimeMs > this.lastModified) {\n  \t\t            throw new node_domexception_1.default(MESSAGE, \"NotReadableError\");\n  \t\t        }\n  \t\t        if (this.size) {\n  \t\t            yield* (0, fs_1.createReadStream)(__classPrivateFieldGet(this, _FileFromPath_path, \"f\"), {\n  \t\t                start: __classPrivateFieldGet(this, _FileFromPath_start, \"f\"),\n  \t\t                end: __classPrivateFieldGet(this, _FileFromPath_start, \"f\") + this.size - 1\n  \t\t            });\n  \t\t        }\n  \t\t    }\n  \t\t    get [(_FileFromPath_path = new WeakMap(), _FileFromPath_start = new WeakMap(), Symbol.toStringTag)]() {\n  \t\t        return \"File\";\n  \t\t    }\n  \t\t}\n  \t\tfunction createFileFromPath(path, { mtimeMs, size }, filenameOrOptions, options = {}) {\n  \t\t    let filename;\n  \t\t    if ((0, isPlainObject_1.default)(filenameOrOptions)) {\n  \t\t        [options, filename] = [filenameOrOptions, undefined];\n  \t\t    }\n  \t\t    else {\n  \t\t        filename = filenameOrOptions;\n  \t\t    }\n  \t\t    const file = new FileFromPath({ path, size, lastModified: mtimeMs });\n  \t\t    if (!filename) {\n  \t\t        filename = file.name;\n  \t\t    }\n  \t\t    return new File_1.File([file], filename, {\n  \t\t        ...options, lastModified: file.lastModified\n  \t\t    });\n  \t\t}\n  \t\tfunction fileFromPathSync(path, filenameOrOptions, options = {}) {\n  \t\t    const stats = (0, fs_1.statSync)(path);\n  \t\t    return createFileFromPath(path, stats, filenameOrOptions, options);\n  \t\t}\n  \t\texports.fileFromPathSync = fileFromPathSync;\n  \t\tasync function fileFromPath(path, filenameOrOptions, options) {\n  \t\t    const stats = await fs_1.promises.stat(path);\n  \t\t    return createFileFromPath(path, stats, filenameOrOptions, options);\n  \t\t}\n  \t\texports.fileFromPath = fileFromPath; \n  \t} (fileFromPath$1));\n  \treturn fileFromPath$1;\n  }\n\n  var __createBinding$1 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() { return m[k]; } };\n      }\n      Object.defineProperty(o, k2, desc);\n  }) : (function(o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      o[k2] = m[k];\n  }));\n  var __setModuleDefault$1 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n      Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  }) : function(o, v) {\n      o[\"default\"] = v;\n  });\n  var __importStar$1 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n      if (mod && mod.__esModule) return mod;\n      var result = {};\n      if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);\n      __setModuleDefault$1(result, mod);\n      return result;\n  };\n  var __importDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importDefault) || function (mod) {\n      return (mod && mod.__esModule) ? mod : { \"default\": mod };\n  };\n  Object.defineProperty(nodeRuntime, \"__esModule\", { value: true });\n  nodeRuntime.getRuntime = void 0;\n  /**\n   * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n   */\n  const nf = __importStar$1(browserExports$2);\n  const fd = __importStar$1(require$$1$1);\n  const agentkeepalive_1 = __importDefault(browserExports$1);\n  const abort_controller_1 = browserExports;\n  const node_fs_1 = require$$4;\n  const form_data_encoder_1 = cjs;\n  const node_stream_1 = require$$6;\n  const MultipartBody_1 = MultipartBody$1;\n  const web_1 = require$$8;\n  let fileFromPathWarned = false;\n  async function fileFromPath(path, ...args) {\n      // this import fails in environments that don't handle export maps correctly, like old versions of Jest\n      const { fileFromPath: _fileFromPath } = await Promise.resolve().then(() => __importStar$1(requireFileFromPath()));\n      if (!fileFromPathWarned) {\n          console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path)}) instead`);\n          fileFromPathWarned = true;\n      }\n      // @ts-ignore\n      return await _fileFromPath(path, ...args);\n  }\n  const defaultHttpAgent = new agentkeepalive_1.default({ keepAlive: true, timeout: 5 * 60 * 1000 });\n  const defaultHttpsAgent = new agentkeepalive_1.default.HttpsAgent({ keepAlive: true, timeout: 5 * 60 * 1000 });\n  async function getMultipartRequestOptions(form, opts) {\n      const encoder = new form_data_encoder_1.FormDataEncoder(form);\n      const readable = node_stream_1.Readable.from(encoder);\n      const body = new MultipartBody_1.MultipartBody(readable);\n      const headers = {\n          ...opts.headers,\n          ...encoder.headers,\n          'Content-Length': encoder.contentLength,\n      };\n      return { ...opts, body: body, headers };\n  }\n  function getRuntime() {\n      // Polyfill global object if needed.\n      if (typeof AbortController === 'undefined') {\n          // @ts-expect-error (the types are subtly different, but compatible in practice)\n          globalThis.AbortController = abort_controller_1.AbortController;\n      }\n      return {\n          kind: 'node',\n          fetch: nf.default,\n          Request: nf.Request,\n          Response: nf.Response,\n          Headers: nf.Headers,\n          FormData: fd.FormData,\n          Blob: fd.Blob,\n          File: fd.File,\n          ReadableStream: web_1.ReadableStream,\n          getMultipartRequestOptions,\n          getDefaultAgent: (url) => (url.startsWith('https') ? defaultHttpsAgent : defaultHttpAgent),\n          fileFromPath,\n          isFsReadStream: (value) => value instanceof node_fs_1.ReadStream,\n      };\n  }\n  nodeRuntime.getRuntime = getRuntime;\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t/**\n  \t * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n  \t */\n  \t__exportStar(nodeRuntime, exports);\n  \t\n  } (runtimeNode));\n\n  /**\n   * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n   */\n\n  (function (exports) {\n  \tconst shims = registry;\n  \tconst auto = runtimeNode;\n  \tif (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\n  \tfor (const property of Object.keys(shims)) {\n  \t  Object.defineProperty(exports, property, {\n  \t    get() {\n  \t      return shims[property];\n  \t    },\n  \t  });\n  \t} \n  } (_shims));\n\n  var hasRequiredStreaming;\n\n  function requireStreaming () {\n  \tif (hasRequiredStreaming) return streaming;\n  \thasRequiredStreaming = 1;\n  \tObject.defineProperty(streaming, \"__esModule\", { value: true });\n  \tstreaming.readableStreamAsyncIterable = streaming._decodeChunks = streaming._iterSSEMessages = streaming.Stream = void 0;\n  \tconst index_1 = _shims;\n  \tconst error_1 = requireError();\n  \tconst error_2 = requireError();\n  \tclass Stream {\n  \t    constructor(iterator, controller) {\n  \t        this.iterator = iterator;\n  \t        this.controller = controller;\n  \t    }\n  \t    static fromSSEResponse(response, controller) {\n  \t        let consumed = false;\n  \t        async function* iterator() {\n  \t            if (consumed) {\n  \t                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n  \t            }\n  \t            consumed = true;\n  \t            let done = false;\n  \t            try {\n  \t                for await (const sse of _iterSSEMessages(response, controller)) {\n  \t                    if (done)\n  \t                        continue;\n  \t                    if (sse.data.startsWith('[DONE]')) {\n  \t                        done = true;\n  \t                        continue;\n  \t                    }\n  \t                    if (sse.event === null) {\n  \t                        let data;\n  \t                        try {\n  \t                            data = JSON.parse(sse.data);\n  \t                        }\n  \t                        catch (e) {\n  \t                            console.error(`Could not parse message into JSON:`, sse.data);\n  \t                            console.error(`From chunk:`, sse.raw);\n  \t                            throw e;\n  \t                        }\n  \t                        if (data && data.error) {\n  \t                            throw new error_2.APIError(undefined, data.error, undefined, undefined);\n  \t                        }\n  \t                        yield data;\n  \t                    }\n  \t                    else {\n  \t                        let data;\n  \t                        try {\n  \t                            data = JSON.parse(sse.data);\n  \t                        }\n  \t                        catch (e) {\n  \t                            console.error(`Could not parse message into JSON:`, sse.data);\n  \t                            console.error(`From chunk:`, sse.raw);\n  \t                            throw e;\n  \t                        }\n  \t                        // TODO: Is this where the error should be thrown?\n  \t                        if (sse.event == 'error') {\n  \t                            throw new error_2.APIError(undefined, data.error, data.message, undefined);\n  \t                        }\n  \t                        yield { event: sse.event, data: data };\n  \t                    }\n  \t                }\n  \t                done = true;\n  \t            }\n  \t            catch (e) {\n  \t                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n  \t                if (e instanceof Error && e.name === 'AbortError')\n  \t                    return;\n  \t                throw e;\n  \t            }\n  \t            finally {\n  \t                // If the user `break`s, abort the ongoing request.\n  \t                if (!done)\n  \t                    controller.abort();\n  \t            }\n  \t        }\n  \t        return new Stream(iterator, controller);\n  \t    }\n  \t    /**\n  \t     * Generates a Stream from a newline-separated ReadableStream\n  \t     * where each item is a JSON value.\n  \t     */\n  \t    static fromReadableStream(readableStream, controller) {\n  \t        let consumed = false;\n  \t        async function* iterLines() {\n  \t            const lineDecoder = new LineDecoder();\n  \t            const iter = readableStreamAsyncIterable(readableStream);\n  \t            for await (const chunk of iter) {\n  \t                for (const line of lineDecoder.decode(chunk)) {\n  \t                    yield line;\n  \t                }\n  \t            }\n  \t            for (const line of lineDecoder.flush()) {\n  \t                yield line;\n  \t            }\n  \t        }\n  \t        async function* iterator() {\n  \t            if (consumed) {\n  \t                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n  \t            }\n  \t            consumed = true;\n  \t            let done = false;\n  \t            try {\n  \t                for await (const line of iterLines()) {\n  \t                    if (done)\n  \t                        continue;\n  \t                    if (line)\n  \t                        yield JSON.parse(line);\n  \t                }\n  \t                done = true;\n  \t            }\n  \t            catch (e) {\n  \t                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n  \t                if (e instanceof Error && e.name === 'AbortError')\n  \t                    return;\n  \t                throw e;\n  \t            }\n  \t            finally {\n  \t                // If the user `break`s, abort the ongoing request.\n  \t                if (!done)\n  \t                    controller.abort();\n  \t            }\n  \t        }\n  \t        return new Stream(iterator, controller);\n  \t    }\n  \t    [Symbol.asyncIterator]() {\n  \t        return this.iterator();\n  \t    }\n  \t    /**\n  \t     * Splits the stream into two streams which can be\n  \t     * independently read from at different speeds.\n  \t     */\n  \t    tee() {\n  \t        const left = [];\n  \t        const right = [];\n  \t        const iterator = this.iterator();\n  \t        const teeIterator = (queue) => {\n  \t            return {\n  \t                next: () => {\n  \t                    if (queue.length === 0) {\n  \t                        const result = iterator.next();\n  \t                        left.push(result);\n  \t                        right.push(result);\n  \t                    }\n  \t                    return queue.shift();\n  \t                },\n  \t            };\n  \t        };\n  \t        return [\n  \t            new Stream(() => teeIterator(left), this.controller),\n  \t            new Stream(() => teeIterator(right), this.controller),\n  \t        ];\n  \t    }\n  \t    /**\n  \t     * Converts this stream to a newline-separated ReadableStream of\n  \t     * JSON stringified values in the stream\n  \t     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n  \t     */\n  \t    toReadableStream() {\n  \t        const self = this;\n  \t        let iter;\n  \t        const encoder = new TextEncoder();\n  \t        return new index_1.ReadableStream({\n  \t            async start() {\n  \t                iter = self[Symbol.asyncIterator]();\n  \t            },\n  \t            async pull(ctrl) {\n  \t                try {\n  \t                    const { value, done } = await iter.next();\n  \t                    if (done)\n  \t                        return ctrl.close();\n  \t                    const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n  \t                    ctrl.enqueue(bytes);\n  \t                }\n  \t                catch (err) {\n  \t                    ctrl.error(err);\n  \t                }\n  \t            },\n  \t            async cancel() {\n  \t                await iter.return?.();\n  \t            },\n  \t        });\n  \t    }\n  \t}\n  \tstreaming.Stream = Stream;\n  \tasync function* _iterSSEMessages(response, controller) {\n  \t    if (!response.body) {\n  \t        controller.abort();\n  \t        throw new error_1.OpenAIError(`Attempted to iterate over a response with no body`);\n  \t    }\n  \t    const sseDecoder = new SSEDecoder();\n  \t    const lineDecoder = new LineDecoder();\n  \t    const iter = readableStreamAsyncIterable(response.body);\n  \t    for await (const sseChunk of iterSSEChunks(iter)) {\n  \t        for (const line of lineDecoder.decode(sseChunk)) {\n  \t            const sse = sseDecoder.decode(line);\n  \t            if (sse)\n  \t                yield sse;\n  \t        }\n  \t    }\n  \t    for (const line of lineDecoder.flush()) {\n  \t        const sse = sseDecoder.decode(line);\n  \t        if (sse)\n  \t            yield sse;\n  \t    }\n  \t}\n  \tstreaming._iterSSEMessages = _iterSSEMessages;\n  \t/**\n  \t * Given an async iterable iterator, iterates over it and yields full\n  \t * SSE chunks, i.e. yields when a double new-line is encountered.\n  \t */\n  \tasync function* iterSSEChunks(iterator) {\n  \t    let data = new Uint8Array();\n  \t    for await (const chunk of iterator) {\n  \t        if (chunk == null) {\n  \t            continue;\n  \t        }\n  \t        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n  \t            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n  \t                : chunk;\n  \t        let newData = new Uint8Array(data.length + binaryChunk.length);\n  \t        newData.set(data);\n  \t        newData.set(binaryChunk, data.length);\n  \t        data = newData;\n  \t        let patternIndex;\n  \t        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n  \t            yield data.slice(0, patternIndex);\n  \t            data = data.slice(patternIndex);\n  \t        }\n  \t    }\n  \t    if (data.length > 0) {\n  \t        yield data;\n  \t    }\n  \t}\n  \tfunction findDoubleNewlineIndex(buffer) {\n  \t    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  \t    // and returns the index right after the first occurrence of any pattern,\n  \t    // or -1 if none of the patterns are found.\n  \t    const newline = 0x0a; // \\n\n  \t    const carriage = 0x0d; // \\r\n  \t    for (let i = 0; i < buffer.length - 2; i++) {\n  \t        if (buffer[i] === newline && buffer[i + 1] === newline) {\n  \t            // \\n\\n\n  \t            return i + 2;\n  \t        }\n  \t        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n  \t            // \\r\\r\n  \t            return i + 2;\n  \t        }\n  \t        if (buffer[i] === carriage &&\n  \t            buffer[i + 1] === newline &&\n  \t            i + 3 < buffer.length &&\n  \t            buffer[i + 2] === carriage &&\n  \t            buffer[i + 3] === newline) {\n  \t            // \\r\\n\\r\\n\n  \t            return i + 4;\n  \t        }\n  \t    }\n  \t    return -1;\n  \t}\n  \tclass SSEDecoder {\n  \t    constructor() {\n  \t        this.event = null;\n  \t        this.data = [];\n  \t        this.chunks = [];\n  \t    }\n  \t    decode(line) {\n  \t        if (line.endsWith('\\r')) {\n  \t            line = line.substring(0, line.length - 1);\n  \t        }\n  \t        if (!line) {\n  \t            // empty line and we didn't previously encounter any messages\n  \t            if (!this.event && !this.data.length)\n  \t                return null;\n  \t            const sse = {\n  \t                event: this.event,\n  \t                data: this.data.join('\\n'),\n  \t                raw: this.chunks,\n  \t            };\n  \t            this.event = null;\n  \t            this.data = [];\n  \t            this.chunks = [];\n  \t            return sse;\n  \t        }\n  \t        this.chunks.push(line);\n  \t        if (line.startsWith(':')) {\n  \t            return null;\n  \t        }\n  \t        let [fieldname, _, value] = partition(line, ':');\n  \t        if (value.startsWith(' ')) {\n  \t            value = value.substring(1);\n  \t        }\n  \t        if (fieldname === 'event') {\n  \t            this.event = value;\n  \t        }\n  \t        else if (fieldname === 'data') {\n  \t            this.data.push(value);\n  \t        }\n  \t        return null;\n  \t    }\n  \t}\n  \t/**\n  \t * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n  \t * reading lines from text.\n  \t *\n  \t * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n  \t */\n  \tclass LineDecoder {\n  \t    constructor() {\n  \t        this.buffer = [];\n  \t        this.trailingCR = false;\n  \t    }\n  \t    decode(chunk) {\n  \t        let text = this.decodeText(chunk);\n  \t        if (this.trailingCR) {\n  \t            text = '\\r' + text;\n  \t            this.trailingCR = false;\n  \t        }\n  \t        if (text.endsWith('\\r')) {\n  \t            this.trailingCR = true;\n  \t            text = text.slice(0, -1);\n  \t        }\n  \t        if (!text) {\n  \t            return [];\n  \t        }\n  \t        const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n  \t        let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n  \t        // if there is a trailing new line then the last entry will be an empty\n  \t        // string which we don't care about\n  \t        if (trailingNewline) {\n  \t            lines.pop();\n  \t        }\n  \t        if (lines.length === 1 && !trailingNewline) {\n  \t            this.buffer.push(lines[0]);\n  \t            return [];\n  \t        }\n  \t        if (this.buffer.length > 0) {\n  \t            lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n  \t            this.buffer = [];\n  \t        }\n  \t        if (!trailingNewline) {\n  \t            this.buffer = [lines.pop() || ''];\n  \t        }\n  \t        return lines;\n  \t    }\n  \t    decodeText(bytes) {\n  \t        if (bytes == null)\n  \t            return '';\n  \t        if (typeof bytes === 'string')\n  \t            return bytes;\n  \t        // Node:\n  \t        if (typeof Buffer !== 'undefined') {\n  \t            if (bytes instanceof Buffer) {\n  \t                return bytes.toString();\n  \t            }\n  \t            if (bytes instanceof Uint8Array) {\n  \t                return Buffer.from(bytes).toString();\n  \t            }\n  \t            throw new error_1.OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n  \t        }\n  \t        // Browser\n  \t        if (typeof TextDecoder !== 'undefined') {\n  \t            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n  \t                this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n  \t                return this.textDecoder.decode(bytes);\n  \t            }\n  \t            throw new error_1.OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n  \t        }\n  \t        throw new error_1.OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n  \t    }\n  \t    flush() {\n  \t        if (!this.buffer.length && !this.trailingCR) {\n  \t            return [];\n  \t        }\n  \t        const lines = [this.buffer.join('')];\n  \t        this.buffer = [];\n  \t        this.trailingCR = false;\n  \t        return lines;\n  \t    }\n  \t}\n  \t// prettier-ignore\n  \tLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\n  \tLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n  \t/** This is an internal helper function that's just used for testing */\n  \tfunction _decodeChunks(chunks) {\n  \t    const decoder = new LineDecoder();\n  \t    const lines = [];\n  \t    for (const chunk of chunks) {\n  \t        lines.push(...decoder.decode(chunk));\n  \t    }\n  \t    return lines;\n  \t}\n  \tstreaming._decodeChunks = _decodeChunks;\n  \tfunction partition(str, delimiter) {\n  \t    const index = str.indexOf(delimiter);\n  \t    if (index !== -1) {\n  \t        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  \t    }\n  \t    return [str, '', ''];\n  \t}\n  \t/**\n  \t * Most browsers don't yet have async iterable support for ReadableStream,\n  \t * and Node has a very different way of reading bytes from its \"ReadableStream\".\n  \t *\n  \t * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n  \t */\n  \tfunction readableStreamAsyncIterable(stream) {\n  \t    if (stream[Symbol.asyncIterator])\n  \t        return stream;\n  \t    const reader = stream.getReader();\n  \t    return {\n  \t        async next() {\n  \t            try {\n  \t                const result = await reader.read();\n  \t                if (result?.done)\n  \t                    reader.releaseLock(); // release lock when stream becomes closed\n  \t                return result;\n  \t            }\n  \t            catch (e) {\n  \t                reader.releaseLock(); // release lock when stream becomes errored\n  \t                throw e;\n  \t            }\n  \t        },\n  \t        async return() {\n  \t            const cancelPromise = reader.cancel();\n  \t            reader.releaseLock();\n  \t            await cancelPromise;\n  \t            return { done: true, value: undefined };\n  \t        },\n  \t        [Symbol.asyncIterator]() {\n  \t            return this;\n  \t        },\n  \t    };\n  \t}\n  \tstreaming.readableStreamAsyncIterable = readableStreamAsyncIterable;\n  \t\n  \treturn streaming;\n  }\n\n  var uploads$1 = {};\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = exports.isMultipartBody = exports.toFile = exports.isUploadable = exports.isBlobLike = exports.isFileLike = exports.isResponseLike = exports.fileFromPath = void 0;\n  \tconst index_1 = _shims;\n  \tvar index_2 = _shims;\n  \tObject.defineProperty(exports, \"fileFromPath\", { enumerable: true, get: function () { return index_2.fileFromPath; } });\n  \tconst isResponseLike = (value) => value != null &&\n  \t    typeof value === 'object' &&\n  \t    typeof value.url === 'string' &&\n  \t    typeof value.blob === 'function';\n  \texports.isResponseLike = isResponseLike;\n  \tconst isFileLike = (value) => value != null &&\n  \t    typeof value === 'object' &&\n  \t    typeof value.name === 'string' &&\n  \t    typeof value.lastModified === 'number' &&\n  \t    (0, exports.isBlobLike)(value);\n  \texports.isFileLike = isFileLike;\n  \t/**\n  \t * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n  \t * adds the arrayBuffer() method type because it is available and used at runtime\n  \t */\n  \tconst isBlobLike = (value) => value != null &&\n  \t    typeof value === 'object' &&\n  \t    typeof value.size === 'number' &&\n  \t    typeof value.type === 'string' &&\n  \t    typeof value.text === 'function' &&\n  \t    typeof value.slice === 'function' &&\n  \t    typeof value.arrayBuffer === 'function';\n  \texports.isBlobLike = isBlobLike;\n  \tconst isUploadable = (value) => {\n  \t    return (0, exports.isFileLike)(value) || (0, exports.isResponseLike)(value) || (0, index_1.isFsReadStream)(value);\n  \t};\n  \texports.isUploadable = isUploadable;\n  \t/**\n  \t * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n  \t * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n  \t * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n  \t * @param {Object=} options additional properties\n  \t * @param {string=} options.type the MIME type of the content\n  \t * @param {number=} options.lastModified the last modified timestamp\n  \t * @returns a {@link File} with the given properties\n  \t */\n  \tasync function toFile(value, name, options) {\n  \t    // If it's a promise, resolve it.\n  \t    value = await value;\n  \t    // If we've been given a `File` we don't need to do anything\n  \t    if ((0, exports.isFileLike)(value)) {\n  \t        return value;\n  \t    }\n  \t    if ((0, exports.isResponseLike)(value)) {\n  \t        const blob = await value.blob();\n  \t        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n  \t        // we need to convert the `Blob` into an array buffer because the `Blob` class\n  \t        // that `node-fetch` defines is incompatible with the web standard which results\n  \t        // in `new File` interpreting it as a string instead of binary data.\n  \t        const data = (0, exports.isBlobLike)(blob) ? [(await blob.arrayBuffer())] : [blob];\n  \t        return new index_1.File(data, name, options);\n  \t    }\n  \t    const bits = await getBytes(value);\n  \t    name || (name = getName(value) ?? 'unknown_file');\n  \t    if (!options?.type) {\n  \t        const type = bits[0]?.type;\n  \t        if (typeof type === 'string') {\n  \t            options = { ...options, type };\n  \t        }\n  \t    }\n  \t    return new index_1.File(bits, name, options);\n  \t}\n  \texports.toFile = toFile;\n  \tasync function getBytes(value) {\n  \t    let parts = [];\n  \t    if (typeof value === 'string' ||\n  \t        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n  \t        value instanceof ArrayBuffer) {\n  \t        parts.push(value);\n  \t    }\n  \t    else if ((0, exports.isBlobLike)(value)) {\n  \t        parts.push(await value.arrayBuffer());\n  \t    }\n  \t    else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  \t    ) {\n  \t        for await (const chunk of value) {\n  \t            parts.push(chunk); // TODO, consider validating?\n  \t        }\n  \t    }\n  \t    else {\n  \t        throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n\t            ?.name}; props: ${propsForError(value)}`);\n  \t    }\n  \t    return parts;\n  \t}\n  \tfunction propsForError(value) {\n  \t    const props = Object.getOwnPropertyNames(value);\n  \t    return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n  \t}\n  \tfunction getName(value) {\n  \t    return (getStringFromMaybeBuffer(value.name) ||\n  \t        getStringFromMaybeBuffer(value.filename) ||\n  \t        // For fs.ReadStream\n  \t        getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop());\n  \t}\n  \tconst getStringFromMaybeBuffer = (x) => {\n  \t    if (typeof x === 'string')\n  \t        return x;\n  \t    if (typeof Buffer !== 'undefined' && x instanceof Buffer)\n  \t        return String(x);\n  \t    return undefined;\n  \t};\n  \tconst isAsyncIterableIterator = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n  \tconst isMultipartBody = (body) => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n  \texports.isMultipartBody = isMultipartBody;\n  \t/**\n  \t * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n  \t * Otherwise returns the request as is.\n  \t */\n  \tconst maybeMultipartFormRequestOptions = async (opts) => {\n  \t    if (!hasUploadableValue(opts.body))\n  \t        return opts;\n  \t    const form = await (0, exports.createForm)(opts.body);\n  \t    return (0, index_1.getMultipartRequestOptions)(form, opts);\n  \t};\n  \texports.maybeMultipartFormRequestOptions = maybeMultipartFormRequestOptions;\n  \tconst multipartFormRequestOptions = async (opts) => {\n  \t    const form = await (0, exports.createForm)(opts.body);\n  \t    return (0, index_1.getMultipartRequestOptions)(form, opts);\n  \t};\n  \texports.multipartFormRequestOptions = multipartFormRequestOptions;\n  \tconst createForm = async (body) => {\n  \t    const form = new index_1.FormData();\n  \t    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  \t    return form;\n  \t};\n  \texports.createForm = createForm;\n  \tconst hasUploadableValue = (value) => {\n  \t    if ((0, exports.isUploadable)(value))\n  \t        return true;\n  \t    if (Array.isArray(value))\n  \t        return value.some(hasUploadableValue);\n  \t    if (value && typeof value === 'object') {\n  \t        for (const k in value) {\n  \t            if (hasUploadableValue(value[k]))\n  \t                return true;\n  \t        }\n  \t    }\n  \t    return false;\n  \t};\n  \tconst addFormValue = async (form, key, value) => {\n  \t    if (value === undefined)\n  \t        return;\n  \t    if (value == null) {\n  \t        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n  \t    }\n  \t    // TODO: make nested formats configurable\n  \t    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n  \t        form.append(key, String(value));\n  \t    }\n  \t    else if ((0, exports.isUploadable)(value)) {\n  \t        const file = await toFile(value);\n  \t        form.append(key, file);\n  \t    }\n  \t    else if (Array.isArray(value)) {\n  \t        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n  \t    }\n  \t    else if (typeof value === 'object') {\n  \t        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n  \t    }\n  \t    else {\n  \t        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n  \t    }\n  \t};\n  \t\n  } (uploads$1));\n\n  var hasRequiredCore;\n\n  function requireCore () {\n  \tif (hasRequiredCore) return core;\n  \thasRequiredCore = 1;\n  \t(function (exports) {\n  \t\tvar __classPrivateFieldSet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n  \t\t    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  \t\t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  \t\t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  \t\t    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  \t\t};\n  \t\tvar __classPrivateFieldGet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n  \t\t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  \t\t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  \t\t    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  \t\t};\n  \t\tvar _AbstractPage_client;\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.isObj = exports.toBase64 = exports.getHeader = exports.getRequiredHeader = exports.isHeadersProtocol = exports.isRunningInBrowser = exports.debug = exports.hasOwn = exports.isEmptyObj = exports.maybeCoerceBoolean = exports.maybeCoerceFloat = exports.maybeCoerceInteger = exports.coerceBoolean = exports.coerceFloat = exports.coerceInteger = exports.readEnv = exports.ensurePresent = exports.castToError = exports.sleep = exports.safeJSON = exports.isRequestOptions = exports.createResponseHeaders = exports.PagePromise = exports.AbstractPage = exports.APIClient = exports.APIPromise = exports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = void 0;\n  \t\tconst version_1 = version;\n  \t\tconst streaming_1 = requireStreaming();\n  \t\tconst error_1 = requireError();\n  \t\tconst index_1 = _shims;\n  \t\tconst uploads_1 = uploads$1;\n  \t\tvar uploads_2 = uploads$1;\n  \t\tObject.defineProperty(exports, \"maybeMultipartFormRequestOptions\", { enumerable: true, get: function () { return uploads_2.maybeMultipartFormRequestOptions; } });\n  \t\tObject.defineProperty(exports, \"multipartFormRequestOptions\", { enumerable: true, get: function () { return uploads_2.multipartFormRequestOptions; } });\n  \t\tObject.defineProperty(exports, \"createForm\", { enumerable: true, get: function () { return uploads_2.createForm; } });\n  \t\tasync function defaultParseResponse(props) {\n  \t\t    const { response } = props;\n  \t\t    if (props.options.stream) {\n  \t\t        debug('response', response.status, response.url, response.headers, response.body);\n  \t\t        // Note: there is an invariant here that isn't represented in the type system\n  \t\t        // that if you set `stream: true` the response type must also be `Stream<T>`\n  \t\t        if (props.options.__streamClass) {\n  \t\t            return props.options.__streamClass.fromSSEResponse(response, props.controller);\n  \t\t        }\n  \t\t        return streaming_1.Stream.fromSSEResponse(response, props.controller);\n  \t\t    }\n  \t\t    // fetch refuses to read the body when the status code is 204.\n  \t\t    if (response.status === 204) {\n  \t\t        return null;\n  \t\t    }\n  \t\t    if (props.options.__binaryResponse) {\n  \t\t        return response;\n  \t\t    }\n  \t\t    const contentType = response.headers.get('content-type');\n  \t\t    const isJSON = contentType?.includes('application/json') || contentType?.includes('application/vnd.api+json');\n  \t\t    if (isJSON) {\n  \t\t        const json = await response.json();\n  \t\t        debug('response', response.status, response.url, response.headers, json);\n  \t\t        return _addRequestID(json, response);\n  \t\t    }\n  \t\t    const text = await response.text();\n  \t\t    debug('response', response.status, response.url, response.headers, text);\n  \t\t    // TODO handle blob, arraybuffer, other content types, etc.\n  \t\t    return text;\n  \t\t}\n  \t\tfunction _addRequestID(value, response) {\n  \t\t    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n  \t\t        return value;\n  \t\t    }\n  \t\t    return Object.defineProperty(value, '_request_id', {\n  \t\t        value: response.headers.get('x-request-id'),\n  \t\t        enumerable: false,\n  \t\t    });\n  \t\t}\n  \t\t/**\n  \t\t * A subclass of `Promise` providing additional helper methods\n  \t\t * for interacting with the SDK.\n  \t\t */\n  \t\tclass APIPromise extends Promise {\n  \t\t    constructor(responsePromise, parseResponse = defaultParseResponse) {\n  \t\t        super((resolve) => {\n  \t\t            // this is maybe a bit weird but this has to be a no-op to not implicitly\n  \t\t            // parse the response body; instead .then, .catch, .finally are overridden\n  \t\t            // to parse the response\n  \t\t            resolve(null);\n  \t\t        });\n  \t\t        this.responsePromise = responsePromise;\n  \t\t        this.parseResponse = parseResponse;\n  \t\t    }\n  \t\t    _thenUnwrap(transform) {\n  \t\t        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props)), props.response));\n  \t\t    }\n  \t\t    /**\n  \t\t     * Gets the raw `Response` instance instead of parsing the response\n  \t\t     * data.\n  \t\t     *\n  \t\t     * If you want to parse the response body but still get the `Response`\n  \t\t     * instance, you can use {@link withResponse()}.\n  \t\t     *\n  \t\t     *  Getting the wrong TypeScript type for `Response`?\n  \t\t     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n  \t\t     * or add one of these imports before your first `import  from 'openai'`:\n  \t\t     * - `import 'openai/shims/node'` (if you're running on Node)\n  \t\t     * - `import 'openai/shims/web'` (otherwise)\n  \t\t     */\n  \t\t    asResponse() {\n  \t\t        return this.responsePromise.then((p) => p.response);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Gets the parsed response data and the raw `Response` instance.\n  \t\t     *\n  \t\t     * If you just want to get the raw `Response` instance without parsing it,\n  \t\t     * you can use {@link asResponse()}.\n  \t\t     *\n  \t\t     *\n  \t\t     *  Getting the wrong TypeScript type for `Response`?\n  \t\t     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n  \t\t     * or add one of these imports before your first `import  from 'openai'`:\n  \t\t     * - `import 'openai/shims/node'` (if you're running on Node)\n  \t\t     * - `import 'openai/shims/web'` (otherwise)\n  \t\t     */\n  \t\t    async withResponse() {\n  \t\t        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n  \t\t        return { data, response };\n  \t\t    }\n  \t\t    parse() {\n  \t\t        if (!this.parsedPromise) {\n  \t\t            this.parsedPromise = this.responsePromise.then(this.parseResponse);\n  \t\t        }\n  \t\t        return this.parsedPromise;\n  \t\t    }\n  \t\t    then(onfulfilled, onrejected) {\n  \t\t        return this.parse().then(onfulfilled, onrejected);\n  \t\t    }\n  \t\t    catch(onrejected) {\n  \t\t        return this.parse().catch(onrejected);\n  \t\t    }\n  \t\t    finally(onfinally) {\n  \t\t        return this.parse().finally(onfinally);\n  \t\t    }\n  \t\t}\n  \t\texports.APIPromise = APIPromise;\n  \t\tclass APIClient {\n  \t\t    constructor({ baseURL, maxRetries = 2, timeout = 600000, // 10 minutes\n  \t\t    httpAgent, fetch: overridenFetch, }) {\n  \t\t        this.baseURL = baseURL;\n  \t\t        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n  \t\t        this.timeout = validatePositiveInteger('timeout', timeout);\n  \t\t        this.httpAgent = httpAgent;\n  \t\t        this.fetch = overridenFetch ?? index_1.fetch;\n  \t\t    }\n  \t\t    authHeaders(opts) {\n  \t\t        return {};\n  \t\t    }\n  \t\t    /**\n  \t\t     * Override this to add your own default headers, for example:\n  \t\t     *\n  \t\t     *  {\n  \t\t     *    ...super.defaultHeaders(),\n  \t\t     *    Authorization: 'Bearer 123',\n  \t\t     *  }\n  \t\t     */\n  \t\t    defaultHeaders(opts) {\n  \t\t        return {\n  \t\t            Accept: 'application/json',\n  \t\t            'Content-Type': 'application/json',\n  \t\t            'User-Agent': this.getUserAgent(),\n  \t\t            ...getPlatformHeaders(),\n  \t\t            ...this.authHeaders(opts),\n  \t\t        };\n  \t\t    }\n  \t\t    /**\n  \t\t     * Override this to add your own headers validation:\n  \t\t     */\n  \t\t    validateHeaders(headers, customHeaders) { }\n  \t\t    defaultIdempotencyKey() {\n  \t\t        return `stainless-node-retry-${uuid4()}`;\n  \t\t    }\n  \t\t    get(path, opts) {\n  \t\t        return this.methodRequest('get', path, opts);\n  \t\t    }\n  \t\t    post(path, opts) {\n  \t\t        return this.methodRequest('post', path, opts);\n  \t\t    }\n  \t\t    patch(path, opts) {\n  \t\t        return this.methodRequest('patch', path, opts);\n  \t\t    }\n  \t\t    put(path, opts) {\n  \t\t        return this.methodRequest('put', path, opts);\n  \t\t    }\n  \t\t    delete(path, opts) {\n  \t\t        return this.methodRequest('delete', path, opts);\n  \t\t    }\n  \t\t    methodRequest(method, path, opts) {\n  \t\t        return this.request(Promise.resolve(opts).then(async (opts) => {\n  \t\t            const body = opts && (0, uploads_1.isBlobLike)(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n  \t\t                : opts?.body instanceof DataView ? opts.body\n  \t\t                    : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n  \t\t                        : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n  \t\t                            : opts?.body;\n  \t\t            return { method, path, ...opts, body };\n  \t\t        }));\n  \t\t    }\n  \t\t    getAPIList(path, Page, opts) {\n  \t\t        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n  \t\t    }\n  \t\t    calculateContentLength(body) {\n  \t\t        if (typeof body === 'string') {\n  \t\t            if (typeof Buffer !== 'undefined') {\n  \t\t                return Buffer.byteLength(body, 'utf8').toString();\n  \t\t            }\n  \t\t            if (typeof TextEncoder !== 'undefined') {\n  \t\t                const encoder = new TextEncoder();\n  \t\t                const encoded = encoder.encode(body);\n  \t\t                return encoded.length.toString();\n  \t\t            }\n  \t\t        }\n  \t\t        else if (ArrayBuffer.isView(body)) {\n  \t\t            return body.byteLength.toString();\n  \t\t        }\n  \t\t        return null;\n  \t\t    }\n  \t\t    buildRequest(options, { retryCount = 0 } = {}) {\n  \t\t        const { method, path, query, headers: headers = {} } = options;\n  \t\t        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n  \t\t            options.body\n  \t\t            : (0, uploads_1.isMultipartBody)(options.body) ? options.body.body\n  \t\t                : options.body ? JSON.stringify(options.body, null, 2)\n  \t\t                    : null;\n  \t\t        const contentLength = this.calculateContentLength(body);\n  \t\t        const url = this.buildURL(path, query);\n  \t\t        if ('timeout' in options)\n  \t\t            validatePositiveInteger('timeout', options.timeout);\n  \t\t        const timeout = options.timeout ?? this.timeout;\n  \t\t        const httpAgent = options.httpAgent ?? this.httpAgent ?? (0, index_1.getDefaultAgent)(url);\n  \t\t        const minAgentTimeout = timeout + 1000;\n  \t\t        if (typeof httpAgent?.options?.timeout === 'number' &&\n  \t\t            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n  \t\t            // Allow any given request to bump our agent active socket timeout.\n  \t\t            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n  \t\t            // and without mutating agent we would need to create more of them.\n  \t\t            // This tradeoff optimizes for performance.\n  \t\t            httpAgent.options.timeout = minAgentTimeout;\n  \t\t        }\n  \t\t        if (this.idempotencyHeader && method !== 'get') {\n  \t\t            if (!options.idempotencyKey)\n  \t\t                options.idempotencyKey = this.defaultIdempotencyKey();\n  \t\t            headers[this.idempotencyHeader] = options.idempotencyKey;\n  \t\t        }\n  \t\t        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n  \t\t        const req = {\n  \t\t            method,\n  \t\t            ...(body && { body: body }),\n  \t\t            headers: reqHeaders,\n  \t\t            ...(httpAgent && { agent: httpAgent }),\n  \t\t            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n  \t\t            // not compatible with standard web types\n  \t\t            signal: options.signal ?? null,\n  \t\t        };\n  \t\t        return { req, url, timeout };\n  \t\t    }\n  \t\t    buildHeaders({ options, headers, contentLength, retryCount, }) {\n  \t\t        const reqHeaders = {};\n  \t\t        if (contentLength) {\n  \t\t            reqHeaders['content-length'] = contentLength;\n  \t\t        }\n  \t\t        const defaultHeaders = this.defaultHeaders(options);\n  \t\t        applyHeadersMut(reqHeaders, defaultHeaders);\n  \t\t        applyHeadersMut(reqHeaders, headers);\n  \t\t        // let builtin fetch set the Content-Type for multipart bodies\n  \t\t        if ((0, uploads_1.isMultipartBody)(options.body) && index_1.kind !== 'node') {\n  \t\t            delete reqHeaders['content-type'];\n  \t\t        }\n  \t\t        // Don't set the retry count header if it was already set or removed by the caller. We check `headers`,\n  \t\t        // which can contain nulls, instead of `reqHeaders` to account for the removal case.\n  \t\t        if ((0, exports.getHeader)(headers, 'x-stainless-retry-count') === undefined) {\n  \t\t            reqHeaders['x-stainless-retry-count'] = String(retryCount);\n  \t\t        }\n  \t\t        this.validateHeaders(reqHeaders, headers);\n  \t\t        return reqHeaders;\n  \t\t    }\n  \t\t    /**\n  \t\t     * Used as a callback for mutating the given `FinalRequestOptions` object.\n  \t\t     */\n  \t\t    async prepareOptions(options) { }\n  \t\t    /**\n  \t\t     * Used as a callback for mutating the given `RequestInit` object.\n  \t\t     *\n  \t\t     * This is useful for cases where you want to add certain headers based off of\n  \t\t     * the request properties, e.g. `method` or `url`.\n  \t\t     */\n  \t\t    async prepareRequest(request, { url, options }) { }\n  \t\t    parseHeaders(headers) {\n  \t\t        return (!headers ? {}\n  \t\t            : Symbol.iterator in headers ?\n  \t\t                Object.fromEntries(Array.from(headers).map((header) => [...header]))\n  \t\t                : { ...headers });\n  \t\t    }\n  \t\t    makeStatusError(status, error, message, headers) {\n  \t\t        return error_1.APIError.generate(status, error, message, headers);\n  \t\t    }\n  \t\t    request(options, remainingRetries = null) {\n  \t\t        return new APIPromise(this.makeRequest(options, remainingRetries));\n  \t\t    }\n  \t\t    async makeRequest(optionsInput, retriesRemaining) {\n  \t\t        const options = await optionsInput;\n  \t\t        const maxRetries = options.maxRetries ?? this.maxRetries;\n  \t\t        if (retriesRemaining == null) {\n  \t\t            retriesRemaining = maxRetries;\n  \t\t        }\n  \t\t        await this.prepareOptions(options);\n  \t\t        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n  \t\t        await this.prepareRequest(req, { url, options });\n  \t\t        debug('request', url, options, req.headers);\n  \t\t        if (options.signal?.aborted) {\n  \t\t            throw new error_1.APIUserAbortError();\n  \t\t        }\n  \t\t        const controller = new AbortController();\n  \t\t        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(exports.castToError);\n  \t\t        if (response instanceof Error) {\n  \t\t            if (options.signal?.aborted) {\n  \t\t                throw new error_1.APIUserAbortError();\n  \t\t            }\n  \t\t            if (retriesRemaining) {\n  \t\t                return this.retryRequest(options, retriesRemaining);\n  \t\t            }\n  \t\t            if (response.name === 'AbortError') {\n  \t\t                throw new error_1.APIConnectionTimeoutError();\n  \t\t            }\n  \t\t            throw new error_1.APIConnectionError({ cause: response });\n  \t\t        }\n  \t\t        const responseHeaders = (0, exports.createResponseHeaders)(response.headers);\n  \t\t        if (!response.ok) {\n  \t\t            if (retriesRemaining && this.shouldRetry(response)) {\n  \t\t                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n  \t\t                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n  \t\t                return this.retryRequest(options, retriesRemaining, responseHeaders);\n  \t\t            }\n  \t\t            const errText = await response.text().catch((e) => (0, exports.castToError)(e).message);\n  \t\t            const errJSON = (0, exports.safeJSON)(errText);\n  \t\t            const errMessage = errJSON ? undefined : errText;\n  \t\t            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n  \t\t            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n  \t\t            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n  \t\t            throw err;\n  \t\t        }\n  \t\t        return { response, options, controller };\n  \t\t    }\n  \t\t    requestAPIList(Page, options) {\n  \t\t        const request = this.makeRequest(options, null);\n  \t\t        return new PagePromise(this, request, Page);\n  \t\t    }\n  \t\t    buildURL(path, query) {\n  \t\t        const url = isAbsoluteURL(path) ?\n  \t\t            new URL(path)\n  \t\t            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n  \t\t        const defaultQuery = this.defaultQuery();\n  \t\t        if (!isEmptyObj(defaultQuery)) {\n  \t\t            query = { ...defaultQuery, ...query };\n  \t\t        }\n  \t\t        if (typeof query === 'object' && query && !Array.isArray(query)) {\n  \t\t            url.search = this.stringifyQuery(query);\n  \t\t        }\n  \t\t        return url.toString();\n  \t\t    }\n  \t\t    stringifyQuery(query) {\n  \t\t        return Object.entries(query)\n  \t\t            .filter(([_, value]) => typeof value !== 'undefined')\n  \t\t            .map(([key, value]) => {\n  \t\t            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n  \t\t                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n  \t\t            }\n  \t\t            if (value === null) {\n  \t\t                return `${encodeURIComponent(key)}=`;\n  \t\t            }\n  \t\t            throw new error_1.OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n  \t\t        })\n  \t\t            .join('&');\n  \t\t    }\n  \t\t    async fetchWithTimeout(url, init, ms, controller) {\n  \t\t        const { signal, ...options } = init || {};\n  \t\t        if (signal)\n  \t\t            signal.addEventListener('abort', () => controller.abort());\n  \t\t        const timeout = setTimeout(() => controller.abort(), ms);\n  \t\t        return (this.getRequestClient()\n  \t\t            // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n  \t\t            .fetch.call(undefined, url, { signal: controller.signal, ...options })\n  \t\t            .finally(() => {\n  \t\t            clearTimeout(timeout);\n  \t\t        }));\n  \t\t    }\n  \t\t    getRequestClient() {\n  \t\t        return { fetch: this.fetch };\n  \t\t    }\n  \t\t    shouldRetry(response) {\n  \t\t        // Note this is not a standard header.\n  \t\t        const shouldRetryHeader = response.headers.get('x-should-retry');\n  \t\t        // If the server explicitly says whether or not to retry, obey.\n  \t\t        if (shouldRetryHeader === 'true')\n  \t\t            return true;\n  \t\t        if (shouldRetryHeader === 'false')\n  \t\t            return false;\n  \t\t        // Retry on request timeouts.\n  \t\t        if (response.status === 408)\n  \t\t            return true;\n  \t\t        // Retry on lock timeouts.\n  \t\t        if (response.status === 409)\n  \t\t            return true;\n  \t\t        // Retry on rate limits.\n  \t\t        if (response.status === 429)\n  \t\t            return true;\n  \t\t        // Retry internal errors.\n  \t\t        if (response.status >= 500)\n  \t\t            return true;\n  \t\t        return false;\n  \t\t    }\n  \t\t    async retryRequest(options, retriesRemaining, responseHeaders) {\n  \t\t        let timeoutMillis;\n  \t\t        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n  \t\t        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n  \t\t        if (retryAfterMillisHeader) {\n  \t\t            const timeoutMs = parseFloat(retryAfterMillisHeader);\n  \t\t            if (!Number.isNaN(timeoutMs)) {\n  \t\t                timeoutMillis = timeoutMs;\n  \t\t            }\n  \t\t        }\n  \t\t        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n  \t\t        const retryAfterHeader = responseHeaders?.['retry-after'];\n  \t\t        if (retryAfterHeader && !timeoutMillis) {\n  \t\t            const timeoutSeconds = parseFloat(retryAfterHeader);\n  \t\t            if (!Number.isNaN(timeoutSeconds)) {\n  \t\t                timeoutMillis = timeoutSeconds * 1000;\n  \t\t            }\n  \t\t            else {\n  \t\t                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n  \t\t            }\n  \t\t        }\n  \t\t        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n  \t\t        // just do what it says, but otherwise calculate a default\n  \t\t        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n  \t\t            const maxRetries = options.maxRetries ?? this.maxRetries;\n  \t\t            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n  \t\t        }\n  \t\t        await (0, exports.sleep)(timeoutMillis);\n  \t\t        return this.makeRequest(options, retriesRemaining - 1);\n  \t\t    }\n  \t\t    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n  \t\t        const initialRetryDelay = 0.5;\n  \t\t        const maxRetryDelay = 8.0;\n  \t\t        const numRetries = maxRetries - retriesRemaining;\n  \t\t        // Apply exponential backoff, but not more than the max.\n  \t\t        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n  \t\t        // Apply some jitter, take up to at most 25 percent of the retry time.\n  \t\t        const jitter = 1 - Math.random() * 0.25;\n  \t\t        return sleepSeconds * jitter * 1000;\n  \t\t    }\n  \t\t    getUserAgent() {\n  \t\t        return `${this.constructor.name}/JS ${version_1.VERSION}`;\n  \t\t    }\n  \t\t}\n  \t\texports.APIClient = APIClient;\n  \t\tclass AbstractPage {\n  \t\t    constructor(client, response, body, options) {\n  \t\t        _AbstractPage_client.set(this, void 0);\n  \t\t        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n  \t\t        this.options = options;\n  \t\t        this.response = response;\n  \t\t        this.body = body;\n  \t\t    }\n  \t\t    hasNextPage() {\n  \t\t        const items = this.getPaginatedItems();\n  \t\t        if (!items.length)\n  \t\t            return false;\n  \t\t        return this.nextPageInfo() != null;\n  \t\t    }\n  \t\t    async getNextPage() {\n  \t\t        const nextInfo = this.nextPageInfo();\n  \t\t        if (!nextInfo) {\n  \t\t            throw new error_1.OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n  \t\t        }\n  \t\t        const nextOptions = { ...this.options };\n  \t\t        if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n  \t\t            nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n  \t\t        }\n  \t\t        else if ('url' in nextInfo) {\n  \t\t            const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n  \t\t            for (const [key, value] of params) {\n  \t\t                nextInfo.url.searchParams.set(key, value);\n  \t\t            }\n  \t\t            nextOptions.query = undefined;\n  \t\t            nextOptions.path = nextInfo.url.toString();\n  \t\t        }\n  \t\t        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n  \t\t    }\n  \t\t    async *iterPages() {\n  \t\t        // eslint-disable-next-line @typescript-eslint/no-this-alias\n  \t\t        let page = this;\n  \t\t        yield page;\n  \t\t        while (page.hasNextPage()) {\n  \t\t            page = await page.getNextPage();\n  \t\t            yield page;\n  \t\t        }\n  \t\t    }\n  \t\t    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n  \t\t        for await (const page of this.iterPages()) {\n  \t\t            for (const item of page.getPaginatedItems()) {\n  \t\t                yield item;\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t}\n  \t\texports.AbstractPage = AbstractPage;\n  \t\t/**\n  \t\t * This subclass of Promise will resolve to an instantiated Page once the request completes.\n  \t\t *\n  \t\t * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n  \t\t *\n  \t\t *    for await (const item of client.items.list()) {\n  \t\t *      console.log(item)\n  \t\t *    }\n  \t\t */\n  \t\tclass PagePromise extends APIPromise {\n  \t\t    constructor(client, request, Page) {\n  \t\t        super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));\n  \t\t    }\n  \t\t    /**\n  \t\t     * Allow auto-paginating iteration on an unawaited list call, eg:\n  \t\t     *\n  \t\t     *    for await (const item of client.items.list()) {\n  \t\t     *      console.log(item)\n  \t\t     *    }\n  \t\t     */\n  \t\t    async *[Symbol.asyncIterator]() {\n  \t\t        const page = await this;\n  \t\t        for await (const item of page) {\n  \t\t            yield item;\n  \t\t        }\n  \t\t    }\n  \t\t}\n  \t\texports.PagePromise = PagePromise;\n  \t\tconst createResponseHeaders = (headers) => {\n  \t\t    return new Proxy(Object.fromEntries(\n  \t\t    // @ts-ignore\n  \t\t    headers.entries()), {\n  \t\t        get(target, name) {\n  \t\t            const key = name.toString();\n  \t\t            return target[key.toLowerCase()] || target[key];\n  \t\t        },\n  \t\t    });\n  \t\t};\n  \t\texports.createResponseHeaders = createResponseHeaders;\n  \t\t// This is required so that we can determine if a given object matches the RequestOptions\n  \t\t// type at runtime. While this requires duplication, it is enforced by the TypeScript\n  \t\t// compiler such that any missing / extraneous keys will cause an error.\n  \t\tconst requestOptionsKeys = {\n  \t\t    method: true,\n  \t\t    path: true,\n  \t\t    query: true,\n  \t\t    body: true,\n  \t\t    headers: true,\n  \t\t    maxRetries: true,\n  \t\t    stream: true,\n  \t\t    timeout: true,\n  \t\t    httpAgent: true,\n  \t\t    signal: true,\n  \t\t    idempotencyKey: true,\n  \t\t    __binaryRequest: true,\n  \t\t    __binaryResponse: true,\n  \t\t    __streamClass: true,\n  \t\t};\n  \t\tconst isRequestOptions = (obj) => {\n  \t\t    return (typeof obj === 'object' &&\n  \t\t        obj !== null &&\n  \t\t        !isEmptyObj(obj) &&\n  \t\t        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n  \t\t};\n  \t\texports.isRequestOptions = isRequestOptions;\n  \t\tconst getPlatformProperties = () => {\n  \t\t    if (typeof Deno !== 'undefined' && Deno.build != null) {\n  \t\t        return {\n  \t\t            'X-Stainless-Lang': 'js',\n  \t\t            'X-Stainless-Package-Version': version_1.VERSION,\n  \t\t            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n  \t\t            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n  \t\t            'X-Stainless-Runtime': 'deno',\n  \t\t            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n  \t\t        };\n  \t\t    }\n  \t\t    if (typeof EdgeRuntime !== 'undefined') {\n  \t\t        return {\n  \t\t            'X-Stainless-Lang': 'js',\n  \t\t            'X-Stainless-Package-Version': version_1.VERSION,\n  \t\t            'X-Stainless-OS': 'Unknown',\n  \t\t            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n  \t\t            'X-Stainless-Runtime': 'edge',\n  \t\t            'X-Stainless-Runtime-Version': messages$1.browser$1.version,\n  \t\t        };\n  \t\t    }\n  \t\t    // Check if Node.js\n  \t\t    if (Object.prototype.toString.call(typeof messages$1.browser$1 !== 'undefined' ? messages$1.browser$1 : 0) === '[object process]') {\n  \t\t        return {\n  \t\t            'X-Stainless-Lang': 'js',\n  \t\t            'X-Stainless-Package-Version': version_1.VERSION,\n  \t\t            'X-Stainless-OS': normalizePlatform(messages$1.browser$1.platform),\n  \t\t            'X-Stainless-Arch': normalizeArch(messages$1.browser$1.arch),\n  \t\t            'X-Stainless-Runtime': 'node',\n  \t\t            'X-Stainless-Runtime-Version': messages$1.browser$1.version,\n  \t\t        };\n  \t\t    }\n  \t\t    const browserInfo = getBrowserInfo();\n  \t\t    if (browserInfo) {\n  \t\t        return {\n  \t\t            'X-Stainless-Lang': 'js',\n  \t\t            'X-Stainless-Package-Version': version_1.VERSION,\n  \t\t            'X-Stainless-OS': 'Unknown',\n  \t\t            'X-Stainless-Arch': 'unknown',\n  \t\t            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n  \t\t            'X-Stainless-Runtime-Version': browserInfo.version,\n  \t\t        };\n  \t\t    }\n  \t\t    // TODO add support for Cloudflare workers, etc.\n  \t\t    return {\n  \t\t        'X-Stainless-Lang': 'js',\n  \t\t        'X-Stainless-Package-Version': version_1.VERSION,\n  \t\t        'X-Stainless-OS': 'Unknown',\n  \t\t        'X-Stainless-Arch': 'unknown',\n  \t\t        'X-Stainless-Runtime': 'unknown',\n  \t\t        'X-Stainless-Runtime-Version': 'unknown',\n  \t\t    };\n  \t\t};\n  \t\t// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\n  \t\tfunction getBrowserInfo() {\n  \t\t    if (typeof navigator === 'undefined' || !navigator) {\n  \t\t        return null;\n  \t\t    }\n  \t\t    // NOTE: The order matters here!\n  \t\t    const browserPatterns = [\n  \t\t        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n  \t\t        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n  \t\t        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n  \t\t        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n  \t\t        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n  \t\t        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n  \t\t    ];\n  \t\t    // Find the FIRST matching browser\n  \t\t    for (const { key, pattern } of browserPatterns) {\n  \t\t        const match = pattern.exec(navigator.userAgent);\n  \t\t        if (match) {\n  \t\t            const major = match[1] || 0;\n  \t\t            const minor = match[2] || 0;\n  \t\t            const patch = match[3] || 0;\n  \t\t            return { browser: key, version: `${major}.${minor}.${patch}` };\n  \t\t        }\n  \t\t    }\n  \t\t    return null;\n  \t\t}\n  \t\tconst normalizeArch = (arch) => {\n  \t\t    // Node docs:\n  \t\t    // - https://nodejs.org/api/process.html#processarch\n  \t\t    // Deno docs:\n  \t\t    // - https://doc.deno.land/deno/stable/~/Deno.build\n  \t\t    if (arch === 'x32')\n  \t\t        return 'x32';\n  \t\t    if (arch === 'x86_64' || arch === 'x64')\n  \t\t        return 'x64';\n  \t\t    if (arch === 'arm')\n  \t\t        return 'arm';\n  \t\t    if (arch === 'aarch64' || arch === 'arm64')\n  \t\t        return 'arm64';\n  \t\t    if (arch)\n  \t\t        return `other:${arch}`;\n  \t\t    return 'unknown';\n  \t\t};\n  \t\tconst normalizePlatform = (platform) => {\n  \t\t    // Node platforms:\n  \t\t    // - https://nodejs.org/api/process.html#processplatform\n  \t\t    // Deno platforms:\n  \t\t    // - https://doc.deno.land/deno/stable/~/Deno.build\n  \t\t    // - https://github.com/denoland/deno/issues/14799\n  \t\t    platform = platform.toLowerCase();\n  \t\t    // NOTE: this iOS check is untested and may not work\n  \t\t    // Node does not work natively on IOS, there is a fork at\n  \t\t    // https://github.com/nodejs-mobile/nodejs-mobile\n  \t\t    // however it is unknown at the time of writing how to detect if it is running\n  \t\t    if (platform.includes('ios'))\n  \t\t        return 'iOS';\n  \t\t    if (platform === 'android')\n  \t\t        return 'Android';\n  \t\t    if (platform === 'darwin')\n  \t\t        return 'MacOS';\n  \t\t    if (platform === 'win32')\n  \t\t        return 'Windows';\n  \t\t    if (platform === 'freebsd')\n  \t\t        return 'FreeBSD';\n  \t\t    if (platform === 'openbsd')\n  \t\t        return 'OpenBSD';\n  \t\t    if (platform === 'linux')\n  \t\t        return 'Linux';\n  \t\t    if (platform)\n  \t\t        return `Other:${platform}`;\n  \t\t    return 'Unknown';\n  \t\t};\n  \t\tlet _platformHeaders;\n  \t\tconst getPlatformHeaders = () => {\n  \t\t    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n  \t\t};\n  \t\tconst safeJSON = (text) => {\n  \t\t    try {\n  \t\t        return JSON.parse(text);\n  \t\t    }\n  \t\t    catch (err) {\n  \t\t        return undefined;\n  \t\t    }\n  \t\t};\n  \t\texports.safeJSON = safeJSON;\n  \t\t// https://stackoverflow.com/a/19709846\n  \t\tconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\n  \t\tconst isAbsoluteURL = (url) => {\n  \t\t    return startsWithSchemeRegexp.test(url);\n  \t\t};\n  \t\tconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n  \t\texports.sleep = sleep;\n  \t\tconst validatePositiveInteger = (name, n) => {\n  \t\t    if (typeof n !== 'number' || !Number.isInteger(n)) {\n  \t\t        throw new error_1.OpenAIError(`${name} must be an integer`);\n  \t\t    }\n  \t\t    if (n < 0) {\n  \t\t        throw new error_1.OpenAIError(`${name} must be a positive integer`);\n  \t\t    }\n  \t\t    return n;\n  \t\t};\n  \t\tconst castToError = (err) => {\n  \t\t    if (err instanceof Error)\n  \t\t        return err;\n  \t\t    if (typeof err === 'object' && err !== null) {\n  \t\t        try {\n  \t\t            return new Error(JSON.stringify(err));\n  \t\t        }\n  \t\t        catch { }\n  \t\t    }\n  \t\t    return new Error(err);\n  \t\t};\n  \t\texports.castToError = castToError;\n  \t\tconst ensurePresent = (value) => {\n  \t\t    if (value == null)\n  \t\t        throw new error_1.OpenAIError(`Expected a value to be given but received ${value} instead.`);\n  \t\t    return value;\n  \t\t};\n  \t\texports.ensurePresent = ensurePresent;\n  \t\t/**\n  \t\t * Read an environment variable.\n  \t\t *\n  \t\t * Trims beginning and trailing whitespace.\n  \t\t *\n  \t\t * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n  \t\t */\n  \t\tconst readEnv = (env) => {\n  \t\t    if (typeof messages$1.browser$1 !== 'undefined') {\n  \t\t        return messages$1.browser$1.env?.[env]?.trim() ?? undefined;\n  \t\t    }\n  \t\t    if (typeof Deno !== 'undefined') {\n  \t\t        return Deno.env?.get?.(env)?.trim();\n  \t\t    }\n  \t\t    return undefined;\n  \t\t};\n  \t\texports.readEnv = readEnv;\n  \t\tconst coerceInteger = (value) => {\n  \t\t    if (typeof value === 'number')\n  \t\t        return Math.round(value);\n  \t\t    if (typeof value === 'string')\n  \t\t        return parseInt(value, 10);\n  \t\t    throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n  \t\t};\n  \t\texports.coerceInteger = coerceInteger;\n  \t\tconst coerceFloat = (value) => {\n  \t\t    if (typeof value === 'number')\n  \t\t        return value;\n  \t\t    if (typeof value === 'string')\n  \t\t        return parseFloat(value);\n  \t\t    throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n  \t\t};\n  \t\texports.coerceFloat = coerceFloat;\n  \t\tconst coerceBoolean = (value) => {\n  \t\t    if (typeof value === 'boolean')\n  \t\t        return value;\n  \t\t    if (typeof value === 'string')\n  \t\t        return value === 'true';\n  \t\t    return Boolean(value);\n  \t\t};\n  \t\texports.coerceBoolean = coerceBoolean;\n  \t\tconst maybeCoerceInteger = (value) => {\n  \t\t    if (value === undefined) {\n  \t\t        return undefined;\n  \t\t    }\n  \t\t    return (0, exports.coerceInteger)(value);\n  \t\t};\n  \t\texports.maybeCoerceInteger = maybeCoerceInteger;\n  \t\tconst maybeCoerceFloat = (value) => {\n  \t\t    if (value === undefined) {\n  \t\t        return undefined;\n  \t\t    }\n  \t\t    return (0, exports.coerceFloat)(value);\n  \t\t};\n  \t\texports.maybeCoerceFloat = maybeCoerceFloat;\n  \t\tconst maybeCoerceBoolean = (value) => {\n  \t\t    if (value === undefined) {\n  \t\t        return undefined;\n  \t\t    }\n  \t\t    return (0, exports.coerceBoolean)(value);\n  \t\t};\n  \t\texports.maybeCoerceBoolean = maybeCoerceBoolean;\n  \t\t// https://stackoverflow.com/a/34491287\n  \t\tfunction isEmptyObj(obj) {\n  \t\t    if (!obj)\n  \t\t        return true;\n  \t\t    for (const _k in obj)\n  \t\t        return false;\n  \t\t    return true;\n  \t\t}\n  \t\texports.isEmptyObj = isEmptyObj;\n  \t\t// https://eslint.org/docs/latest/rules/no-prototype-builtins\n  \t\tfunction hasOwn(obj, key) {\n  \t\t    return Object.prototype.hasOwnProperty.call(obj, key);\n  \t\t}\n  \t\texports.hasOwn = hasOwn;\n  \t\t/**\n  \t\t * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n  \t\t * using lower-case for all properties,\n  \t\t * ignoring any keys with undefined values,\n  \t\t * and deleting any keys with null values.\n  \t\t */\n  \t\tfunction applyHeadersMut(targetHeaders, newHeaders) {\n  \t\t    for (const k in newHeaders) {\n  \t\t        if (!hasOwn(newHeaders, k))\n  \t\t            continue;\n  \t\t        const lowerKey = k.toLowerCase();\n  \t\t        if (!lowerKey)\n  \t\t            continue;\n  \t\t        const val = newHeaders[k];\n  \t\t        if (val === null) {\n  \t\t            delete targetHeaders[lowerKey];\n  \t\t        }\n  \t\t        else if (val !== undefined) {\n  \t\t            targetHeaders[lowerKey] = val;\n  \t\t        }\n  \t\t    }\n  \t\t}\n  \t\tfunction debug(action, ...args) {\n  \t\t    if (typeof messages$1.browser$1 !== 'undefined' && messages$1.browser$1?.env?.['DEBUG'] === 'true') {\n  \t\t        console.log(`OpenAI:DEBUG:${action}`, ...args);\n  \t\t    }\n  \t\t}\n  \t\texports.debug = debug;\n  \t\t/**\n  \t\t * https://stackoverflow.com/a/2117523\n  \t\t */\n  \t\tconst uuid4 = () => {\n  \t\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n  \t\t        const r = (Math.random() * 16) | 0;\n  \t\t        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n  \t\t        return v.toString(16);\n  \t\t    });\n  \t\t};\n  \t\tconst isRunningInBrowser = () => {\n  \t\t    return (\n  \t\t    // @ts-ignore\n  \t\t    typeof window !== 'undefined' &&\n  \t\t        // @ts-ignore\n  \t\t        typeof window.document !== 'undefined' &&\n  \t\t        // @ts-ignore\n  \t\t        typeof navigator !== 'undefined');\n  \t\t};\n  \t\texports.isRunningInBrowser = isRunningInBrowser;\n  \t\tconst isHeadersProtocol = (headers) => {\n  \t\t    return typeof headers?.get === 'function';\n  \t\t};\n  \t\texports.isHeadersProtocol = isHeadersProtocol;\n  \t\tconst getRequiredHeader = (headers, header) => {\n  \t\t    const foundHeader = (0, exports.getHeader)(headers, header);\n  \t\t    if (foundHeader === undefined) {\n  \t\t        throw new Error(`Could not find ${header} header`);\n  \t\t    }\n  \t\t    return foundHeader;\n  \t\t};\n  \t\texports.getRequiredHeader = getRequiredHeader;\n  \t\tconst getHeader = (headers, header) => {\n  \t\t    const lowerCasedHeader = header.toLowerCase();\n  \t\t    if ((0, exports.isHeadersProtocol)(headers)) {\n  \t\t        // to deal with the case where the header looks like Stainless-Event-Id\n  \t\t        const intercapsHeader = header[0]?.toUpperCase() +\n  \t\t            header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n  \t\t        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n  \t\t            const value = headers.get(key);\n  \t\t            if (value) {\n  \t\t                return value;\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t    for (const [key, value] of Object.entries(headers)) {\n  \t\t        if (key.toLowerCase() === lowerCasedHeader) {\n  \t\t            if (Array.isArray(value)) {\n  \t\t                if (value.length <= 1)\n  \t\t                    return value[0];\n  \t\t                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n  \t\t                return value[0];\n  \t\t            }\n  \t\t            return value;\n  \t\t        }\n  \t\t    }\n  \t\t    return undefined;\n  \t\t};\n  \t\texports.getHeader = getHeader;\n  \t\t/**\n  \t\t * Encodes a string to Base64 format.\n  \t\t */\n  \t\tconst toBase64 = (str) => {\n  \t\t    if (!str)\n  \t\t        return '';\n  \t\t    if (typeof Buffer !== 'undefined') {\n  \t\t        return Buffer.from(str).toString('base64');\n  \t\t    }\n  \t\t    if (typeof btoa !== 'undefined') {\n  \t\t        return btoa(str);\n  \t\t    }\n  \t\t    throw new error_1.OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n  \t\t};\n  \t\texports.toBase64 = toBase64;\n  \t\tfunction isObj(obj) {\n  \t\t    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n  \t\t}\n  \t\texports.isObj = isObj;\n  \t\t\n  \t} (core));\n  \treturn core;\n  }\n\n  var hasRequiredError;\n\n  function requireError () {\n  \tif (hasRequiredError) return error;\n  \thasRequiredError = 1;\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(error, \"__esModule\", { value: true });\n  \terror.ContentFilterFinishReasonError = error.LengthFinishReasonError = error.InternalServerError = error.RateLimitError = error.UnprocessableEntityError = error.ConflictError = error.NotFoundError = error.PermissionDeniedError = error.AuthenticationError = error.BadRequestError = error.APIConnectionTimeoutError = error.APIConnectionError = error.APIUserAbortError = error.APIError = error.OpenAIError = void 0;\n  \tconst core_1 = requireCore();\n  \tclass OpenAIError extends Error {\n  \t}\n  \terror.OpenAIError = OpenAIError;\n  \tclass APIError extends OpenAIError {\n  \t    constructor(status, error, message, headers) {\n  \t        super(`${APIError.makeMessage(status, error, message)}`);\n  \t        this.status = status;\n  \t        this.headers = headers;\n  \t        this.request_id = headers?.['x-request-id'];\n  \t        const data = error;\n  \t        this.error = data;\n  \t        this.code = data?.['code'];\n  \t        this.param = data?.['param'];\n  \t        this.type = data?.['type'];\n  \t    }\n  \t    static makeMessage(status, error, message) {\n  \t        const msg = error?.message ?\n  \t            typeof error.message === 'string' ?\n  \t                error.message\n  \t                : JSON.stringify(error.message)\n  \t            : error ? JSON.stringify(error)\n  \t                : message;\n  \t        if (status && msg) {\n  \t            return `${status} ${msg}`;\n  \t        }\n  \t        if (status) {\n  \t            return `${status} status code (no body)`;\n  \t        }\n  \t        if (msg) {\n  \t            return msg;\n  \t        }\n  \t        return '(no status code or body)';\n  \t    }\n  \t    static generate(status, errorResponse, message, headers) {\n  \t        if (!status) {\n  \t            return new APIConnectionError({ message, cause: (0, core_1.castToError)(errorResponse) });\n  \t        }\n  \t        const error = errorResponse?.['error'];\n  \t        if (status === 400) {\n  \t            return new BadRequestError(status, error, message, headers);\n  \t        }\n  \t        if (status === 401) {\n  \t            return new AuthenticationError(status, error, message, headers);\n  \t        }\n  \t        if (status === 403) {\n  \t            return new PermissionDeniedError(status, error, message, headers);\n  \t        }\n  \t        if (status === 404) {\n  \t            return new NotFoundError(status, error, message, headers);\n  \t        }\n  \t        if (status === 409) {\n  \t            return new ConflictError(status, error, message, headers);\n  \t        }\n  \t        if (status === 422) {\n  \t            return new UnprocessableEntityError(status, error, message, headers);\n  \t        }\n  \t        if (status === 429) {\n  \t            return new RateLimitError(status, error, message, headers);\n  \t        }\n  \t        if (status >= 500) {\n  \t            return new InternalServerError(status, error, message, headers);\n  \t        }\n  \t        return new APIError(status, error, message, headers);\n  \t    }\n  \t}\n  \terror.APIError = APIError;\n  \tclass APIUserAbortError extends APIError {\n  \t    constructor({ message } = {}) {\n  \t        super(undefined, undefined, message || 'Request was aborted.', undefined);\n  \t        this.status = undefined;\n  \t    }\n  \t}\n  \terror.APIUserAbortError = APIUserAbortError;\n  \tclass APIConnectionError extends APIError {\n  \t    constructor({ message, cause }) {\n  \t        super(undefined, undefined, message || 'Connection error.', undefined);\n  \t        this.status = undefined;\n  \t        // in some environments the 'cause' property is already declared\n  \t        // @ts-ignore\n  \t        if (cause)\n  \t            this.cause = cause;\n  \t    }\n  \t}\n  \terror.APIConnectionError = APIConnectionError;\n  \tclass APIConnectionTimeoutError extends APIConnectionError {\n  \t    constructor({ message } = {}) {\n  \t        super({ message: message ?? 'Request timed out.' });\n  \t    }\n  \t}\n  \terror.APIConnectionTimeoutError = APIConnectionTimeoutError;\n  \tclass BadRequestError extends APIError {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.status = 400;\n  \t    }\n  \t}\n  \terror.BadRequestError = BadRequestError;\n  \tclass AuthenticationError extends APIError {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.status = 401;\n  \t    }\n  \t}\n  \terror.AuthenticationError = AuthenticationError;\n  \tclass PermissionDeniedError extends APIError {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.status = 403;\n  \t    }\n  \t}\n  \terror.PermissionDeniedError = PermissionDeniedError;\n  \tclass NotFoundError extends APIError {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.status = 404;\n  \t    }\n  \t}\n  \terror.NotFoundError = NotFoundError;\n  \tclass ConflictError extends APIError {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.status = 409;\n  \t    }\n  \t}\n  \terror.ConflictError = ConflictError;\n  \tclass UnprocessableEntityError extends APIError {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.status = 422;\n  \t    }\n  \t}\n  \terror.UnprocessableEntityError = UnprocessableEntityError;\n  \tclass RateLimitError extends APIError {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.status = 429;\n  \t    }\n  \t}\n  \terror.RateLimitError = RateLimitError;\n  \tclass InternalServerError extends APIError {\n  \t}\n  \terror.InternalServerError = InternalServerError;\n  \tclass LengthFinishReasonError extends OpenAIError {\n  \t    constructor() {\n  \t        super(`Could not parse response content as the length limit was reached`);\n  \t    }\n  \t}\n  \terror.LengthFinishReasonError = LengthFinishReasonError;\n  \tclass ContentFilterFinishReasonError extends OpenAIError {\n  \t    constructor() {\n  \t        super(`Could not parse response content as the request was rejected by the content filter`);\n  \t    }\n  \t}\n  \terror.ContentFilterFinishReasonError = ContentFilterFinishReasonError;\n  \t\n  \treturn error;\n  }\n\n  var qs = {};\n\n  var formats = {};\n\n  Object.defineProperty(formats, \"__esModule\", { value: true });\n  formats.RFC3986 = formats.RFC1738 = formats.formatters = formats.default_format = void 0;\n  formats.default_format = 'RFC3986';\n  formats.formatters = {\n      RFC1738: (v) => String(v).replace(/%20/g, '+'),\n      RFC3986: (v) => String(v),\n  };\n  formats.RFC1738 = 'RFC1738';\n  formats.RFC3986 = 'RFC3986';\n\n  var stringify$1 = {};\n\n  var utils = {};\n\n  Object.defineProperty(utils, \"__esModule\", { value: true });\n  utils.maybe_map = utils.combine = utils.is_buffer = utils.is_regexp = utils.compact = utils.encode = utils.decode = utils.assign_single_source = utils.merge = void 0;\n  const formats_1$1 = formats;\n  const has$1 = Object.prototype.hasOwnProperty;\n  const is_array$1 = Array.isArray;\n  const hex_table = (() => {\n      const array = [];\n      for (let i = 0; i < 256; ++i) {\n          array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n      }\n      return array;\n  })();\n  function compact_queue(queue) {\n      while (queue.length > 1) {\n          const item = queue.pop();\n          if (!item)\n              continue;\n          const obj = item.obj[item.prop];\n          if (is_array$1(obj)) {\n              const compacted = [];\n              for (let j = 0; j < obj.length; ++j) {\n                  if (typeof obj[j] !== 'undefined') {\n                      compacted.push(obj[j]);\n                  }\n              }\n              // @ts-ignore\n              item.obj[item.prop] = compacted;\n          }\n      }\n  }\n  function array_to_object(source, options) {\n      const obj = options && options.plainObjects ? Object.create(null) : {};\n      for (let i = 0; i < source.length; ++i) {\n          if (typeof source[i] !== 'undefined') {\n              obj[i] = source[i];\n          }\n      }\n      return obj;\n  }\n  function merge(target, source, options = {}) {\n      if (!source) {\n          return target;\n      }\n      if (typeof source !== 'object') {\n          if (is_array$1(target)) {\n              target.push(source);\n          }\n          else if (target && typeof target === 'object') {\n              if ((options && (options.plainObjects || options.allowPrototypes)) ||\n                  !has$1.call(Object.prototype, source)) {\n                  target[source] = true;\n              }\n          }\n          else {\n              return [target, source];\n          }\n          return target;\n      }\n      if (!target || typeof target !== 'object') {\n          return [target].concat(source);\n      }\n      let mergeTarget = target;\n      if (is_array$1(target) && !is_array$1(source)) {\n          // @ts-ignore\n          mergeTarget = array_to_object(target, options);\n      }\n      if (is_array$1(target) && is_array$1(source)) {\n          source.forEach(function (item, i) {\n              if (has$1.call(target, i)) {\n                  const targetItem = target[i];\n                  if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                      target[i] = merge(targetItem, item, options);\n                  }\n                  else {\n                      target.push(item);\n                  }\n              }\n              else {\n                  target[i] = item;\n              }\n          });\n          return target;\n      }\n      return Object.keys(source).reduce(function (acc, key) {\n          const value = source[key];\n          if (has$1.call(acc, key)) {\n              acc[key] = merge(acc[key], value, options);\n          }\n          else {\n              acc[key] = value;\n          }\n          return acc;\n      }, mergeTarget);\n  }\n  utils.merge = merge;\n  function assign_single_source(target, source) {\n      return Object.keys(source).reduce(function (acc, key) {\n          acc[key] = source[key];\n          return acc;\n      }, target);\n  }\n  utils.assign_single_source = assign_single_source;\n  function decode(str, _, charset) {\n      const strWithoutPlus = str.replace(/\\+/g, ' ');\n      if (charset === 'iso-8859-1') {\n          // unescape never throws, no try...catch needed:\n          return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n      }\n      // utf-8\n      try {\n          return decodeURIComponent(strWithoutPlus);\n      }\n      catch (e) {\n          return strWithoutPlus;\n      }\n  }\n  utils.decode = decode;\n  const limit = 1024;\n  const encode = (str, _defaultEncoder, charset, _kind, format) => {\n      // This code was originally written by Brian White for the io.js core querystring library.\n      // It has been adapted here for stricter adherence to RFC 3986\n      if (str.length === 0) {\n          return str;\n      }\n      let string = str;\n      if (typeof str === 'symbol') {\n          string = Symbol.prototype.toString.call(str);\n      }\n      else if (typeof str !== 'string') {\n          string = String(str);\n      }\n      if (charset === 'iso-8859-1') {\n          return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n              return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n          });\n      }\n      let out = '';\n      for (let j = 0; j < string.length; j += limit) {\n          const segment = string.length >= limit ? string.slice(j, j + limit) : string;\n          const arr = [];\n          for (let i = 0; i < segment.length; ++i) {\n              let c = segment.charCodeAt(i);\n              if (c === 0x2d || // -\n                  c === 0x2e || // .\n                  c === 0x5f || // _\n                  c === 0x7e || // ~\n                  (c >= 0x30 && c <= 0x39) || // 0-9\n                  (c >= 0x41 && c <= 0x5a) || // a-z\n                  (c >= 0x61 && c <= 0x7a) || // A-Z\n                  (format === formats_1$1.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n              ) {\n                  arr[arr.length] = segment.charAt(i);\n                  continue;\n              }\n              if (c < 0x80) {\n                  arr[arr.length] = hex_table[c];\n                  continue;\n              }\n              if (c < 0x800) {\n                  arr[arr.length] = hex_table[0xc0 | (c >> 6)] + hex_table[0x80 | (c & 0x3f)];\n                  continue;\n              }\n              if (c < 0xd800 || c >= 0xe000) {\n                  arr[arr.length] =\n                      hex_table[0xe0 | (c >> 12)] + hex_table[0x80 | ((c >> 6) & 0x3f)] + hex_table[0x80 | (c & 0x3f)];\n                  continue;\n              }\n              i += 1;\n              c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff));\n              arr[arr.length] =\n                  hex_table[0xf0 | (c >> 18)] +\n                      hex_table[0x80 | ((c >> 12) & 0x3f)] +\n                      hex_table[0x80 | ((c >> 6) & 0x3f)] +\n                      hex_table[0x80 | (c & 0x3f)];\n          }\n          out += arr.join('');\n      }\n      return out;\n  };\n  utils.encode = encode;\n  function compact(value) {\n      const queue = [{ obj: { o: value }, prop: 'o' }];\n      const refs = [];\n      for (let i = 0; i < queue.length; ++i) {\n          const item = queue[i];\n          // @ts-ignore\n          const obj = item.obj[item.prop];\n          const keys = Object.keys(obj);\n          for (let j = 0; j < keys.length; ++j) {\n              const key = keys[j];\n              const val = obj[key];\n              if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                  queue.push({ obj: obj, prop: key });\n                  refs.push(val);\n              }\n          }\n      }\n      compact_queue(queue);\n      return value;\n  }\n  utils.compact = compact;\n  function is_regexp(obj) {\n      return Object.prototype.toString.call(obj) === '[object RegExp]';\n  }\n  utils.is_regexp = is_regexp;\n  function is_buffer(obj) {\n      if (!obj || typeof obj !== 'object') {\n          return false;\n      }\n      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n  }\n  utils.is_buffer = is_buffer;\n  function combine(a, b) {\n      return [].concat(a, b);\n  }\n  utils.combine = combine;\n  function maybe_map(val, fn) {\n      if (is_array$1(val)) {\n          const mapped = [];\n          for (let i = 0; i < val.length; i += 1) {\n              mapped.push(fn(val[i]));\n          }\n          return mapped;\n      }\n      return fn(val);\n  }\n  utils.maybe_map = maybe_map;\n\n  Object.defineProperty(stringify$1, \"__esModule\", { value: true });\n  stringify$1.stringify = void 0;\n  const utils_1 = utils;\n  const formats_1 = formats;\n  const has = Object.prototype.hasOwnProperty;\n  const array_prefix_generators = {\n      brackets(prefix) {\n          return String(prefix) + '[]';\n      },\n      comma: 'comma',\n      indices(prefix, key) {\n          return String(prefix) + '[' + key + ']';\n      },\n      repeat(prefix) {\n          return String(prefix);\n      },\n  };\n  const is_array = Array.isArray;\n  const push = Array.prototype.push;\n  const push_to_array = function (arr, value_or_array) {\n      push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);\n  };\n  const to_ISO = Date.prototype.toISOString;\n  const defaults = {\n      addQueryPrefix: false,\n      allowDots: false,\n      allowEmptyArrays: false,\n      arrayFormat: 'indices',\n      charset: 'utf-8',\n      charsetSentinel: false,\n      delimiter: '&',\n      encode: true,\n      encodeDotInKeys: false,\n      encoder: utils_1.encode,\n      encodeValuesOnly: false,\n      format: formats_1.default_format,\n      formatter: formats_1.formatters[formats_1.default_format],\n      /** @deprecated */\n      indices: false,\n      serializeDate(date) {\n          return to_ISO.call(date);\n      },\n      skipNulls: false,\n      strictNullHandling: false,\n  };\n  function is_non_nullish_primitive(v) {\n      return (typeof v === 'string' ||\n          typeof v === 'number' ||\n          typeof v === 'boolean' ||\n          typeof v === 'symbol' ||\n          typeof v === 'bigint');\n  }\n  const sentinel = {};\n  function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {\n      let obj = object;\n      let tmp_sc = sideChannel;\n      let step = 0;\n      let find_flag = false;\n      while ((tmp_sc = tmp_sc.get(sentinel)) !== void undefined && !find_flag) {\n          // Where object last appeared in the ref tree\n          const pos = tmp_sc.get(object);\n          step += 1;\n          if (typeof pos !== 'undefined') {\n              if (pos === step) {\n                  throw new RangeError('Cyclic object value');\n              }\n              else {\n                  find_flag = true; // Break while\n              }\n          }\n          if (typeof tmp_sc.get(sentinel) === 'undefined') {\n              step = 0;\n          }\n      }\n      if (typeof filter === 'function') {\n          obj = filter(prefix, obj);\n      }\n      else if (obj instanceof Date) {\n          obj = serializeDate?.(obj);\n      }\n      else if (generateArrayPrefix === 'comma' && is_array(obj)) {\n          obj = (0, utils_1.maybe_map)(obj, function (value) {\n              if (value instanceof Date) {\n                  return serializeDate?.(value);\n              }\n              return value;\n          });\n      }\n      if (obj === null) {\n          if (strictNullHandling) {\n              return encoder && !encodeValuesOnly ?\n                  // @ts-expect-error\n                  encoder(prefix, defaults.encoder, charset, 'key', format)\n                  : prefix;\n          }\n          obj = '';\n      }\n      if (is_non_nullish_primitive(obj) || (0, utils_1.is_buffer)(obj)) {\n          if (encoder) {\n              const key_value = encodeValuesOnly ? prefix\n                  // @ts-expect-error\n                  : encoder(prefix, defaults.encoder, charset, 'key', format);\n              return [\n                  formatter?.(key_value) +\n                      '=' +\n                      // @ts-expect-error\n                      formatter?.(encoder(obj, defaults.encoder, charset, 'value', format)),\n              ];\n          }\n          return [formatter?.(prefix) + '=' + formatter?.(String(obj))];\n      }\n      const values = [];\n      if (typeof obj === 'undefined') {\n          return values;\n      }\n      let obj_keys;\n      if (generateArrayPrefix === 'comma' && is_array(obj)) {\n          // we need to join elements in\n          if (encodeValuesOnly && encoder) {\n              // @ts-expect-error values only\n              obj = (0, utils_1.maybe_map)(obj, encoder);\n          }\n          obj_keys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n      }\n      else if (is_array(filter)) {\n          obj_keys = filter;\n      }\n      else {\n          const keys = Object.keys(obj);\n          obj_keys = sort ? keys.sort(sort) : keys;\n      }\n      const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n      const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;\n      if (allowEmptyArrays && is_array(obj) && obj.length === 0) {\n          return adjusted_prefix + '[]';\n      }\n      for (let j = 0; j < obj_keys.length; ++j) {\n          const key = obj_keys[j];\n          const value = \n          // @ts-ignore\n          typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n          if (skipNulls && value === null) {\n              continue;\n          }\n          // @ts-ignore\n          const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\\./g, '%2E') : key;\n          const key_prefix = is_array(obj) ?\n              typeof generateArrayPrefix === 'function' ?\n                  generateArrayPrefix(adjusted_prefix, encoded_key)\n                  : adjusted_prefix\n              : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');\n          sideChannel.set(object, step);\n          const valueSideChannel = new WeakMap();\n          valueSideChannel.set(sentinel, sideChannel);\n          push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, \n          // @ts-ignore\n          generateArrayPrefix === 'comma' && encodeValuesOnly && is_array(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));\n      }\n      return values;\n  }\n  function normalize_stringify_options(opts = defaults) {\n      if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n          throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n      }\n      if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n          throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n      }\n      if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n          throw new TypeError('Encoder has to be a function.');\n      }\n      const charset = opts.charset || defaults.charset;\n      if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n          throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n      }\n      let format = formats_1.default_format;\n      if (typeof opts.format !== 'undefined') {\n          if (!has.call(formats_1.formatters, opts.format)) {\n              throw new TypeError('Unknown format option provided.');\n          }\n          format = opts.format;\n      }\n      const formatter = formats_1.formatters[format];\n      let filter = defaults.filter;\n      if (typeof opts.filter === 'function' || is_array(opts.filter)) {\n          filter = opts.filter;\n      }\n      let arrayFormat;\n      if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {\n          arrayFormat = opts.arrayFormat;\n      }\n      else if ('indices' in opts) {\n          arrayFormat = opts.indices ? 'indices' : 'repeat';\n      }\n      else {\n          arrayFormat = defaults.arrayFormat;\n      }\n      if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n          throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n      }\n      const allowDots = typeof opts.allowDots === 'undefined' ?\n          !!opts.encodeDotInKeys === true ?\n              true\n              : defaults.allowDots\n          : !!opts.allowDots;\n      return {\n          addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n          // @ts-ignore\n          allowDots: allowDots,\n          allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n          arrayFormat: arrayFormat,\n          charset: charset,\n          charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n          commaRoundTrip: !!opts.commaRoundTrip,\n          delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n          encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n          encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n          encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n          encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n          filter: filter,\n          format: format,\n          formatter: formatter,\n          serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n          skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n          // @ts-ignore\n          sort: typeof opts.sort === 'function' ? opts.sort : null,\n          strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n      };\n  }\n  function stringify(object, opts = {}) {\n      let obj = object;\n      const options = normalize_stringify_options(opts);\n      let obj_keys;\n      let filter;\n      if (typeof options.filter === 'function') {\n          filter = options.filter;\n          obj = filter('', obj);\n      }\n      else if (is_array(options.filter)) {\n          filter = options.filter;\n          obj_keys = filter;\n      }\n      const keys = [];\n      if (typeof obj !== 'object' || obj === null) {\n          return '';\n      }\n      const generateArrayPrefix = array_prefix_generators[options.arrayFormat];\n      const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n      if (!obj_keys) {\n          obj_keys = Object.keys(obj);\n      }\n      if (options.sort) {\n          obj_keys.sort(options.sort);\n      }\n      const sideChannel = new WeakMap();\n      for (let i = 0; i < obj_keys.length; ++i) {\n          const key = obj_keys[i];\n          if (options.skipNulls && obj[key] === null) {\n              continue;\n          }\n          push_to_array(keys, inner_stringify(obj[key], key, \n          // @ts-expect-error\n          generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));\n      }\n      const joined = keys.join(options.delimiter);\n      let prefix = options.addQueryPrefix === true ? '?' : '';\n      if (options.charsetSentinel) {\n          if (options.charset === 'iso-8859-1') {\n              // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n              prefix += 'utf8=%26%2310003%3B&';\n          }\n          else {\n              // encodeURIComponent('')\n              prefix += 'utf8=%E2%9C%93&';\n          }\n      }\n      return joined.length > 0 ? prefix + joined : '';\n  }\n  stringify$1.stringify = stringify;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.formats = exports.stringify = void 0;\n  \tconst formats_1 = formats;\n  \tconst formats$1 = {\n  \t    formatters: formats_1.formatters,\n  \t    RFC1738: formats_1.RFC1738,\n  \t    RFC3986: formats_1.RFC3986,\n  \t    default: formats_1.default_format,\n  \t};\n  \texports.formats = formats$1;\n  \tvar stringify_1 = stringify$1;\n  \tObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return stringify_1.stringify; } });\n  \t\n  } (qs));\n\n  var pagination = {};\n\n  // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  Object.defineProperty(pagination, \"__esModule\", { value: true });\n  pagination.CursorPage = pagination.Page = void 0;\n  const core_1 = requireCore();\n  /**\n   * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n   */\n  class Page extends core_1.AbstractPage {\n      constructor(client, response, body, options) {\n          super(client, response, body, options);\n          this.data = body.data || [];\n          this.object = body.object;\n      }\n      getPaginatedItems() {\n          return this.data ?? [];\n      }\n      // @deprecated Please use `nextPageInfo()` instead\n      /**\n       * This page represents a response that isn't actually paginated at the API level\n       * so there will never be any next page params.\n       */\n      nextPageParams() {\n          return null;\n      }\n      nextPageInfo() {\n          return null;\n      }\n  }\n  pagination.Page = Page;\n  class CursorPage extends core_1.AbstractPage {\n      constructor(client, response, body, options) {\n          super(client, response, body, options);\n          this.data = body.data || [];\n      }\n      getPaginatedItems() {\n          return this.data ?? [];\n      }\n      // @deprecated Please use `nextPageInfo()` instead\n      nextPageParams() {\n          const info = this.nextPageInfo();\n          if (!info)\n              return null;\n          if ('params' in info)\n              return info.params;\n          const params = Object.fromEntries(info.url.searchParams);\n          if (!Object.keys(params).length)\n              return null;\n          return params;\n      }\n      nextPageInfo() {\n          const data = this.getPaginatedItems();\n          if (!data.length) {\n              return null;\n          }\n          const id = data[data.length - 1]?.id;\n          if (!id) {\n              return null;\n          }\n          return { params: { after: id } };\n      }\n  }\n  pagination.CursorPage = CursorPage;\n\n  var resources = {};\n\n  var chat$2 = {};\n\n  var completions$2 = {};\n\n  var resource = {};\n\n  // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  Object.defineProperty(resource, \"__esModule\", { value: true });\n  resource.APIResource = void 0;\n  class APIResource {\n      constructor(client) {\n          this._client = client;\n      }\n  }\n  resource.APIResource = APIResource;\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Completions = void 0;\n  \tconst resource_1 = resource;\n  \tclass Completions extends resource_1.APIResource {\n  \t    create(body, options) {\n  \t        return this._client.post('/chat/completions', { body, ...options, stream: body.stream ?? false });\n  \t    }\n  \t}\n  \texports.Completions = Completions;\n  \t(function (Completions) {\n  \t})(Completions = exports.Completions || (exports.Completions = {}));\n  \t\n  } (completions$2));\n\n  var chat$1 = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Chat = void 0;\n  \tconst resource_1 = resource;\n  \tconst CompletionsAPI = __importStar(completions$2);\n  \tclass Chat extends resource_1.APIResource {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.completions = new CompletionsAPI.Completions(this._client);\n  \t    }\n  \t}\n  \texports.Chat = Chat;\n  \t(function (Chat) {\n  \t    Chat.Completions = CompletionsAPI.Completions;\n  \t})(Chat = exports.Chat || (exports.Chat = {}));\n  \t\n  } (chat$1));\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Chat = exports.Completions = void 0;\n  \tvar completions_1 = completions$2;\n  \tObject.defineProperty(exports, \"Completions\", { enumerable: true, get: function () { return completions_1.Completions; } });\n  \tvar chat_1 = chat$1;\n  \tObject.defineProperty(exports, \"Chat\", { enumerable: true, get: function () { return chat_1.Chat; } });\n  \t\n  } (chat$2));\n\n  var shared = {};\n\n  // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  Object.defineProperty(shared, \"__esModule\", { value: true });\n\n  var audio = {};\n\n  var speech = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Speech = void 0;\n  \tconst resource_1 = resource;\n  \tclass Speech extends resource_1.APIResource {\n  \t    /**\n  \t     * Generates audio from the input text.\n  \t     */\n  \t    create(body, options) {\n  \t        return this._client.post('/audio/speech', { body, ...options, __binaryResponse: true });\n  \t    }\n  \t}\n  \texports.Speech = Speech;\n  \t(function (Speech) {\n  \t})(Speech = exports.Speech || (exports.Speech = {}));\n  \t\n  } (speech));\n\n  var transcriptions = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Transcriptions = void 0;\n  \tconst resource_1 = resource;\n  \tconst Core = __importStar(requireCore());\n  \tclass Transcriptions extends resource_1.APIResource {\n  \t    /**\n  \t     * Transcribes audio into the input language.\n  \t     */\n  \t    create(body, options) {\n  \t        return this._client.post('/audio/transcriptions', Core.multipartFormRequestOptions({ body, ...options }));\n  \t    }\n  \t}\n  \texports.Transcriptions = Transcriptions;\n  \t(function (Transcriptions) {\n  \t})(Transcriptions = exports.Transcriptions || (exports.Transcriptions = {}));\n  \t\n  } (transcriptions));\n\n  var translations = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Translations = void 0;\n  \tconst resource_1 = resource;\n  \tconst Core = __importStar(requireCore());\n  \tclass Translations extends resource_1.APIResource {\n  \t    /**\n  \t     * Translates audio into English.\n  \t     */\n  \t    create(body, options) {\n  \t        return this._client.post('/audio/translations', Core.multipartFormRequestOptions({ body, ...options }));\n  \t    }\n  \t}\n  \texports.Translations = Translations;\n  \t(function (Translations) {\n  \t})(Translations = exports.Translations || (exports.Translations = {}));\n  \t\n  } (translations));\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Audio = void 0;\n  \tconst resource_1 = resource;\n  \tconst SpeechAPI = __importStar(speech);\n  \tconst TranscriptionsAPI = __importStar(transcriptions);\n  \tconst TranslationsAPI = __importStar(translations);\n  \tclass Audio extends resource_1.APIResource {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\n  \t        this.translations = new TranslationsAPI.Translations(this._client);\n  \t        this.speech = new SpeechAPI.Speech(this._client);\n  \t    }\n  \t}\n  \texports.Audio = Audio;\n  \t(function (Audio) {\n  \t    Audio.Transcriptions = TranscriptionsAPI.Transcriptions;\n  \t    Audio.Translations = TranslationsAPI.Translations;\n  \t    Audio.Speech = SpeechAPI.Speech;\n  \t})(Audio = exports.Audio || (exports.Audio = {}));\n  \t\n  } (audio));\n\n  var batches = {};\n\n  var hasRequiredBatches;\n\n  function requireBatches () {\n  \tif (hasRequiredBatches) return batches;\n  \thasRequiredBatches = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.BatchesPage = exports.Batches = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst BatchesAPI = __importStar(requireBatches());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Batches extends resource_1.APIResource {\n  \t\t    /**\n  \t\t     * Creates and executes a batch from an uploaded file of requests\n  \t\t     */\n  \t\t    create(body, options) {\n  \t\t        return this._client.post('/batches', { body, ...options });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Retrieves a batch.\n  \t\t     */\n  \t\t    retrieve(batchId, options) {\n  \t\t        return this._client.get(`/batches/${batchId}`, options);\n  \t\t    }\n  \t\t    list(query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list({}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList('/batches', BatchesPage, { query, ...options });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to\n  \t\t     * 10 minutes, before changing to `cancelled`, where it will have partial results\n  \t\t     * (if any) available in the output file.\n  \t\t     */\n  \t\t    cancel(batchId, options) {\n  \t\t        return this._client.post(`/batches/${batchId}/cancel`, options);\n  \t\t    }\n  \t\t}\n  \t\texports.Batches = Batches;\n  \t\tclass BatchesPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.BatchesPage = BatchesPage;\n  \t\t(function (Batches) {\n  \t\t    Batches.BatchesPage = BatchesAPI.BatchesPage;\n  \t\t})(Batches = exports.Batches || (exports.Batches = {}));\n  \t\t\n  \t} (batches));\n  \treturn batches;\n  }\n\n  var beta = {};\n\n  var assistants = {};\n\n  var hasRequiredAssistants;\n\n  function requireAssistants () {\n  \tif (hasRequiredAssistants) return assistants;\n  \thasRequiredAssistants = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.AssistantsPage = exports.Assistants = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst AssistantsAPI = __importStar(requireAssistants());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Assistants extends resource_1.APIResource {\n  \t\t    /**\n  \t\t     * Create an assistant with a model and instructions.\n  \t\t     */\n  \t\t    create(body, options) {\n  \t\t        return this._client.post('/assistants', {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Retrieves an assistant.\n  \t\t     */\n  \t\t    retrieve(assistantId, options) {\n  \t\t        return this._client.get(`/assistants/${assistantId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Modifies an assistant.\n  \t\t     */\n  \t\t    update(assistantId, body, options) {\n  \t\t        return this._client.post(`/assistants/${assistantId}`, {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    list(query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list({}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList('/assistants', AssistantsPage, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Delete an assistant.\n  \t\t     */\n  \t\t    del(assistantId, options) {\n  \t\t        return this._client.delete(`/assistants/${assistantId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t}\n  \t\texports.Assistants = Assistants;\n  \t\tclass AssistantsPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.AssistantsPage = AssistantsPage;\n  \t\t(function (Assistants) {\n  \t\t    Assistants.AssistantsPage = AssistantsAPI.AssistantsPage;\n  \t\t})(Assistants = exports.Assistants || (exports.Assistants = {}));\n  \t\t\n  \t} (assistants));\n  \treturn assistants;\n  }\n\n  var chat = {};\n\n  var completions$1 = {};\n\n  var ChatCompletionRunner$1 = {};\n\n  var AbstractChatCompletionRunner$1 = {};\n\n  var RunnableFunction = {};\n\n  Object.defineProperty(RunnableFunction, \"__esModule\", { value: true });\n  RunnableFunction.ParsingToolFunction = RunnableFunction.ParsingFunction = RunnableFunction.isRunnableFunctionWithParse = void 0;\n  function isRunnableFunctionWithParse(fn) {\n      return typeof fn.parse === 'function';\n  }\n  RunnableFunction.isRunnableFunctionWithParse = isRunnableFunctionWithParse;\n  /**\n   * This is helper class for passing a `function` and `parse` where the `function`\n   * argument type matches the `parse` return type.\n   *\n   * @deprecated - please use ParsingToolFunction instead.\n   */\n  class ParsingFunction {\n      constructor(input) {\n          this.function = input.function;\n          this.parse = input.parse;\n          this.parameters = input.parameters;\n          this.description = input.description;\n          this.name = input.name;\n      }\n  }\n  RunnableFunction.ParsingFunction = ParsingFunction;\n  /**\n   * This is helper class for passing a `function` and `parse` where the `function`\n   * argument type matches the `parse` return type.\n   */\n  class ParsingToolFunction {\n      constructor(input) {\n          this.type = 'function';\n          this.function = input;\n      }\n  }\n  RunnableFunction.ParsingToolFunction = ParsingToolFunction;\n\n  var chatCompletionUtils = {};\n\n  Object.defineProperty(chatCompletionUtils, \"__esModule\", { value: true });\n  chatCompletionUtils.isPresent = chatCompletionUtils.isToolMessage = chatCompletionUtils.isFunctionMessage = chatCompletionUtils.isAssistantMessage = void 0;\n  const isAssistantMessage = (message) => {\n      return message?.role === 'assistant';\n  };\n  chatCompletionUtils.isAssistantMessage = isAssistantMessage;\n  const isFunctionMessage = (message) => {\n      return message?.role === 'function';\n  };\n  chatCompletionUtils.isFunctionMessage = isFunctionMessage;\n  const isToolMessage = (message) => {\n      return message?.role === 'tool';\n  };\n  chatCompletionUtils.isToolMessage = isToolMessage;\n  function isPresent(obj) {\n      return obj != null;\n  }\n  chatCompletionUtils.isPresent = isPresent;\n\n  var EventStream$1 = {};\n\n  var __classPrivateFieldSet$2 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n      if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n      return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  };\n  var __classPrivateFieldGet$3 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n      return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  };\n  var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\n  Object.defineProperty(EventStream$1, \"__esModule\", { value: true });\n  EventStream$1.EventStream = void 0;\n  const error_1$4 = requireError();\n  class EventStream {\n      constructor() {\n          _EventStream_instances.add(this);\n          this.controller = new AbortController();\n          _EventStream_connectedPromise.set(this, void 0);\n          _EventStream_resolveConnectedPromise.set(this, () => { });\n          _EventStream_rejectConnectedPromise.set(this, () => { });\n          _EventStream_endPromise.set(this, void 0);\n          _EventStream_resolveEndPromise.set(this, () => { });\n          _EventStream_rejectEndPromise.set(this, () => { });\n          _EventStream_listeners.set(this, {});\n          _EventStream_ended.set(this, false);\n          _EventStream_errored.set(this, false);\n          _EventStream_aborted.set(this, false);\n          _EventStream_catchingPromiseCreated.set(this, false);\n          __classPrivateFieldSet$2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n              __classPrivateFieldSet$2(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n              __classPrivateFieldSet$2(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n          }), \"f\");\n          __classPrivateFieldSet$2(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n              __classPrivateFieldSet$2(this, _EventStream_resolveEndPromise, resolve, \"f\");\n              __classPrivateFieldSet$2(this, _EventStream_rejectEndPromise, reject, \"f\");\n          }), \"f\");\n          // Don't let these promises cause unhandled rejection errors.\n          // we will manually cause an unhandled rejection error later\n          // if the user hasn't registered any error listener or called\n          // any promise-returning method.\n          __classPrivateFieldGet$3(this, _EventStream_connectedPromise, \"f\").catch(() => { });\n          __classPrivateFieldGet$3(this, _EventStream_endPromise, \"f\").catch(() => { });\n      }\n      _run(executor) {\n          // Unfortunately if we call `executor()` immediately we get runtime errors about\n          // references to `this` before the `super()` constructor call returns.\n          setTimeout(() => {\n              executor().then(() => {\n                  this._emitFinal();\n                  this._emit('end');\n              }, __classPrivateFieldGet$3(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n          }, 0);\n      }\n      _connected() {\n          if (this.ended)\n              return;\n          __classPrivateFieldGet$3(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n          this._emit('connect');\n      }\n      get ended() {\n          return __classPrivateFieldGet$3(this, _EventStream_ended, \"f\");\n      }\n      get errored() {\n          return __classPrivateFieldGet$3(this, _EventStream_errored, \"f\");\n      }\n      get aborted() {\n          return __classPrivateFieldGet$3(this, _EventStream_aborted, \"f\");\n      }\n      abort() {\n          this.controller.abort();\n      }\n      /**\n       * Adds the listener function to the end of the listeners array for the event.\n       * No checks are made to see if the listener has already been added. Multiple calls passing\n       * the same combination of event and listener will result in the listener being added, and\n       * called, multiple times.\n       * @returns this ChatCompletionStream, so that calls can be chained\n       */\n      on(event, listener) {\n          const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, \"f\")[event] = []);\n          listeners.push({ listener });\n          return this;\n      }\n      /**\n       * Removes the specified listener from the listener array for the event.\n       * off() will remove, at most, one instance of a listener from the listener array. If any single\n       * listener has been added multiple times to the listener array for the specified event, then\n       * off() must be called multiple times to remove each instance.\n       * @returns this ChatCompletionStream, so that calls can be chained\n       */\n      off(event, listener) {\n          const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, \"f\")[event];\n          if (!listeners)\n              return this;\n          const index = listeners.findIndex((l) => l.listener === listener);\n          if (index >= 0)\n              listeners.splice(index, 1);\n          return this;\n      }\n      /**\n       * Adds a one-time listener function for the event. The next time the event is triggered,\n       * this listener is removed and then invoked.\n       * @returns this ChatCompletionStream, so that calls can be chained\n       */\n      once(event, listener) {\n          const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, \"f\")[event] = []);\n          listeners.push({ listener, once: true });\n          return this;\n      }\n      /**\n       * This is similar to `.once()`, but returns a Promise that resolves the next time\n       * the event is triggered, instead of calling a listener callback.\n       * @returns a Promise that resolves the next time given event is triggered,\n       * or rejects if an error is emitted.  (If you request the 'error' event,\n       * returns a promise that resolves with the error).\n       *\n       * Example:\n       *\n       *   const message = await stream.emitted('message') // rejects if the stream errors\n       */\n      emitted(event) {\n          return new Promise((resolve, reject) => {\n              __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, \"f\");\n              if (event !== 'error')\n                  this.once('error', reject);\n              this.once(event, resolve);\n          });\n      }\n      async done() {\n          __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, \"f\");\n          await __classPrivateFieldGet$3(this, _EventStream_endPromise, \"f\");\n      }\n      _emit(event, ...args) {\n          // make sure we don't emit any events after end\n          if (__classPrivateFieldGet$3(this, _EventStream_ended, \"f\")) {\n              return;\n          }\n          if (event === 'end') {\n              __classPrivateFieldSet$2(this, _EventStream_ended, true, \"f\");\n              __classPrivateFieldGet$3(this, _EventStream_resolveEndPromise, \"f\").call(this);\n          }\n          const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, \"f\")[event];\n          if (listeners) {\n              __classPrivateFieldGet$3(this, _EventStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n              listeners.forEach(({ listener }) => listener(...args));\n          }\n          if (event === 'abort') {\n              const error = args[0];\n              if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                  Promise.reject(error);\n              }\n              __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n              __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n              this._emit('end');\n              return;\n          }\n          if (event === 'error') {\n              // NOTE: _emit('error', error) should only be called from #handleError().\n              const error = args[0];\n              if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                  // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                  // If you are seeing stack traces here, make sure to handle errors via either:\n                  // - runner.on('error', () => ...)\n                  // - await runner.done()\n                  // - await runner.finalChatCompletion()\n                  // - etc.\n                  Promise.reject(error);\n              }\n              __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n              __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n              this._emit('end');\n          }\n      }\n      _emitFinal() { }\n  }\n  EventStream$1.EventStream = EventStream;\n  _EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n      __classPrivateFieldSet$2(this, _EventStream_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n          error = new error_1$4.APIUserAbortError();\n      }\n      if (error instanceof error_1$4.APIUserAbortError) {\n          __classPrivateFieldSet$2(this, _EventStream_aborted, true, \"f\");\n          return this._emit('abort', error);\n      }\n      if (error instanceof error_1$4.OpenAIError) {\n          return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n          const openAIError = new error_1$4.OpenAIError(error.message);\n          // @ts-ignore\n          openAIError.cause = error;\n          return this._emit('error', openAIError);\n      }\n      return this._emit('error', new error_1$4.OpenAIError(String(error)));\n  };\n\n  var parser$1 = {};\n\n  Object.defineProperty(parser$1, \"__esModule\", { value: true });\n  parser$1.validateInputTools = parser$1.hasAutoParseableInput = parser$1.shouldParseToolCall = parser$1.parseChatCompletion = parser$1.maybeParseChatCompletion = parser$1.isAutoParsableTool = parser$1.makeParseableTool = parser$1.isAutoParsableResponseFormat = parser$1.makeParseableResponseFormat = void 0;\n  const error_1$3 = requireError();\n  function makeParseableResponseFormat(response_format, parser) {\n      const obj = { ...response_format };\n      Object.defineProperties(obj, {\n          $brand: {\n              value: 'auto-parseable-response-format',\n              enumerable: false,\n          },\n          $parseRaw: {\n              value: parser,\n              enumerable: false,\n          },\n      });\n      return obj;\n  }\n  parser$1.makeParseableResponseFormat = makeParseableResponseFormat;\n  function isAutoParsableResponseFormat(response_format) {\n      return response_format?.['$brand'] === 'auto-parseable-response-format';\n  }\n  parser$1.isAutoParsableResponseFormat = isAutoParsableResponseFormat;\n  function makeParseableTool(tool, { parser, callback, }) {\n      const obj = { ...tool };\n      Object.defineProperties(obj, {\n          $brand: {\n              value: 'auto-parseable-tool',\n              enumerable: false,\n          },\n          $parseRaw: {\n              value: parser,\n              enumerable: false,\n          },\n          $callback: {\n              value: callback,\n              enumerable: false,\n          },\n      });\n      return obj;\n  }\n  parser$1.makeParseableTool = makeParseableTool;\n  function isAutoParsableTool(tool) {\n      return tool?.['$brand'] === 'auto-parseable-tool';\n  }\n  parser$1.isAutoParsableTool = isAutoParsableTool;\n  function maybeParseChatCompletion(completion, params) {\n      if (!params || !hasAutoParseableInput(params)) {\n          return {\n              ...completion,\n              choices: completion.choices.map((choice) => ({\n                  ...choice,\n                  message: { ...choice.message, parsed: null, tool_calls: choice.message.tool_calls ?? [] },\n              })),\n          };\n      }\n      return parseChatCompletion(completion, params);\n  }\n  parser$1.maybeParseChatCompletion = maybeParseChatCompletion;\n  function parseChatCompletion(completion, params) {\n      const choices = completion.choices.map((choice) => {\n          if (choice.finish_reason === 'length') {\n              throw new error_1$3.LengthFinishReasonError();\n          }\n          if (choice.finish_reason === 'content_filter') {\n              throw new error_1$3.ContentFilterFinishReasonError();\n          }\n          return {\n              ...choice,\n              message: {\n                  ...choice.message,\n                  tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall$1(params, toolCall)) ?? [],\n                  parsed: choice.message.content && !choice.message.refusal ?\n                      parseResponseFormat(params, choice.message.content)\n                      : null,\n              },\n          };\n      });\n      return { ...completion, choices };\n  }\n  parser$1.parseChatCompletion = parseChatCompletion;\n  function parseResponseFormat(params, content) {\n      if (params.response_format?.type !== 'json_schema') {\n          return null;\n      }\n      if (params.response_format?.type === 'json_schema') {\n          if ('$parseRaw' in params.response_format) {\n              const response_format = params.response_format;\n              return response_format.$parseRaw(content);\n          }\n          return JSON.parse(content);\n      }\n      return null;\n  }\n  function parseToolCall$1(params, toolCall) {\n      const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n      return {\n          ...toolCall,\n          function: {\n              ...toolCall.function,\n              parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\n                  : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\n                      : null,\n          },\n      };\n  }\n  function shouldParseToolCall(params, toolCall) {\n      if (!params) {\n          return false;\n      }\n      const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n      return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n  }\n  parser$1.shouldParseToolCall = shouldParseToolCall;\n  function hasAutoParseableInput(params) {\n      if (isAutoParsableResponseFormat(params.response_format)) {\n          return true;\n      }\n      return (params.tools?.some((t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true)) ?? false);\n  }\n  parser$1.hasAutoParseableInput = hasAutoParseableInput;\n  function validateInputTools(tools) {\n      for (const tool of tools ?? []) {\n          if (tool.type !== 'function') {\n              throw new error_1$3.OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n          }\n          if (tool.function.strict !== true) {\n              throw new error_1$3.OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n          }\n      }\n  }\n  parser$1.validateInputTools = validateInputTools;\n\n  var __classPrivateFieldGet$2 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n      return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  };\n  var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\n  Object.defineProperty(AbstractChatCompletionRunner$1, \"__esModule\", { value: true });\n  AbstractChatCompletionRunner$1.AbstractChatCompletionRunner = void 0;\n  const error_1$2 = requireError();\n  const RunnableFunction_1 = RunnableFunction;\n  const chatCompletionUtils_1$1 = chatCompletionUtils;\n  const EventStream_1$1 = EventStream$1;\n  const parser_1$2 = parser$1;\n  const DEFAULT_MAX_CHAT_COMPLETIONS = 10;\n  class AbstractChatCompletionRunner extends EventStream_1$1.EventStream {\n      constructor() {\n          super(...arguments);\n          _AbstractChatCompletionRunner_instances.add(this);\n          this._chatCompletions = [];\n          this.messages = [];\n      }\n      _addChatCompletion(chatCompletion) {\n          this._chatCompletions.push(chatCompletion);\n          this._emit('chatCompletion', chatCompletion);\n          const message = chatCompletion.choices[0]?.message;\n          if (message)\n              this._addMessage(message);\n          return chatCompletion;\n      }\n      _addMessage(message, emit = true) {\n          if (!('content' in message))\n              message.content = null;\n          this.messages.push(message);\n          if (emit) {\n              this._emit('message', message);\n              if (((0, chatCompletionUtils_1$1.isFunctionMessage)(message) || (0, chatCompletionUtils_1$1.isToolMessage)(message)) && message.content) {\n                  // Note, this assumes that {role: 'tool', content: } is always the result of a call of tool of type=function.\n                  this._emit('functionCallResult', message.content);\n              }\n              else if ((0, chatCompletionUtils_1$1.isAssistantMessage)(message) && message.function_call) {\n                  this._emit('functionCall', message.function_call);\n              }\n              else if ((0, chatCompletionUtils_1$1.isAssistantMessage)(message) && message.tool_calls) {\n                  for (const tool_call of message.tool_calls) {\n                      if (tool_call.type === 'function') {\n                          this._emit('functionCall', tool_call.function);\n                      }\n                  }\n              }\n          }\n      }\n      /**\n       * @returns a promise that resolves with the final ChatCompletion, or rejects\n       * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n       */\n      async finalChatCompletion() {\n          await this.done();\n          const completion = this._chatCompletions[this._chatCompletions.length - 1];\n          if (!completion)\n              throw new error_1$2.OpenAIError('stream ended without producing a ChatCompletion');\n          return completion;\n      }\n      /**\n       * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n       */\n      async finalContent() {\n          await this.done();\n          return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n      }\n      /**\n       * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n       * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n       */\n      async finalMessage() {\n          await this.done();\n          return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n      }\n      /**\n       * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n       */\n      async finalFunctionCall() {\n          await this.done();\n          return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n      }\n      async finalFunctionCallResult() {\n          await this.done();\n          return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n      }\n      async totalUsage() {\n          await this.done();\n          return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n      }\n      allChatCompletions() {\n          return [...this._chatCompletions];\n      }\n      _emitFinal() {\n          const completion = this._chatCompletions[this._chatCompletions.length - 1];\n          if (completion)\n              this._emit('finalChatCompletion', completion);\n          const finalMessage = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n          if (finalMessage)\n              this._emit('finalMessage', finalMessage);\n          const finalContent = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n          if (finalContent)\n              this._emit('finalContent', finalContent);\n          const finalFunctionCall = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n          if (finalFunctionCall)\n              this._emit('finalFunctionCall', finalFunctionCall);\n          const finalFunctionCallResult = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n          if (finalFunctionCallResult != null)\n              this._emit('finalFunctionCallResult', finalFunctionCallResult);\n          if (this._chatCompletions.some((c) => c.usage)) {\n              this._emit('totalUsage', __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n          }\n      }\n      async _createChatCompletion(client, params, options) {\n          const signal = options?.signal;\n          if (signal) {\n              if (signal.aborted)\n                  this.controller.abort();\n              signal.addEventListener('abort', () => this.controller.abort());\n          }\n          __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n          const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });\n          this._connected();\n          return this._addChatCompletion((0, parser_1$2.parseChatCompletion)(chatCompletion, params));\n      }\n      async _runChatCompletion(client, params, options) {\n          for (const message of params.messages) {\n              this._addMessage(message, false);\n          }\n          return await this._createChatCompletion(client, params, options);\n      }\n      async _runFunctions(client, params, options) {\n          const role = 'function';\n          const { function_call = 'auto', stream, ...restParams } = params;\n          const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n          const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n          const functionsByName = {};\n          for (const f of params.functions) {\n              functionsByName[f.name || f.function.name] = f;\n          }\n          const functions = params.functions.map((f) => ({\n              name: f.name || f.function.name,\n              parameters: f.parameters,\n              description: f.description,\n          }));\n          for (const message of params.messages) {\n              this._addMessage(message, false);\n          }\n          for (let i = 0; i < maxChatCompletions; ++i) {\n              const chatCompletion = await this._createChatCompletion(client, {\n                  ...restParams,\n                  function_call,\n                  functions,\n                  messages: [...this.messages],\n              }, options);\n              const message = chatCompletion.choices[0]?.message;\n              if (!message) {\n                  throw new error_1$2.OpenAIError(`missing message in ChatCompletion response`);\n              }\n              if (!message.function_call)\n                  return;\n              const { name, arguments: args } = message.function_call;\n              const fn = functionsByName[name];\n              if (!fn) {\n                  const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n                    .map((f) => JSON.stringify(f.name))\n                    .join(', ')}. Please try again`;\n                  this._addMessage({ role, name, content });\n                  continue;\n              }\n              else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                  const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                  this._addMessage({ role, name, content });\n                  continue;\n              }\n              let parsed;\n              try {\n                  parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n              }\n              catch (error) {\n                  this._addMessage({\n                      role,\n                      name,\n                      content: error instanceof Error ? error.message : String(error),\n                  });\n                  continue;\n              }\n              // @ts-expect-error it can't rule out `never` type.\n              const rawContent = await fn.function(parsed, this);\n              const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n              this._addMessage({ role, name, content });\n              if (singleFunctionToCall)\n                  return;\n          }\n      }\n      async _runTools(client, params, options) {\n          const role = 'tool';\n          const { tool_choice = 'auto', stream, ...restParams } = params;\n          const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n          const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n          // TODO(someday): clean this logic up\n          const inputTools = params.tools.map((tool) => {\n              if ((0, parser_1$2.isAutoParsableTool)(tool)) {\n                  if (!tool.$callback) {\n                      throw new error_1$2.OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n                  }\n                  return {\n                      type: 'function',\n                      function: {\n                          function: tool.$callback,\n                          name: tool.function.name,\n                          description: tool.function.description || '',\n                          parameters: tool.function.parameters,\n                          parse: tool.$parseRaw,\n                          strict: true,\n                      },\n                  };\n              }\n              return tool;\n          });\n          const functionsByName = {};\n          for (const f of inputTools) {\n              if (f.type === 'function') {\n                  functionsByName[f.function.name || f.function.function.name] = f.function;\n              }\n          }\n          const tools = 'tools' in params ?\n              inputTools.map((t) => t.type === 'function' ?\n                  {\n                      type: 'function',\n                      function: {\n                          name: t.function.name || t.function.function.name,\n                          parameters: t.function.parameters,\n                          description: t.function.description,\n                          strict: t.function.strict,\n                      },\n                  }\n                  : t)\n              : undefined;\n          for (const message of params.messages) {\n              this._addMessage(message, false);\n          }\n          for (let i = 0; i < maxChatCompletions; ++i) {\n              const chatCompletion = await this._createChatCompletion(client, {\n                  ...restParams,\n                  tool_choice,\n                  tools,\n                  messages: [...this.messages],\n              }, options);\n              const message = chatCompletion.choices[0]?.message;\n              if (!message) {\n                  throw new error_1$2.OpenAIError(`missing message in ChatCompletion response`);\n              }\n              if (!message.tool_calls?.length) {\n                  return;\n              }\n              for (const tool_call of message.tool_calls) {\n                  if (tool_call.type !== 'function')\n                      continue;\n                  const tool_call_id = tool_call.id;\n                  const { name, arguments: args } = tool_call.function;\n                  const fn = functionsByName[name];\n                  if (!fn) {\n                      const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName)\n                        .map((name) => JSON.stringify(name))\n                        .join(', ')}. Please try again`;\n                      this._addMessage({ role, tool_call_id, content });\n                      continue;\n                  }\n                  else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                      const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                      this._addMessage({ role, tool_call_id, content });\n                      continue;\n                  }\n                  let parsed;\n                  try {\n                      parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n                  }\n                  catch (error) {\n                      const content = error instanceof Error ? error.message : String(error);\n                      this._addMessage({ role, tool_call_id, content });\n                      continue;\n                  }\n                  // @ts-expect-error it can't rule out `never` type.\n                  const rawContent = await fn.function(parsed, this);\n                  const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n                  this._addMessage({ role, tool_call_id, content });\n                  if (singleFunctionToCall) {\n                      return;\n                  }\n              }\n          }\n          return;\n      }\n  }\n  AbstractChatCompletionRunner$1.AbstractChatCompletionRunner = AbstractChatCompletionRunner;\n  _AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;\n  }, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n      let i = this.messages.length;\n      while (i-- > 0) {\n          const message = this.messages[i];\n          if ((0, chatCompletionUtils_1$1.isAssistantMessage)(message)) {\n              const { function_call, ...rest } = message;\n              const ret = {\n                  ...rest,\n                  content: message.content ?? null,\n                  refusal: message.refusal ?? null,\n              };\n              if (function_call) {\n                  ret.function_call = function_call;\n              }\n              return ret;\n          }\n      }\n      throw new error_1$2.OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n  }, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n      for (let i = this.messages.length - 1; i >= 0; i--) {\n          const message = this.messages[i];\n          if ((0, chatCompletionUtils_1$1.isAssistantMessage)(message) && message?.function_call) {\n              return message.function_call;\n          }\n          if ((0, chatCompletionUtils_1$1.isAssistantMessage)(message) && message?.tool_calls?.length) {\n              return message.tool_calls.at(-1)?.function;\n          }\n      }\n      return;\n  }, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n      for (let i = this.messages.length - 1; i >= 0; i--) {\n          const message = this.messages[i];\n          if ((0, chatCompletionUtils_1$1.isFunctionMessage)(message) && message.content != null) {\n              return message.content;\n          }\n          if ((0, chatCompletionUtils_1$1.isToolMessage)(message) &&\n              message.content != null &&\n              typeof message.content === 'string' &&\n              this.messages.some((x) => x.role === 'assistant' &&\n                  x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id))) {\n              return message.content;\n          }\n      }\n      return;\n  }, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n      const total = {\n          completion_tokens: 0,\n          prompt_tokens: 0,\n          total_tokens: 0,\n      };\n      for (const { usage } of this._chatCompletions) {\n          if (usage) {\n              total.completion_tokens += usage.completion_tokens;\n              total.prompt_tokens += usage.prompt_tokens;\n              total.total_tokens += usage.total_tokens;\n          }\n      }\n      return total;\n  }, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n      if (params.n != null && params.n > 1) {\n          throw new error_1$2.OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n      }\n  }, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n      return (typeof rawContent === 'string' ? rawContent\n          : rawContent === undefined ? 'undefined'\n              : JSON.stringify(rawContent));\n  };\n\n  Object.defineProperty(ChatCompletionRunner$1, \"__esModule\", { value: true });\n  ChatCompletionRunner$1.ChatCompletionRunner = void 0;\n  const AbstractChatCompletionRunner_1$1 = AbstractChatCompletionRunner$1;\n  const chatCompletionUtils_1 = chatCompletionUtils;\n  class ChatCompletionRunner extends AbstractChatCompletionRunner_1$1.AbstractChatCompletionRunner {\n      /** @deprecated - please use `runTools` instead. */\n      static runFunctions(client, params, options) {\n          const runner = new ChatCompletionRunner();\n          const opts = {\n              ...options,\n              headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n          };\n          runner._run(() => runner._runFunctions(client, params, opts));\n          return runner;\n      }\n      static runTools(client, params, options) {\n          const runner = new ChatCompletionRunner();\n          const opts = {\n              ...options,\n              headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n          };\n          runner._run(() => runner._runTools(client, params, opts));\n          return runner;\n      }\n      _addMessage(message, emit = true) {\n          super._addMessage(message, emit);\n          if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.content) {\n              this._emit('content', message.content);\n          }\n      }\n  }\n  ChatCompletionRunner$1.ChatCompletionRunner = ChatCompletionRunner;\n\n  var ChatCompletionStreamingRunner$1 = {};\n\n  var ChatCompletionStream$1 = {};\n\n  var parser = {};\n\n  Object.defineProperty(parser, \"__esModule\", { value: true });\n  parser.MalformedJSON = parser.PartialJSON = parser.partialParse = void 0;\n  const STR = 0b000000001;\n  const NUM = 0b000000010;\n  const ARR = 0b000000100;\n  const OBJ = 0b000001000;\n  const NULL = 0b000010000;\n  const BOOL = 0b000100000;\n  const NAN = 0b001000000;\n  const INFINITY = 0b010000000;\n  const MINUS_INFINITY = 0b100000000;\n  const INF = INFINITY | MINUS_INFINITY;\n  const SPECIAL = NULL | BOOL | INF | NAN;\n  const ATOM = STR | NUM | SPECIAL;\n  const COLLECTION = ARR | OBJ;\n  const ALL = ATOM | COLLECTION;\n  const Allow = {\n      STR,\n      NUM,\n      ARR,\n      OBJ,\n      NULL,\n      BOOL,\n      NAN,\n      INFINITY,\n      MINUS_INFINITY,\n      INF,\n      SPECIAL,\n      ATOM,\n      COLLECTION,\n      ALL,\n  };\n  // The JSON string segment was unable to be parsed completely\n  class PartialJSON extends Error {\n  }\n  parser.PartialJSON = PartialJSON;\n  class MalformedJSON extends Error {\n  }\n  parser.MalformedJSON = MalformedJSON;\n  /**\n   * Parse incomplete JSON\n   * @param {string} jsonString Partial JSON to be parsed\n   * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n   * @returns The parsed JSON\n   * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n   * @throws {MalformedJSON} If the JSON is malformed\n   */\n  function parseJSON(jsonString, allowPartial = Allow.ALL) {\n      if (typeof jsonString !== 'string') {\n          throw new TypeError(`expecting str, got ${typeof jsonString}`);\n      }\n      if (!jsonString.trim()) {\n          throw new Error(`${jsonString} is empty`);\n      }\n      return _parseJSON(jsonString.trim(), allowPartial);\n  }\n  const _parseJSON = (jsonString, allow) => {\n      const length = jsonString.length;\n      let index = 0;\n      const markPartialJSON = (msg) => {\n          throw new PartialJSON(`${msg} at position ${index}`);\n      };\n      const throwMalformedError = (msg) => {\n          throw new MalformedJSON(`${msg} at position ${index}`);\n      };\n      const parseAny = () => {\n          skipBlank();\n          if (index >= length)\n              markPartialJSON('Unexpected end of input');\n          if (jsonString[index] === '\"')\n              return parseStr();\n          if (jsonString[index] === '{')\n              return parseObj();\n          if (jsonString[index] === '[')\n              return parseArr();\n          if (jsonString.substring(index, index + 4) === 'null' ||\n              (Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index)))) {\n              index += 4;\n              return null;\n          }\n          if (jsonString.substring(index, index + 4) === 'true' ||\n              (Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index)))) {\n              index += 4;\n              return true;\n          }\n          if (jsonString.substring(index, index + 5) === 'false' ||\n              (Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index)))) {\n              index += 5;\n              return false;\n          }\n          if (jsonString.substring(index, index + 8) === 'Infinity' ||\n              (Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index)))) {\n              index += 8;\n              return Infinity;\n          }\n          if (jsonString.substring(index, index + 9) === '-Infinity' ||\n              (Allow.MINUS_INFINITY & allow &&\n                  1 < length - index &&\n                  length - index < 9 &&\n                  '-Infinity'.startsWith(jsonString.substring(index)))) {\n              index += 9;\n              return -Infinity;\n          }\n          if (jsonString.substring(index, index + 3) === 'NaN' ||\n              (Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index)))) {\n              index += 3;\n              return NaN;\n          }\n          return parseNum();\n      };\n      const parseStr = () => {\n          const start = index;\n          let escape = false;\n          index++; // skip initial quote\n          while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === '\\\\'))) {\n              escape = jsonString[index] === '\\\\' ? !escape : false;\n              index++;\n          }\n          if (jsonString.charAt(index) == '\"') {\n              try {\n                  return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n              }\n              catch (e) {\n                  throwMalformedError(String(e));\n              }\n          }\n          else if (Allow.STR & allow) {\n              try {\n                  return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n              }\n              catch (e) {\n                  // SyntaxError: Invalid escape sequence\n                  return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n              }\n          }\n          markPartialJSON('Unterminated string literal');\n      };\n      const parseObj = () => {\n          index++; // skip initial brace\n          skipBlank();\n          const obj = {};\n          try {\n              while (jsonString[index] !== '}') {\n                  skipBlank();\n                  if (index >= length && Allow.OBJ & allow)\n                      return obj;\n                  const key = parseStr();\n                  skipBlank();\n                  index++; // skip colon\n                  try {\n                      const value = parseAny();\n                      Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });\n                  }\n                  catch (e) {\n                      if (Allow.OBJ & allow)\n                          return obj;\n                      else\n                          throw e;\n                  }\n                  skipBlank();\n                  if (jsonString[index] === ',')\n                      index++; // skip comma\n              }\n          }\n          catch (e) {\n              if (Allow.OBJ & allow)\n                  return obj;\n              else\n                  markPartialJSON(\"Expected '}' at end of object\");\n          }\n          index++; // skip final brace\n          return obj;\n      };\n      const parseArr = () => {\n          index++; // skip initial bracket\n          const arr = [];\n          try {\n              while (jsonString[index] !== ']') {\n                  arr.push(parseAny());\n                  skipBlank();\n                  if (jsonString[index] === ',') {\n                      index++; // skip comma\n                  }\n              }\n          }\n          catch (e) {\n              if (Allow.ARR & allow) {\n                  return arr;\n              }\n              markPartialJSON(\"Expected ']' at end of array\");\n          }\n          index++; // skip final bracket\n          return arr;\n      };\n      const parseNum = () => {\n          if (index === 0) {\n              if (jsonString === '-' && Allow.NUM & allow)\n                  markPartialJSON(\"Not sure what '-' is\");\n              try {\n                  return JSON.parse(jsonString);\n              }\n              catch (e) {\n                  if (Allow.NUM & allow) {\n                      try {\n                          if ('.' === jsonString[jsonString.length - 1])\n                              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\n                          return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\n                      }\n                      catch (e) { }\n                  }\n                  throwMalformedError(String(e));\n              }\n          }\n          const start = index;\n          if (jsonString[index] === '-')\n              index++;\n          while (jsonString[index] && !',]}'.includes(jsonString[index]))\n              index++;\n          if (index == length && !(Allow.NUM & allow))\n              markPartialJSON('Unterminated number literal');\n          try {\n              return JSON.parse(jsonString.substring(start, index));\n          }\n          catch (e) {\n              if (jsonString.substring(start, index) === '-' && Allow.NUM & allow)\n                  markPartialJSON(\"Not sure what '-' is\");\n              try {\n                  return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n              }\n              catch (e) {\n                  throwMalformedError(String(e));\n              }\n          }\n      };\n      const skipBlank = () => {\n          while (index < length && ' \\n\\r\\t'.includes(jsonString[index])) {\n              index++;\n          }\n      };\n      return parseAny();\n  };\n  // using this function with malformed JSON is undefined behavior\n  const partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);\n  parser.partialParse = partialParse;\n\n  var __classPrivateFieldSet$1 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n      if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n      return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  };\n  var __classPrivateFieldGet$1 = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n      return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  };\n  var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;\n  Object.defineProperty(ChatCompletionStream$1, \"__esModule\", { value: true });\n  ChatCompletionStream$1.ChatCompletionStream = void 0;\n  const error_1$1 = requireError();\n  const AbstractChatCompletionRunner_1 = AbstractChatCompletionRunner$1;\n  const streaming_1$1 = requireStreaming();\n  const parser_1$1 = parser$1;\n  const parser_2 = parser;\n  class ChatCompletionStream extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {\n      constructor(params) {\n          super();\n          _ChatCompletionStream_instances.add(this);\n          _ChatCompletionStream_params.set(this, void 0);\n          _ChatCompletionStream_choiceEventStates.set(this, void 0);\n          _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n          __classPrivateFieldSet$1(this, _ChatCompletionStream_params, params, \"f\");\n          __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n      }\n      get currentChatCompletionSnapshot() {\n          return __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n      }\n      /**\n       * Intended for use on the frontend, consuming a stream produced with\n       * `.toReadableStream()` on the backend.\n       *\n       * Note that messages sent to the model do not appear in `.on('message')`\n       * in this context.\n       */\n      static fromReadableStream(stream) {\n          const runner = new ChatCompletionStream(null);\n          runner._run(() => runner._fromReadableStream(stream));\n          return runner;\n      }\n      static createChatCompletion(client, params, options) {\n          const runner = new ChatCompletionStream(params);\n          runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n          return runner;\n      }\n      async _createChatCompletion(client, params, options) {\n          super._createChatCompletion;\n          const signal = options?.signal;\n          if (signal) {\n              if (signal.aborted)\n                  this.controller.abort();\n              signal.addEventListener('abort', () => this.controller.abort());\n          }\n          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n          const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n          this._connected();\n          for await (const chunk of stream) {\n              __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n          }\n          if (stream.controller.signal?.aborted) {\n              throw new error_1$1.APIUserAbortError();\n          }\n          return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n      }\n      async _fromReadableStream(readableStream, options) {\n          const signal = options?.signal;\n          if (signal) {\n              if (signal.aborted)\n                  this.controller.abort();\n              signal.addEventListener('abort', () => this.controller.abort());\n          }\n          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n          this._connected();\n          const stream = streaming_1$1.Stream.fromReadableStream(readableStream, this.controller);\n          let chatId;\n          for await (const chunk of stream) {\n              if (chatId && chatId !== chunk.id) {\n                  // A new request has been made.\n                  this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n              }\n              __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n              chatId = chunk.id;\n          }\n          if (stream.controller.signal?.aborted) {\n              throw new error_1$1.APIUserAbortError();\n          }\n          return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n      }\n      [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n          if (this.ended)\n              return;\n          __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n      }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n          let state = __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n          if (state) {\n              return state;\n          }\n          state = {\n              content_done: false,\n              refusal_done: false,\n              logprobs_content_done: false,\n              logprobs_refusal_done: false,\n              done_tool_calls: new Set(),\n              current_tool_call_index: null,\n          };\n          __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n          return state;\n      }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n          if (this.ended)\n              return;\n          const completion = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n          this._emit('chunk', chunk, completion);\n          for (const choice of chunk.choices) {\n              const choiceSnapshot = completion.choices[choice.index];\n              if (choice.delta.content != null &&\n                  choiceSnapshot.message?.role === 'assistant' &&\n                  choiceSnapshot.message?.content) {\n                  this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n                  this._emit('content.delta', {\n                      delta: choice.delta.content,\n                      snapshot: choiceSnapshot.message.content,\n                      parsed: choiceSnapshot.message.parsed,\n                  });\n              }\n              if (choice.delta.refusal != null &&\n                  choiceSnapshot.message?.role === 'assistant' &&\n                  choiceSnapshot.message?.refusal) {\n                  this._emit('refusal.delta', {\n                      delta: choice.delta.refusal,\n                      snapshot: choiceSnapshot.message.refusal,\n                  });\n              }\n              if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n                  this._emit('logprobs.content.delta', {\n                      content: choice.logprobs?.content,\n                      snapshot: choiceSnapshot.logprobs?.content ?? [],\n                  });\n              }\n              if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n                  this._emit('logprobs.refusal.delta', {\n                      refusal: choice.logprobs?.refusal,\n                      snapshot: choiceSnapshot.logprobs?.refusal ?? [],\n                  });\n              }\n              const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n              if (choiceSnapshot.finish_reason) {\n                  __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                  if (state.current_tool_call_index != null) {\n                      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                  }\n              }\n              for (const toolCall of choice.delta.tool_calls ?? []) {\n                  if (state.current_tool_call_index !== toolCall.index) {\n                      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                      // new tool call started, the previous one is done\n                      if (state.current_tool_call_index != null) {\n                          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                      }\n                  }\n                  state.current_tool_call_index = toolCall.index;\n              }\n              for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n                  const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n                  if (!toolCallSnapshot?.type) {\n                      continue;\n                  }\n                  if (toolCallSnapshot?.type === 'function') {\n                      this._emit('tool_calls.function.arguments.delta', {\n                          name: toolCallSnapshot.function?.name,\n                          index: toolCallDelta.index,\n                          arguments: toolCallSnapshot.function.arguments,\n                          parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n                          arguments_delta: toolCallDelta.function?.arguments ?? '',\n                      });\n                  }\n                  else {\n                      assertNever(toolCallSnapshot?.type);\n                  }\n              }\n          }\n      }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n          const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n          if (state.done_tool_calls.has(toolCallIndex)) {\n              // we've already fired the done event\n              return;\n          }\n          const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n          if (!toolCallSnapshot) {\n              throw new Error('no tool call snapshot');\n          }\n          if (!toolCallSnapshot.type) {\n              throw new Error('tool call snapshot missing `type`');\n          }\n          if (toolCallSnapshot.type === 'function') {\n              const inputTool = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, \"f\")?.tools?.find((tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);\n              this._emit('tool_calls.function.arguments.done', {\n                  name: toolCallSnapshot.function.name,\n                  index: toolCallIndex,\n                  arguments: toolCallSnapshot.function.arguments,\n                  parsed_arguments: (0, parser_1$1.isAutoParsableTool)(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\n                      : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\n                          : null,\n              });\n          }\n          else {\n              assertNever(toolCallSnapshot.type);\n          }\n      }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n          const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n          if (choiceSnapshot.message.content && !state.content_done) {\n              state.content_done = true;\n              const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n              this._emit('content.done', {\n                  content: choiceSnapshot.message.content,\n                  parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null,\n              });\n          }\n          if (choiceSnapshot.message.refusal && !state.refusal_done) {\n              state.refusal_done = true;\n              this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\n          }\n          if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n              state.logprobs_content_done = true;\n              this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\n          }\n          if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n              state.logprobs_refusal_done = true;\n              this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\n          }\n      }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n          if (this.ended) {\n              throw new error_1$1.OpenAIError(`stream has ended, this shouldn't happen`);\n          }\n          const snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n          if (!snapshot) {\n              throw new error_1$1.OpenAIError(`request ended without sending any chunks`);\n          }\n          __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n          __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n          return finalizeChatCompletion(snapshot, __classPrivateFieldGet$1(this, _ChatCompletionStream_params, \"f\"));\n      }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n          const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, \"f\")?.response_format;\n          if ((0, parser_1$1.isAutoParsableResponseFormat)(responseFormat)) {\n              return responseFormat;\n          }\n          return null;\n      }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n          var _a, _b, _c, _d;\n          let snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n          const { choices, ...rest } = chunk;\n          if (!snapshot) {\n              snapshot = __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n                  ...rest,\n                  choices: [],\n              }, \"f\");\n          }\n          else {\n              Object.assign(snapshot, rest);\n          }\n          for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n              let choice = snapshot.choices[index];\n              if (!choice) {\n                  choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n              }\n              if (logprobs) {\n                  if (!choice.logprobs) {\n                      choice.logprobs = Object.assign({}, logprobs);\n                  }\n                  else {\n                      const { content, refusal, ...rest } = logprobs;\n                      Object.assign(choice.logprobs, rest);\n                      if (content) {\n                          (_a = choice.logprobs).content ?? (_a.content = []);\n                          choice.logprobs.content.push(...content);\n                      }\n                      if (refusal) {\n                          (_b = choice.logprobs).refusal ?? (_b.refusal = []);\n                          choice.logprobs.refusal.push(...refusal);\n                      }\n                  }\n              }\n              if (finish_reason) {\n                  choice.finish_reason = finish_reason;\n                  if (__classPrivateFieldGet$1(this, _ChatCompletionStream_params, \"f\") && (0, parser_1$1.hasAutoParseableInput)(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, \"f\"))) {\n                      if (finish_reason === 'length') {\n                          throw new error_1$1.LengthFinishReasonError();\n                      }\n                      if (finish_reason === 'content_filter') {\n                          throw new error_1$1.ContentFilterFinishReasonError();\n                      }\n                  }\n              }\n              Object.assign(choice, other);\n              if (!delta)\n                  continue; // Shouldn't happen; just in case.\n              const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\n              Object.assign(choice.message, rest);\n              if (refusal) {\n                  choice.message.refusal = (choice.message.refusal || '') + refusal;\n              }\n              if (role)\n                  choice.message.role = role;\n              if (function_call) {\n                  if (!choice.message.function_call) {\n                      choice.message.function_call = function_call;\n                  }\n                  else {\n                      if (function_call.name)\n                          choice.message.function_call.name = function_call.name;\n                      if (function_call.arguments) {\n                          (_c = choice.message.function_call).arguments ?? (_c.arguments = '');\n                          choice.message.function_call.arguments += function_call.arguments;\n                      }\n                  }\n              }\n              if (content) {\n                  choice.message.content = (choice.message.content || '') + content;\n                  if (!choice.message.refusal && __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {\n                      choice.message.parsed = (0, parser_2.partialParse)(choice.message.content);\n                  }\n              }\n              if (tool_calls) {\n                  if (!choice.message.tool_calls)\n                      choice.message.tool_calls = [];\n                  for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n                      const tool_call = ((_d = choice.message.tool_calls)[index] ?? (_d[index] = {}));\n                      Object.assign(tool_call, rest);\n                      if (id)\n                          tool_call.id = id;\n                      if (type)\n                          tool_call.type = type;\n                      if (fn)\n                          tool_call.function ?? (tool_call.function = { name: fn.name ?? '', arguments: '' });\n                      if (fn?.name)\n                          tool_call.function.name = fn.name;\n                      if (fn?.arguments) {\n                          tool_call.function.arguments += fn.arguments;\n                          if ((0, parser_1$1.shouldParseToolCall)(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, \"f\"), tool_call)) {\n                              tool_call.function.parsed_arguments = (0, parser_2.partialParse)(tool_call.function.arguments);\n                          }\n                      }\n                  }\n              }\n          }\n          return snapshot;\n      }, Symbol.asyncIterator)]() {\n          const pushQueue = [];\n          const readQueue = [];\n          let done = false;\n          this.on('chunk', (chunk) => {\n              const reader = readQueue.shift();\n              if (reader) {\n                  reader.resolve(chunk);\n              }\n              else {\n                  pushQueue.push(chunk);\n              }\n          });\n          this.on('end', () => {\n              done = true;\n              for (const reader of readQueue) {\n                  reader.resolve(undefined);\n              }\n              readQueue.length = 0;\n          });\n          this.on('abort', (err) => {\n              done = true;\n              for (const reader of readQueue) {\n                  reader.reject(err);\n              }\n              readQueue.length = 0;\n          });\n          this.on('error', (err) => {\n              done = true;\n              for (const reader of readQueue) {\n                  reader.reject(err);\n              }\n              readQueue.length = 0;\n          });\n          return {\n              next: async () => {\n                  if (!pushQueue.length) {\n                      if (done) {\n                          return { value: undefined, done: true };\n                      }\n                      return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                  }\n                  const chunk = pushQueue.shift();\n                  return { value: chunk, done: false };\n              },\n              return: async () => {\n                  this.abort();\n                  return { value: undefined, done: true };\n              },\n          };\n      }\n      toReadableStream() {\n          const stream = new streaming_1$1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n          return stream.toReadableStream();\n      }\n  }\n  ChatCompletionStream$1.ChatCompletionStream = ChatCompletionStream;\n  function finalizeChatCompletion(snapshot, params) {\n      const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n      const completion = {\n          ...rest,\n          id,\n          choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {\n              if (!finish_reason) {\n                  throw new error_1$1.OpenAIError(`missing finish_reason for choice ${index}`);\n              }\n              const { content = null, function_call, tool_calls, ...messageRest } = message;\n              const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n              if (!role) {\n                  throw new error_1$1.OpenAIError(`missing role for choice ${index}`);\n              }\n              if (function_call) {\n                  const { arguments: args, name } = function_call;\n                  if (args == null) {\n                      throw new error_1$1.OpenAIError(`missing function_call.arguments for choice ${index}`);\n                  }\n                  if (!name) {\n                      throw new error_1$1.OpenAIError(`missing function_call.name for choice ${index}`);\n                  }\n                  return {\n                      ...choiceRest,\n                      message: {\n                          content,\n                          function_call: { arguments: args, name },\n                          role,\n                          refusal: message.refusal ?? null,\n                      },\n                      finish_reason,\n                      index,\n                      logprobs,\n                  };\n              }\n              if (tool_calls) {\n                  return {\n                      ...choiceRest,\n                      index,\n                      finish_reason,\n                      logprobs,\n                      message: {\n                          ...messageRest,\n                          role,\n                          content,\n                          refusal: message.refusal ?? null,\n                          tool_calls: tool_calls.map((tool_call, i) => {\n                              const { function: fn, type, id, ...toolRest } = tool_call;\n                              const { arguments: args, name, ...fnRest } = fn || {};\n                              if (id == null) {\n                                  throw new error_1$1.OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                              }\n                              if (type == null) {\n                                  throw new error_1$1.OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                              }\n                              if (name == null) {\n                                  throw new error_1$1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n                              }\n                              if (args == null) {\n                                  throw new error_1$1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n                              }\n                              return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n                          }),\n                      },\n                  };\n              }\n              return {\n                  ...choiceRest,\n                  message: { ...messageRest, content, role, refusal: message.refusal ?? null },\n                  finish_reason,\n                  index,\n                  logprobs,\n              };\n          }),\n          created,\n          model,\n          object: 'chat.completion',\n          ...(system_fingerprint ? { system_fingerprint } : {}),\n      };\n      return (0, parser_1$1.maybeParseChatCompletion)(completion, params);\n  }\n  function str(x) {\n      return JSON.stringify(x);\n  }\n  function assertNever(_x) { }\n\n  Object.defineProperty(ChatCompletionStreamingRunner$1, \"__esModule\", { value: true });\n  ChatCompletionStreamingRunner$1.ChatCompletionStreamingRunner = void 0;\n  const ChatCompletionStream_1 = ChatCompletionStream$1;\n  class ChatCompletionStreamingRunner extends ChatCompletionStream_1.ChatCompletionStream {\n      static fromReadableStream(stream) {\n          const runner = new ChatCompletionStreamingRunner(null);\n          runner._run(() => runner._fromReadableStream(stream));\n          return runner;\n      }\n      /** @deprecated - please use `runTools` instead. */\n      static runFunctions(client, params, options) {\n          const runner = new ChatCompletionStreamingRunner(null);\n          const opts = {\n              ...options,\n              headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n          };\n          runner._run(() => runner._runFunctions(client, params, opts));\n          return runner;\n      }\n      static runTools(client, params, options) {\n          const runner = new ChatCompletionStreamingRunner(\n          // @ts-expect-error TODO these types are incompatible\n          params);\n          const opts = {\n              ...options,\n              headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n          };\n          runner._run(() => runner._runTools(client, params, opts));\n          return runner;\n      }\n  }\n  ChatCompletionStreamingRunner$1.ChatCompletionStreamingRunner = ChatCompletionStreamingRunner;\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Completions = exports.ChatCompletionStream = exports.ParsingToolFunction = exports.ParsingFunction = exports.ChatCompletionStreamingRunner = exports.ChatCompletionRunner = void 0;\n  \tconst resource_1 = resource;\n  \tconst ChatCompletionRunner_1 = ChatCompletionRunner$1;\n  \tvar ChatCompletionRunner_2 = ChatCompletionRunner$1;\n  \tObject.defineProperty(exports, \"ChatCompletionRunner\", { enumerable: true, get: function () { return ChatCompletionRunner_2.ChatCompletionRunner; } });\n  \tconst ChatCompletionStreamingRunner_1 = ChatCompletionStreamingRunner$1;\n  \tvar ChatCompletionStreamingRunner_2 = ChatCompletionStreamingRunner$1;\n  \tObject.defineProperty(exports, \"ChatCompletionStreamingRunner\", { enumerable: true, get: function () { return ChatCompletionStreamingRunner_2.ChatCompletionStreamingRunner; } });\n  \tvar RunnableFunction_1 = RunnableFunction;\n  \tObject.defineProperty(exports, \"ParsingFunction\", { enumerable: true, get: function () { return RunnableFunction_1.ParsingFunction; } });\n  \tObject.defineProperty(exports, \"ParsingToolFunction\", { enumerable: true, get: function () { return RunnableFunction_1.ParsingToolFunction; } });\n  \tconst ChatCompletionStream_1 = ChatCompletionStream$1;\n  \tconst parser_1 = parser$1;\n  \tvar ChatCompletionStream_2 = ChatCompletionStream$1;\n  \tObject.defineProperty(exports, \"ChatCompletionStream\", { enumerable: true, get: function () { return ChatCompletionStream_2.ChatCompletionStream; } });\n  \tclass Completions extends resource_1.APIResource {\n  \t    parse(body, options) {\n  \t        (0, parser_1.validateInputTools)(body.tools);\n  \t        return this._client.chat.completions\n  \t            .create(body, {\n  \t            ...options,\n  \t            headers: {\n  \t                ...options?.headers,\n  \t                'X-Stainless-Helper-Method': 'beta.chat.completions.parse',\n  \t            },\n  \t        })\n  \t            ._thenUnwrap((completion) => (0, parser_1.parseChatCompletion)(completion, body));\n  \t    }\n  \t    runFunctions(body, options) {\n  \t        if (body.stream) {\n  \t            return ChatCompletionStreamingRunner_1.ChatCompletionStreamingRunner.runFunctions(this._client, body, options);\n  \t        }\n  \t        return ChatCompletionRunner_1.ChatCompletionRunner.runFunctions(this._client, body, options);\n  \t    }\n  \t    runTools(body, options) {\n  \t        if (body.stream) {\n  \t            return ChatCompletionStreamingRunner_1.ChatCompletionStreamingRunner.runTools(this._client, body, options);\n  \t        }\n  \t        return ChatCompletionRunner_1.ChatCompletionRunner.runTools(this._client, body, options);\n  \t    }\n  \t    /**\n  \t     * Creates a chat completion stream\n  \t     */\n  \t    stream(body, options) {\n  \t        return ChatCompletionStream_1.ChatCompletionStream.createChatCompletion(this._client, body, options);\n  \t    }\n  \t}\n  \texports.Completions = Completions;\n  \t\n  } (completions$1));\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Chat = void 0;\n  \tconst resource_1 = resource;\n  \tconst CompletionsAPI = __importStar(completions$1);\n  \tclass Chat extends resource_1.APIResource {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.completions = new CompletionsAPI.Completions(this._client);\n  \t    }\n  \t}\n  \texports.Chat = Chat;\n  \t(function (Chat) {\n  \t    Chat.Completions = CompletionsAPI.Completions;\n  \t})(Chat = exports.Chat || (exports.Chat = {}));\n  \t\n  } (chat));\n\n  var threads = {};\n\n  var AssistantStream$1 = {};\n\n  var __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() { return m[k]; } };\n      }\n      Object.defineProperty(o, k2, desc);\n  }) : (function(o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      o[k2] = m[k];\n  }));\n  var __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n      Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  }) : function(o, v) {\n      o[\"default\"] = v;\n  });\n  var __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n      if (mod && mod.__esModule) return mod;\n      var result = {};\n      if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n      __setModuleDefault(result, mod);\n      return result;\n  };\n  var __classPrivateFieldGet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n      return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  };\n  var __classPrivateFieldSet = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n      if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n      if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n      if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n      return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  };\n  var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;\n  Object.defineProperty(AssistantStream$1, \"__esModule\", { value: true });\n  AssistantStream$1.AssistantStream = void 0;\n  const Core = __importStar(requireCore());\n  const streaming_1 = requireStreaming();\n  const error_1 = requireError();\n  const EventStream_1 = EventStream$1;\n  class AssistantStream extends EventStream_1.EventStream {\n      constructor() {\n          super(...arguments);\n          _AssistantStream_instances.add(this);\n          //Track all events in a single list for reference\n          _AssistantStream_events.set(this, []);\n          //Used to accumulate deltas\n          //We are accumulating many types so the value here is not strict\n          _AssistantStream_runStepSnapshots.set(this, {});\n          _AssistantStream_messageSnapshots.set(this, {});\n          _AssistantStream_messageSnapshot.set(this, void 0);\n          _AssistantStream_finalRun.set(this, void 0);\n          _AssistantStream_currentContentIndex.set(this, void 0);\n          _AssistantStream_currentContent.set(this, void 0);\n          _AssistantStream_currentToolCallIndex.set(this, void 0);\n          _AssistantStream_currentToolCall.set(this, void 0);\n          //For current snapshot methods\n          _AssistantStream_currentEvent.set(this, void 0);\n          _AssistantStream_currentRunSnapshot.set(this, void 0);\n          _AssistantStream_currentRunStepSnapshot.set(this, void 0);\n      }\n      [(_AssistantStream_events = new WeakMap(), _AssistantStream_runStepSnapshots = new WeakMap(), _AssistantStream_messageSnapshots = new WeakMap(), _AssistantStream_messageSnapshot = new WeakMap(), _AssistantStream_finalRun = new WeakMap(), _AssistantStream_currentContentIndex = new WeakMap(), _AssistantStream_currentContent = new WeakMap(), _AssistantStream_currentToolCallIndex = new WeakMap(), _AssistantStream_currentToolCall = new WeakMap(), _AssistantStream_currentEvent = new WeakMap(), _AssistantStream_currentRunSnapshot = new WeakMap(), _AssistantStream_currentRunStepSnapshot = new WeakMap(), _AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {\n          const pushQueue = [];\n          const readQueue = [];\n          let done = false;\n          //Catch all for passing along all events\n          this.on('event', (event) => {\n              const reader = readQueue.shift();\n              if (reader) {\n                  reader.resolve(event);\n              }\n              else {\n                  pushQueue.push(event);\n              }\n          });\n          this.on('end', () => {\n              done = true;\n              for (const reader of readQueue) {\n                  reader.resolve(undefined);\n              }\n              readQueue.length = 0;\n          });\n          this.on('abort', (err) => {\n              done = true;\n              for (const reader of readQueue) {\n                  reader.reject(err);\n              }\n              readQueue.length = 0;\n          });\n          this.on('error', (err) => {\n              done = true;\n              for (const reader of readQueue) {\n                  reader.reject(err);\n              }\n              readQueue.length = 0;\n          });\n          return {\n              next: async () => {\n                  if (!pushQueue.length) {\n                      if (done) {\n                          return { value: undefined, done: true };\n                      }\n                      return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                  }\n                  const chunk = pushQueue.shift();\n                  return { value: chunk, done: false };\n              },\n              return: async () => {\n                  this.abort();\n                  return { value: undefined, done: true };\n              },\n          };\n      }\n      static fromReadableStream(stream) {\n          const runner = new AssistantStream();\n          runner._run(() => runner._fromReadableStream(stream));\n          return runner;\n      }\n      async _fromReadableStream(readableStream, options) {\n          const signal = options?.signal;\n          if (signal) {\n              if (signal.aborted)\n                  this.controller.abort();\n              signal.addEventListener('abort', () => this.controller.abort());\n          }\n          this._connected();\n          const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);\n          for await (const event of stream) {\n              __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n          }\n          if (stream.controller.signal?.aborted) {\n              throw new error_1.APIUserAbortError();\n          }\n          return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n      }\n      toReadableStream() {\n          const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n          return stream.toReadableStream();\n      }\n      static createToolAssistantStream(threadId, runId, runs, params, options) {\n          const runner = new AssistantStream();\n          runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {\n              ...options,\n              headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n          }));\n          return runner;\n      }\n      async _createToolAssistantStream(run, threadId, runId, params, options) {\n          const signal = options?.signal;\n          if (signal) {\n              if (signal.aborted)\n                  this.controller.abort();\n              signal.addEventListener('abort', () => this.controller.abort());\n          }\n          const body = { ...params, stream: true };\n          const stream = await run.submitToolOutputs(threadId, runId, body, {\n              ...options,\n              signal: this.controller.signal,\n          });\n          this._connected();\n          for await (const event of stream) {\n              __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n          }\n          if (stream.controller.signal?.aborted) {\n              throw new error_1.APIUserAbortError();\n          }\n          return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n      }\n      static createThreadAssistantStream(params, thread, options) {\n          const runner = new AssistantStream();\n          runner._run(() => runner._threadAssistantStream(params, thread, {\n              ...options,\n              headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n          }));\n          return runner;\n      }\n      static createAssistantStream(threadId, runs, params, options) {\n          const runner = new AssistantStream();\n          runner._run(() => runner._runAssistantStream(threadId, runs, params, {\n              ...options,\n              headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n          }));\n          return runner;\n      }\n      currentEvent() {\n          return __classPrivateFieldGet(this, _AssistantStream_currentEvent, \"f\");\n      }\n      currentRun() {\n          return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, \"f\");\n      }\n      currentMessageSnapshot() {\n          return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\");\n      }\n      currentRunStepSnapshot() {\n          return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, \"f\");\n      }\n      async finalRunSteps() {\n          await this.done();\n          return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\"));\n      }\n      async finalMessages() {\n          await this.done();\n          return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\"));\n      }\n      async finalRun() {\n          await this.done();\n          if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n              throw Error('Final run was not received.');\n          return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n      }\n      async _createThreadAssistantStream(thread, params, options) {\n          const signal = options?.signal;\n          if (signal) {\n              if (signal.aborted)\n                  this.controller.abort();\n              signal.addEventListener('abort', () => this.controller.abort());\n          }\n          const body = { ...params, stream: true };\n          const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });\n          this._connected();\n          for await (const event of stream) {\n              __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n          }\n          if (stream.controller.signal?.aborted) {\n              throw new error_1.APIUserAbortError();\n          }\n          return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n      }\n      async _createAssistantStream(run, threadId, params, options) {\n          const signal = options?.signal;\n          if (signal) {\n              if (signal.aborted)\n                  this.controller.abort();\n              signal.addEventListener('abort', () => this.controller.abort());\n          }\n          const body = { ...params, stream: true };\n          const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });\n          this._connected();\n          for await (const event of stream) {\n              __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n          }\n          if (stream.controller.signal?.aborted) {\n              throw new error_1.APIUserAbortError();\n          }\n          return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n      }\n      static accumulateDelta(acc, delta) {\n          for (const [key, deltaValue] of Object.entries(delta)) {\n              if (!acc.hasOwnProperty(key)) {\n                  acc[key] = deltaValue;\n                  continue;\n              }\n              let accValue = acc[key];\n              if (accValue === null || accValue === undefined) {\n                  acc[key] = deltaValue;\n                  continue;\n              }\n              // We don't accumulate these special properties\n              if (key === 'index' || key === 'type') {\n                  acc[key] = deltaValue;\n                  continue;\n              }\n              // Type-specific accumulation logic\n              if (typeof accValue === 'string' && typeof deltaValue === 'string') {\n                  accValue += deltaValue;\n              }\n              else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\n                  accValue += deltaValue;\n              }\n              else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\n                  accValue = this.accumulateDelta(accValue, deltaValue);\n              }\n              else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n                  if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {\n                      accValue.push(...deltaValue); // Use spread syntax for efficient addition\n                      continue;\n                  }\n                  for (const deltaEntry of deltaValue) {\n                      if (!Core.isObj(deltaEntry)) {\n                          throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\n                      }\n                      const index = deltaEntry['index'];\n                      if (index == null) {\n                          console.error(deltaEntry);\n                          throw new Error('Expected array delta entry to have an `index` property');\n                      }\n                      if (typeof index !== 'number') {\n                          throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\n                      }\n                      const accEntry = accValue[index];\n                      if (accEntry == null) {\n                          accValue.push(deltaEntry);\n                      }\n                      else {\n                          accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n                      }\n                  }\n                  continue;\n              }\n              else {\n                  throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\n              }\n              acc[key] = accValue;\n          }\n          return acc;\n      }\n      _addRun(run) {\n          return run;\n      }\n      async _threadAssistantStream(params, thread, options) {\n          return await this._createThreadAssistantStream(thread, params, options);\n      }\n      async _runAssistantStream(threadId, runs, params, options) {\n          return await this._createAssistantStream(runs, threadId, params, options);\n      }\n      async _runToolAssistantStream(threadId, runId, runs, params, options) {\n          return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n      }\n  }\n  AssistantStream$1.AssistantStream = AssistantStream;\n  _AssistantStream_addEvent = function _AssistantStream_addEvent(event) {\n      if (this.ended)\n          return;\n      __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, \"f\");\n      __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleEvent).call(this, event);\n      switch (event.event) {\n          case 'thread.created':\n              //No action on this event.\n              break;\n          case 'thread.run.created':\n          case 'thread.run.queued':\n          case 'thread.run.in_progress':\n          case 'thread.run.requires_action':\n          case 'thread.run.completed':\n          case 'thread.run.failed':\n          case 'thread.run.cancelling':\n          case 'thread.run.cancelled':\n          case 'thread.run.expired':\n              __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRun).call(this, event);\n              break;\n          case 'thread.run.step.created':\n          case 'thread.run.step.in_progress':\n          case 'thread.run.step.delta':\n          case 'thread.run.step.completed':\n          case 'thread.run.step.failed':\n          case 'thread.run.step.cancelled':\n          case 'thread.run.step.expired':\n              __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRunStep).call(this, event);\n              break;\n          case 'thread.message.created':\n          case 'thread.message.in_progress':\n          case 'thread.message.delta':\n          case 'thread.message.completed':\n          case 'thread.message.incomplete':\n              __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleMessage).call(this, event);\n              break;\n          case 'error':\n              //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n              throw new Error('Encountered an error event in event processing - errors should be processed earlier');\n      }\n  }, _AssistantStream_endRequest = function _AssistantStream_endRequest() {\n      if (this.ended) {\n          throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);\n      }\n      if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n          throw Error('Final run has not been received');\n      return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n  }, _AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {\n      const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, \"f\");\n      __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\")[accumulatedMessage.id] = accumulatedMessage;\n      for (const content of newContent) {\n          const snapshotContent = accumulatedMessage.content[content.index];\n          if (snapshotContent?.type == 'text') {\n              this._emit('textCreated', snapshotContent.text);\n          }\n      }\n      switch (event.event) {\n          case 'thread.message.created':\n              this._emit('messageCreated', event.data);\n              break;\n          case 'thread.message.in_progress':\n              break;\n          case 'thread.message.delta':\n              this._emit('messageDelta', event.data.delta, accumulatedMessage);\n              if (event.data.delta.content) {\n                  for (const content of event.data.delta.content) {\n                      //If it is text delta, emit a text delta event\n                      if (content.type == 'text' && content.text) {\n                          let textDelta = content.text;\n                          let snapshot = accumulatedMessage.content[content.index];\n                          if (snapshot && snapshot.type == 'text') {\n                              this._emit('textDelta', textDelta, snapshot.text);\n                          }\n                          else {\n                              throw Error('The snapshot associated with this text delta is not text or missing');\n                          }\n                      }\n                      if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")) {\n                          //See if we have in progress content\n                          if (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\")) {\n                              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").type) {\n                                  case 'text':\n                                      this._emit('textDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                      break;\n                                  case 'image_file':\n                                      this._emit('imageFileDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                      break;\n                              }\n                          }\n                          __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, \"f\");\n                      }\n                      __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], \"f\");\n                  }\n              }\n              break;\n          case 'thread.message.completed':\n          case 'thread.message.incomplete':\n              //We emit the latest content we were working on on completion (including incomplete)\n              if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\") !== undefined) {\n                  const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")];\n                  if (currentContent) {\n                      switch (currentContent.type) {\n                          case 'image_file':\n                              this._emit('imageFileDone', currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                              break;\n                          case 'text':\n                              this._emit('textDone', currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                              break;\n                      }\n                  }\n              }\n              if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\")) {\n                  this._emit('messageDone', event.data);\n              }\n              __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, \"f\");\n      }\n  }, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {\n      const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateRunStep).call(this, event);\n      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, \"f\");\n      switch (event.event) {\n          case 'thread.run.step.created':\n              this._emit('runStepCreated', event.data);\n              break;\n          case 'thread.run.step.delta':\n              const delta = event.data.delta;\n              if (delta.step_details &&\n                  delta.step_details.type == 'tool_calls' &&\n                  delta.step_details.tool_calls &&\n                  accumulatedRunStep.step_details.type == 'tool_calls') {\n                  for (const toolCall of delta.step_details.tool_calls) {\n                      if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, \"f\")) {\n                          this._emit('toolCallDelta', toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);\n                      }\n                      else {\n                          if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                              this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                          }\n                          __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, \"f\");\n                          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], \"f\");\n                          if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"))\n                              this._emit('toolCallCreated', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                      }\n                  }\n              }\n              this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\n              break;\n          case 'thread.run.step.completed':\n          case 'thread.run.step.failed':\n          case 'thread.run.step.cancelled':\n          case 'thread.run.step.expired':\n              __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, \"f\");\n              const details = event.data.step_details;\n              if (details.type == 'tool_calls') {\n                  if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                      this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                      __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n                  }\n              }\n              this._emit('runStepDone', event.data, accumulatedRunStep);\n              break;\n      }\n  }, _AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {\n      __classPrivateFieldGet(this, _AssistantStream_events, \"f\").push(event);\n      this._emit('event', event);\n  }, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {\n      switch (event.event) {\n          case 'thread.run.step.created':\n              __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n              return event.data;\n          case 'thread.run.step.delta':\n              let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n              if (!snapshot) {\n                  throw Error('Received a RunStepDelta before creation of a snapshot');\n              }\n              let data = event.data;\n              if (data.delta) {\n                  const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);\n                  __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = accumulated;\n              }\n              return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n          case 'thread.run.step.completed':\n          case 'thread.run.step.failed':\n          case 'thread.run.step.cancelled':\n          case 'thread.run.step.expired':\n          case 'thread.run.step.in_progress':\n              __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n              break;\n      }\n      if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id])\n          return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n      throw new Error('No snapshot available');\n  }, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {\n      let newContent = [];\n      switch (event.event) {\n          case 'thread.message.created':\n              //On creation the snapshot is just the initial message\n              return [event.data, newContent];\n          case 'thread.message.delta':\n              if (!snapshot) {\n                  throw Error('Received a delta with no existing snapshot (there should be one from message creation)');\n              }\n              let data = event.data;\n              //If this delta does not have content, nothing to process\n              if (data.delta.content) {\n                  for (const contentElement of data.delta.content) {\n                      if (contentElement.index in snapshot.content) {\n                          let currentContent = snapshot.content[contentElement.index];\n                          snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);\n                      }\n                      else {\n                          snapshot.content[contentElement.index] = contentElement;\n                          // This is a new element\n                          newContent.push(contentElement);\n                      }\n                  }\n              }\n              return [snapshot, newContent];\n          case 'thread.message.in_progress':\n          case 'thread.message.completed':\n          case 'thread.message.incomplete':\n              //No changes on other thread events\n              if (snapshot) {\n                  return [snapshot, newContent];\n              }\n              else {\n                  throw Error('Received thread message event with no existing snapshot');\n              }\n      }\n      throw Error('Tried to accumulate a non-message event');\n  }, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {\n      return AssistantStream.accumulateDelta(currentContent, contentElement);\n  }, _AssistantStream_handleRun = function _AssistantStream_handleRun(event) {\n      __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, \"f\");\n      switch (event.event) {\n          case 'thread.run.created':\n              break;\n          case 'thread.run.queued':\n              break;\n          case 'thread.run.in_progress':\n              break;\n          case 'thread.run.requires_action':\n          case 'thread.run.cancelled':\n          case 'thread.run.failed':\n          case 'thread.run.completed':\n          case 'thread.run.expired':\n              __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, \"f\");\n              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                  this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                  __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n              }\n              break;\n      }\n  };\n\n  var messages = {};\n\n  var hasRequiredMessages;\n\n  function requireMessages () {\n  \tif (hasRequiredMessages) return messages;\n  \thasRequiredMessages = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.MessagesPage = exports.Messages = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst MessagesAPI = __importStar(requireMessages());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Messages extends resource_1.APIResource {\n  \t\t    /**\n  \t\t     * Create a message.\n  \t\t     */\n  \t\t    create(threadId, body, options) {\n  \t\t        return this._client.post(`/threads/${threadId}/messages`, {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Retrieve a message.\n  \t\t     */\n  \t\t    retrieve(threadId, messageId, options) {\n  \t\t        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Modifies a message.\n  \t\t     */\n  \t\t    update(threadId, messageId, body, options) {\n  \t\t        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    list(threadId, query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list(threadId, {}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Deletes a message.\n  \t\t     */\n  \t\t    del(threadId, messageId, options) {\n  \t\t        return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t}\n  \t\texports.Messages = Messages;\n  \t\tclass MessagesPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.MessagesPage = MessagesPage;\n  \t\t(function (Messages) {\n  \t\t    Messages.MessagesPage = MessagesAPI.MessagesPage;\n  \t\t})(Messages = exports.Messages || (exports.Messages = {}));\n  \t\t\n  \t} (messages));\n  \treturn messages;\n  }\n\n  var runs = {};\n\n  var steps = {};\n\n  var hasRequiredSteps;\n\n  function requireSteps () {\n  \tif (hasRequiredSteps) return steps;\n  \thasRequiredSteps = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.RunStepsPage = exports.Steps = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst StepsAPI = __importStar(requireSteps());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Steps extends resource_1.APIResource {\n  \t\t    retrieve(threadId, runId, stepId, query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.retrieve(threadId, runId, stepId, {}, query);\n  \t\t        }\n  \t\t        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    list(threadId, runId, query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list(threadId, runId, {}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t}\n  \t\texports.Steps = Steps;\n  \t\tclass RunStepsPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.RunStepsPage = RunStepsPage;\n  \t\t(function (Steps) {\n  \t\t    Steps.RunStepsPage = StepsAPI.RunStepsPage;\n  \t\t})(Steps = exports.Steps || (exports.Steps = {}));\n  \t\t\n  \t} (steps));\n  \treturn steps;\n  }\n\n  var hasRequiredRuns;\n\n  function requireRuns () {\n  \tif (hasRequiredRuns) return runs;\n  \thasRequiredRuns = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.RunsPage = exports.Runs = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst AssistantStream_1 = AssistantStream$1;\n  \t\tconst core_2 = requireCore();\n  \t\tconst RunsAPI = __importStar(requireRuns());\n  \t\tconst StepsAPI = __importStar(requireSteps());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Runs extends resource_1.APIResource {\n  \t\t    constructor() {\n  \t\t        super(...arguments);\n  \t\t        this.steps = new StepsAPI.Steps(this._client);\n  \t\t    }\n  \t\t    create(threadId, params, options) {\n  \t\t        const { include, ...body } = params;\n  \t\t        return this._client.post(`/threads/${threadId}/runs`, {\n  \t\t            query: { include },\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t            stream: params.stream ?? false,\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Retrieves a run.\n  \t\t     */\n  \t\t    retrieve(threadId, runId, options) {\n  \t\t        return this._client.get(`/threads/${threadId}/runs/${runId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Modifies a run.\n  \t\t     */\n  \t\t    update(threadId, runId, body, options) {\n  \t\t        return this._client.post(`/threads/${threadId}/runs/${runId}`, {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    list(threadId, query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list(threadId, {}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Cancels a run that is `in_progress`.\n  \t\t     */\n  \t\t    cancel(threadId, runId, options) {\n  \t\t        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * A helper to create a run an poll for a terminal state. More information on Run\n  \t\t     * lifecycles can be found here:\n  \t\t     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n  \t\t     */\n  \t\t    async createAndPoll(threadId, body, options) {\n  \t\t        const run = await this.create(threadId, body, options);\n  \t\t        return await this.poll(threadId, run.id, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Create a Run stream\n  \t\t     *\n  \t\t     * @deprecated use `stream` instead\n  \t\t     */\n  \t\t    createAndStream(threadId, body, options) {\n  \t\t        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * A helper to poll a run status until it reaches a terminal state. More\n  \t\t     * information on Run lifecycles can be found here:\n  \t\t     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n  \t\t     */\n  \t\t    async poll(threadId, runId, options) {\n  \t\t        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n  \t\t        if (options?.pollIntervalMs) {\n  \t\t            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n  \t\t        }\n  \t\t        while (true) {\n  \t\t            const { data: run, response } = await this.retrieve(threadId, runId, {\n  \t\t                ...options,\n  \t\t                headers: { ...options?.headers, ...headers },\n  \t\t            }).withResponse();\n  \t\t            switch (run.status) {\n  \t\t                //If we are in any sort of intermediate state we poll\n  \t\t                case 'queued':\n  \t\t                case 'in_progress':\n  \t\t                case 'cancelling':\n  \t\t                    let sleepInterval = 5000;\n  \t\t                    if (options?.pollIntervalMs) {\n  \t\t                        sleepInterval = options.pollIntervalMs;\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        const headerInterval = response.headers.get('openai-poll-after-ms');\n  \t\t                        if (headerInterval) {\n  \t\t                            const headerIntervalMs = parseInt(headerInterval);\n  \t\t                            if (!isNaN(headerIntervalMs)) {\n  \t\t                                sleepInterval = headerIntervalMs;\n  \t\t                            }\n  \t\t                        }\n  \t\t                    }\n  \t\t                    await (0, core_2.sleep)(sleepInterval);\n  \t\t                    break;\n  \t\t                //We return the run in any terminal state.\n  \t\t                case 'requires_action':\n  \t\t                case 'incomplete':\n  \t\t                case 'cancelled':\n  \t\t                case 'completed':\n  \t\t                case 'failed':\n  \t\t                case 'expired':\n  \t\t                    return run;\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t    /**\n  \t\t     * Create a Run stream\n  \t\t     */\n  \t\t    stream(threadId, body, options) {\n  \t\t        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n  \t\t    }\n  \t\t    submitToolOutputs(threadId, runId, body, options) {\n  \t\t        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t            stream: body.stream ?? false,\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * A helper to submit a tool output to a run and poll for a terminal run state.\n  \t\t     * More information on Run lifecycles can be found here:\n  \t\t     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n  \t\t     */\n  \t\t    async submitToolOutputsAndPoll(threadId, runId, body, options) {\n  \t\t        const run = await this.submitToolOutputs(threadId, runId, body, options);\n  \t\t        return await this.poll(threadId, run.id, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Submit the tool outputs from a previous run and stream the run to a terminal\n  \t\t     * state. More information on Run lifecycles can be found here:\n  \t\t     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n  \t\t     */\n  \t\t    submitToolOutputsStream(threadId, runId, body, options) {\n  \t\t        return AssistantStream_1.AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);\n  \t\t    }\n  \t\t}\n  \t\texports.Runs = Runs;\n  \t\tclass RunsPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.RunsPage = RunsPage;\n  \t\t(function (Runs) {\n  \t\t    Runs.RunsPage = RunsAPI.RunsPage;\n  \t\t    Runs.Steps = StepsAPI.Steps;\n  \t\t    Runs.RunStepsPage = StepsAPI.RunStepsPage;\n  \t\t})(Runs = exports.Runs || (exports.Runs = {}));\n  \t\t\n  \t} (runs));\n  \treturn runs;\n  }\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Threads = void 0;\n  \tconst resource_1 = resource;\n  \tconst core_1 = requireCore();\n  \tconst AssistantStream_1 = AssistantStream$1;\n  \tconst MessagesAPI = __importStar(requireMessages());\n  \tconst RunsAPI = __importStar(requireRuns());\n  \tclass Threads extends resource_1.APIResource {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.runs = new RunsAPI.Runs(this._client);\n  \t        this.messages = new MessagesAPI.Messages(this._client);\n  \t    }\n  \t    create(body = {}, options) {\n  \t        if ((0, core_1.isRequestOptions)(body)) {\n  \t            return this.create({}, body);\n  \t        }\n  \t        return this._client.post('/threads', {\n  \t            body,\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Retrieves a thread.\n  \t     */\n  \t    retrieve(threadId, options) {\n  \t        return this._client.get(`/threads/${threadId}`, {\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Modifies a thread.\n  \t     */\n  \t    update(threadId, body, options) {\n  \t        return this._client.post(`/threads/${threadId}`, {\n  \t            body,\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Delete a thread.\n  \t     */\n  \t    del(threadId, options) {\n  \t        return this._client.delete(`/threads/${threadId}`, {\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t        });\n  \t    }\n  \t    createAndRun(body, options) {\n  \t        return this._client.post('/threads/runs', {\n  \t            body,\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t            stream: body.stream ?? false,\n  \t        });\n  \t    }\n  \t    /**\n  \t     * A helper to create a thread, start a run and then poll for a terminal state.\n  \t     * More information on Run lifecycles can be found here:\n  \t     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n  \t     */\n  \t    async createAndRunPoll(body, options) {\n  \t        const run = await this.createAndRun(body, options);\n  \t        return await this.runs.poll(run.thread_id, run.id, options);\n  \t    }\n  \t    /**\n  \t     * Create a thread and stream the run back\n  \t     */\n  \t    createAndRunStream(body, options) {\n  \t        return AssistantStream_1.AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);\n  \t    }\n  \t}\n  \texports.Threads = Threads;\n  \t(function (Threads) {\n  \t    Threads.Runs = RunsAPI.Runs;\n  \t    Threads.RunsPage = RunsAPI.RunsPage;\n  \t    Threads.Messages = MessagesAPI.Messages;\n  \t    Threads.MessagesPage = MessagesAPI.MessagesPage;\n  \t})(Threads = exports.Threads || (exports.Threads = {}));\n  \t\n  } (threads));\n\n  var vectorStores = {};\n\n  var fileBatches = {};\n\n  var Util = {};\n\n  Object.defineProperty(Util, \"__esModule\", { value: true });\n  Util.allSettledWithThrow = void 0;\n  /**\n   * Like `Promise.allSettled()` but throws an error if any promises are rejected.\n   */\n  const allSettledWithThrow = async (promises) => {\n      const results = await Promise.allSettled(promises);\n      const rejected = results.filter((result) => result.status === 'rejected');\n      if (rejected.length) {\n          for (const result of rejected) {\n              console.error(result.reason);\n          }\n          throw new Error(`${rejected.length} promise(s) failed - see the above errors`);\n      }\n      // Note: TS was complaining about using `.filter().map()` here for some reason\n      const values = [];\n      for (const result of results) {\n          if (result.status === 'fulfilled') {\n              values.push(result.value);\n          }\n      }\n      return values;\n  };\n  Util.allSettledWithThrow = allSettledWithThrow;\n\n  var files$1 = {};\n\n  var hasRequiredFiles$1;\n\n  function requireFiles$1 () {\n  \tif (hasRequiredFiles$1) return files$1;\n  \thasRequiredFiles$1 = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.VectorStoreFilesPage = exports.Files = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst FilesAPI = __importStar(requireFiles$1());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Files extends resource_1.APIResource {\n  \t\t    /**\n  \t\t     * Create a vector store file by attaching a\n  \t\t     * [File](https://platform.openai.com/docs/api-reference/files) to a\n  \t\t     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\n  \t\t     */\n  \t\t    create(vectorStoreId, body, options) {\n  \t\t        return this._client.post(`/vector_stores/${vectorStoreId}/files`, {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Retrieves a vector store file.\n  \t\t     */\n  \t\t    retrieve(vectorStoreId, fileId, options) {\n  \t\t        return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    list(vectorStoreId, query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list(vectorStoreId, {}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Delete a vector store file. This will remove the file from the vector store but\n  \t\t     * the file itself will not be deleted. To delete the file, use the\n  \t\t     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\n  \t\t     * endpoint.\n  \t\t     */\n  \t\t    del(vectorStoreId, fileId, options) {\n  \t\t        return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Attach a file to the given vector store and wait for it to be processed.\n  \t\t     */\n  \t\t    async createAndPoll(vectorStoreId, body, options) {\n  \t\t        const file = await this.create(vectorStoreId, body, options);\n  \t\t        return await this.poll(vectorStoreId, file.id, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Wait for the vector store file to finish processing.\n  \t\t     *\n  \t\t     * Note: this will return even if the file failed to process, you need to check\n  \t\t     * file.last_error and file.status to handle these cases\n  \t\t     */\n  \t\t    async poll(vectorStoreId, fileId, options) {\n  \t\t        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n  \t\t        if (options?.pollIntervalMs) {\n  \t\t            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n  \t\t        }\n  \t\t        while (true) {\n  \t\t            const fileResponse = await this.retrieve(vectorStoreId, fileId, {\n  \t\t                ...options,\n  \t\t                headers,\n  \t\t            }).withResponse();\n  \t\t            const file = fileResponse.data;\n  \t\t            switch (file.status) {\n  \t\t                case 'in_progress':\n  \t\t                    let sleepInterval = 5000;\n  \t\t                    if (options?.pollIntervalMs) {\n  \t\t                        sleepInterval = options.pollIntervalMs;\n  \t\t                    }\n  \t\t                    else {\n  \t\t                        const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\n  \t\t                        if (headerInterval) {\n  \t\t                            const headerIntervalMs = parseInt(headerInterval);\n  \t\t                            if (!isNaN(headerIntervalMs)) {\n  \t\t                                sleepInterval = headerIntervalMs;\n  \t\t                            }\n  \t\t                        }\n  \t\t                    }\n  \t\t                    await (0, core_1.sleep)(sleepInterval);\n  \t\t                    break;\n  \t\t                case 'failed':\n  \t\t                case 'completed':\n  \t\t                    return file;\n  \t\t            }\n  \t\t        }\n  \t\t    }\n  \t\t    /**\n  \t\t     * Upload a file to the `files` API and then attach it to the given vector store.\n  \t\t     *\n  \t\t     * Note the file will be asynchronously processed (you can use the alternative\n  \t\t     * polling helper method to wait for processing to complete).\n  \t\t     */\n  \t\t    async upload(vectorStoreId, file, options) {\n  \t\t        const fileInfo = await this._client.files.create({ file: file, purpose: 'assistants' }, options);\n  \t\t        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Add a file to a vector store and poll until processing is complete.\n  \t\t     */\n  \t\t    async uploadAndPoll(vectorStoreId, file, options) {\n  \t\t        const fileInfo = await this.upload(vectorStoreId, file, options);\n  \t\t        return await this.poll(vectorStoreId, fileInfo.id, options);\n  \t\t    }\n  \t\t}\n  \t\texports.Files = Files;\n  \t\tclass VectorStoreFilesPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.VectorStoreFilesPage = VectorStoreFilesPage;\n  \t\t(function (Files) {\n  \t\t    Files.VectorStoreFilesPage = FilesAPI.VectorStoreFilesPage;\n  \t\t})(Files = exports.Files || (exports.Files = {}));\n  \t\t\n  \t} (files$1));\n  \treturn files$1;\n  }\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.VectorStoreFilesPage = exports.FileBatches = void 0;\n  \tconst resource_1 = resource;\n  \tconst core_1 = requireCore();\n  \tconst core_2 = requireCore();\n  \tconst Util_1 = Util;\n  \tconst files_1 = requireFiles$1();\n  \tObject.defineProperty(exports, \"VectorStoreFilesPage\", { enumerable: true, get: function () { return files_1.VectorStoreFilesPage; } });\n  \tclass FileBatches extends resource_1.APIResource {\n  \t    /**\n  \t     * Create a vector store file batch.\n  \t     */\n  \t    create(vectorStoreId, body, options) {\n  \t        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {\n  \t            body,\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Retrieves a vector store file batch.\n  \t     */\n  \t    retrieve(vectorStoreId, batchId, options) {\n  \t        return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Cancel a vector store file batch. This attempts to cancel the processing of\n  \t     * files in this batch as soon as possible.\n  \t     */\n  \t    cancel(vectorStoreId, batchId, options) {\n  \t        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {\n  \t            ...options,\n  \t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Create a vector store batch and poll until all files have been processed.\n  \t     */\n  \t    async createAndPoll(vectorStoreId, body, options) {\n  \t        const batch = await this.create(vectorStoreId, body);\n  \t        return await this.poll(vectorStoreId, batch.id, options);\n  \t    }\n  \t    listFiles(vectorStoreId, batchId, query = {}, options) {\n  \t        if ((0, core_1.isRequestOptions)(query)) {\n  \t            return this.listFiles(vectorStoreId, batchId, {}, query);\n  \t        }\n  \t        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, files_1.VectorStoreFilesPage, { query, ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n  \t    }\n  \t    /**\n  \t     * Wait for the given file batch to be processed.\n  \t     *\n  \t     * Note: this will return even if one of the files failed to process, you need to\n  \t     * check batch.file_counts.failed_count to handle this case.\n  \t     */\n  \t    async poll(vectorStoreId, batchId, options) {\n  \t        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n  \t        if (options?.pollIntervalMs) {\n  \t            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n  \t        }\n  \t        while (true) {\n  \t            const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {\n  \t                ...options,\n  \t                headers,\n  \t            }).withResponse();\n  \t            switch (batch.status) {\n  \t                case 'in_progress':\n  \t                    let sleepInterval = 5000;\n  \t                    if (options?.pollIntervalMs) {\n  \t                        sleepInterval = options.pollIntervalMs;\n  \t                    }\n  \t                    else {\n  \t                        const headerInterval = response.headers.get('openai-poll-after-ms');\n  \t                        if (headerInterval) {\n  \t                            const headerIntervalMs = parseInt(headerInterval);\n  \t                            if (!isNaN(headerIntervalMs)) {\n  \t                                sleepInterval = headerIntervalMs;\n  \t                            }\n  \t                        }\n  \t                    }\n  \t                    await (0, core_2.sleep)(sleepInterval);\n  \t                    break;\n  \t                case 'failed':\n  \t                case 'cancelled':\n  \t                case 'completed':\n  \t                    return batch;\n  \t            }\n  \t        }\n  \t    }\n  \t    /**\n  \t     * Uploads the given files concurrently and then creates a vector store file batch.\n  \t     *\n  \t     * The concurrency limit is configurable using the `maxConcurrency` parameter.\n  \t     */\n  \t    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {\n  \t        if (files == null || files.length == 0) {\n  \t            throw new Error(`No \\`files\\` provided to process. If you've already uploaded files you should use \\`.createAndPoll()\\` instead`);\n  \t        }\n  \t        const configuredConcurrency = options?.maxConcurrency ?? 5;\n  \t        // We cap the number of workers at the number of files (so we don't start any unnecessary workers)\n  \t        const concurrencyLimit = Math.min(configuredConcurrency, files.length);\n  \t        const client = this._client;\n  \t        const fileIterator = files.values();\n  \t        const allFileIds = [...fileIds];\n  \t        // This code is based on this design. The libraries don't accommodate our environment limits.\n  \t        // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all\n  \t        async function processFiles(iterator) {\n  \t            for (let item of iterator) {\n  \t                const fileObj = await client.files.create({ file: item, purpose: 'assistants' }, options);\n  \t                allFileIds.push(fileObj.id);\n  \t            }\n  \t        }\n  \t        // Start workers to process results\n  \t        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);\n  \t        // Wait for all processing to complete.\n  \t        await (0, Util_1.allSettledWithThrow)(workers);\n  \t        return await this.createAndPoll(vectorStoreId, {\n  \t            file_ids: allFileIds,\n  \t        });\n  \t    }\n  \t}\n  \texports.FileBatches = FileBatches;\n  \t(function (FileBatches) {\n  \t})(FileBatches = exports.FileBatches || (exports.FileBatches = {}));\n  \t\n  } (fileBatches));\n\n  var hasRequiredVectorStores;\n\n  function requireVectorStores () {\n  \tif (hasRequiredVectorStores) return vectorStores;\n  \thasRequiredVectorStores = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.VectorStoresPage = exports.VectorStores = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst VectorStoresAPI = __importStar(requireVectorStores());\n  \t\tconst FileBatchesAPI = __importStar(fileBatches);\n  \t\tconst FilesAPI = __importStar(requireFiles$1());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass VectorStores extends resource_1.APIResource {\n  \t\t    constructor() {\n  \t\t        super(...arguments);\n  \t\t        this.files = new FilesAPI.Files(this._client);\n  \t\t        this.fileBatches = new FileBatchesAPI.FileBatches(this._client);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Create a vector store.\n  \t\t     */\n  \t\t    create(body, options) {\n  \t\t        return this._client.post('/vector_stores', {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Retrieves a vector store.\n  \t\t     */\n  \t\t    retrieve(vectorStoreId, options) {\n  \t\t        return this._client.get(`/vector_stores/${vectorStoreId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Modifies a vector store.\n  \t\t     */\n  \t\t    update(vectorStoreId, body, options) {\n  \t\t        return this._client.post(`/vector_stores/${vectorStoreId}`, {\n  \t\t            body,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    list(query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list({}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList('/vector_stores', VectorStoresPage, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Delete a vector store.\n  \t\t     */\n  \t\t    del(vectorStoreId, options) {\n  \t\t        return this._client.delete(`/vector_stores/${vectorStoreId}`, {\n  \t\t            ...options,\n  \t\t            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t}\n  \t\texports.VectorStores = VectorStores;\n  \t\tclass VectorStoresPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.VectorStoresPage = VectorStoresPage;\n  \t\t(function (VectorStores) {\n  \t\t    VectorStores.VectorStoresPage = VectorStoresAPI.VectorStoresPage;\n  \t\t    VectorStores.Files = FilesAPI.Files;\n  \t\t    VectorStores.VectorStoreFilesPage = FilesAPI.VectorStoreFilesPage;\n  \t\t    VectorStores.FileBatches = FileBatchesAPI.FileBatches;\n  \t\t})(VectorStores = exports.VectorStores || (exports.VectorStores = {}));\n  \t\t\n  \t} (vectorStores));\n  \treturn vectorStores;\n  }\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Beta = void 0;\n  \tconst resource_1 = resource;\n  \tconst AssistantsAPI = __importStar(requireAssistants());\n  \tconst ChatAPI = __importStar(chat);\n  \tconst ThreadsAPI = __importStar(threads);\n  \tconst VectorStoresAPI = __importStar(requireVectorStores());\n  \tclass Beta extends resource_1.APIResource {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.vectorStores = new VectorStoresAPI.VectorStores(this._client);\n  \t        this.chat = new ChatAPI.Chat(this._client);\n  \t        this.assistants = new AssistantsAPI.Assistants(this._client);\n  \t        this.threads = new ThreadsAPI.Threads(this._client);\n  \t    }\n  \t}\n  \texports.Beta = Beta;\n  \t(function (Beta) {\n  \t    Beta.VectorStores = VectorStoresAPI.VectorStores;\n  \t    Beta.VectorStoresPage = VectorStoresAPI.VectorStoresPage;\n  \t    Beta.Chat = ChatAPI.Chat;\n  \t    Beta.Assistants = AssistantsAPI.Assistants;\n  \t    Beta.AssistantsPage = AssistantsAPI.AssistantsPage;\n  \t    Beta.Threads = ThreadsAPI.Threads;\n  \t})(Beta = exports.Beta || (exports.Beta = {}));\n  \t\n  } (beta));\n\n  var completions = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Completions = void 0;\n  \tconst resource_1 = resource;\n  \tclass Completions extends resource_1.APIResource {\n  \t    create(body, options) {\n  \t        return this._client.post('/completions', { body, ...options, stream: body.stream ?? false });\n  \t    }\n  \t}\n  \texports.Completions = Completions;\n  \t(function (Completions) {\n  \t})(Completions = exports.Completions || (exports.Completions = {}));\n  \t\n  } (completions));\n\n  var embeddings$4 = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Embeddings = void 0;\n  \tconst resource_1 = resource;\n  \tclass Embeddings extends resource_1.APIResource {\n  \t    /**\n  \t     * Creates an embedding vector representing the input text.\n  \t     */\n  \t    create(body, options) {\n  \t        return this._client.post('/embeddings', { body, ...options });\n  \t    }\n  \t}\n  \texports.Embeddings = Embeddings;\n  \t(function (Embeddings) {\n  \t})(Embeddings = exports.Embeddings || (exports.Embeddings = {}));\n  \t\n  } (embeddings$4));\n\n  var files = {};\n\n  var hasRequiredFiles;\n\n  function requireFiles () {\n  \tif (hasRequiredFiles) return files;\n  \thasRequiredFiles = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.FileObjectsPage = exports.Files = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst core_2 = requireCore();\n  \t\tconst error_1 = requireError();\n  \t\tconst Core = __importStar(requireCore());\n  \t\tconst FilesAPI = __importStar(requireFiles());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Files extends resource_1.APIResource {\n  \t\t    /**\n  \t\t     * Upload a file that can be used across various endpoints. Individual files can be\n  \t\t     * up to 512 MB, and the size of all files uploaded by one organization can be up\n  \t\t     * to 100 GB.\n  \t\t     *\n  \t\t     * The Assistants API supports files up to 2 million tokens and of specific file\n  \t\t     * types. See the\n  \t\t     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for\n  \t\t     * details.\n  \t\t     *\n  \t\t     * The Fine-tuning API only supports `.jsonl` files. The input also has certain\n  \t\t     * required formats for fine-tuning\n  \t\t     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n  \t\t     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n  \t\t     * models.\n  \t\t     *\n  \t\t     * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also\n  \t\t     * has a specific required\n  \t\t     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).\n  \t\t     *\n  \t\t     * Please [contact us](https://help.openai.com/) if you need to increase these\n  \t\t     * storage limits.\n  \t\t     */\n  \t\t    create(body, options) {\n  \t\t        return this._client.post('/files', Core.multipartFormRequestOptions({ body, ...options }));\n  \t\t    }\n  \t\t    /**\n  \t\t     * Returns information about a specific file.\n  \t\t     */\n  \t\t    retrieve(fileId, options) {\n  \t\t        return this._client.get(`/files/${fileId}`, options);\n  \t\t    }\n  \t\t    list(query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list({}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList('/files', FileObjectsPage, { query, ...options });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Delete a file.\n  \t\t     */\n  \t\t    del(fileId, options) {\n  \t\t        return this._client.delete(`/files/${fileId}`, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Returns the contents of the specified file.\n  \t\t     */\n  \t\t    content(fileId, options) {\n  \t\t        return this._client.get(`/files/${fileId}/content`, { ...options, __binaryResponse: true });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Returns the contents of the specified file.\n  \t\t     *\n  \t\t     * @deprecated The `.content()` method should be used instead\n  \t\t     */\n  \t\t    retrieveContent(fileId, options) {\n  \t\t        return this._client.get(`/files/${fileId}/content`, {\n  \t\t            ...options,\n  \t\t            headers: { Accept: 'application/json', ...options?.headers },\n  \t\t        });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Waits for the given file to be processed, default timeout is 30 mins.\n  \t\t     */\n  \t\t    async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {\n  \t\t        const TERMINAL_STATES = new Set(['processed', 'error', 'deleted']);\n  \t\t        const start = Date.now();\n  \t\t        let file = await this.retrieve(id);\n  \t\t        while (!file.status || !TERMINAL_STATES.has(file.status)) {\n  \t\t            await (0, core_2.sleep)(pollInterval);\n  \t\t            file = await this.retrieve(id);\n  \t\t            if (Date.now() - start > maxWait) {\n  \t\t                throw new error_1.APIConnectionTimeoutError({\n  \t\t                    message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,\n  \t\t                });\n  \t\t            }\n  \t\t        }\n  \t\t        return file;\n  \t\t    }\n  \t\t}\n  \t\texports.Files = Files;\n  \t\t/**\n  \t\t * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n  \t\t */\n  \t\tclass FileObjectsPage extends pagination_1.Page {\n  \t\t}\n  \t\texports.FileObjectsPage = FileObjectsPage;\n  \t\t(function (Files) {\n  \t\t    Files.FileObjectsPage = FilesAPI.FileObjectsPage;\n  \t\t})(Files = exports.Files || (exports.Files = {}));\n  \t\t\n  \t} (files));\n  \treturn files;\n  }\n\n  var fineTuning = {};\n\n  var jobs = {};\n\n  var checkpoints = {};\n\n  var hasRequiredCheckpoints;\n\n  function requireCheckpoints () {\n  \tif (hasRequiredCheckpoints) return checkpoints;\n  \thasRequiredCheckpoints = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.FineTuningJobCheckpointsPage = exports.Checkpoints = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst CheckpointsAPI = __importStar(requireCheckpoints());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Checkpoints extends resource_1.APIResource {\n  \t\t    list(fineTuningJobId, query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list(fineTuningJobId, {}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });\n  \t\t    }\n  \t\t}\n  \t\texports.Checkpoints = Checkpoints;\n  \t\tclass FineTuningJobCheckpointsPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n  \t\t(function (Checkpoints) {\n  \t\t    Checkpoints.FineTuningJobCheckpointsPage = CheckpointsAPI.FineTuningJobCheckpointsPage;\n  \t\t})(Checkpoints = exports.Checkpoints || (exports.Checkpoints = {}));\n  \t\t\n  \t} (checkpoints));\n  \treturn checkpoints;\n  }\n\n  var hasRequiredJobs;\n\n  function requireJobs () {\n  \tif (hasRequiredJobs) return jobs;\n  \thasRequiredJobs = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.FineTuningJobEventsPage = exports.FineTuningJobsPage = exports.Jobs = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst core_1 = requireCore();\n  \t\tconst JobsAPI = __importStar(requireJobs());\n  \t\tconst CheckpointsAPI = __importStar(requireCheckpoints());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Jobs extends resource_1.APIResource {\n  \t\t    constructor() {\n  \t\t        super(...arguments);\n  \t\t        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Creates a fine-tuning job which begins the process of creating a new model from\n  \t\t     * a given dataset.\n  \t\t     *\n  \t\t     * Response includes details of the enqueued job including job status and the name\n  \t\t     * of the fine-tuned models once complete.\n  \t\t     *\n  \t\t     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n  \t\t     */\n  \t\t    create(body, options) {\n  \t\t        return this._client.post('/fine_tuning/jobs', { body, ...options });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Get info about a fine-tuning job.\n  \t\t     *\n  \t\t     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n  \t\t     */\n  \t\t    retrieve(fineTuningJobId, options) {\n  \t\t        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);\n  \t\t    }\n  \t\t    list(query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.list({}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList('/fine_tuning/jobs', FineTuningJobsPage, { query, ...options });\n  \t\t    }\n  \t\t    /**\n  \t\t     * Immediately cancel a fine-tune job.\n  \t\t     */\n  \t\t    cancel(fineTuningJobId, options) {\n  \t\t        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);\n  \t\t    }\n  \t\t    listEvents(fineTuningJobId, query = {}, options) {\n  \t\t        if ((0, core_1.isRequestOptions)(query)) {\n  \t\t            return this.listEvents(fineTuningJobId, {}, query);\n  \t\t        }\n  \t\t        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {\n  \t\t            query,\n  \t\t            ...options,\n  \t\t        });\n  \t\t    }\n  \t\t}\n  \t\texports.Jobs = Jobs;\n  \t\tclass FineTuningJobsPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.FineTuningJobsPage = FineTuningJobsPage;\n  \t\tclass FineTuningJobEventsPage extends pagination_1.CursorPage {\n  \t\t}\n  \t\texports.FineTuningJobEventsPage = FineTuningJobEventsPage;\n  \t\t(function (Jobs) {\n  \t\t    Jobs.FineTuningJobsPage = JobsAPI.FineTuningJobsPage;\n  \t\t    Jobs.FineTuningJobEventsPage = JobsAPI.FineTuningJobEventsPage;\n  \t\t    Jobs.Checkpoints = CheckpointsAPI.Checkpoints;\n  \t\t    Jobs.FineTuningJobCheckpointsPage = CheckpointsAPI.FineTuningJobCheckpointsPage;\n  \t\t})(Jobs = exports.Jobs || (exports.Jobs = {}));\n  \t\t\n  \t} (jobs));\n  \treturn jobs;\n  }\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.FineTuning = void 0;\n  \tconst resource_1 = resource;\n  \tconst JobsAPI = __importStar(requireJobs());\n  \tclass FineTuning extends resource_1.APIResource {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.jobs = new JobsAPI.Jobs(this._client);\n  \t    }\n  \t}\n  \texports.FineTuning = FineTuning;\n  \t(function (FineTuning) {\n  \t    FineTuning.Jobs = JobsAPI.Jobs;\n  \t    FineTuning.FineTuningJobsPage = JobsAPI.FineTuningJobsPage;\n  \t    FineTuning.FineTuningJobEventsPage = JobsAPI.FineTuningJobEventsPage;\n  \t})(FineTuning = exports.FineTuning || (exports.FineTuning = {}));\n  \t\n  } (fineTuning));\n\n  var images = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Images = void 0;\n  \tconst resource_1 = resource;\n  \tconst Core = __importStar(requireCore());\n  \tclass Images extends resource_1.APIResource {\n  \t    /**\n  \t     * Creates a variation of a given image.\n  \t     */\n  \t    createVariation(body, options) {\n  \t        return this._client.post('/images/variations', Core.multipartFormRequestOptions({ body, ...options }));\n  \t    }\n  \t    /**\n  \t     * Creates an edited or extended image given an original image and a prompt.\n  \t     */\n  \t    edit(body, options) {\n  \t        return this._client.post('/images/edits', Core.multipartFormRequestOptions({ body, ...options }));\n  \t    }\n  \t    /**\n  \t     * Creates an image given a prompt.\n  \t     */\n  \t    generate(body, options) {\n  \t        return this._client.post('/images/generations', { body, ...options });\n  \t    }\n  \t}\n  \texports.Images = Images;\n  \t(function (Images) {\n  \t})(Images = exports.Images || (exports.Images = {}));\n  \t\n  } (images));\n\n  var models = {};\n\n  var hasRequiredModels;\n\n  function requireModels () {\n  \tif (hasRequiredModels) return models;\n  \thasRequiredModels = 1;\n  \t(function (exports) {\n  \t\t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \t\tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t\t    }\n  \t\t    Object.defineProperty(o, k2, desc);\n  \t\t}) : (function(o, m, k, k2) {\n  \t\t    if (k2 === undefined) k2 = k;\n  \t\t    o[k2] = m[k];\n  \t\t}));\n  \t\tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t\t}) : function(o, v) {\n  \t\t    o[\"default\"] = v;\n  \t\t});\n  \t\tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t\t    if (mod && mod.__esModule) return mod;\n  \t\t    var result = {};\n  \t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t\t    __setModuleDefault(result, mod);\n  \t\t    return result;\n  \t\t};\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.ModelsPage = exports.Models = void 0;\n  \t\tconst resource_1 = resource;\n  \t\tconst ModelsAPI = __importStar(requireModels());\n  \t\tconst pagination_1 = pagination;\n  \t\tclass Models extends resource_1.APIResource {\n  \t\t    /**\n  \t\t     * Retrieves a model instance, providing basic information about the model such as\n  \t\t     * the owner and permissioning.\n  \t\t     */\n  \t\t    retrieve(model, options) {\n  \t\t        return this._client.get(`/models/${model}`, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Lists the currently available models, and provides basic information about each\n  \t\t     * one such as the owner and availability.\n  \t\t     */\n  \t\t    list(options) {\n  \t\t        return this._client.getAPIList('/models', ModelsPage, options);\n  \t\t    }\n  \t\t    /**\n  \t\t     * Delete a fine-tuned model. You must have the Owner role in your organization to\n  \t\t     * delete a model.\n  \t\t     */\n  \t\t    del(model, options) {\n  \t\t        return this._client.delete(`/models/${model}`, options);\n  \t\t    }\n  \t\t}\n  \t\texports.Models = Models;\n  \t\t/**\n  \t\t * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n  \t\t */\n  \t\tclass ModelsPage extends pagination_1.Page {\n  \t\t}\n  \t\texports.ModelsPage = ModelsPage;\n  \t\t(function (Models) {\n  \t\t    Models.ModelsPage = ModelsAPI.ModelsPage;\n  \t\t})(Models = exports.Models || (exports.Models = {}));\n  \t\t\n  \t} (models));\n  \treturn models;\n  }\n\n  var moderations = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Moderations = void 0;\n  \tconst resource_1 = resource;\n  \tclass Moderations extends resource_1.APIResource {\n  \t    /**\n  \t     * Classifies if text is potentially harmful.\n  \t     */\n  \t    create(body, options) {\n  \t        return this._client.post('/moderations', { body, ...options });\n  \t    }\n  \t}\n  \texports.Moderations = Moderations;\n  \t(function (Moderations) {\n  \t})(Moderations = exports.Moderations || (exports.Moderations = {}));\n  \t\n  } (moderations));\n\n  var uploads = {};\n\n  var parts = {};\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Parts = void 0;\n  \tconst resource_1 = resource;\n  \tconst Core = __importStar(requireCore());\n  \tclass Parts extends resource_1.APIResource {\n  \t    /**\n  \t     * Adds a\n  \t     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an\n  \t     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.\n  \t     * A Part represents a chunk of bytes from the file you are trying to upload.\n  \t     *\n  \t     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload\n  \t     * maximum of 8 GB.\n  \t     *\n  \t     * It is possible to add multiple Parts in parallel. You can decide the intended\n  \t     * order of the Parts when you\n  \t     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).\n  \t     */\n  \t    create(uploadId, body, options) {\n  \t        return this._client.post(`/uploads/${uploadId}/parts`, Core.multipartFormRequestOptions({ body, ...options }));\n  \t    }\n  \t}\n  \texports.Parts = Parts;\n  \t(function (Parts) {\n  \t})(Parts = exports.Parts || (exports.Parts = {}));\n  \t\n  } (parts));\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __setModuleDefault = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n  \t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  \t}) : function(o, v) {\n  \t    o[\"default\"] = v;\n  \t});\n  \tvar __importStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar) || function (mod) {\n  \t    if (mod && mod.__esModule) return mod;\n  \t    var result = {};\n  \t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  \t    __setModuleDefault(result, mod);\n  \t    return result;\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Uploads = void 0;\n  \tconst resource_1 = resource;\n  \tconst PartsAPI = __importStar(parts);\n  \tclass Uploads extends resource_1.APIResource {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        this.parts = new PartsAPI.Parts(this._client);\n  \t    }\n  \t    /**\n  \t     * Creates an intermediate\n  \t     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object\n  \t     * that you can add\n  \t     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.\n  \t     * Currently, an Upload can accept at most 8 GB in total and expires after an hour\n  \t     * after you create it.\n  \t     *\n  \t     * Once you complete the Upload, we will create a\n  \t     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n  \t     * contains all the parts you uploaded. This File is usable in the rest of our\n  \t     * platform as a regular File object.\n  \t     *\n  \t     * For certain `purpose`s, the correct `mime_type` must be specified. Please refer\n  \t     * to documentation for the supported MIME types for your use case:\n  \t     *\n  \t     * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search/supported-files)\n  \t     *\n  \t     * For guidance on the proper filename extensions for each purpose, please follow\n  \t     * the documentation on\n  \t     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).\n  \t     */\n  \t    create(body, options) {\n  \t        return this._client.post('/uploads', { body, ...options });\n  \t    }\n  \t    /**\n  \t     * Cancels the Upload. No Parts may be added after an Upload is cancelled.\n  \t     */\n  \t    cancel(uploadId, options) {\n  \t        return this._client.post(`/uploads/${uploadId}/cancel`, options);\n  \t    }\n  \t    /**\n  \t     * Completes the\n  \t     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).\n  \t     *\n  \t     * Within the returned Upload object, there is a nested\n  \t     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n  \t     * is ready to use in the rest of the platform.\n  \t     *\n  \t     * You can specify the order of the Parts by passing in an ordered list of the Part\n  \t     * IDs.\n  \t     *\n  \t     * The number of bytes uploaded upon completion must match the number of bytes\n  \t     * initially specified when creating the Upload object. No Parts may be added after\n  \t     * an Upload is completed.\n  \t     */\n  \t    complete(uploadId, body, options) {\n  \t        return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });\n  \t    }\n  \t}\n  \texports.Uploads = Uploads;\n  \t(function (Uploads) {\n  \t    Uploads.Parts = PartsAPI.Parts;\n  \t})(Uploads = exports.Uploads || (exports.Uploads = {}));\n  \t\n  } (uploads));\n\n  (function (exports) {\n  \t// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.Uploads = exports.Moderations = exports.Models = exports.ModelsPage = exports.Images = exports.FineTuning = exports.Files = exports.FileObjectsPage = exports.Embeddings = exports.Completions = exports.Beta = exports.Batches = exports.BatchesPage = exports.Audio = void 0;\n  \t__exportStar(chat$2, exports);\n  \t__exportStar(shared, exports);\n  \tvar audio_1 = audio;\n  \tObject.defineProperty(exports, \"Audio\", { enumerable: true, get: function () { return audio_1.Audio; } });\n  \tvar batches_1 = requireBatches();\n  \tObject.defineProperty(exports, \"BatchesPage\", { enumerable: true, get: function () { return batches_1.BatchesPage; } });\n  \tObject.defineProperty(exports, \"Batches\", { enumerable: true, get: function () { return batches_1.Batches; } });\n  \tvar beta_1 = beta;\n  \tObject.defineProperty(exports, \"Beta\", { enumerable: true, get: function () { return beta_1.Beta; } });\n  \tvar completions_1 = completions;\n  \tObject.defineProperty(exports, \"Completions\", { enumerable: true, get: function () { return completions_1.Completions; } });\n  \tvar embeddings_1 = embeddings$4;\n  \tObject.defineProperty(exports, \"Embeddings\", { enumerable: true, get: function () { return embeddings_1.Embeddings; } });\n  \tvar files_1 = requireFiles();\n  \tObject.defineProperty(exports, \"FileObjectsPage\", { enumerable: true, get: function () { return files_1.FileObjectsPage; } });\n  \tObject.defineProperty(exports, \"Files\", { enumerable: true, get: function () { return files_1.Files; } });\n  \tvar fine_tuning_1 = fineTuning;\n  \tObject.defineProperty(exports, \"FineTuning\", { enumerable: true, get: function () { return fine_tuning_1.FineTuning; } });\n  \tvar images_1 = images;\n  \tObject.defineProperty(exports, \"Images\", { enumerable: true, get: function () { return images_1.Images; } });\n  \tvar models_1 = requireModels();\n  \tObject.defineProperty(exports, \"ModelsPage\", { enumerable: true, get: function () { return models_1.ModelsPage; } });\n  \tObject.defineProperty(exports, \"Models\", { enumerable: true, get: function () { return models_1.Models; } });\n  \tvar moderations_1 = moderations;\n  \tObject.defineProperty(exports, \"Moderations\", { enumerable: true, get: function () { return moderations_1.Moderations; } });\n  \tvar uploads_1 = uploads;\n  \tObject.defineProperty(exports, \"Uploads\", { enumerable: true, get: function () { return uploads_1.Uploads; } });\n  \t\n  } (resources));\n\n  (function (module, exports) {\n    var __createBinding = messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || ((\"get\" in desc) ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n          enumerable: true,\n          get: function () {\n            return m[k];\n          }\n        };\n      }\n      Object.defineProperty(o, k2, desc);\n    } : function (o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      o[k2] = m[k];\n    });\n    var __setModuleDefault = messages$1.commonjsGlobal && messages$1.commonjsGlobal.__setModuleDefault || (Object.create ? function (o, v) {\n      Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n      });\n    } : function (o, v) {\n      o[\"default\"] = v;\n    });\n    var __importStar = messages$1.commonjsGlobal && messages$1.commonjsGlobal.__importStar || (function (mod) {\n      if (mod && mod.__esModule) return mod;\n      var result = {};\n      if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n      __setModuleDefault(result, mod);\n      return result;\n    });\n    var _a;\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.AzureOpenAI = exports.fileFromPath = exports.toFile = exports.UnprocessableEntityError = exports.PermissionDeniedError = exports.InternalServerError = exports.AuthenticationError = exports.BadRequestError = exports.RateLimitError = exports.ConflictError = exports.NotFoundError = exports.APIUserAbortError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIError = exports.OpenAIError = exports.OpenAI = void 0;\n    const Errors = __importStar(requireError());\n    const Uploads = __importStar(uploads$1);\n    const qs$1 = __importStar(qs);\n    const Core = __importStar(requireCore());\n    const Pagination = __importStar(pagination);\n    const API = __importStar(resources);\n    class OpenAI extends Core.APIClient {\n      constructor({baseURL = Core.readEnv(\"OPENAI_BASE_URL\"), apiKey = Core.readEnv(\"OPENAI_API_KEY\"), organization = Core.readEnv(\"OPENAI_ORG_ID\") ?? null, project = Core.readEnv(\"OPENAI_PROJECT_ID\") ?? null, ...opts} = {}) {\n        if (apiKey === undefined) {\n          throw new Errors.OpenAIError(\"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\");\n        }\n        const options = {\n          apiKey,\n          organization,\n          project,\n          ...opts,\n          baseURL: baseURL || `https://api.openai.com/v1`\n        };\n        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n          throw new Errors.OpenAIError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\\n\\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\\n\");\n        }\n        super({\n          baseURL: options.baseURL,\n          timeout: options.timeout ?? 600000,\n          httpAgent: options.httpAgent,\n          maxRetries: options.maxRetries,\n          fetch: options.fetch\n        });\n        this.completions = new API.Completions(this);\n        this.chat = new API.Chat(this);\n        this.embeddings = new API.Embeddings(this);\n        this.files = new API.Files(this);\n        this.images = new API.Images(this);\n        this.audio = new API.Audio(this);\n        this.moderations = new API.Moderations(this);\n        this.models = new API.Models(this);\n        this.fineTuning = new API.FineTuning(this);\n        this.beta = new API.Beta(this);\n        this.batches = new API.Batches(this);\n        this.uploads = new API.Uploads(this);\n        this._options = options;\n        this.apiKey = apiKey;\n        this.organization = organization;\n        this.project = project;\n      }\n      defaultQuery() {\n        return this._options.defaultQuery;\n      }\n      defaultHeaders(opts) {\n        return {\n          ...super.defaultHeaders(opts),\n          \"OpenAI-Organization\": this.organization,\n          \"OpenAI-Project\": this.project,\n          ...this._options.defaultHeaders\n        };\n      }\n      authHeaders(opts) {\n        return {\n          Authorization: `Bearer ${this.apiKey}`\n        };\n      }\n      stringifyQuery(query) {\n        return qs$1.stringify(query, {\n          arrayFormat: \"brackets\"\n        });\n      }\n    }\n    exports.OpenAI = OpenAI;\n    _a = OpenAI;\n    OpenAI.OpenAI = _a;\n    OpenAI.DEFAULT_TIMEOUT = 600000;\n    OpenAI.OpenAIError = Errors.OpenAIError;\n    OpenAI.APIError = Errors.APIError;\n    OpenAI.APIConnectionError = Errors.APIConnectionError;\n    OpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\n    OpenAI.APIUserAbortError = Errors.APIUserAbortError;\n    OpenAI.NotFoundError = Errors.NotFoundError;\n    OpenAI.ConflictError = Errors.ConflictError;\n    OpenAI.RateLimitError = Errors.RateLimitError;\n    OpenAI.BadRequestError = Errors.BadRequestError;\n    OpenAI.AuthenticationError = Errors.AuthenticationError;\n    OpenAI.InternalServerError = Errors.InternalServerError;\n    OpenAI.PermissionDeniedError = Errors.PermissionDeniedError;\n    OpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;\n    OpenAI.toFile = Uploads.toFile;\n    OpenAI.fileFromPath = Uploads.fileFromPath;\n    (exports.OpenAIError = Errors.OpenAIError, exports.APIError = Errors.APIError, exports.APIConnectionError = Errors.APIConnectionError, exports.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError, exports.APIUserAbortError = Errors.APIUserAbortError, exports.NotFoundError = Errors.NotFoundError, exports.ConflictError = Errors.ConflictError, exports.RateLimitError = Errors.RateLimitError, exports.BadRequestError = Errors.BadRequestError, exports.AuthenticationError = Errors.AuthenticationError, exports.InternalServerError = Errors.InternalServerError, exports.PermissionDeniedError = Errors.PermissionDeniedError, exports.UnprocessableEntityError = Errors.UnprocessableEntityError);\n    exports.toFile = Uploads.toFile;\n    exports.fileFromPath = Uploads.fileFromPath;\n    (function (OpenAI) {\n      OpenAI.Page = Pagination.Page;\n      OpenAI.CursorPage = Pagination.CursorPage;\n      OpenAI.Completions = API.Completions;\n      OpenAI.Chat = API.Chat;\n      OpenAI.Embeddings = API.Embeddings;\n      OpenAI.Files = API.Files;\n      OpenAI.FileObjectsPage = API.FileObjectsPage;\n      OpenAI.Images = API.Images;\n      OpenAI.Audio = API.Audio;\n      OpenAI.Moderations = API.Moderations;\n      OpenAI.Models = API.Models;\n      OpenAI.ModelsPage = API.ModelsPage;\n      OpenAI.FineTuning = API.FineTuning;\n      OpenAI.Beta = API.Beta;\n      OpenAI.Batches = API.Batches;\n      OpenAI.BatchesPage = API.BatchesPage;\n      OpenAI.Uploads = API.Uploads;\n    })(OpenAI = exports.OpenAI || (exports.OpenAI = {}));\n    class AzureOpenAI extends OpenAI {\n      constructor({baseURL = Core.readEnv(\"OPENAI_BASE_URL\"), apiKey = Core.readEnv(\"AZURE_OPENAI_API_KEY\"), apiVersion = Core.readEnv(\"OPENAI_API_VERSION\"), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts} = {}) {\n        if (!apiVersion) {\n          throw new Errors.OpenAIError(\"The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).\");\n        }\n        if (typeof azureADTokenProvider === \"function\") {\n          dangerouslyAllowBrowser = true;\n        }\n        if (!azureADTokenProvider && !apiKey) {\n          throw new Errors.OpenAIError(\"Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.\");\n        }\n        if (azureADTokenProvider && apiKey) {\n          throw new Errors.OpenAIError(\"The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.\");\n        }\n        apiKey ?? (apiKey = API_KEY_SENTINEL);\n        opts.defaultQuery = {\n          ...opts.defaultQuery,\n          \"api-version\": apiVersion\n        };\n        if (!baseURL) {\n          if (!endpoint) {\n            endpoint = messages$1.browser$1.env[\"AZURE_OPENAI_ENDPOINT\"];\n          }\n          if (!endpoint) {\n            throw new Errors.OpenAIError(\"Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable\");\n          }\n          baseURL = `${endpoint}/openai`;\n        } else {\n          if (endpoint) {\n            throw new Errors.OpenAIError(\"baseURL and endpoint are mutually exclusive\");\n          }\n        }\n        super({\n          apiKey,\n          baseURL,\n          ...opts,\n          ...dangerouslyAllowBrowser !== undefined ? {\n            dangerouslyAllowBrowser\n          } : {}\n        });\n        this.apiVersion = \"\";\n        this._azureADTokenProvider = azureADTokenProvider;\n        this.apiVersion = apiVersion;\n        this._deployment = deployment;\n      }\n      buildRequest(options) {\n        if (_deployments_endpoints.has(options.path) && options.method === \"post\" && options.body !== undefined) {\n          if (!Core.isObj(options.body)) {\n            throw new Error(\"Expected request body to be an object\");\n          }\n          const model = this._deployment || options.body[\"model\"];\n          if (model !== undefined && !this.baseURL.includes(\"/deployments\")) {\n            options.path = `/deployments/${model}${options.path}`;\n          }\n        }\n        return super.buildRequest(options);\n      }\n      async _getAzureADToken() {\n        if (typeof this._azureADTokenProvider === \"function\") {\n          const token = await this._azureADTokenProvider();\n          if (!token || typeof token !== \"string\") {\n            throw new Errors.OpenAIError(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);\n          }\n          return token;\n        }\n        return undefined;\n      }\n      authHeaders(opts) {\n        return {};\n      }\n      async prepareOptions(opts) {\n        if (opts.headers?.[\"api-key\"]) {\n          return super.prepareOptions(opts);\n        }\n        const token = await this._getAzureADToken();\n        opts.headers ?? (opts.headers = {});\n        if (token) {\n          opts.headers[\"Authorization\"] = `Bearer ${token}`;\n        } else if (this.apiKey !== API_KEY_SENTINEL) {\n          opts.headers[\"api-key\"] = this.apiKey;\n        } else {\n          throw new Errors.OpenAIError(\"Unable to handle auth\");\n        }\n        return super.prepareOptions(opts);\n      }\n    }\n    exports.AzureOpenAI = AzureOpenAI;\n    const _deployments_endpoints = new Set([\"/completions\", \"/chat/completions\", \"/embeddings\", \"/audio/transcriptions\", \"/audio/translations\", \"/audio/speech\", \"/images/generations\"]);\n    const API_KEY_SENTINEL = \"<Missing Key>\";\n    exports = module.exports = OpenAI;\n    module.exports.AzureOpenAI = AzureOpenAI;\n    exports.default = OpenAI;\n  })(openai$2, openai$2.exports);\n  var openaiExports = openai$2.exports;\n\n  var chat_models$3 = {};\n\n  var outputs = messages$1.outputs;\n\n  var env = messages$1.env;\n\n  var chat_models$2 = {};\n\n  var base$3 = {};\n\n  var base$2 = {};\n\n  var hash$1 = {};\n\n  var hash = {};\n\n  Object.defineProperty(hash, \"__esModule\", { value: true });\n  hash.insecureHash = void 0;\n  var root = typeof window === \"object\" ? window : {};\n  var HEX_CHARS = \"0123456789abcdef\".split(\"\");\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var blocks = [];\n  function Sha1(sharedMemory) {\n      if (sharedMemory) {\n          blocks[0] =\n              blocks[16] =\n                  blocks[1] =\n                      blocks[2] =\n                          blocks[3] =\n                              blocks[4] =\n                                  blocks[5] =\n                                      blocks[6] =\n                                          blocks[7] =\n                                              blocks[8] =\n                                                  blocks[9] =\n                                                      blocks[10] =\n                                                          blocks[11] =\n                                                              blocks[12] =\n                                                                  blocks[13] =\n                                                                      blocks[14] =\n                                                                          blocks[15] =\n                                                                              0;\n          this.blocks = blocks;\n      }\n      else {\n          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      }\n      this.h0 = 0x67452301;\n      this.h1 = 0xefcdab89;\n      this.h2 = 0x98badcfe;\n      this.h3 = 0x10325476;\n      this.h4 = 0xc3d2e1f0;\n      this.block = this.start = this.bytes = this.hBytes = 0;\n      this.finalized = this.hashed = false;\n      this.first = true;\n  }\n  Sha1.prototype.update = function (message) {\n      if (this.finalized) {\n          return;\n      }\n      var notString = typeof message !== \"string\";\n      if (notString && message.constructor === root.ArrayBuffer) {\n          message = new Uint8Array(message);\n      }\n      var code, index = 0, i, length = message.length || 0, blocks = this.blocks;\n      while (index < length) {\n          if (this.hashed) {\n              this.hashed = false;\n              blocks[0] = this.block;\n              blocks[16] =\n                  blocks[1] =\n                      blocks[2] =\n                          blocks[3] =\n                              blocks[4] =\n                                  blocks[5] =\n                                      blocks[6] =\n                                          blocks[7] =\n                                              blocks[8] =\n                                                  blocks[9] =\n                                                      blocks[10] =\n                                                          blocks[11] =\n                                                              blocks[12] =\n                                                                  blocks[13] =\n                                                                      blocks[14] =\n                                                                          blocks[15] =\n                                                                              0;\n          }\n          if (notString) {\n              for (i = this.start; index < length && i < 64; ++index) {\n                  blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n              }\n          }\n          else {\n              for (i = this.start; index < length && i < 64; ++index) {\n                  code = message.charCodeAt(index);\n                  if (code < 0x80) {\n                      blocks[i >> 2] |= code << SHIFT[i++ & 3];\n                  }\n                  else if (code < 0x800) {\n                      blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                  }\n                  else if (code < 0xd800 || code >= 0xe000) {\n                      blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n                      blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                  }\n                  else {\n                      code =\n                          0x10000 +\n                              (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                      blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n                      blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n                      blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                  }\n              }\n          }\n          this.lastByteIndex = i;\n          this.bytes += i - this.start;\n          if (i >= 64) {\n              this.block = blocks[16];\n              this.start = i - 64;\n              this.hash();\n              this.hashed = true;\n          }\n          else {\n              this.start = i;\n          }\n      }\n      if (this.bytes > 4294967295) {\n          this.hBytes += (this.bytes / 4294967296) << 0;\n          this.bytes = this.bytes % 4294967296;\n      }\n      return this;\n  };\n  Sha1.prototype.finalize = function () {\n      if (this.finalized) {\n          return;\n      }\n      this.finalized = true;\n      var blocks = this.blocks, i = this.lastByteIndex;\n      blocks[16] = this.block;\n      blocks[i >> 2] |= EXTRA[i & 3];\n      this.block = blocks[16];\n      if (i >= 56) {\n          if (!this.hashed) {\n              this.hash();\n          }\n          blocks[0] = this.block;\n          blocks[16] =\n              blocks[1] =\n                  blocks[2] =\n                      blocks[3] =\n                          blocks[4] =\n                              blocks[5] =\n                                  blocks[6] =\n                                      blocks[7] =\n                                          blocks[8] =\n                                              blocks[9] =\n                                                  blocks[10] =\n                                                      blocks[11] =\n                                                          blocks[12] =\n                                                              blocks[13] =\n                                                                  blocks[14] =\n                                                                      blocks[15] =\n                                                                          0;\n      }\n      blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n      blocks[15] = this.bytes << 3;\n      this.hash();\n  };\n  Sha1.prototype.hash = function () {\n      var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;\n      var f, j, t, blocks = this.blocks;\n      for (j = 16; j < 80; ++j) {\n          t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];\n          blocks[j] = (t << 1) | (t >>> 31);\n      }\n      for (j = 0; j < 20; j += 5) {\n          f = (b & c) | (~b & d);\n          t = (a << 5) | (a >>> 27);\n          e = (t + f + e + 1518500249 + blocks[j]) << 0;\n          b = (b << 30) | (b >>> 2);\n          f = (a & b) | (~a & c);\n          t = (e << 5) | (e >>> 27);\n          d = (t + f + d + 1518500249 + blocks[j + 1]) << 0;\n          a = (a << 30) | (a >>> 2);\n          f = (e & a) | (~e & b);\n          t = (d << 5) | (d >>> 27);\n          c = (t + f + c + 1518500249 + blocks[j + 2]) << 0;\n          e = (e << 30) | (e >>> 2);\n          f = (d & e) | (~d & a);\n          t = (c << 5) | (c >>> 27);\n          b = (t + f + b + 1518500249 + blocks[j + 3]) << 0;\n          d = (d << 30) | (d >>> 2);\n          f = (c & d) | (~c & e);\n          t = (b << 5) | (b >>> 27);\n          a = (t + f + a + 1518500249 + blocks[j + 4]) << 0;\n          c = (c << 30) | (c >>> 2);\n      }\n      for (; j < 40; j += 5) {\n          f = b ^ c ^ d;\n          t = (a << 5) | (a >>> 27);\n          e = (t + f + e + 1859775393 + blocks[j]) << 0;\n          b = (b << 30) | (b >>> 2);\n          f = a ^ b ^ c;\n          t = (e << 5) | (e >>> 27);\n          d = (t + f + d + 1859775393 + blocks[j + 1]) << 0;\n          a = (a << 30) | (a >>> 2);\n          f = e ^ a ^ b;\n          t = (d << 5) | (d >>> 27);\n          c = (t + f + c + 1859775393 + blocks[j + 2]) << 0;\n          e = (e << 30) | (e >>> 2);\n          f = d ^ e ^ a;\n          t = (c << 5) | (c >>> 27);\n          b = (t + f + b + 1859775393 + blocks[j + 3]) << 0;\n          d = (d << 30) | (d >>> 2);\n          f = c ^ d ^ e;\n          t = (b << 5) | (b >>> 27);\n          a = (t + f + a + 1859775393 + blocks[j + 4]) << 0;\n          c = (c << 30) | (c >>> 2);\n      }\n      for (; j < 60; j += 5) {\n          f = (b & c) | (b & d) | (c & d);\n          t = (a << 5) | (a >>> 27);\n          e = (t + f + e - 1894007588 + blocks[j]) << 0;\n          b = (b << 30) | (b >>> 2);\n          f = (a & b) | (a & c) | (b & c);\n          t = (e << 5) | (e >>> 27);\n          d = (t + f + d - 1894007588 + blocks[j + 1]) << 0;\n          a = (a << 30) | (a >>> 2);\n          f = (e & a) | (e & b) | (a & b);\n          t = (d << 5) | (d >>> 27);\n          c = (t + f + c - 1894007588 + blocks[j + 2]) << 0;\n          e = (e << 30) | (e >>> 2);\n          f = (d & e) | (d & a) | (e & a);\n          t = (c << 5) | (c >>> 27);\n          b = (t + f + b - 1894007588 + blocks[j + 3]) << 0;\n          d = (d << 30) | (d >>> 2);\n          f = (c & d) | (c & e) | (d & e);\n          t = (b << 5) | (b >>> 27);\n          a = (t + f + a - 1894007588 + blocks[j + 4]) << 0;\n          c = (c << 30) | (c >>> 2);\n      }\n      for (; j < 80; j += 5) {\n          f = b ^ c ^ d;\n          t = (a << 5) | (a >>> 27);\n          e = (t + f + e - 899497514 + blocks[j]) << 0;\n          b = (b << 30) | (b >>> 2);\n          f = a ^ b ^ c;\n          t = (e << 5) | (e >>> 27);\n          d = (t + f + d - 899497514 + blocks[j + 1]) << 0;\n          a = (a << 30) | (a >>> 2);\n          f = e ^ a ^ b;\n          t = (d << 5) | (d >>> 27);\n          c = (t + f + c - 899497514 + blocks[j + 2]) << 0;\n          e = (e << 30) | (e >>> 2);\n          f = d ^ e ^ a;\n          t = (c << 5) | (c >>> 27);\n          b = (t + f + b - 899497514 + blocks[j + 3]) << 0;\n          d = (d << 30) | (d >>> 2);\n          f = c ^ d ^ e;\n          t = (b << 5) | (b >>> 27);\n          a = (t + f + a - 899497514 + blocks[j + 4]) << 0;\n          c = (c << 30) | (c >>> 2);\n      }\n      this.h0 = (this.h0 + a) << 0;\n      this.h1 = (this.h1 + b) << 0;\n      this.h2 = (this.h2 + c) << 0;\n      this.h3 = (this.h3 + d) << 0;\n      this.h4 = (this.h4 + e) << 0;\n  };\n  Sha1.prototype.hex = function () {\n      this.finalize();\n      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n      return (HEX_CHARS[(h0 >> 28) & 0x0f] +\n          HEX_CHARS[(h0 >> 24) & 0x0f] +\n          HEX_CHARS[(h0 >> 20) & 0x0f] +\n          HEX_CHARS[(h0 >> 16) & 0x0f] +\n          HEX_CHARS[(h0 >> 12) & 0x0f] +\n          HEX_CHARS[(h0 >> 8) & 0x0f] +\n          HEX_CHARS[(h0 >> 4) & 0x0f] +\n          HEX_CHARS[h0 & 0x0f] +\n          HEX_CHARS[(h1 >> 28) & 0x0f] +\n          HEX_CHARS[(h1 >> 24) & 0x0f] +\n          HEX_CHARS[(h1 >> 20) & 0x0f] +\n          HEX_CHARS[(h1 >> 16) & 0x0f] +\n          HEX_CHARS[(h1 >> 12) & 0x0f] +\n          HEX_CHARS[(h1 >> 8) & 0x0f] +\n          HEX_CHARS[(h1 >> 4) & 0x0f] +\n          HEX_CHARS[h1 & 0x0f] +\n          HEX_CHARS[(h2 >> 28) & 0x0f] +\n          HEX_CHARS[(h2 >> 24) & 0x0f] +\n          HEX_CHARS[(h2 >> 20) & 0x0f] +\n          HEX_CHARS[(h2 >> 16) & 0x0f] +\n          HEX_CHARS[(h2 >> 12) & 0x0f] +\n          HEX_CHARS[(h2 >> 8) & 0x0f] +\n          HEX_CHARS[(h2 >> 4) & 0x0f] +\n          HEX_CHARS[h2 & 0x0f] +\n          HEX_CHARS[(h3 >> 28) & 0x0f] +\n          HEX_CHARS[(h3 >> 24) & 0x0f] +\n          HEX_CHARS[(h3 >> 20) & 0x0f] +\n          HEX_CHARS[(h3 >> 16) & 0x0f] +\n          HEX_CHARS[(h3 >> 12) & 0x0f] +\n          HEX_CHARS[(h3 >> 8) & 0x0f] +\n          HEX_CHARS[(h3 >> 4) & 0x0f] +\n          HEX_CHARS[h3 & 0x0f] +\n          HEX_CHARS[(h4 >> 28) & 0x0f] +\n          HEX_CHARS[(h4 >> 24) & 0x0f] +\n          HEX_CHARS[(h4 >> 20) & 0x0f] +\n          HEX_CHARS[(h4 >> 16) & 0x0f] +\n          HEX_CHARS[(h4 >> 12) & 0x0f] +\n          HEX_CHARS[(h4 >> 8) & 0x0f] +\n          HEX_CHARS[(h4 >> 4) & 0x0f] +\n          HEX_CHARS[h4 & 0x0f]);\n  };\n  Sha1.prototype.toString = Sha1.prototype.hex;\n  Sha1.prototype.digest = function () {\n      this.finalize();\n      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n      return [\n          (h0 >> 24) & 0xff,\n          (h0 >> 16) & 0xff,\n          (h0 >> 8) & 0xff,\n          h0 & 0xff,\n          (h1 >> 24) & 0xff,\n          (h1 >> 16) & 0xff,\n          (h1 >> 8) & 0xff,\n          h1 & 0xff,\n          (h2 >> 24) & 0xff,\n          (h2 >> 16) & 0xff,\n          (h2 >> 8) & 0xff,\n          h2 & 0xff,\n          (h3 >> 24) & 0xff,\n          (h3 >> 16) & 0xff,\n          (h3 >> 8) & 0xff,\n          h3 & 0xff,\n          (h4 >> 24) & 0xff,\n          (h4 >> 16) & 0xff,\n          (h4 >> 8) & 0xff,\n          h4 & 0xff,\n      ];\n  };\n  Sha1.prototype.array = Sha1.prototype.digest;\n  Sha1.prototype.arrayBuffer = function () {\n      this.finalize();\n      var buffer = new ArrayBuffer(20);\n      var dataView = new DataView(buffer);\n      dataView.setUint32(0, this.h0);\n      dataView.setUint32(4, this.h1);\n      dataView.setUint32(8, this.h2);\n      dataView.setUint32(12, this.h3);\n      dataView.setUint32(16, this.h4);\n      return buffer;\n  };\n  const insecureHash = (message) => {\n      return new Sha1(true).update(message)[\"hex\"]();\n  };\n  hash.insecureHash = insecureHash;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.insecureHash = void 0;\n  \tvar hash_js_1 = hash;\n  \tObject.defineProperty(exports, \"insecureHash\", { enumerable: true, get: function () { return hash_js_1.insecureHash; } }); \n  } (hash$1));\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.InMemoryCache = exports.BaseCache = exports.serializeGeneration = exports.deserializeStoredGeneration = exports.getCacheKey = void 0;\n  \tconst hash_js_1 = hash$1;\n  \tconst utils_js_1 = messages$1.utils;\n  \t/**\n  \t * This cache key should be consistent across all versions of LangChain.\n  \t * It is currently NOT consistent across versions of LangChain.\n  \t *\n  \t * A huge benefit of having a remote cache (like redis) is that you can\n  \t * access the cache from different processes/machines. The allows you to\n  \t * separate concerns and scale horizontally.\n  \t *\n  \t * TODO: Make cache key consistent across versions of LangChain.\n  \t */\n  \tconst getCacheKey = (...strings) => (0, hash_js_1.insecureHash)(strings.join(\"_\"));\n  \texports.getCacheKey = getCacheKey;\n  \tfunction deserializeStoredGeneration(storedGeneration) {\n  \t    if (storedGeneration.message !== undefined) {\n  \t        return {\n  \t            text: storedGeneration.text,\n  \t            message: (0, utils_js_1.mapStoredMessageToChatMessage)(storedGeneration.message),\n  \t        };\n  \t    }\n  \t    else {\n  \t        return { text: storedGeneration.text };\n  \t    }\n  \t}\n  \texports.deserializeStoredGeneration = deserializeStoredGeneration;\n  \tfunction serializeGeneration(generation) {\n  \t    const serializedValue = {\n  \t        text: generation.text,\n  \t    };\n  \t    if (generation.message !== undefined) {\n  \t        serializedValue.message = generation.message.toDict();\n  \t    }\n  \t    return serializedValue;\n  \t}\n  \texports.serializeGeneration = serializeGeneration;\n  \t/**\n  \t * Base class for all caches. All caches should extend this class.\n  \t */\n  \tclass BaseCache {\n  \t}\n  \texports.BaseCache = BaseCache;\n  \tconst GLOBAL_MAP = new Map();\n  \t/**\n  \t * A cache for storing LLM generations that stores data in memory.\n  \t */\n  \tclass InMemoryCache extends BaseCache {\n  \t    constructor(map) {\n  \t        super();\n  \t        Object.defineProperty(this, \"cache\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        this.cache = map ?? new Map();\n  \t    }\n  \t    /**\n  \t     * Retrieves data from the cache using a prompt and an LLM key. If the\n  \t     * data is not found, it returns null.\n  \t     * @param prompt The prompt used to find the data.\n  \t     * @param llmKey The LLM key used to find the data.\n  \t     * @returns The data corresponding to the prompt and LLM key, or null if not found.\n  \t     */\n  \t    lookup(prompt, llmKey) {\n  \t        return Promise.resolve(this.cache.get((0, exports.getCacheKey)(prompt, llmKey)) ?? null);\n  \t    }\n  \t    /**\n  \t     * Updates the cache with new data using a prompt and an LLM key.\n  \t     * @param prompt The prompt used to store the data.\n  \t     * @param llmKey The LLM key used to store the data.\n  \t     * @param value The data to be stored.\n  \t     */\n  \t    async update(prompt, llmKey, value) {\n  \t        this.cache.set((0, exports.getCacheKey)(prompt, llmKey), value);\n  \t    }\n  \t    /**\n  \t     * Returns a global instance of InMemoryCache using a predefined global\n  \t     * map as the initial cache.\n  \t     * @returns A global instance of InMemoryCache.\n  \t     */\n  \t    static global() {\n  \t        return new InMemoryCache(GLOBAL_MAP);\n  \t    }\n  \t}\n  \texports.InMemoryCache = InMemoryCache; \n  } (base$2));\n\n  var prompt_values = {};\n\n  Object.defineProperty(prompt_values, \"__esModule\", { value: true });\n  prompt_values.ImagePromptValue = prompt_values.ChatPromptValue = prompt_values.StringPromptValue = prompt_values.BasePromptValue = void 0;\n  const serializable_js_1 = messages$1.serializable;\n  const human_js_1 = messages$1.human;\n  const utils_js_1$1 = messages$1.utils;\n  /**\n   * Base PromptValue class. All prompt values should extend this class.\n   */\n  class BasePromptValue extends serializable_js_1.Serializable {\n  }\n  prompt_values.BasePromptValue = BasePromptValue;\n  /**\n   * Represents a prompt value as a string. It extends the BasePromptValue\n   * class and overrides the toString and toChatMessages methods.\n   */\n  class StringPromptValue extends BasePromptValue {\n      static lc_name() {\n          return \"StringPromptValue\";\n      }\n      constructor(value) {\n          super({ value });\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"prompt_values\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"value\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.value = value;\n      }\n      toString() {\n          return this.value;\n      }\n      toChatMessages() {\n          return [new human_js_1.HumanMessage(this.value)];\n      }\n  }\n  prompt_values.StringPromptValue = StringPromptValue;\n  /**\n   * Class that represents a chat prompt value. It extends the\n   * BasePromptValue and includes an array of BaseMessage instances.\n   */\n  class ChatPromptValue extends BasePromptValue {\n      static lc_name() {\n          return \"ChatPromptValue\";\n      }\n      constructor(fields) {\n          if (Array.isArray(fields)) {\n              // eslint-disable-next-line no-param-reassign\n              fields = { messages: fields };\n          }\n          super(fields);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"prompt_values\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"messages\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.messages = fields.messages;\n      }\n      toString() {\n          return (0, utils_js_1$1.getBufferString)(this.messages);\n      }\n      toChatMessages() {\n          return this.messages;\n      }\n  }\n  prompt_values.ChatPromptValue = ChatPromptValue;\n  /**\n   * Class that represents an image prompt value. It extends the\n   * BasePromptValue and includes an ImageURL instance.\n   */\n  class ImagePromptValue extends BasePromptValue {\n      static lc_name() {\n          return \"ImagePromptValue\";\n      }\n      constructor(fields) {\n          if (!(\"imageUrl\" in fields)) {\n              // eslint-disable-next-line no-param-reassign\n              fields = { imageUrl: fields };\n          }\n          super(fields);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"prompt_values\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"imageUrl\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          /** @ignore */\n          Object.defineProperty(this, \"value\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.imageUrl = fields.imageUrl;\n      }\n      toString() {\n          return this.imageUrl.url;\n      }\n      toChatMessages() {\n          return [\n              new human_js_1.HumanMessage({\n                  content: [\n                      {\n                          type: \"image_url\",\n                          image_url: {\n                              detail: this.imageUrl.detail,\n                              url: this.imageUrl.url,\n                          },\n                      },\n                  ],\n              }),\n          ];\n      }\n  }\n  prompt_values.ImagePromptValue = ImagePromptValue;\n\n  var tiktoken = {};\n\n  var lite = {};\n\n  var base64Js = {};\n\n  base64Js.byteLength = byteLength;\n  base64Js.toByteArray = toByteArray;\n  base64Js.fromByteArray = fromByteArray;\n\n  var lookup = [];\n  var revLookup = [];\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  // Support decoding URL-safe base64 strings, as Node.js does.\n  // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n\n  function getLens (b64) {\n    var len = b64.length;\n\n    if (len % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf('=');\n    if (validLen === -1) validLen = len;\n\n    var placeHoldersLen = validLen === len\n      ? 0\n      : 4 - (validLen % 4);\n\n    return [validLen, placeHoldersLen]\n  }\n\n  // base64 is 4/3 + up to two characters of the original data\n  function byteLength (b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n  }\n\n  function _byteLength (b64, validLen, placeHoldersLen) {\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n  }\n\n  function toByteArray (b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n    var curByte = 0;\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0\n      ? validLen - 4\n      : validLen;\n\n    var i;\n    for (i = 0; i < len; i += 4) {\n      tmp =\n        (revLookup[b64.charCodeAt(i)] << 18) |\n        (revLookup[b64.charCodeAt(i + 1)] << 12) |\n        (revLookup[b64.charCodeAt(i + 2)] << 6) |\n        revLookup[b64.charCodeAt(i + 3)];\n      arr[curByte++] = (tmp >> 16) & 0xFF;\n      arr[curByte++] = (tmp >> 8) & 0xFF;\n      arr[curByte++] = tmp & 0xFF;\n    }\n\n    if (placeHoldersLen === 2) {\n      tmp =\n        (revLookup[b64.charCodeAt(i)] << 2) |\n        (revLookup[b64.charCodeAt(i + 1)] >> 4);\n      arr[curByte++] = tmp & 0xFF;\n    }\n\n    if (placeHoldersLen === 1) {\n      tmp =\n        (revLookup[b64.charCodeAt(i)] << 10) |\n        (revLookup[b64.charCodeAt(i + 1)] << 4) |\n        (revLookup[b64.charCodeAt(i + 2)] >> 2);\n      arr[curByte++] = (tmp >> 8) & 0xFF;\n      arr[curByte++] = tmp & 0xFF;\n    }\n\n    return arr\n  }\n\n  function tripletToBase64 (num) {\n    return lookup[num >> 18 & 0x3F] +\n      lookup[num >> 12 & 0x3F] +\n      lookup[num >> 6 & 0x3F] +\n      lookup[num & 0x3F]\n  }\n\n  function encodeChunk (uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n      tmp =\n        ((uint8[i] << 16) & 0xFF0000) +\n        ((uint8[i + 1] << 8) & 0xFF00) +\n        (uint8[i + 2] & 0xFF);\n      output.push(tripletToBase64(tmp));\n    }\n    return output.join('')\n  }\n\n  function fromByteArray (uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n      tmp = uint8[len - 1];\n      parts.push(\n        lookup[tmp >> 2] +\n        lookup[(tmp << 4) & 0x3F] +\n        '=='\n      );\n    } else if (extraBytes === 2) {\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n      parts.push(\n        lookup[tmp >> 10] +\n        lookup[(tmp >> 4) & 0x3F] +\n        lookup[(tmp << 2) & 0x3F] +\n        '='\n      );\n    }\n\n    return parts.join('')\n  }\n\n  var base64 = base64Js;\n\n  function _interopDefault$1 (e) { return e && e.__esModule ? e : { default: e }; }\n\n  var base64__default = /*#__PURE__*/_interopDefault$1(base64);\n\n  var __defProp = Object.defineProperty;\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n  var __publicField = (obj, key, value) => {\n    __defNormalProp(obj, key + \"\" , value);\n    return value;\n  };\n\n  // src/core.ts\n  function bytePairMerge(piece, ranks) {\n    let parts = Array.from(\n      { length: piece.length },\n      (_, i) => ({ start: i, end: i + 1 })\n    );\n    while (parts.length > 1) {\n      let minRank = null;\n      for (let i = 0; i < parts.length - 1; i++) {\n        const slice = piece.slice(parts[i].start, parts[i + 1].end);\n        const rank = ranks.get(slice.join(\",\"));\n        if (rank == null)\n          continue;\n        if (minRank == null || rank < minRank[0]) {\n          minRank = [rank, i];\n        }\n      }\n      if (minRank != null) {\n        const i = minRank[1];\n        parts[i] = { start: parts[i].start, end: parts[i + 1].end };\n        parts.splice(i + 1, 1);\n      } else {\n        break;\n      }\n    }\n    return parts;\n  }\n  function bytePairEncode(piece, ranks) {\n    if (piece.length === 1)\n      return [ranks.get(piece.join(\",\"))];\n    return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(\",\"))).filter((x) => x != null);\n  }\n  function escapeRegex(str) {\n    return str.replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n  }\n  var _Tiktoken = class {\n    /** @internal */\n    specialTokens;\n    /** @internal */\n    inverseSpecialTokens;\n    /** @internal */\n    patStr;\n    /** @internal */\n    textEncoder = new TextEncoder();\n    /** @internal */\n    textDecoder = new TextDecoder(\"utf-8\");\n    /** @internal */\n    rankMap = /* @__PURE__ */ new Map();\n    /** @internal */\n    textMap = /* @__PURE__ */ new Map();\n    constructor(ranks, extendedSpecialTokens) {\n      this.patStr = ranks.pat_str;\n      const uncompressed = ranks.bpe_ranks.split(\"\\n\").filter(Boolean).reduce((memo, x) => {\n        const [_, offsetStr, ...tokens] = x.split(\" \");\n        const offset = Number.parseInt(offsetStr, 10);\n        tokens.forEach((token, i) => memo[token] = offset + i);\n        return memo;\n      }, {});\n      for (const [token, rank] of Object.entries(uncompressed)) {\n        const bytes = base64__default.default.toByteArray(token);\n        this.rankMap.set(bytes.join(\",\"), rank);\n        this.textMap.set(rank, bytes);\n      }\n      this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };\n      this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {\n        memo[rank] = this.textEncoder.encode(text);\n        return memo;\n      }, {});\n    }\n    encode(text, allowedSpecial = [], disallowedSpecial = \"all\") {\n      const regexes = new RegExp(this.patStr, \"ug\");\n      const specialRegex = _Tiktoken.specialTokenRegex(\n        Object.keys(this.specialTokens)\n      );\n      const ret = [];\n      const allowedSpecialSet = new Set(\n        allowedSpecial === \"all\" ? Object.keys(this.specialTokens) : allowedSpecial\n      );\n      const disallowedSpecialSet = new Set(\n        disallowedSpecial === \"all\" ? Object.keys(this.specialTokens).filter(\n          (x) => !allowedSpecialSet.has(x)\n        ) : disallowedSpecial\n      );\n      if (disallowedSpecialSet.size > 0) {\n        const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([\n          ...disallowedSpecialSet\n        ]);\n        const specialMatch = text.match(disallowedSpecialRegex);\n        if (specialMatch != null) {\n          throw new Error(\n            `The text contains a special token that is not allowed: ${specialMatch[0]}`\n          );\n        }\n      }\n      let start = 0;\n      while (true) {\n        let nextSpecial = null;\n        let startFind = start;\n        while (true) {\n          specialRegex.lastIndex = startFind;\n          nextSpecial = specialRegex.exec(text);\n          if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))\n            break;\n          startFind = nextSpecial.index + 1;\n        }\n        const end = nextSpecial?.index ?? text.length;\n        for (const match of text.substring(start, end).matchAll(regexes)) {\n          const piece = this.textEncoder.encode(match[0]);\n          const token2 = this.rankMap.get(piece.join(\",\"));\n          if (token2 != null) {\n            ret.push(token2);\n            continue;\n          }\n          ret.push(...bytePairEncode(piece, this.rankMap));\n        }\n        if (nextSpecial == null)\n          break;\n        let token = this.specialTokens[nextSpecial[0]];\n        ret.push(token);\n        start = nextSpecial.index + nextSpecial[0].length;\n      }\n      return ret;\n    }\n    decode(tokens) {\n      const res = [];\n      let length = 0;\n      for (let i2 = 0; i2 < tokens.length; ++i2) {\n        const token = tokens[i2];\n        const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];\n        if (bytes != null) {\n          res.push(bytes);\n          length += bytes.length;\n        }\n      }\n      const mergedArray = new Uint8Array(length);\n      let i = 0;\n      for (const bytes of res) {\n        mergedArray.set(bytes, i);\n        i += bytes.length;\n      }\n      return this.textDecoder.decode(mergedArray);\n    }\n  };\n  var Tiktoken = _Tiktoken;\n  __publicField(Tiktoken, \"specialTokenRegex\", (tokens) => {\n    return new RegExp(tokens.map((i) => escapeRegex(i)).join(\"|\"), \"g\");\n  });\n  function getEncodingNameForModel(model) {\n    switch (model) {\n      case \"gpt2\": {\n        return \"gpt2\";\n      }\n      case \"code-cushman-001\":\n      case \"code-cushman-002\":\n      case \"code-davinci-001\":\n      case \"code-davinci-002\":\n      case \"cushman-codex\":\n      case \"davinci-codex\":\n      case \"davinci-002\":\n      case \"text-davinci-002\":\n      case \"text-davinci-003\": {\n        return \"p50k_base\";\n      }\n      case \"code-davinci-edit-001\":\n      case \"text-davinci-edit-001\": {\n        return \"p50k_edit\";\n      }\n      case \"ada\":\n      case \"babbage\":\n      case \"babbage-002\":\n      case \"code-search-ada-code-001\":\n      case \"code-search-babbage-code-001\":\n      case \"curie\":\n      case \"davinci\":\n      case \"text-ada-001\":\n      case \"text-babbage-001\":\n      case \"text-curie-001\":\n      case \"text-davinci-001\":\n      case \"text-search-ada-doc-001\":\n      case \"text-search-babbage-doc-001\":\n      case \"text-search-curie-doc-001\":\n      case \"text-search-davinci-doc-001\":\n      case \"text-similarity-ada-001\":\n      case \"text-similarity-babbage-001\":\n      case \"text-similarity-curie-001\":\n      case \"text-similarity-davinci-001\": {\n        return \"r50k_base\";\n      }\n      case \"gpt-3.5-turbo-instruct-0914\":\n      case \"gpt-3.5-turbo-instruct\":\n      case \"gpt-3.5-turbo-16k-0613\":\n      case \"gpt-3.5-turbo-16k\":\n      case \"gpt-3.5-turbo-0613\":\n      case \"gpt-3.5-turbo-0301\":\n      case \"gpt-3.5-turbo\":\n      case \"gpt-4-32k-0613\":\n      case \"gpt-4-32k-0314\":\n      case \"gpt-4-32k\":\n      case \"gpt-4-0613\":\n      case \"gpt-4-0314\":\n      case \"gpt-4\":\n      case \"gpt-3.5-turbo-1106\":\n      case \"gpt-35-turbo\":\n      case \"gpt-4-1106-preview\":\n      case \"gpt-4-vision-preview\":\n      case \"gpt-3.5-turbo-0125\":\n      case \"gpt-4-turbo\":\n      case \"gpt-4-turbo-2024-04-09\":\n      case \"gpt-4-turbo-preview\":\n      case \"gpt-4-0125-preview\":\n      case \"text-embedding-ada-002\":\n      case \"text-embedding-3-small\":\n      case \"text-embedding-3-large\": {\n        return \"cl100k_base\";\n      }\n      case \"gpt-4o\":\n      case \"gpt-4o-2024-05-13\":\n      case \"gpt-4o-2024-08-06\":\n      case \"gpt-4o-mini-2024-07-18\":\n      case \"gpt-4o-mini\": {\n        return \"o200k_base\";\n      }\n      default:\n        throw new Error(\"Unknown model\");\n    }\n  }\n\n  lite.Tiktoken = Tiktoken;\n  lite.getEncodingNameForModel = getEncodingNameForModel;\n\n  Object.defineProperty(tiktoken, \"__esModule\", { value: true });\n  tiktoken.encodingForModel = tiktoken.getEncoding = void 0;\n  const lite_1 = lite;\n  const async_caller_js_1$1 = messages$1.async_caller;\n  const cache = {};\n  const caller = /* #__PURE__ */ new async_caller_js_1$1.AsyncCaller({});\n  async function getEncoding(encoding) {\n      if (!(encoding in cache)) {\n          cache[encoding] = caller\n              .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n              .then((res) => res.json())\n              .then((data) => new lite_1.Tiktoken(data))\n              .catch((e) => {\n              delete cache[encoding];\n              throw e;\n          });\n      }\n      return await cache[encoding];\n  }\n  tiktoken.getEncoding = getEncoding;\n  async function encodingForModel(model) {\n      return getEncoding((0, lite_1.getEncodingNameForModel)(model));\n  }\n  tiktoken.encodingForModel = encodingForModel;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.BaseLanguageModel = exports.BaseLangChain = exports.calculateMaxTokens = exports.isOpenAITool = exports.getModelContextSize = exports.getEmbeddingContextSize = exports.getModelNameForTiktoken = void 0;\n  \tconst base_js_1 = base$2;\n  \tconst prompt_values_js_1 = prompt_values;\n  \tconst utils_js_1 = messages$1.utils;\n  \tconst async_caller_js_1 = messages$1.async_caller;\n  \tconst tiktoken_js_1 = tiktoken;\n  \tconst base_js_2 = messages$1.base;\n  \t// https://www.npmjs.com/package/js-tiktoken\n  \tconst getModelNameForTiktoken = (modelName) => {\n  \t    if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n  \t        return \"gpt-3.5-turbo-16k\";\n  \t    }\n  \t    if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n  \t        return \"gpt-3.5-turbo\";\n  \t    }\n  \t    if (modelName.startsWith(\"gpt-4-32k\")) {\n  \t        return \"gpt-4-32k\";\n  \t    }\n  \t    if (modelName.startsWith(\"gpt-4-\")) {\n  \t        return \"gpt-4\";\n  \t    }\n  \t    if (modelName.startsWith(\"gpt-4o\")) {\n  \t        return \"gpt-4o\";\n  \t    }\n  \t    return modelName;\n  \t};\n  \texports.getModelNameForTiktoken = getModelNameForTiktoken;\n  \tconst getEmbeddingContextSize = (modelName) => {\n  \t    switch (modelName) {\n  \t        case \"text-embedding-ada-002\":\n  \t            return 8191;\n  \t        default:\n  \t            return 2046;\n  \t    }\n  \t};\n  \texports.getEmbeddingContextSize = getEmbeddingContextSize;\n  \tconst getModelContextSize = (modelName) => {\n  \t    switch ((0, exports.getModelNameForTiktoken)(modelName)) {\n  \t        case \"gpt-3.5-turbo-16k\":\n  \t            return 16384;\n  \t        case \"gpt-3.5-turbo\":\n  \t            return 4096;\n  \t        case \"gpt-4-32k\":\n  \t            return 32768;\n  \t        case \"gpt-4\":\n  \t            return 8192;\n  \t        case \"text-davinci-003\":\n  \t            return 4097;\n  \t        case \"text-curie-001\":\n  \t            return 2048;\n  \t        case \"text-babbage-001\":\n  \t            return 2048;\n  \t        case \"text-ada-001\":\n  \t            return 2048;\n  \t        case \"code-davinci-002\":\n  \t            return 8000;\n  \t        case \"code-cushman-001\":\n  \t            return 2048;\n  \t        default:\n  \t            return 4097;\n  \t    }\n  \t};\n  \texports.getModelContextSize = getModelContextSize;\n  \t/**\n  \t * Whether or not the input matches the OpenAI tool definition.\n  \t * @param {unknown} tool The input to check.\n  \t * @returns {boolean} Whether the input is an OpenAI tool definition.\n  \t */\n  \tfunction isOpenAITool(tool) {\n  \t    if (typeof tool !== \"object\" || !tool)\n  \t        return false;\n  \t    if (\"type\" in tool &&\n  \t        tool.type === \"function\" &&\n  \t        \"function\" in tool &&\n  \t        typeof tool.function === \"object\" &&\n  \t        tool.function &&\n  \t        \"name\" in tool.function &&\n  \t        \"parameters\" in tool.function) {\n  \t        return true;\n  \t    }\n  \t    return false;\n  \t}\n  \texports.isOpenAITool = isOpenAITool;\n  \tconst calculateMaxTokens = async ({ prompt, modelName, }) => {\n  \t    let numTokens;\n  \t    try {\n  \t        numTokens = (await (0, tiktoken_js_1.encodingForModel)((0, exports.getModelNameForTiktoken)(modelName))).encode(prompt).length;\n  \t    }\n  \t    catch (error) {\n  \t        console.warn(\"Failed to calculate number of tokens, falling back to approximate count\");\n  \t        // fallback to approximate calculation if tiktoken is not available\n  \t        // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n  \t        numTokens = Math.ceil(prompt.length / 4);\n  \t    }\n  \t    const maxTokens = (0, exports.getModelContextSize)(modelName);\n  \t    return maxTokens - numTokens;\n  \t};\n  \texports.calculateMaxTokens = calculateMaxTokens;\n  \tconst getVerbosity = () => false;\n  \t/**\n  \t * Base class for language models, chains, tools.\n  \t */\n  \tclass BaseLangChain extends base_js_2.Runnable {\n  \t    get lc_attributes() {\n  \t        return {\n  \t            callbacks: undefined,\n  \t            verbose: undefined,\n  \t        };\n  \t    }\n  \t    constructor(params) {\n  \t        super(params);\n  \t        /**\n  \t         * Whether to print out response text.\n  \t         */\n  \t        Object.defineProperty(this, \"verbose\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"callbacks\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"tags\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"metadata\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        this.verbose = params.verbose ?? getVerbosity();\n  \t        this.callbacks = params.callbacks;\n  \t        this.tags = params.tags ?? [];\n  \t        this.metadata = params.metadata ?? {};\n  \t    }\n  \t}\n  \texports.BaseLangChain = BaseLangChain;\n  \t/**\n  \t * Base class for language models.\n  \t */\n  \tclass BaseLanguageModel extends BaseLangChain {\n  \t    /**\n  \t     * Keys that the language model accepts as call options.\n  \t     */\n  \t    get callKeys() {\n  \t        return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n  \t    }\n  \t    constructor({ callbacks, callbackManager, ...params }) {\n  \t        super({\n  \t            callbacks: callbacks ?? callbackManager,\n  \t            ...params,\n  \t        });\n  \t        /**\n  \t         * The async caller should be used by subclasses to make any async calls,\n  \t         * which will thus benefit from the concurrency and retry logic.\n  \t         */\n  \t        Object.defineProperty(this, \"caller\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"cache\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"_encoding\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        if (typeof params.cache === \"object\") {\n  \t            this.cache = params.cache;\n  \t        }\n  \t        else if (params.cache) {\n  \t            this.cache = base_js_1.InMemoryCache.global();\n  \t        }\n  \t        else {\n  \t            this.cache = undefined;\n  \t        }\n  \t        this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n  \t    }\n  \t    async getNumTokens(content) {\n  \t        // TODO: Figure out correct value.\n  \t        if (typeof content !== \"string\") {\n  \t            return 0;\n  \t        }\n  \t        // fallback to approximate calculation if tiktoken is not available\n  \t        let numTokens = Math.ceil(content.length / 4);\n  \t        if (!this._encoding) {\n  \t            try {\n  \t                this._encoding = await (0, tiktoken_js_1.encodingForModel)(\"modelName\" in this\n  \t                    ? (0, exports.getModelNameForTiktoken)(this.modelName)\n  \t                    : \"gpt2\");\n  \t            }\n  \t            catch (error) {\n  \t                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n  \t            }\n  \t        }\n  \t        if (this._encoding) {\n  \t            try {\n  \t                numTokens = this._encoding.encode(content).length;\n  \t            }\n  \t            catch (error) {\n  \t                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n  \t            }\n  \t        }\n  \t        return numTokens;\n  \t    }\n  \t    static _convertInputToPromptValue(input) {\n  \t        if (typeof input === \"string\") {\n  \t            return new prompt_values_js_1.StringPromptValue(input);\n  \t        }\n  \t        else if (Array.isArray(input)) {\n  \t            return new prompt_values_js_1.ChatPromptValue(input.map(utils_js_1.coerceMessageLikeToMessage));\n  \t        }\n  \t        else {\n  \t            return input;\n  \t        }\n  \t    }\n  \t    /**\n  \t     * Get the identifying parameters of the LLM.\n  \t     */\n  \t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t    _identifyingParams() {\n  \t        return {};\n  \t    }\n  \t    /**\n  \t     * Create a unique cache key for a specific call to a specific language model.\n  \t     * @param callOptions Call options for the model\n  \t     * @returns A unique cache key.\n  \t     */\n  \t    _getSerializedCacheKeyParametersForCall(\n  \t    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n  \t    { config, ...callOptions }) {\n  \t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t        const params = {\n  \t            ...this._identifyingParams(),\n  \t            ...callOptions,\n  \t            _type: this._llmType(),\n  \t            _model: this._modelType(),\n  \t        };\n  \t        const filteredEntries = Object.entries(params).filter(([_, value]) => value !== undefined);\n  \t        const serializedEntries = filteredEntries\n  \t            .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n  \t            .sort()\n  \t            .join(\",\");\n  \t        return serializedEntries;\n  \t    }\n  \t    /**\n  \t     * @deprecated\n  \t     * Return a json-like object representing this LLM.\n  \t     */\n  \t    serialize() {\n  \t        return {\n  \t            ...this._identifyingParams(),\n  \t            _type: this._llmType(),\n  \t            _model: this._modelType(),\n  \t        };\n  \t    }\n  \t    /**\n  \t     * @deprecated\n  \t     * Load an LLM from a json-like object describing it.\n  \t     */\n  \t    static async deserialize(_data) {\n  \t        throw new Error(\"Use .toJSON() instead\");\n  \t    }\n  \t}\n  \texports.BaseLanguageModel = BaseLanguageModel; \n  } (base$3));\n\n  var passthrough = {};\n\n  Object.defineProperty(passthrough, \"__esModule\", { value: true });\n  passthrough.RunnablePassthrough = void 0;\n  const stream_js_1$3 = messages$1.stream;\n  const base_js_1$a = messages$1.base;\n  const config_js_1$2 = messages$1.config;\n  /**\n   * A runnable to passthrough inputs unchanged or with additional keys.\n   *\n   * This runnable behaves almost like the identity function, except that it\n   * can be configured to add additional keys to the output, if the input is\n   * an object.\n   *\n   * The example below demonstrates how to use `RunnablePassthrough to\n   * passthrough the input from the `.invoke()`\n   *\n   * @example\n   * ```typescript\n   * const chain = RunnableSequence.from([\n   *   {\n   *     question: new RunnablePassthrough(),\n   *     context: async () => loadContextFromStore(),\n   *   },\n   *   prompt,\n   *   llm,\n   *   outputParser,\n   * ]);\n   * const response = await chain.invoke(\n   *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n   * );\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  class RunnablePassthrough extends base_js_1$a.Runnable {\n      static lc_name() {\n          return \"RunnablePassthrough\";\n      }\n      constructor(fields) {\n          super(fields);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"runnables\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"func\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          if (fields) {\n              this.func = fields.func;\n          }\n      }\n      async invoke(input, options) {\n          const config = (0, config_js_1$2.ensureConfig)(options);\n          if (this.func) {\n              await this.func(input, config);\n          }\n          return this._callWithConfig((input) => Promise.resolve(input), input, config);\n      }\n      async *transform(generator, options) {\n          const config = (0, config_js_1$2.ensureConfig)(options);\n          let finalOutput;\n          let finalOutputSupported = true;\n          for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {\n              yield chunk;\n              if (finalOutputSupported) {\n                  if (finalOutput === undefined) {\n                      finalOutput = chunk;\n                  }\n                  else {\n                      try {\n                          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                          finalOutput = (0, stream_js_1$3.concat)(finalOutput, chunk);\n                      }\n                      catch {\n                          finalOutput = undefined;\n                          finalOutputSupported = false;\n                      }\n                  }\n              }\n          }\n          if (this.func && finalOutput !== undefined) {\n              await this.func(finalOutput, config);\n          }\n      }\n      /**\n       * A runnable that assigns key-value pairs to the input.\n       *\n       * The example below shows how you could use it with an inline function.\n       *\n       * @example\n       * ```typescript\n       * const prompt =\n       *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n       * Question: {question}\n       * SQL Query:`);\n       *\n       * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n       * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n       * // In this case, we're passing the schema.\n       * const sqlQueryGeneratorChain = RunnableSequence.from([\n       *   RunnablePassthrough.assign({\n       *     schema: async () => db.getTableInfo(),\n       *   }),\n       *   prompt,\n       *   new ChatOpenAI({}).bind({ stop: [\"\\nSQLResult:\"] }),\n       *   new StringOutputParser(),\n       * ]);\n       * const result = await sqlQueryGeneratorChain.invoke({\n       *   question: \"How many employees are there?\",\n       * });\n       * ```\n       */\n      static assign(mapping) {\n          return new base_js_1$a.RunnableAssign(new base_js_1$a.RunnableMap({ steps: mapping }));\n      }\n  }\n  passthrough.RunnablePassthrough = RunnablePassthrough;\n\n  var is_zod_schema = {};\n\n  Object.defineProperty(is_zod_schema, \"__esModule\", { value: true });\n  is_zod_schema.isZodSchema = void 0;\n  /**\n   * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n   *\n   * @param {z.ZodType<RunOutput> | Record<string, any>} input\n   * @returns {boolean} Whether or not the provided input is a Zod schema.\n   */\n  function isZodSchema$1(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input) {\n      // Check for a characteristic method of Zod schemas\n      return typeof input?.parse === \"function\";\n  }\n  is_zod_schema.isZodSchema = isZodSchema$1;\n\n  Object.defineProperty(chat_models$2, \"__esModule\", { value: true });\n  chat_models$2.SimpleChatModel = chat_models$2.BaseChatModel = chat_models$2.createChatMessageChunkEncoderStream = void 0;\n  const zod_to_json_schema_1$4 = messages$1.cjs;\n  const index_js_1$4 = messages$1.messages$1;\n  const outputs_js_1$2 = messages$1.outputs;\n  const base_js_1$9 = base$3;\n  const manager_js_1$1 = messages$1.manager;\n  const base_js_2$1 = messages$1.base;\n  const event_stream_js_1$1 = messages$1.event_stream;\n  const log_stream_js_1$1 = messages$1.log_stream;\n  const stream_js_1$2 = messages$1.stream;\n  const passthrough_js_1$1 = passthrough;\n  const is_zod_schema_js_1$1 = is_zod_schema;\n  /**\n   * Creates a transform stream for encoding chat message chunks.\n   * @deprecated Use {@link BytesOutputParser} instead\n   * @returns A TransformStream instance that encodes chat message chunks.\n   */\n  function createChatMessageChunkEncoderStream() {\n      const textEncoder = new TextEncoder();\n      return new TransformStream({\n          transform(chunk, controller) {\n              controller.enqueue(textEncoder.encode(typeof chunk.content === \"string\"\n                  ? chunk.content\n                  : JSON.stringify(chunk.content)));\n          },\n      });\n  }\n  chat_models$2.createChatMessageChunkEncoderStream = createChatMessageChunkEncoderStream;\n  /**\n   * Base class for chat models. It extends the BaseLanguageModel class and\n   * provides methods for generating chat based on input messages.\n   */\n  class BaseChatModel extends base_js_1$9.BaseLanguageModel {\n      constructor(fields) {\n          super(fields);\n          // Only ever instantiated in main LangChain\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain\", \"chat_models\", this._llmType()]\n          });\n      }\n      _separateRunnableConfigFromCallOptionsCompat(options) {\n          // For backwards compat, keep `signal` in both runnableConfig and callOptions\n          const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n          callOptions.signal = runnableConfig.signal;\n          return [runnableConfig, callOptions];\n      }\n      /**\n       * Invokes the chat model with a single input.\n       * @param input The input for the language model.\n       * @param options The call options.\n       * @returns A Promise that resolves to a BaseMessageChunk.\n       */\n      async invoke(input, options) {\n          const promptValue = BaseChatModel._convertInputToPromptValue(input);\n          const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n          const chatGeneration = result.generations[0][0];\n          // TODO: Remove cast after figuring out inheritance\n          return chatGeneration.message;\n      }\n      // eslint-disable-next-line require-yield\n      async *_streamResponseChunks(_messages, _options, _runManager) {\n          throw new Error(\"Not implemented.\");\n      }\n      async *_streamIterator(input, options) {\n          // Subclass check required to avoid double callbacks with default implementation\n          if (this._streamResponseChunks ===\n              BaseChatModel.prototype._streamResponseChunks) {\n              yield this.invoke(input, options);\n          }\n          else {\n              const prompt = BaseChatModel._convertInputToPromptValue(input);\n              const messages = prompt.toChatMessages();\n              const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n              const inheritableMetadata = {\n                  ...runnableConfig.metadata,\n                  ...this.getLsParams(callOptions),\n              };\n              const callbackManager_ = await manager_js_1$1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n              const extra = {\n                  options: callOptions,\n                  invocation_params: this?.invocationParams(callOptions),\n                  batch_size: 1,\n              };\n              const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [messages], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n              let generationChunk;\n              try {\n                  for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {\n                      if (chunk.message.id == null) {\n                          const runId = runManagers?.at(0)?.runId;\n                          if (runId != null)\n                              chunk.message._updateId(`run-${runId}`);\n                      }\n                      chunk.message.response_metadata = {\n                          ...chunk.generationInfo,\n                          ...chunk.message.response_metadata,\n                      };\n                      yield chunk.message;\n                      if (!generationChunk) {\n                          generationChunk = chunk;\n                      }\n                      else {\n                          generationChunk = generationChunk.concat(chunk);\n                      }\n                  }\n              }\n              catch (err) {\n                  await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                  throw err;\n              }\n              await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                  // TODO: Remove cast after figuring out inheritance\n                  generations: [[generationChunk]],\n              })));\n          }\n      }\n      getLsParams(options) {\n          return {\n              ls_model_type: \"chat\",\n              ls_stop: options.stop,\n          };\n      }\n      /** @ignore */\n      async _generateUncached(messages, parsedOptions, handledOptions) {\n          const baseMessages = messages.map((messageList) => messageList.map(index_js_1$4.coerceMessageLikeToMessage));\n          const inheritableMetadata = {\n              ...handledOptions.metadata,\n              ...this.getLsParams(parsedOptions),\n          };\n          // create callback manager and start run\n          const callbackManager_ = await manager_js_1$1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n          const extra = {\n              options: parsedOptions,\n              invocation_params: this?.invocationParams(parsedOptions),\n              batch_size: 1,\n          };\n          const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n          const generations = [];\n          const llmOutputs = [];\n          // Even if stream is not explicitly called, check if model is implicitly\n          // called from streamEvents() or streamLog() to get all streamed events.\n          // Bail out if _streamResponseChunks not overridden\n          const hasStreamingHandler = !!runManagers?.[0].handlers.find((handler) => {\n              return (0, event_stream_js_1$1.isStreamEventsHandler)(handler) || (0, log_stream_js_1$1.isLogStreamHandler)(handler);\n          });\n          if (hasStreamingHandler &&\n              baseMessages.length === 1 &&\n              this._streamResponseChunks !==\n                  BaseChatModel.prototype._streamResponseChunks) {\n              try {\n                  const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers?.[0]);\n                  let aggregated;\n                  for await (const chunk of stream) {\n                      if (chunk.message.id == null) {\n                          const runId = runManagers?.at(0)?.runId;\n                          if (runId != null)\n                              chunk.message._updateId(`run-${runId}`);\n                      }\n                      if (aggregated === undefined) {\n                          aggregated = chunk;\n                      }\n                      else {\n                          aggregated = (0, stream_js_1$2.concat)(aggregated, chunk);\n                      }\n                  }\n                  if (aggregated === undefined) {\n                      throw new Error(\"Received empty response from chat model call.\");\n                  }\n                  generations.push([aggregated]);\n                  await runManagers?.[0].handleLLMEnd({\n                      generations,\n                      llmOutput: {},\n                  });\n              }\n              catch (e) {\n                  await runManagers?.[0].handleLLMError(e);\n                  throw e;\n              }\n          }\n          else {\n              // generate results\n              const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, { ...parsedOptions, promptIndex: i }, runManagers?.[i])));\n              // handle results\n              await Promise.all(results.map(async (pResult, i) => {\n                  if (pResult.status === \"fulfilled\") {\n                      const result = pResult.value;\n                      for (const generation of result.generations) {\n                          if (generation.message.id == null) {\n                              const runId = runManagers?.at(0)?.runId;\n                              if (runId != null)\n                                  generation.message._updateId(`run-${runId}`);\n                          }\n                          generation.message.response_metadata = {\n                              ...generation.generationInfo,\n                              ...generation.message.response_metadata,\n                          };\n                      }\n                      if (result.generations.length === 1) {\n                          result.generations[0].message.response_metadata = {\n                              ...result.llmOutput,\n                              ...result.generations[0].message.response_metadata,\n                          };\n                      }\n                      generations[i] = result.generations;\n                      llmOutputs[i] = result.llmOutput;\n                      return runManagers?.[i]?.handleLLMEnd({\n                          generations: [result.generations],\n                          llmOutput: result.llmOutput,\n                      });\n                  }\n                  else {\n                      // status === \"rejected\"\n                      await runManagers?.[i]?.handleLLMError(pResult.reason);\n                      return Promise.reject(pResult.reason);\n                  }\n              }));\n          }\n          // create combined output\n          const output = {\n              generations,\n              llmOutput: llmOutputs.length\n                  ? this._combineLLMOutput?.(...llmOutputs)\n                  : undefined,\n          };\n          Object.defineProperty(output, outputs_js_1$2.RUN_KEY, {\n              value: runManagers\n                  ? { runIds: runManagers?.map((manager) => manager.runId) }\n                  : undefined,\n              configurable: true,\n          });\n          return output;\n      }\n      async _generateCached({ messages, cache, llmStringKey, parsedOptions, handledOptions, }) {\n          const baseMessages = messages.map((messageList) => messageList.map(index_js_1$4.coerceMessageLikeToMessage));\n          const inheritableMetadata = {\n              ...handledOptions.metadata,\n              ...this.getLsParams(parsedOptions),\n          };\n          // create callback manager and start run\n          const callbackManager_ = await manager_js_1$1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n          const extra = {\n              options: parsedOptions,\n              invocation_params: this?.invocationParams(parsedOptions),\n              batch_size: 1,\n              cached: true,\n          };\n          const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n          // generate results\n          const missingPromptIndices = [];\n          const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {\n              // Join all content into one string for the prompt index\n              const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n              const result = await cache.lookup(prompt, llmStringKey);\n              if (result == null) {\n                  missingPromptIndices.push(index);\n              }\n              return result;\n          }));\n          // Map run managers to the results before filtering out null results\n          // Null results are just absent from the cache.\n          const cachedResults = results\n              .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n              .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n              result.status === \"rejected\");\n          // Handle results and call run managers\n          const generations = [];\n          await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n              if (promiseResult.status === \"fulfilled\") {\n                  const result = promiseResult.value;\n                  generations[i] = result;\n                  if (result.length) {\n                      await runManager?.handleLLMNewToken(result[0].text);\n                  }\n                  return runManager?.handleLLMEnd({\n                      generations: [result],\n                  });\n              }\n              else {\n                  // status === \"rejected\"\n                  await runManager?.handleLLMError(promiseResult.reason);\n                  return Promise.reject(promiseResult.reason);\n              }\n          }));\n          const output = {\n              generations,\n              missingPromptIndices,\n          };\n          // This defines RUN_KEY as a non-enumerable property on the output object\n          // so that it is not serialized when the output is stringified, and so that\n          // it isnt included when listing the keys of the output object.\n          Object.defineProperty(output, outputs_js_1$2.RUN_KEY, {\n              value: runManagers\n                  ? { runIds: runManagers?.map((manager) => manager.runId) }\n                  : undefined,\n              configurable: true,\n          });\n          return output;\n      }\n      /**\n       * Generates chat based on the input messages.\n       * @param messages An array of arrays of BaseMessage instances.\n       * @param options The call options or an array of stop sequences.\n       * @param callbacks The callbacks for the language model.\n       * @returns A Promise that resolves to an LLMResult.\n       */\n      async generate(messages, options, callbacks) {\n          // parse call options\n          let parsedOptions;\n          if (Array.isArray(options)) {\n              parsedOptions = { stop: options };\n          }\n          else {\n              parsedOptions = options;\n          }\n          const baseMessages = messages.map((messageList) => messageList.map(index_js_1$4.coerceMessageLikeToMessage));\n          const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n          runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n          if (!this.cache) {\n              return this._generateUncached(baseMessages, callOptions, runnableConfig);\n          }\n          const { cache } = this;\n          const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n          const { generations, missingPromptIndices } = await this._generateCached({\n              messages: baseMessages,\n              cache,\n              llmStringKey,\n              parsedOptions: callOptions,\n              handledOptions: runnableConfig,\n          });\n          let llmOutput = {};\n          if (missingPromptIndices.length > 0) {\n              const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig);\n              await Promise.all(results.generations.map(async (generation, index) => {\n                  const promptIndex = missingPromptIndices[index];\n                  generations[promptIndex] = generation;\n                  // Join all content into one string for the prompt index\n                  const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();\n                  return cache.update(prompt, llmStringKey, generation);\n              }));\n              llmOutput = results.llmOutput ?? {};\n          }\n          return { generations, llmOutput };\n      }\n      /**\n       * Get the parameters used to invoke the model\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      invocationParams(_options) {\n          return {};\n      }\n      _modelType() {\n          return \"base_chat_model\";\n      }\n      /**\n       * @deprecated\n       * Return a json-like object representing this LLM.\n       */\n      serialize() {\n          return {\n              ...this.invocationParams(),\n              _type: this._llmType(),\n              _model: this._modelType(),\n          };\n      }\n      /**\n       * Generates a prompt based on the input prompt values.\n       * @param promptValues An array of BasePromptValue instances.\n       * @param options The call options or an array of stop sequences.\n       * @param callbacks The callbacks for the language model.\n       * @returns A Promise that resolves to an LLMResult.\n       */\n      async generatePrompt(promptValues, options, callbacks) {\n          const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());\n          return this.generate(promptMessages, options, callbacks);\n      }\n      /**\n       * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n       *\n       * Makes a single call to the chat model.\n       * @param messages An array of BaseMessage instances.\n       * @param options The call options or an array of stop sequences.\n       * @param callbacks The callbacks for the language model.\n       * @returns A Promise that resolves to a BaseMessage.\n       */\n      async call(messages, options, callbacks) {\n          const result = await this.generate([messages.map(index_js_1$4.coerceMessageLikeToMessage)], options, callbacks);\n          const generations = result.generations;\n          return generations[0][0].message;\n      }\n      /**\n       * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n       *\n       * Makes a single call to the chat model with a prompt value.\n       * @param promptValue The value of the prompt.\n       * @param options The call options or an array of stop sequences.\n       * @param callbacks The callbacks for the language model.\n       * @returns A Promise that resolves to a BaseMessage.\n       */\n      async callPrompt(promptValue, options, callbacks) {\n          const promptMessages = promptValue.toChatMessages();\n          return this.call(promptMessages, options, callbacks);\n      }\n      /**\n       * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n       *\n       * Predicts the next message based on the input messages.\n       * @param messages An array of BaseMessage instances.\n       * @param options The call options or an array of stop sequences.\n       * @param callbacks The callbacks for the language model.\n       * @returns A Promise that resolves to a BaseMessage.\n       */\n      async predictMessages(messages, options, callbacks) {\n          return this.call(messages, options, callbacks);\n      }\n      /**\n       * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n       *\n       * Predicts the next message based on a text input.\n       * @param text The text input.\n       * @param options The call options or an array of stop sequences.\n       * @param callbacks The callbacks for the language model.\n       * @returns A Promise that resolves to a string.\n       */\n      async predict(text, options, callbacks) {\n          const message = new index_js_1$4.HumanMessage(text);\n          const result = await this.call([message], options, callbacks);\n          if (typeof result.content !== \"string\") {\n              throw new Error(\"Cannot use predict when output is not a string.\");\n          }\n          return result.content;\n      }\n      withStructuredOutput(outputSchema, config) {\n          if (typeof this.bindTools !== \"function\") {\n              throw new Error(`Chat model must implement \".bindTools()\" to use withStructuredOutput.`);\n          }\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const schema = outputSchema;\n          const name = config?.name;\n          const description = schema.description ?? \"A function available to call.\";\n          const method = config?.method;\n          const includeRaw = config?.includeRaw;\n          if (method === \"jsonMode\") {\n              throw new Error(`Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`);\n          }\n          let functionName = name ?? \"extract\";\n          let tools;\n          if ((0, is_zod_schema_js_1$1.isZodSchema)(schema)) {\n              tools = [\n                  {\n                      type: \"function\",\n                      function: {\n                          name: functionName,\n                          description,\n                          parameters: (0, zod_to_json_schema_1$4.zodToJsonSchema)(schema),\n                      },\n                  },\n              ];\n          }\n          else {\n              if (\"name\" in schema) {\n                  functionName = schema.name;\n              }\n              tools = [\n                  {\n                      type: \"function\",\n                      function: {\n                          name: functionName,\n                          description,\n                          parameters: schema,\n                      },\n                  },\n              ];\n          }\n          const llm = this.bindTools(tools);\n          const outputParser = base_js_2$1.RunnableLambda.from((input) => {\n              if (!input.tool_calls || input.tool_calls.length === 0) {\n                  throw new Error(\"No tool calls found in the response.\");\n              }\n              const toolCall = input.tool_calls.find((tc) => tc.name === functionName);\n              if (!toolCall) {\n                  throw new Error(`No tool call found with name ${functionName}.`);\n              }\n              return toolCall.args;\n          });\n          if (!includeRaw) {\n              return llm.pipe(outputParser).withConfig({\n                  runName: \"StructuredOutput\",\n              });\n          }\n          const parserAssign = passthrough_js_1$1.RunnablePassthrough.assign({\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              parsed: (input, config) => outputParser.invoke(input.raw, config),\n          });\n          const parserNone = passthrough_js_1$1.RunnablePassthrough.assign({\n              parsed: () => null,\n          });\n          const parsedWithFallback = parserAssign.withFallbacks({\n              fallbacks: [parserNone],\n          });\n          return base_js_2$1.RunnableSequence.from([\n              {\n                  raw: llm,\n              },\n              parsedWithFallback,\n          ]).withConfig({\n              runName: \"StructuredOutputRunnable\",\n          });\n      }\n  }\n  chat_models$2.BaseChatModel = BaseChatModel;\n  /**\n   * An abstract class that extends BaseChatModel and provides a simple\n   * implementation of _generate.\n   */\n  class SimpleChatModel extends BaseChatModel {\n      async _generate(messages, options, runManager) {\n          const text = await this._call(messages, options, runManager);\n          const message = new index_js_1$4.AIMessage(text);\n          if (typeof message.content !== \"string\") {\n              throw new Error(\"Cannot generate with a simple chat model when output is not a string.\");\n          }\n          return {\n              generations: [\n                  {\n                      text: message.content,\n                      message,\n                  },\n              ],\n          };\n      }\n  }\n  chat_models$2.SimpleChatModel = SimpleChatModel;\n\n  var chat_models$1 = chat_models$2;\n\n  var base$1 = base$3;\n\n  var runnables$1 = {};\n\n  var router = {};\n\n  Object.defineProperty(router, \"__esModule\", { value: true });\n  router.RouterRunnable = void 0;\n  const base_js_1$8 = messages$1.base;\n  const config_js_1$1 = messages$1.config;\n  /**\n   * A runnable that routes to a set of runnables based on Input['key'].\n   * Returns the output of the selected runnable.\n   */\n  class RouterRunnable extends base_js_1$8.Runnable {\n      static lc_name() {\n          return \"RouterRunnable\";\n      }\n      constructor(fields) {\n          super(fields);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"runnables\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"runnables\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.runnables = fields.runnables;\n      }\n      async invoke(input, options) {\n          const { key, input: actualInput } = input;\n          const runnable = this.runnables[key];\n          if (runnable === undefined) {\n              throw new Error(`No runnable associated with key \"${key}\".`);\n          }\n          return runnable.invoke(actualInput, (0, config_js_1$1.ensureConfig)(options));\n      }\n      async batch(inputs, options, batchOptions) {\n          const keys = inputs.map((input) => input.key);\n          const actualInputs = inputs.map((input) => input.input);\n          const missingKey = keys.find((key) => this.runnables[key] === undefined);\n          if (missingKey !== undefined) {\n              throw new Error(`One or more keys do not have a corresponding runnable.`);\n          }\n          const runnables = keys.map((key) => this.runnables[key]);\n          const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n          const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n          const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n          const batchResults = [];\n          for (let i = 0; i < actualInputs.length; i += batchSize) {\n              const batchPromises = actualInputs\n                  .slice(i, i + batchSize)\n                  .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n              const batchResult = await Promise.all(batchPromises);\n              batchResults.push(batchResult);\n          }\n          return batchResults.flat();\n      }\n      async stream(input, options) {\n          const { key, input: actualInput } = input;\n          const runnable = this.runnables[key];\n          if (runnable === undefined) {\n              throw new Error(`No runnable associated with key \"${key}\".`);\n          }\n          return runnable.stream(actualInput, options);\n      }\n  }\n  router.RouterRunnable = RouterRunnable;\n\n  var branch = {};\n\n  Object.defineProperty(branch, \"__esModule\", { value: true });\n  branch.RunnableBranch = void 0;\n  const base_js_1$7 = messages$1.base;\n  const config_js_1 = messages$1.config;\n  const stream_js_1$1 = messages$1.stream;\n  /**\n   * Class that represents a runnable branch. The RunnableBranch is\n   * initialized with an array of branches and a default branch. When invoked,\n   * it evaluates the condition of each branch in order and executes the\n   * corresponding branch if the condition is true. If none of the conditions\n   * are true, it executes the default branch.\n   * @example\n   * ```typescript\n   * const branch = RunnableBranch.from([\n   *   [\n   *     (x: { topic: string; question: string }) =>\n   *       x.topic.toLowerCase().includes(\"anthropic\"),\n   *     anthropicChain,\n   *   ],\n   *   [\n   *     (x: { topic: string; question: string }) =>\n   *       x.topic.toLowerCase().includes(\"langchain\"),\n   *     langChainChain,\n   *   ],\n   *   generalChain,\n   * ]);\n   *\n   * const fullChain = RunnableSequence.from([\n   *   {\n   *     topic: classificationChain,\n   *     question: (input: { question: string }) => input.question,\n   *   },\n   *   branch,\n   * ]);\n   *\n   * const result = await fullChain.invoke({\n   *   question: \"how do I use LangChain?\",\n   * });\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  class RunnableBranch extends base_js_1$7.Runnable {\n      static lc_name() {\n          return \"RunnableBranch\";\n      }\n      constructor(fields) {\n          super(fields);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"runnables\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"default\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"branches\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.branches = fields.branches;\n          this.default = fields.default;\n      }\n      /**\n       * Convenience method for instantiating a RunnableBranch from\n       * RunnableLikes (objects, functions, or Runnables).\n       *\n       * Each item in the input except for the last one should be a\n       * tuple with two items. The first is a \"condition\" RunnableLike that\n       * returns \"true\" if the second RunnableLike in the tuple should run.\n       *\n       * The final item in the input should be a RunnableLike that acts as a\n       * default branch if no other branches match.\n       *\n       * @example\n       * ```ts\n       * import { RunnableBranch } from \"@langchain/core/runnables\";\n       *\n       * const branch = RunnableBranch.from([\n       *   [(x: number) => x > 0, (x: number) => x + 1],\n       *   [(x: number) => x < 0, (x: number) => x - 1],\n       *   (x: number) => x\n       * ]);\n       * ```\n       * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n       *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n       * @returns A new RunnableBranch.\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      static from(branches) {\n          if (branches.length < 1) {\n              throw new Error(\"RunnableBranch requires at least one branch\");\n          }\n          const branchLikes = branches.slice(0, -1);\n          const coercedBranches = branchLikes.map(([condition, runnable]) => [\n              (0, base_js_1$7._coerceToRunnable)(condition),\n              (0, base_js_1$7._coerceToRunnable)(runnable),\n          ]);\n          const defaultBranch = (0, base_js_1$7._coerceToRunnable)(branches[branches.length - 1]);\n          return new this({\n              branches: coercedBranches,\n              default: defaultBranch,\n          });\n      }\n      async _invoke(input, config, runManager) {\n          let result;\n          for (let i = 0; i < this.branches.length; i += 1) {\n              const [condition, branchRunnable] = this.branches[i];\n              const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                  callbacks: runManager?.getChild(`condition:${i + 1}`),\n              }));\n              if (conditionValue) {\n                  result = await branchRunnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n                      callbacks: runManager?.getChild(`branch:${i + 1}`),\n                  }));\n                  break;\n              }\n          }\n          if (!result) {\n              result = await this.default.invoke(input, (0, config_js_1.patchConfig)(config, {\n                  callbacks: runManager?.getChild(\"branch:default\"),\n              }));\n          }\n          return result;\n      }\n      async invoke(input, config = {}) {\n          return this._callWithConfig(this._invoke, input, config);\n      }\n      async *_streamIterator(input, config) {\n          const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n          const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1$7._coerceToDict)(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n          let finalOutput;\n          let finalOutputSupported = true;\n          let stream;\n          try {\n              for (let i = 0; i < this.branches.length; i += 1) {\n                  const [condition, branchRunnable] = this.branches[i];\n                  const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                      callbacks: runManager?.getChild(`condition:${i + 1}`),\n                  }));\n                  if (conditionValue) {\n                      stream = await branchRunnable.stream(input, (0, config_js_1.patchConfig)(config, {\n                          callbacks: runManager?.getChild(`branch:${i + 1}`),\n                      }));\n                      for await (const chunk of stream) {\n                          yield chunk;\n                          if (finalOutputSupported) {\n                              if (finalOutput === undefined) {\n                                  finalOutput = chunk;\n                              }\n                              else {\n                                  try {\n                                      finalOutput = (0, stream_js_1$1.concat)(finalOutput, chunk);\n                                  }\n                                  catch (e) {\n                                      finalOutput = undefined;\n                                      finalOutputSupported = false;\n                                  }\n                              }\n                          }\n                      }\n                      break;\n                  }\n              }\n              if (stream === undefined) {\n                  stream = await this.default.stream(input, (0, config_js_1.patchConfig)(config, {\n                      callbacks: runManager?.getChild(\"branch:default\"),\n                  }));\n                  for await (const chunk of stream) {\n                      yield chunk;\n                      if (finalOutputSupported) {\n                          if (finalOutput === undefined) {\n                              finalOutput = chunk;\n                          }\n                          else {\n                              try {\n                                  finalOutput = (0, stream_js_1$1.concat)(finalOutput, chunk);\n                              }\n                              catch (e) {\n                                  finalOutput = undefined;\n                                  finalOutputSupported = false;\n                              }\n                          }\n                      }\n                  }\n              }\n          }\n          catch (e) {\n              await runManager?.handleChainError(e);\n              throw e;\n          }\n          await runManager?.handleChainEnd(finalOutput ?? {});\n      }\n  }\n  branch.RunnableBranch = RunnableBranch;\n\n  var history = {};\n\n  Object.defineProperty(history, \"__esModule\", { value: true });\n  history.RunnableWithMessageHistory = void 0;\n  const index_js_1$3 = messages$1.messages$1;\n  const base_js_1$6 = messages$1.base;\n  const passthrough_js_1 = passthrough;\n  /**\n   * Wraps a LCEL chain and manages history. It appends input messages\n   * and chain outputs as history, and adds the current history messages to\n   * the chain input.\n   * @example\n   * ```typescript\n   * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n   *\n   * import {\n   *   ChatPromptTemplate,\n   *   MessagesPlaceholder,\n   * } from \"@langchain/core/prompts\";\n   * import { ChatAnthropic } from \"@langchain/anthropic\";\n   * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n   * // For demos, you can also use an in-memory store:\n   * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n   *\n   * const prompt = ChatPromptTemplate.fromMessages([\n   *   [\"system\", \"You're an assistant who's good at {ability}\"],\n   *   new MessagesPlaceholder(\"history\"),\n   *   [\"human\", \"{question}\"],\n   * ]);\n   *\n   * const chain = prompt.pipe(new ChatAnthropic({}));\n   *\n   * const chainWithHistory = new RunnableWithMessageHistory({\n   *   runnable: chain,\n   *   getMessageHistory: (sessionId) =>\n   *     new UpstashRedisChatMessageHistory({\n   *       sessionId,\n   *       config: {\n   *         url: process.env.UPSTASH_REDIS_REST_URL!,\n   *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n   *       },\n   *     }),\n   *   inputMessagesKey: \"question\",\n   *   historyMessagesKey: \"history\",\n   * });\n   *\n   * const result = await chainWithHistory.invoke(\n   *   {\n   *     ability: \"math\",\n   *     question: \"What does cosine mean?\",\n   *   },\n   *   {\n   *     configurable: {\n   *       sessionId: \"some_string_identifying_a_user\",\n   *     },\n   *   }\n   * );\n   *\n   * const result2 = await chainWithHistory.invoke(\n   *   {\n   *     ability: \"math\",\n   *     question: \"What's its inverse?\",\n   *   },\n   *   {\n   *     configurable: {\n   *       sessionId: \"some_string_identifying_a_user\",\n   *     },\n   *   }\n   * );\n   * ```\n   */\n  class RunnableWithMessageHistory extends base_js_1$6.RunnableBinding {\n      constructor(fields) {\n          let historyChain = new base_js_1$6.RunnableLambda({\n              func: (input, options) => this._enterHistory(input, options ?? {}),\n          }).withConfig({ runName: \"loadHistory\" });\n          const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n          if (messagesKey) {\n              historyChain = passthrough_js_1.RunnablePassthrough.assign({\n                  [messagesKey]: historyChain,\n              }).withConfig({ runName: \"insertHistory\" });\n          }\n          const bound = historyChain\n              .pipe(fields.runnable.withListeners({\n              onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n          }))\n              .withConfig({ runName: \"RunnableWithMessageHistory\" });\n          const config = fields.config ?? {};\n          super({\n              ...fields,\n              config,\n              bound,\n          });\n          Object.defineProperty(this, \"runnable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"inputMessagesKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"outputMessagesKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"historyMessagesKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"getMessageHistory\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.runnable = fields.runnable;\n          this.getMessageHistory = fields.getMessageHistory;\n          this.inputMessagesKey = fields.inputMessagesKey;\n          this.outputMessagesKey = fields.outputMessagesKey;\n          this.historyMessagesKey = fields.historyMessagesKey;\n      }\n      _getInputMessages(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      inputValue) {\n          let parsedInputValue;\n          if (typeof inputValue === \"object\" &&\n              !Array.isArray(inputValue) &&\n              !(0, index_js_1$3.isBaseMessage)(inputValue)) {\n              let key;\n              if (this.inputMessagesKey) {\n                  key = this.inputMessagesKey;\n              }\n              else if (Object.keys(inputValue).length === 1) {\n                  key = Object.keys(inputValue)[0];\n              }\n              else {\n                  key = \"input\";\n              }\n              if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n                  parsedInputValue = inputValue[key][0];\n              }\n              else {\n                  parsedInputValue = inputValue[key];\n              }\n          }\n          else {\n              parsedInputValue = inputValue;\n          }\n          if (typeof parsedInputValue === \"string\") {\n              return [new index_js_1$3.HumanMessage(parsedInputValue)];\n          }\n          else if (Array.isArray(parsedInputValue)) {\n              return parsedInputValue;\n          }\n          else if ((0, index_js_1$3.isBaseMessage)(parsedInputValue)) {\n              return [parsedInputValue];\n          }\n          else {\n              throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n          }\n      }\n      _getOutputMessages(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      outputValue) {\n          let parsedOutputValue;\n          if (!Array.isArray(outputValue) &&\n              !(0, index_js_1$3.isBaseMessage)(outputValue) &&\n              typeof outputValue !== \"string\") {\n              let key;\n              if (this.outputMessagesKey !== undefined) {\n                  key = this.outputMessagesKey;\n              }\n              else if (Object.keys(outputValue).length === 1) {\n                  key = Object.keys(outputValue)[0];\n              }\n              else {\n                  key = \"output\";\n              }\n              // If you are wrapping a chat model directly\n              // The output is actually this weird generations object\n              if (outputValue.generations !== undefined) {\n                  parsedOutputValue = outputValue.generations[0][0].message;\n              }\n              else {\n                  parsedOutputValue = outputValue[key];\n              }\n          }\n          else {\n              parsedOutputValue = outputValue;\n          }\n          if (typeof parsedOutputValue === \"string\") {\n              return [new index_js_1$3.AIMessage(parsedOutputValue)];\n          }\n          else if (Array.isArray(parsedOutputValue)) {\n              return parsedOutputValue;\n          }\n          else if ((0, index_js_1$3.isBaseMessage)(parsedOutputValue)) {\n              return [parsedOutputValue];\n          }\n          else {\n              throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n          }\n      }\n      async _enterHistory(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      input, kwargs) {\n          const history = kwargs?.configurable?.messageHistory;\n          const messages = await history.getMessages();\n          if (this.historyMessagesKey === undefined) {\n              return messages.concat(this._getInputMessages(input));\n          }\n          return messages;\n      }\n      async _exitHistory(run, config) {\n          const history = config.configurable?.messageHistory;\n          // Get input messages\n          let inputs;\n          // Chat model inputs are nested arrays\n          if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n              inputs = run.inputs[0];\n          }\n          else {\n              inputs = run.inputs;\n          }\n          let inputMessages = this._getInputMessages(inputs);\n          // If historic messages were prepended to the input messages, remove them to\n          // avoid adding duplicate messages to history.\n          if (this.historyMessagesKey === undefined) {\n              const existingMessages = await history.getMessages();\n              inputMessages = inputMessages.slice(existingMessages.length);\n          }\n          // Get output messages\n          const outputValue = run.outputs;\n          if (!outputValue) {\n              throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n          }\n          const outputMessages = this._getOutputMessages(outputValue);\n          await history.addMessages([...inputMessages, ...outputMessages]);\n      }\n      async _mergeConfig(...configs) {\n          const config = await super._mergeConfig(...configs);\n          // Extract sessionId\n          if (!config.configurable || !config.configurable.sessionId) {\n              const exampleInput = {\n                  [this.inputMessagesKey ?? \"input\"]: \"foo\",\n              };\n              const exampleConfig = { configurable: { sessionId: \"123\" } };\n              throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                  `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n          }\n          // attach messageHistory\n          const { sessionId } = config.configurable;\n          config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n          return config;\n      }\n  }\n  history.RunnableWithMessageHistory = RunnableWithMessageHistory;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.RunnableWithMessageHistory = exports.RunnableBranch = exports.RouterRunnable = exports.RunnablePassthrough = exports.mergeConfigs = exports.ensureConfig = exports.patchConfig = exports.getCallbackManagerForConfig = exports.RunnableToolLike = exports._coerceToRunnable = exports.RunnablePick = exports.RunnableAssign = exports.RunnableWithFallbacks = exports.RunnableLambda = exports.RunnableParallel = exports.RunnableMap = exports.RunnableSequence = exports.RunnableRetry = exports.RunnableEach = exports.RunnableBinding = exports.Runnable = void 0;\n  \tvar base_js_1 = messages$1.base;\n  \tObject.defineProperty(exports, \"Runnable\", { enumerable: true, get: function () { return base_js_1.Runnable; } });\n  \tObject.defineProperty(exports, \"RunnableBinding\", { enumerable: true, get: function () { return base_js_1.RunnableBinding; } });\n  \tObject.defineProperty(exports, \"RunnableEach\", { enumerable: true, get: function () { return base_js_1.RunnableEach; } });\n  \tObject.defineProperty(exports, \"RunnableRetry\", { enumerable: true, get: function () { return base_js_1.RunnableRetry; } });\n  \tObject.defineProperty(exports, \"RunnableSequence\", { enumerable: true, get: function () { return base_js_1.RunnableSequence; } });\n  \tObject.defineProperty(exports, \"RunnableMap\", { enumerable: true, get: function () { return base_js_1.RunnableMap; } });\n  \tObject.defineProperty(exports, \"RunnableParallel\", { enumerable: true, get: function () { return base_js_1.RunnableParallel; } });\n  \tObject.defineProperty(exports, \"RunnableLambda\", { enumerable: true, get: function () { return base_js_1.RunnableLambda; } });\n  \tObject.defineProperty(exports, \"RunnableWithFallbacks\", { enumerable: true, get: function () { return base_js_1.RunnableWithFallbacks; } });\n  \tObject.defineProperty(exports, \"RunnableAssign\", { enumerable: true, get: function () { return base_js_1.RunnableAssign; } });\n  \tObject.defineProperty(exports, \"RunnablePick\", { enumerable: true, get: function () { return base_js_1.RunnablePick; } });\n  \tObject.defineProperty(exports, \"_coerceToRunnable\", { enumerable: true, get: function () { return base_js_1._coerceToRunnable; } });\n  \tObject.defineProperty(exports, \"RunnableToolLike\", { enumerable: true, get: function () { return base_js_1.RunnableToolLike; } });\n  \tvar config_js_1 = messages$1.config;\n  \tObject.defineProperty(exports, \"getCallbackManagerForConfig\", { enumerable: true, get: function () { return config_js_1.getCallbackManagerForConfig; } });\n  \tObject.defineProperty(exports, \"patchConfig\", { enumerable: true, get: function () { return config_js_1.patchConfig; } });\n  \tObject.defineProperty(exports, \"ensureConfig\", { enumerable: true, get: function () { return config_js_1.ensureConfig; } });\n  \tObject.defineProperty(exports, \"mergeConfigs\", { enumerable: true, get: function () { return config_js_1.mergeConfigs; } });\n  \tvar passthrough_js_1 = passthrough;\n  \tObject.defineProperty(exports, \"RunnablePassthrough\", { enumerable: true, get: function () { return passthrough_js_1.RunnablePassthrough; } });\n  \tvar router_js_1 = router;\n  \tObject.defineProperty(exports, \"RouterRunnable\", { enumerable: true, get: function () { return router_js_1.RouterRunnable; } });\n  \tvar branch_js_1 = branch;\n  \tObject.defineProperty(exports, \"RunnableBranch\", { enumerable: true, get: function () { return branch_js_1.RunnableBranch; } });\n  \tvar history_js_1 = history;\n  \tObject.defineProperty(exports, \"RunnableWithMessageHistory\", { enumerable: true, get: function () { return history_js_1.RunnableWithMessageHistory; } }); \n  } (runnables$1));\n\n  var runnables = runnables$1;\n\n  var output_parsers$1 = {};\n\n  var base = {};\n\n  Object.defineProperty(base, \"__esModule\", { value: true });\n  base.OutputParserException = base.BaseOutputParser = base.BaseLLMOutputParser = void 0;\n  const index_js_1$2 = runnables$1;\n  /**\n   * Abstract base class for parsing the output of a Large Language Model\n   * (LLM) call. It provides methods for parsing the result of an LLM call\n   * and invoking the parser with a given input.\n   */\n  class BaseLLMOutputParser extends index_js_1$2.Runnable {\n      /**\n       * Parses the result of an LLM call with a given prompt. By default, it\n       * simply calls `parseResult`.\n       * @param generations The generations from an LLM call.\n       * @param _prompt The prompt used in the LLM call.\n       * @param callbacks Optional callbacks.\n       * @returns A promise of the parsed output.\n       */\n      parseResultWithPrompt(generations, _prompt, callbacks) {\n          return this.parseResult(generations, callbacks);\n      }\n      _baseMessageToString(message) {\n          return typeof message.content === \"string\"\n              ? message.content\n              : this._baseMessageContentToString(message.content);\n      }\n      _baseMessageContentToString(content) {\n          return JSON.stringify(content);\n      }\n      /**\n       * Calls the parser with a given input and optional configuration options.\n       * If the input is a string, it creates a generation with the input as\n       * text and calls `parseResult`. If the input is a `BaseMessage`, it\n       * creates a generation with the input as a message and the content of the\n       * input as text, and then calls `parseResult`.\n       * @param input The input to the parser, which can be a string or a `BaseMessage`.\n       * @param options Optional configuration options.\n       * @returns A promise of the parsed output.\n       */\n      async invoke(input, options) {\n          if (typeof input === \"string\") {\n              return this._callWithConfig(async (input, options) => this.parseResult([{ text: input }], options?.callbacks), input, { ...options, runType: \"parser\" });\n          }\n          else {\n              return this._callWithConfig(async (input, options) => this.parseResult([\n                  {\n                      message: input,\n                      text: this._baseMessageToString(input),\n                  },\n              ], options?.callbacks), input, { ...options, runType: \"parser\" });\n          }\n      }\n  }\n  base.BaseLLMOutputParser = BaseLLMOutputParser;\n  /**\n   * Class to parse the output of an LLM call.\n   */\n  class BaseOutputParser extends BaseLLMOutputParser {\n      parseResult(generations, callbacks) {\n          return this.parse(generations[0].text, callbacks);\n      }\n      async parseWithPrompt(text, _prompt, callbacks) {\n          return this.parse(text, callbacks);\n      }\n      /**\n       * Return the string type key uniquely identifying this class of parser\n       */\n      _type() {\n          throw new Error(\"_type not implemented\");\n      }\n  }\n  base.BaseOutputParser = BaseOutputParser;\n  /**\n   * Exception that output parsers should raise to signify a parsing error.\n   *\n   * This exists to differentiate parsing errors from other code or execution errors\n   * that also may arise inside the output parser. OutputParserExceptions will be\n   * available to catch and handle in ways to fix the parsing error, while other\n   * errors will be raised.\n   *\n   * @param message - The error that's being re-raised or an error message.\n   * @param llmOutput - String model output which is error-ing.\n   * @param observation - String explanation of error which can be passed to a\n   *     model to try and remediate the issue.\n   * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n   *     after an OutputParserException has been raised. This gives the underlying\n   *     model driving the agent the context that the previous output was improperly\n   *     structured, in the hopes that it will update the output to the correct\n   *     format.\n   */\n  class OutputParserException extends Error {\n      constructor(message, llmOutput, observation, sendToLLM = false) {\n          super(message);\n          Object.defineProperty(this, \"llmOutput\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"observation\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"sendToLLM\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.llmOutput = llmOutput;\n          this.observation = observation;\n          this.sendToLLM = sendToLLM;\n          if (sendToLLM) {\n              if (observation === undefined || llmOutput === undefined) {\n                  throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n              }\n          }\n      }\n  }\n  base.OutputParserException = OutputParserException;\n\n  var bytes = {};\n\n  var transform = {};\n\n  var jsonSchema = {};\n\n  var src = {};\n\n  var deepCompareStrict$1 = {};\n\n  Object.defineProperty(deepCompareStrict$1, \"__esModule\", { value: true });\n  deepCompareStrict$1.deepCompareStrict = void 0;\n  function deepCompareStrict(a, b) {\n      const typeofa = typeof a;\n      if (typeofa !== typeof b) {\n          return false;\n      }\n      if (Array.isArray(a)) {\n          if (!Array.isArray(b)) {\n              return false;\n          }\n          const length = a.length;\n          if (length !== b.length) {\n              return false;\n          }\n          for (let i = 0; i < length; i++) {\n              if (!deepCompareStrict(a[i], b[i])) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      if (typeofa === \"object\") {\n          if (!a || !b) {\n              return a === b;\n          }\n          const aKeys = Object.keys(a);\n          const bKeys = Object.keys(b);\n          const length = aKeys.length;\n          if (length !== bKeys.length) {\n              return false;\n          }\n          for (const k of aKeys) {\n              if (!deepCompareStrict(a[k], b[k])) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return a === b;\n  }\n  deepCompareStrict$1.deepCompareStrict = deepCompareStrict;\n\n  var dereference = {};\n\n  var pointer = {};\n\n  Object.defineProperty(pointer, \"__esModule\", { value: true });\n  pointer.escapePointer = pointer.encodePointer = void 0;\n  function encodePointer(p) {\n      return encodeURI(escapePointer(p));\n  }\n  pointer.encodePointer = encodePointer;\n  function escapePointer(p) {\n      return p.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }\n  pointer.escapePointer = escapePointer;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.dereference = exports.initialBaseURI = exports.ignoredKeyword = exports.schemaMapKeyword = exports.schemaArrayKeyword = exports.schemaKeyword = void 0;\n  \tconst pointer_js_1 = pointer;\n  \texports.schemaKeyword = {\n  \t    additionalItems: true,\n  \t    unevaluatedItems: true,\n  \t    items: true,\n  \t    contains: true,\n  \t    additionalProperties: true,\n  \t    unevaluatedProperties: true,\n  \t    propertyNames: true,\n  \t    not: true,\n  \t    if: true,\n  \t    then: true,\n  \t    else: true,\n  \t};\n  \texports.schemaArrayKeyword = {\n  \t    prefixItems: true,\n  \t    items: true,\n  \t    allOf: true,\n  \t    anyOf: true,\n  \t    oneOf: true,\n  \t};\n  \texports.schemaMapKeyword = {\n  \t    $defs: true,\n  \t    definitions: true,\n  \t    properties: true,\n  \t    patternProperties: true,\n  \t    dependentSchemas: true,\n  \t};\n  \texports.ignoredKeyword = {\n  \t    id: true,\n  \t    $id: true,\n  \t    $ref: true,\n  \t    $schema: true,\n  \t    $anchor: true,\n  \t    $vocabulary: true,\n  \t    $comment: true,\n  \t    default: true,\n  \t    enum: true,\n  \t    const: true,\n  \t    required: true,\n  \t    type: true,\n  \t    maximum: true,\n  \t    minimum: true,\n  \t    exclusiveMaximum: true,\n  \t    exclusiveMinimum: true,\n  \t    multipleOf: true,\n  \t    maxLength: true,\n  \t    minLength: true,\n  \t    pattern: true,\n  \t    format: true,\n  \t    maxItems: true,\n  \t    minItems: true,\n  \t    uniqueItems: true,\n  \t    maxProperties: true,\n  \t    minProperties: true,\n  \t};\n  \t/**\n  \t * Default base URI for schemas without an $id.\n  \t * https://json-schema.org/draft/2019-09/json-schema-core.html#initial-base\n  \t * https://tools.ietf.org/html/rfc3986#section-5.1\n  \t */\n  \texports.initialBaseURI = \n  \t// @ts-ignore\n  \ttypeof self !== \"undefined\" &&\n  \t    self.location &&\n  \t    self.location.origin !== \"null\"\n  \t    ? //@ts-ignore\n  \t        /* #__PURE__ */ new URL(self.location.origin + self.location.pathname + location.search)\n  \t    : /* #__PURE__ */ new URL(\"https://github.com/cfworker\");\n  \tfunction dereference(schema, lookup = Object.create(null), baseURI = exports.initialBaseURI, basePointer = \"\") {\n  \t    if (schema && typeof schema === \"object\" && !Array.isArray(schema)) {\n  \t        const id = schema.$id || schema.id;\n  \t        if (id) {\n  \t            const url = new URL(id, baseURI.href);\n  \t            if (url.hash.length > 1) {\n  \t                lookup[url.href] = schema;\n  \t            }\n  \t            else {\n  \t                url.hash = \"\"; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n  \t                if (basePointer === \"\") {\n  \t                    baseURI = url;\n  \t                }\n  \t                else {\n  \t                    dereference(schema, lookup, baseURI);\n  \t                }\n  \t            }\n  \t        }\n  \t    }\n  \t    else if (schema !== true && schema !== false) {\n  \t        return lookup;\n  \t    }\n  \t    // compute the schema's URI and add it to the mapping.\n  \t    const schemaURI = baseURI.href + (basePointer ? \"#\" + basePointer : \"\");\n  \t    if (lookup[schemaURI] !== undefined) {\n  \t        throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n  \t    }\n  \t    lookup[schemaURI] = schema;\n  \t    // exit early if this is a boolean schema.\n  \t    if (schema === true || schema === false) {\n  \t        return lookup;\n  \t    }\n  \t    // set the schema's absolute URI.\n  \t    if (schema.__absolute_uri__ === undefined) {\n  \t        Object.defineProperty(schema, \"__absolute_uri__\", {\n  \t            enumerable: false,\n  \t            value: schemaURI,\n  \t        });\n  \t    }\n  \t    // if a $ref is found, resolve it's absolute URI.\n  \t    if (schema.$ref && schema.__absolute_ref__ === undefined) {\n  \t        const url = new URL(schema.$ref, baseURI.href);\n  \t        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n  \t        Object.defineProperty(schema, \"__absolute_ref__\", {\n  \t            enumerable: false,\n  \t            value: url.href,\n  \t        });\n  \t    }\n  \t    // if a $recursiveRef is found, resolve it's absolute URI.\n  \t    if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n  \t        const url = new URL(schema.$recursiveRef, baseURI.href);\n  \t        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n  \t        Object.defineProperty(schema, \"__absolute_recursive_ref__\", {\n  \t            enumerable: false,\n  \t            value: url.href,\n  \t        });\n  \t    }\n  \t    // if an $anchor is found, compute it's URI and add it to the mapping.\n  \t    if (schema.$anchor) {\n  \t        const url = new URL(\"#\" + schema.$anchor, baseURI.href);\n  \t        lookup[url.href] = schema;\n  \t    }\n  \t    // process subschemas.\n  \t    for (let key in schema) {\n  \t        if (exports.ignoredKeyword[key]) {\n  \t            continue;\n  \t        }\n  \t        const keyBase = `${basePointer}/${(0, pointer_js_1.encodePointer)(key)}`;\n  \t        const subSchema = schema[key];\n  \t        if (Array.isArray(subSchema)) {\n  \t            if (exports.schemaArrayKeyword[key]) {\n  \t                const length = subSchema.length;\n  \t                for (let i = 0; i < length; i++) {\n  \t                    dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n  \t                }\n  \t            }\n  \t        }\n  \t        else if (exports.schemaMapKeyword[key]) {\n  \t            for (let subKey in subSchema) {\n  \t                dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${(0, pointer_js_1.encodePointer)(subKey)}`);\n  \t            }\n  \t        }\n  \t        else {\n  \t            dereference(subSchema, lookup, baseURI, keyBase);\n  \t        }\n  \t    }\n  \t    return lookup;\n  \t}\n  \texports.dereference = dereference;\n  \t// schema identification examples\n  \t// https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.appendix.A\n  \t// $ref delegation\n  \t// https://github.com/json-schema-org/json-schema-spec/issues/514\n  \t// output format\n  \t// https://json-schema.org/draft/2019-09/json-schema-core.html#output\n  \t// JSON pointer\n  \t// https://tools.ietf.org/html/rfc6901\n  \t// JSON relative pointer\n  \t// https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01 \n  } (dereference));\n\n  var format = {};\n\n  (function (exports) {\n  \t// based on https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.fastFormat = exports.fullFormat = void 0;\n  \tconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\n  \tconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  \tconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\n  \tconst HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\n  \t// const URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n  \tconst URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n  \t// uri-template: https://tools.ietf.org/html/rfc6570\n  \tconst URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n  \t// For the source: https://gist.github.com/dperini/729294\n  \t// For test cases: https://mathiasbynens.be/demo/url-regex\n  \tconst URL_ = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\n  \tconst UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\n  \tconst JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\n  \tconst JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\n  \tconst RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n  \t// date: http://tools.ietf.org/html/rfc3339#section-5.6\n  \tconst FASTDATE = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/;\n  \t// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  \tconst FASTTIME = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\n  \tconst FASTDATETIME = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i;\n  \t// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  \t// const FASTURI = /^(?:[a-z][a-z0-9+-.]*:)(?:\\/?\\/)?[^\\s]*$/i;\n  \tconst FASTURIREFERENCE = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i;\n  \t// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n  \tconst EMAIL = (input) => {\n  \t    if (input[0] === '\"')\n  \t        return false;\n  \t    const [name, host, ...rest] = input.split(\"@\");\n  \t    if (!name ||\n  \t        !host ||\n  \t        rest.length !== 0 ||\n  \t        name.length > 64 ||\n  \t        host.length > 253)\n  \t        return false;\n  \t    if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\"))\n  \t        return false;\n  \t    if (!/^[a-z0-9.-]+$/i.test(host) ||\n  \t        !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))\n  \t        return false;\n  \t    return host\n  \t        .split(\".\")\n  \t        .every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));\n  \t};\n  \t// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  \tconst IPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\n  \t// optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  \tconst IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\n  \t// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n  \tconst DURATION = (input) => input.length > 1 &&\n  \t    input.length < 80 &&\n  \t    (/^P\\d+([.,]\\d+)?W$/.test(input) ||\n  \t        (/^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(input) &&\n  \t            /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(input)));\n  \tfunction bind(r) {\n  \t    return r.test.bind(r);\n  \t}\n  \texports.fullFormat = {\n  \t    date,\n  \t    time: /* #__PURE__ */ time.bind(undefined, false),\n  \t    \"date-time\": date_time,\n  \t    duration: DURATION,\n  \t    uri,\n  \t    \"uri-reference\": /* #__PURE__ */ bind(URIREF),\n  \t    \"uri-template\": /* #__PURE__ */ bind(URITEMPLATE),\n  \t    url: /* #__PURE__ */ bind(URL_),\n  \t    email: EMAIL,\n  \t    hostname: /* #__PURE__ */ bind(HOSTNAME),\n  \t    ipv4: /* #__PURE__ */ bind(IPV4),\n  \t    ipv6: /* #__PURE__ */ bind(IPV6),\n  \t    regex: regex,\n  \t    uuid: /* #__PURE__ */ bind(UUID),\n  \t    \"json-pointer\": /* #__PURE__ */ bind(JSON_POINTER),\n  \t    \"json-pointer-uri-fragment\": /* #__PURE__ */ bind(JSON_POINTER_URI_FRAGMENT),\n  \t    \"relative-json-pointer\": /* #__PURE__ */ bind(RELATIVE_JSON_POINTER),\n  \t};\n  \texports.fastFormat = {\n  \t    ...exports.fullFormat,\n  \t    date: /* #__PURE__ */ bind(FASTDATE),\n  \t    time: /* #__PURE__ */ bind(FASTTIME),\n  \t    \"date-time\": /* #__PURE__ */ bind(FASTDATETIME),\n  \t    \"uri-reference\": /* #__PURE__ */ bind(FASTURIREFERENCE),\n  \t};\n  \tfunction isLeapYear(year) {\n  \t    // https://tools.ietf.org/html/rfc3339#appendix-C\n  \t    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n  \t}\n  \tfunction date(str) {\n  \t    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  \t    const matches = str.match(DATE);\n  \t    if (!matches)\n  \t        return false;\n  \t    const year = +matches[1];\n  \t    const month = +matches[2];\n  \t    const day = +matches[3];\n  \t    return (month >= 1 &&\n  \t        month <= 12 &&\n  \t        day >= 1 &&\n  \t        day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]));\n  \t}\n  \tfunction time(full, str) {\n  \t    const matches = str.match(TIME);\n  \t    if (!matches)\n  \t        return false;\n  \t    const hour = +matches[1];\n  \t    const minute = +matches[2];\n  \t    const second = +matches[3];\n  \t    const timeZone = !!matches[5];\n  \t    return (((hour <= 23 && minute <= 59 && second <= 59) ||\n  \t        (hour == 23 && minute == 59 && second == 60)) &&\n  \t        (!full || timeZone));\n  \t}\n  \tconst DATE_TIME_SEPARATOR = /t|\\s/i;\n  \tfunction date_time(str) {\n  \t    // http://tools.ietf.org/html/rfc3339#section-5.6\n  \t    const dateTime = str.split(DATE_TIME_SEPARATOR);\n  \t    return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);\n  \t}\n  \tconst NOT_URI_FRAGMENT = /\\/|:/;\n  \tconst URI_PATTERN = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n  \tfunction uri(str) {\n  \t    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  \t    return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);\n  \t}\n  \tconst Z_ANCHOR = /[^\\\\]\\\\Z/;\n  \tfunction regex(str) {\n  \t    if (Z_ANCHOR.test(str))\n  \t        return false;\n  \t    try {\n  \t        new RegExp(str);\n  \t        return true;\n  \t    }\n  \t    catch (e) {\n  \t        return false;\n  \t    }\n  \t} \n  } (format));\n\n  var types$1 = {};\n\n  Object.defineProperty(types$1, \"__esModule\", { value: true });\n\n  var ucs2Length = {};\n\n  Object.defineProperty(ucs2Length, \"__esModule\", { value: true });\n  ucs2Length.ucs2length = void 0;\n  /**\n   * Get UCS-2 length of a string\n   * https://mathiasbynens.be/notes/javascript-encoding\n   * https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\n   */\n  function ucs2length(s) {\n      let result = 0;\n      let length = s.length;\n      let index = 0;\n      let charCode;\n      while (index < length) {\n          result++;\n          charCode = s.charCodeAt(index++);\n          if (charCode >= 0xd800 && charCode <= 0xdbff && index < length) {\n              // high surrogate, and there is a next character\n              charCode = s.charCodeAt(index);\n              if ((charCode & 0xfc00) == 0xdc00) {\n                  // low surrogate\n                  index++;\n              }\n          }\n      }\n      return result;\n  }\n  ucs2Length.ucs2length = ucs2length;\n\n  var validate$1 = {};\n\n  Object.defineProperty(validate$1, \"__esModule\", { value: true });\n  validate$1.validate = void 0;\n  const deep_compare_strict_js_1 = deepCompareStrict$1;\n  const dereference_js_1$1 = dereference;\n  const format_js_1 = format;\n  const pointer_js_1 = pointer;\n  const ucs2_length_js_1 = ucs2Length;\n  function validate(instance, schema, draft = \"2019-09\", lookup = (0, dereference_js_1$1.dereference)(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = \"#\", schemaLocation = \"#\", evaluated = Object.create(null)) {\n      if (schema === true) {\n          return { valid: true, errors: [] };\n      }\n      if (schema === false) {\n          return {\n              valid: false,\n              errors: [\n                  {\n                      instanceLocation,\n                      keyword: \"false\",\n                      keywordLocation: instanceLocation,\n                      error: \"False boolean schema.\",\n                  },\n              ],\n          };\n      }\n      const rawInstanceType = typeof instance;\n      let instanceType;\n      switch (rawInstanceType) {\n          case \"boolean\":\n          case \"number\":\n          case \"string\":\n              instanceType = rawInstanceType;\n              break;\n          case \"object\":\n              if (instance === null) {\n                  instanceType = \"null\";\n              }\n              else if (Array.isArray(instance)) {\n                  instanceType = \"array\";\n              }\n              else {\n                  instanceType = \"object\";\n              }\n              break;\n          default:\n              // undefined, bigint, function, symbol\n              throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n      }\n      const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__, } = schema;\n      const errors = [];\n      if ($recursiveAnchor === true && recursiveAnchor === null) {\n          recursiveAnchor = schema;\n      }\n      if ($recursiveRef === \"#\") {\n          const refSchema = recursiveAnchor === null\n              ? lookup[__absolute_recursive_ref__]\n              : recursiveAnchor;\n          const keywordLocation = `${schemaLocation}/$recursiveRef`;\n          const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n          if (!result.valid) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"$recursiveRef\",\n                  keywordLocation,\n                  error: \"A subschema had errors.\",\n              }, ...result.errors);\n          }\n      }\n      if ($ref !== undefined) {\n          const uri = __absolute_ref__ || $ref;\n          const refSchema = lookup[uri];\n          if (refSchema === undefined) {\n              let message = `Unresolved $ref \"${$ref}\".`;\n              if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n                  message += `  Absolute URI \"${__absolute_ref__}\".`;\n              }\n              message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join(\"\\n- \")}`;\n              throw new Error(message);\n          }\n          const keywordLocation = `${schemaLocation}/$ref`;\n          const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n          if (!result.valid) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"$ref\",\n                  keywordLocation,\n                  error: \"A subschema had errors.\",\n              }, ...result.errors);\n          }\n          if (draft === \"4\" || draft === \"7\") {\n              return { valid: errors.length === 0, errors };\n          }\n      }\n      if (Array.isArray($type)) {\n          let length = $type.length;\n          let valid = false;\n          for (let i = 0; i < length; i++) {\n              if (instanceType === $type[i] ||\n                  ($type[i] === \"integer\" &&\n                      instanceType === \"number\" &&\n                      instance % 1 === 0 &&\n                      instance === instance)) {\n                  valid = true;\n                  break;\n              }\n          }\n          if (!valid) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"type\",\n                  keywordLocation: `${schemaLocation}/type`,\n                  error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`,\n              });\n          }\n      }\n      else if ($type === \"integer\") {\n          if (instanceType !== \"number\" || instance % 1 || instance !== instance) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"type\",\n                  keywordLocation: `${schemaLocation}/type`,\n                  error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n              });\n          }\n      }\n      else if ($type !== undefined && instanceType !== $type) {\n          errors.push({\n              instanceLocation,\n              keyword: \"type\",\n              keywordLocation: `${schemaLocation}/type`,\n              error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n          });\n      }\n      if ($const !== undefined) {\n          if (instanceType === \"object\" || instanceType === \"array\") {\n              if (!(0, deep_compare_strict_js_1.deepCompareStrict)(instance, $const)) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"const\",\n                      keywordLocation: `${schemaLocation}/const`,\n                      error: `Instance does not match ${JSON.stringify($const)}.`,\n                  });\n              }\n          }\n          else if (instance !== $const) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"const\",\n                  keywordLocation: `${schemaLocation}/const`,\n                  error: `Instance does not match ${JSON.stringify($const)}.`,\n              });\n          }\n      }\n      if ($enum !== undefined) {\n          if (instanceType === \"object\" || instanceType === \"array\") {\n              if (!$enum.some((value) => (0, deep_compare_strict_js_1.deepCompareStrict)(instance, value))) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"enum\",\n                      keywordLocation: `${schemaLocation}/enum`,\n                      error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n                  });\n              }\n          }\n          else if (!$enum.some((value) => instance === value)) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"enum\",\n                  keywordLocation: `${schemaLocation}/enum`,\n                  error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n              });\n          }\n      }\n      if ($not !== undefined) {\n          const keywordLocation = `${schemaLocation}/not`;\n          const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation /*,\n          evaluated*/);\n          if (result.valid) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"not\",\n                  keywordLocation,\n                  error: 'Instance matched \"not\" schema.',\n              });\n          }\n      }\n      let subEvaluateds = [];\n      if ($anyOf !== undefined) {\n          const keywordLocation = `${schemaLocation}/anyOf`;\n          const errorsLength = errors.length;\n          let anyValid = false;\n          for (let i = 0; i < $anyOf.length; i++) {\n              const subSchema = $anyOf[i];\n              const subEvaluated = Object.create(evaluated);\n              const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n              errors.push(...result.errors);\n              anyValid = anyValid || result.valid;\n              if (result.valid) {\n                  subEvaluateds.push(subEvaluated);\n              }\n          }\n          if (anyValid) {\n              errors.length = errorsLength;\n          }\n          else {\n              errors.splice(errorsLength, 0, {\n                  instanceLocation,\n                  keyword: \"anyOf\",\n                  keywordLocation,\n                  error: \"Instance does not match any subschemas.\",\n              });\n          }\n      }\n      if ($allOf !== undefined) {\n          const keywordLocation = `${schemaLocation}/allOf`;\n          const errorsLength = errors.length;\n          let allValid = true;\n          for (let i = 0; i < $allOf.length; i++) {\n              const subSchema = $allOf[i];\n              const subEvaluated = Object.create(evaluated);\n              const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n              errors.push(...result.errors);\n              allValid = allValid && result.valid;\n              if (result.valid) {\n                  subEvaluateds.push(subEvaluated);\n              }\n          }\n          if (allValid) {\n              errors.length = errorsLength;\n          }\n          else {\n              errors.splice(errorsLength, 0, {\n                  instanceLocation,\n                  keyword: \"allOf\",\n                  keywordLocation,\n                  error: `Instance does not match every subschema.`,\n              });\n          }\n      }\n      if ($oneOf !== undefined) {\n          const keywordLocation = `${schemaLocation}/oneOf`;\n          const errorsLength = errors.length;\n          const matches = $oneOf.filter((subSchema, i) => {\n              const subEvaluated = Object.create(evaluated);\n              const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n              errors.push(...result.errors);\n              if (result.valid) {\n                  subEvaluateds.push(subEvaluated);\n              }\n              return result.valid;\n          }).length;\n          if (matches === 1) {\n              errors.length = errorsLength;\n          }\n          else {\n              errors.splice(errorsLength, 0, {\n                  instanceLocation,\n                  keyword: \"oneOf\",\n                  keywordLocation,\n                  error: `Instance does not match exactly one subschema (${matches} matches).`,\n              });\n          }\n      }\n      if (instanceType === \"object\" || instanceType === \"array\") {\n          Object.assign(evaluated, ...subEvaluateds);\n      }\n      if ($if !== undefined) {\n          const keywordLocation = `${schemaLocation}/if`;\n          const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n          if (conditionResult) {\n              if ($then !== undefined) {\n                  const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n                  if (!thenResult.valid) {\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"if\",\n                          keywordLocation,\n                          error: `Instance does not match \"then\" schema.`,\n                      }, ...thenResult.errors);\n                  }\n              }\n          }\n          else if ($else !== undefined) {\n              const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n              if (!elseResult.valid) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"if\",\n                      keywordLocation,\n                      error: `Instance does not match \"else\" schema.`,\n                  }, ...elseResult.errors);\n              }\n          }\n      }\n      if (instanceType === \"object\") {\n          if ($required !== undefined) {\n              for (const key of $required) {\n                  if (!(key in instance)) {\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"required\",\n                          keywordLocation: `${schemaLocation}/required`,\n                          error: `Instance does not have required property \"${key}\".`,\n                      });\n                  }\n              }\n          }\n          const keys = Object.keys(instance);\n          if ($minProperties !== undefined && keys.length < $minProperties) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"minProperties\",\n                  keywordLocation: `${schemaLocation}/minProperties`,\n                  error: `Instance does not have at least ${$minProperties} properties.`,\n              });\n          }\n          if ($maxProperties !== undefined && keys.length > $maxProperties) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"maxProperties\",\n                  keywordLocation: `${schemaLocation}/maxProperties`,\n                  error: `Instance does not have at least ${$maxProperties} properties.`,\n              });\n          }\n          if ($propertyNames !== undefined) {\n              const keywordLocation = `${schemaLocation}/propertyNames`;\n              for (const key in instance) {\n                  const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                  const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                  if (!result.valid) {\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"propertyNames\",\n                          keywordLocation,\n                          error: `Property name \"${key}\" does not match schema.`,\n                      }, ...result.errors);\n                  }\n              }\n          }\n          if ($dependentRequired !== undefined) {\n              const keywordLocation = `${schemaLocation}/dependantRequired`;\n              for (const key in $dependentRequired) {\n                  if (key in instance) {\n                      const required = $dependentRequired[key];\n                      for (const dependantKey of required) {\n                          if (!(dependantKey in instance)) {\n                              errors.push({\n                                  instanceLocation,\n                                  keyword: \"dependentRequired\",\n                                  keywordLocation,\n                                  error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                              });\n                          }\n                      }\n                  }\n              }\n          }\n          if ($dependentSchemas !== undefined) {\n              for (const key in $dependentSchemas) {\n                  const keywordLocation = `${schemaLocation}/dependentSchemas`;\n                  if (key in instance) {\n                      const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`, evaluated);\n                      if (!result.valid) {\n                          errors.push({\n                              instanceLocation,\n                              keyword: \"dependentSchemas\",\n                              keywordLocation,\n                              error: `Instance has \"${key}\" but does not match dependant schema.`,\n                          }, ...result.errors);\n                      }\n                  }\n              }\n          }\n          if ($dependencies !== undefined) {\n              const keywordLocation = `${schemaLocation}/dependencies`;\n              for (const key in $dependencies) {\n                  if (key in instance) {\n                      const propsOrSchema = $dependencies[key];\n                      if (Array.isArray(propsOrSchema)) {\n                          for (const dependantKey of propsOrSchema) {\n                              if (!(dependantKey in instance)) {\n                                  errors.push({\n                                      instanceLocation,\n                                      keyword: \"dependencies\",\n                                      keywordLocation,\n                                      error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                                  });\n                              }\n                          }\n                      }\n                      else {\n                          const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`);\n                          if (!result.valid) {\n                              errors.push({\n                                  instanceLocation,\n                                  keyword: \"dependencies\",\n                                  keywordLocation,\n                                  error: `Instance has \"${key}\" but does not match dependant schema.`,\n                              }, ...result.errors);\n                          }\n                      }\n                  }\n              }\n          }\n          const thisEvaluated = Object.create(null);\n          let stop = false;\n          if ($properties !== undefined) {\n              const keywordLocation = `${schemaLocation}/properties`;\n              for (const key in $properties) {\n                  if (!(key in instance)) {\n                      continue;\n                  }\n                  const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                  const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`);\n                  if (result.valid) {\n                      evaluated[key] = thisEvaluated[key] = true;\n                  }\n                  else {\n                      stop = shortCircuit;\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"properties\",\n                          keywordLocation,\n                          error: `Property \"${key}\" does not match schema.`,\n                      }, ...result.errors);\n                      if (stop)\n                          break;\n                  }\n              }\n          }\n          if (!stop && $patternProperties !== undefined) {\n              const keywordLocation = `${schemaLocation}/patternProperties`;\n              for (const pattern in $patternProperties) {\n                  const regex = new RegExp(pattern);\n                  const subSchema = $patternProperties[pattern];\n                  for (const key in instance) {\n                      if (!regex.test(key)) {\n                          continue;\n                      }\n                      const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                      const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(pattern)}`);\n                      if (result.valid) {\n                          evaluated[key] = thisEvaluated[key] = true;\n                      }\n                      else {\n                          stop = shortCircuit;\n                          errors.push({\n                              instanceLocation,\n                              keyword: \"patternProperties\",\n                              keywordLocation,\n                              error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`,\n                          }, ...result.errors);\n                      }\n                  }\n              }\n          }\n          if (!stop && $additionalProperties !== undefined) {\n              const keywordLocation = `${schemaLocation}/additionalProperties`;\n              for (const key in instance) {\n                  if (thisEvaluated[key]) {\n                      continue;\n                  }\n                  const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                  const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                  if (result.valid) {\n                      evaluated[key] = true;\n                  }\n                  else {\n                      stop = shortCircuit;\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"additionalProperties\",\n                          keywordLocation,\n                          error: `Property \"${key}\" does not match additional properties schema.`,\n                      }, ...result.errors);\n                  }\n              }\n          }\n          else if (!stop && $unevaluatedProperties !== undefined) {\n              const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n              for (const key in instance) {\n                  if (!evaluated[key]) {\n                      const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                      const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                      if (result.valid) {\n                          evaluated[key] = true;\n                      }\n                      else {\n                          errors.push({\n                              instanceLocation,\n                              keyword: \"unevaluatedProperties\",\n                              keywordLocation,\n                              error: `Property \"${key}\" does not match unevaluated properties schema.`,\n                          }, ...result.errors);\n                      }\n                  }\n              }\n          }\n      }\n      else if (instanceType === \"array\") {\n          if ($maxItems !== undefined && instance.length > $maxItems) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"maxItems\",\n                  keywordLocation: `${schemaLocation}/maxItems`,\n                  error: `Array has too many items (${instance.length} > ${$maxItems}).`,\n              });\n          }\n          if ($minItems !== undefined && instance.length < $minItems) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"minItems\",\n                  keywordLocation: `${schemaLocation}/minItems`,\n                  error: `Array has too few items (${instance.length} < ${$minItems}).`,\n              });\n          }\n          const length = instance.length;\n          let i = 0;\n          let stop = false;\n          if ($prefixItems !== undefined) {\n              const keywordLocation = `${schemaLocation}/prefixItems`;\n              const length2 = Math.min($prefixItems.length, length);\n              for (; i < length2; i++) {\n                  const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                  evaluated[i] = true;\n                  if (!result.valid) {\n                      stop = shortCircuit;\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"prefixItems\",\n                          keywordLocation,\n                          error: `Items did not match schema.`,\n                      }, ...result.errors);\n                      if (stop)\n                          break;\n                  }\n              }\n          }\n          if ($items !== undefined) {\n              const keywordLocation = `${schemaLocation}/items`;\n              if (Array.isArray($items)) {\n                  const length2 = Math.min($items.length, length);\n                  for (; i < length2; i++) {\n                      const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                      evaluated[i] = true;\n                      if (!result.valid) {\n                          stop = shortCircuit;\n                          errors.push({\n                              instanceLocation,\n                              keyword: \"items\",\n                              keywordLocation,\n                              error: `Items did not match schema.`,\n                          }, ...result.errors);\n                          if (stop)\n                              break;\n                      }\n                  }\n              }\n              else {\n                  for (; i < length; i++) {\n                      const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                      evaluated[i] = true;\n                      if (!result.valid) {\n                          stop = shortCircuit;\n                          errors.push({\n                              instanceLocation,\n                              keyword: \"items\",\n                              keywordLocation,\n                              error: `Items did not match schema.`,\n                          }, ...result.errors);\n                          if (stop)\n                              break;\n                      }\n                  }\n              }\n              if (!stop && $additionalItems !== undefined) {\n                  const keywordLocation = `${schemaLocation}/additionalItems`;\n                  for (; i < length; i++) {\n                      const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                      evaluated[i] = true;\n                      if (!result.valid) {\n                          stop = shortCircuit;\n                          errors.push({\n                              instanceLocation,\n                              keyword: \"additionalItems\",\n                              keywordLocation,\n                              error: `Items did not match additional items schema.`,\n                          }, ...result.errors);\n                      }\n                  }\n              }\n          }\n          if ($contains !== undefined) {\n              if (length === 0 && $minContains === undefined) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"contains\",\n                      keywordLocation: `${schemaLocation}/contains`,\n                      error: `Array is empty. It must contain at least one item matching the schema.`,\n                  });\n              }\n              else if ($minContains !== undefined && length < $minContains) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"minContains\",\n                      keywordLocation: `${schemaLocation}/minContains`,\n                      error: `Array has less items (${length}) than minContains (${$minContains}).`,\n                  });\n              }\n              else {\n                  const keywordLocation = `${schemaLocation}/contains`;\n                  const errorsLength = errors.length;\n                  let contained = 0;\n                  for (let j = 0; j < length; j++) {\n                      const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n                      if (result.valid) {\n                          evaluated[j] = true;\n                          contained++;\n                      }\n                      else {\n                          errors.push(...result.errors);\n                      }\n                  }\n                  if (contained >= ($minContains || 0)) {\n                      errors.length = errorsLength;\n                  }\n                  if ($minContains === undefined &&\n                      $maxContains === undefined &&\n                      contained === 0) {\n                      errors.splice(errorsLength, 0, {\n                          instanceLocation,\n                          keyword: \"contains\",\n                          keywordLocation,\n                          error: `Array does not contain item matching schema.`,\n                      });\n                  }\n                  else if ($minContains !== undefined && contained < $minContains) {\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"minContains\",\n                          keywordLocation: `${schemaLocation}/minContains`,\n                          error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`,\n                      });\n                  }\n                  else if ($maxContains !== undefined && contained > $maxContains) {\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"maxContains\",\n                          keywordLocation: `${schemaLocation}/maxContains`,\n                          error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`,\n                      });\n                  }\n              }\n          }\n          if (!stop && $unevaluatedItems !== undefined) {\n              const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n              for (i; i < length; i++) {\n                  if (evaluated[i]) {\n                      continue;\n                  }\n                  const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                  evaluated[i] = true;\n                  if (!result.valid) {\n                      errors.push({\n                          instanceLocation,\n                          keyword: \"unevaluatedItems\",\n                          keywordLocation,\n                          error: `Items did not match unevaluated items schema.`,\n                      }, ...result.errors);\n                  }\n              }\n          }\n          if ($uniqueItems) {\n              for (let j = 0; j < length; j++) {\n                  const a = instance[j];\n                  const ao = typeof a === \"object\" && a !== null;\n                  for (let k = 0; k < length; k++) {\n                      if (j === k) {\n                          continue;\n                      }\n                      const b = instance[k];\n                      const bo = typeof b === \"object\" && b !== null;\n                      if (a === b || (ao && bo && (0, deep_compare_strict_js_1.deepCompareStrict)(a, b))) {\n                          errors.push({\n                              instanceLocation,\n                              keyword: \"uniqueItems\",\n                              keywordLocation: `${schemaLocation}/uniqueItems`,\n                              error: `Duplicate items at indexes ${j} and ${k}.`,\n                          });\n                          j = Number.MAX_SAFE_INTEGER;\n                          k = Number.MAX_SAFE_INTEGER;\n                      }\n                  }\n              }\n          }\n      }\n      else if (instanceType === \"number\") {\n          if (draft === \"4\") {\n              if ($minimum !== undefined &&\n                  (($exclusiveMinimum === true && instance <= $minimum) ||\n                      instance < $minimum)) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"minimum\",\n                      keywordLocation: `${schemaLocation}/minimum`,\n                      error: `${instance} is less than ${$exclusiveMinimum ? \"or equal to \" : \"\"} ${$minimum}.`,\n                  });\n              }\n              if ($maximum !== undefined &&\n                  (($exclusiveMaximum === true && instance >= $maximum) ||\n                      instance > $maximum)) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"maximum\",\n                      keywordLocation: `${schemaLocation}/maximum`,\n                      error: `${instance} is greater than ${$exclusiveMaximum ? \"or equal to \" : \"\"} ${$maximum}.`,\n                  });\n              }\n          }\n          else {\n              if ($minimum !== undefined && instance < $minimum) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"minimum\",\n                      keywordLocation: `${schemaLocation}/minimum`,\n                      error: `${instance} is less than ${$minimum}.`,\n                  });\n              }\n              if ($maximum !== undefined && instance > $maximum) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"maximum\",\n                      keywordLocation: `${schemaLocation}/maximum`,\n                      error: `${instance} is greater than ${$maximum}.`,\n                  });\n              }\n              if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"exclusiveMinimum\",\n                      keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n                      error: `${instance} is less than ${$exclusiveMinimum}.`,\n                  });\n              }\n              if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"exclusiveMaximum\",\n                      keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n                      error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`,\n                  });\n              }\n          }\n          if ($multipleOf !== undefined) {\n              const remainder = instance % $multipleOf;\n              if (Math.abs(0 - remainder) >= 1.1920929e-7 &&\n                  Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n                  errors.push({\n                      instanceLocation,\n                      keyword: \"multipleOf\",\n                      keywordLocation: `${schemaLocation}/multipleOf`,\n                      error: `${instance} is not a multiple of ${$multipleOf}.`,\n                  });\n              }\n          }\n      }\n      else if (instanceType === \"string\") {\n          const length = $minLength === undefined && $maxLength === undefined\n              ? 0\n              : (0, ucs2_length_js_1.ucs2length)(instance);\n          if ($minLength !== undefined && length < $minLength) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"minLength\",\n                  keywordLocation: `${schemaLocation}/minLength`,\n                  error: `String is too short (${length} < ${$minLength}).`,\n              });\n          }\n          if ($maxLength !== undefined && length > $maxLength) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"maxLength\",\n                  keywordLocation: `${schemaLocation}/maxLength`,\n                  error: `String is too long (${length} > ${$maxLength}).`,\n              });\n          }\n          if ($pattern !== undefined && !new RegExp($pattern).test(instance)) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"pattern\",\n                  keywordLocation: `${schemaLocation}/pattern`,\n                  error: `String does not match pattern.`,\n              });\n          }\n          if ($format !== undefined &&\n              format_js_1.fastFormat[$format] &&\n              !format_js_1.fastFormat[$format](instance)) {\n              errors.push({\n                  instanceLocation,\n                  keyword: \"format\",\n                  keywordLocation: `${schemaLocation}/format`,\n                  error: `String does not match format \"${$format}\".`,\n              });\n          }\n      }\n      return { valid: errors.length === 0, errors };\n  }\n  validate$1.validate = validate;\n\n  var validator = {};\n\n  Object.defineProperty(validator, \"__esModule\", { value: true });\n  validator.Validator = void 0;\n  const dereference_js_1 = dereference;\n  const validate_js_1 = validate$1;\n  class Validator {\n      constructor(schema, draft = \"2019-09\", shortCircuit = true) {\n          Object.defineProperty(this, \"schema\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: schema\n          });\n          Object.defineProperty(this, \"draft\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: draft\n          });\n          Object.defineProperty(this, \"shortCircuit\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: shortCircuit\n          });\n          Object.defineProperty(this, \"lookup\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.lookup = (0, dereference_js_1.dereference)(schema);\n      }\n      validate(instance) {\n          return (0, validate_js_1.validate)(instance, this.schema, this.draft, this.lookup, this.shortCircuit);\n      }\n      addSchema(schema, id) {\n          if (id) {\n              schema = { ...schema, $id: id };\n          }\n          (0, dereference_js_1.dereference)(schema, this.lookup);\n      }\n  }\n  validator.Validator = Validator;\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t__exportStar(deepCompareStrict$1, exports);\n  \t__exportStar(dereference, exports);\n  \t__exportStar(format, exports);\n  \t__exportStar(pointer, exports);\n  \t__exportStar(types$1, exports);\n  \t__exportStar(ucs2Length, exports);\n  \t__exportStar(validate$1, exports);\n  \t__exportStar(validator, exports); \n  } (src));\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t__exportStar(src, exports); \n  } (jsonSchema));\n\n  Object.defineProperty(transform, \"__esModule\", { value: true });\n  transform.BaseCumulativeTransformOutputParser = transform.BaseTransformOutputParser = void 0;\n  const base_js_1$5 = base;\n  const base_js_2 = messages$1.base$1;\n  const utils_js_1 = messages$1.utils;\n  const outputs_js_1$1 = messages$1.outputs;\n  const index_js_1$1 = jsonSchema;\n  /**\n   * Class to parse the output of an LLM call that also allows streaming inputs.\n   */\n  class BaseTransformOutputParser extends base_js_1$5.BaseOutputParser {\n      async *_transform(inputGenerator) {\n          for await (const chunk of inputGenerator) {\n              if (typeof chunk === \"string\") {\n                  yield this.parseResult([{ text: chunk }]);\n              }\n              else {\n                  yield this.parseResult([\n                      {\n                          message: chunk,\n                          text: this._baseMessageToString(chunk),\n                      },\n                  ]);\n              }\n          }\n      }\n      /**\n       * Transforms an asynchronous generator of input into an asynchronous\n       * generator of parsed output.\n       * @param inputGenerator An asynchronous generator of input.\n       * @param options A configuration object.\n       * @returns An asynchronous generator of parsed output.\n       */\n      async *transform(inputGenerator, options) {\n          yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n              ...options,\n              runType: \"parser\",\n          });\n      }\n  }\n  transform.BaseTransformOutputParser = BaseTransformOutputParser;\n  /**\n   * A base class for output parsers that can handle streaming input. It\n   * extends the `BaseTransformOutputParser` class and provides a method for\n   * converting parsed outputs into a diff format.\n   */\n  class BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n      constructor(fields) {\n          super(fields);\n          Object.defineProperty(this, \"diff\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: false\n          });\n          this.diff = fields?.diff ?? this.diff;\n      }\n      async *_transform(inputGenerator) {\n          let prevParsed;\n          let accGen;\n          for await (const chunk of inputGenerator) {\n              if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n                  throw new Error(\"Cannot handle non-string output.\");\n              }\n              let chunkGen;\n              if ((0, base_js_2.isBaseMessageChunk)(chunk)) {\n                  if (typeof chunk.content !== \"string\") {\n                      throw new Error(\"Cannot handle non-string message output.\");\n                  }\n                  chunkGen = new outputs_js_1$1.ChatGenerationChunk({\n                      message: chunk,\n                      text: chunk.content,\n                  });\n              }\n              else if ((0, base_js_2.isBaseMessage)(chunk)) {\n                  if (typeof chunk.content !== \"string\") {\n                      throw new Error(\"Cannot handle non-string message output.\");\n                  }\n                  chunkGen = new outputs_js_1$1.ChatGenerationChunk({\n                      message: (0, utils_js_1.convertToChunk)(chunk),\n                      text: chunk.content,\n                  });\n              }\n              else {\n                  chunkGen = new outputs_js_1$1.GenerationChunk({ text: chunk });\n              }\n              if (accGen === undefined) {\n                  accGen = chunkGen;\n              }\n              else {\n                  accGen = accGen.concat(chunkGen);\n              }\n              const parsed = await this.parsePartialResult([accGen]);\n              if (parsed !== undefined &&\n                  parsed !== null &&\n                  !(0, index_js_1$1.deepCompareStrict)(parsed, prevParsed)) {\n                  if (this.diff) {\n                      yield this._diff(prevParsed, parsed);\n                  }\n                  else {\n                      yield parsed;\n                  }\n                  prevParsed = parsed;\n              }\n          }\n      }\n      getFormatInstructions() {\n          return \"\";\n      }\n  }\n  transform.BaseCumulativeTransformOutputParser = BaseCumulativeTransformOutputParser;\n\n  Object.defineProperty(bytes, \"__esModule\", { value: true });\n  bytes.BytesOutputParser = void 0;\n  const transform_js_1$3 = transform;\n  /**\n   * OutputParser that parses LLMResult into the top likely string and\n   * encodes it into bytes.\n   */\n  class BytesOutputParser extends transform_js_1$3.BaseTransformOutputParser {\n      constructor() {\n          super(...arguments);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"output_parsers\", \"bytes\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"textEncoder\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: new TextEncoder()\n          });\n      }\n      static lc_name() {\n          return \"BytesOutputParser\";\n      }\n      parse(text) {\n          return Promise.resolve(this.textEncoder.encode(text));\n      }\n      getFormatInstructions() {\n          return \"\";\n      }\n  }\n  bytes.BytesOutputParser = BytesOutputParser;\n\n  var list = {};\n\n  Object.defineProperty(list, \"__esModule\", { value: true });\n  list.MarkdownListOutputParser = list.NumberedListOutputParser = list.CustomListOutputParser = list.CommaSeparatedListOutputParser = list.ListOutputParser = void 0;\n  const base_js_1$4 = base;\n  const transform_js_1$2 = transform;\n  /**\n   * Class to parse the output of an LLM call to a list.\n   * @augments BaseOutputParser\n   */\n  class ListOutputParser extends transform_js_1$2.BaseTransformOutputParser {\n      constructor() {\n          super(...arguments);\n          Object.defineProperty(this, \"re\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n      }\n      async *_transform(inputGenerator) {\n          let buffer = \"\";\n          for await (const input of inputGenerator) {\n              if (typeof input === \"string\") {\n                  // add current chunk to buffer\n                  buffer += input;\n              }\n              else {\n                  // extract message content and add to buffer\n                  buffer += input.content;\n              }\n              // get parts in buffer\n              if (!this.re) {\n                  const parts = await this.parse(buffer);\n                  if (parts.length > 1) {\n                      // if there are multiple parts, yield all but the last one\n                      for (const part of parts.slice(0, -1)) {\n                          yield [part];\n                      }\n                      // keep the last part in the buffer\n                      buffer = parts[parts.length - 1];\n                  }\n              }\n              else {\n                  // if there is a regex, get all matches\n                  const matches = [...buffer.matchAll(this.re)];\n                  if (matches.length > 1) {\n                      let doneIdx = 0;\n                      // if there are multiple matches, yield all but the last one\n                      for (const match of matches.slice(0, -1)) {\n                          yield [match[1]];\n                          doneIdx += (match.index ?? 0) + match[0].length;\n                      }\n                      // keep the last match in the buffer\n                      buffer = buffer.slice(doneIdx);\n                  }\n              }\n          }\n          // yield the last part\n          for (const part of await this.parse(buffer)) {\n              yield [part];\n          }\n      }\n  }\n  list.ListOutputParser = ListOutputParser;\n  /**\n   * Class to parse the output of an LLM call as a comma-separated list.\n   * @augments ListOutputParser\n   */\n  class CommaSeparatedListOutputParser extends ListOutputParser {\n      constructor() {\n          super(...arguments);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"output_parsers\", \"list\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n      }\n      static lc_name() {\n          return \"CommaSeparatedListOutputParser\";\n      }\n      /**\n       * Parses the given text into an array of strings, using a comma as the\n       * separator. If the parsing fails, throws an OutputParserException.\n       * @param text The text to parse.\n       * @returns An array of strings obtained by splitting the input text at each comma.\n       */\n      async parse(text) {\n          try {\n              return text\n                  .trim()\n                  .split(\",\")\n                  .map((s) => s.trim());\n          }\n          catch (e) {\n              throw new base_js_1$4.OutputParserException(`Could not parse output: ${text}`, text);\n          }\n      }\n      /**\n       * Provides instructions on the expected format of the response for the\n       * CommaSeparatedListOutputParser.\n       * @returns A string containing instructions on the expected format of the response.\n       */\n      getFormatInstructions() {\n          return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n      }\n  }\n  list.CommaSeparatedListOutputParser = CommaSeparatedListOutputParser;\n  /**\n   * Class to parse the output of an LLM call to a list with a specific length and separator.\n   * @augments ListOutputParser\n   */\n  class CustomListOutputParser extends ListOutputParser {\n      constructor({ length, separator }) {\n          super(...arguments);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"output_parsers\", \"list\"]\n          });\n          Object.defineProperty(this, \"length\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"separator\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.length = length;\n          this.separator = separator || \",\";\n      }\n      /**\n       * Parses the given text into an array of strings, using the specified\n       * separator. If the parsing fails or the number of items in the list\n       * doesn't match the expected length, throws an OutputParserException.\n       * @param text The text to parse.\n       * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n       */\n      async parse(text) {\n          try {\n              const items = text\n                  .trim()\n                  .split(this.separator)\n                  .map((s) => s.trim());\n              if (this.length !== undefined && items.length !== this.length) {\n                  throw new base_js_1$4.OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);\n              }\n              return items;\n          }\n          catch (e) {\n              if (Object.getPrototypeOf(e) === base_js_1$4.OutputParserException.prototype) {\n                  throw e;\n              }\n              throw new base_js_1$4.OutputParserException(`Could not parse output: ${text}`);\n          }\n      }\n      /**\n       * Provides instructions on the expected format of the response for the\n       * CustomListOutputParser, including the number of items and the\n       * separator.\n       * @returns A string containing instructions on the expected format of the response.\n       */\n      getFormatInstructions() {\n          return `Your response should be a list of ${this.length === undefined ? \"\" : `${this.length} `}items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${this.separator} baz\\`)`;\n      }\n  }\n  list.CustomListOutputParser = CustomListOutputParser;\n  class NumberedListOutputParser extends ListOutputParser {\n      constructor() {\n          super(...arguments);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"output_parsers\", \"list\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"re\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: /\\d+\\.\\s([^\\n]+)/g\n          });\n      }\n      static lc_name() {\n          return \"NumberedListOutputParser\";\n      }\n      getFormatInstructions() {\n          return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n      }\n      async parse(text) {\n          return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n      }\n  }\n  list.NumberedListOutputParser = NumberedListOutputParser;\n  class MarkdownListOutputParser extends ListOutputParser {\n      constructor() {\n          super(...arguments);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain_core\", \"output_parsers\", \"list\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"re\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: /^\\s*[-*]\\s([^\\n]+)$/gm\n          });\n      }\n      static lc_name() {\n          return \"NumberedListOutputParser\";\n      }\n      getFormatInstructions() {\n          return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n      }\n      async parse(text) {\n          return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n      }\n  }\n  list.MarkdownListOutputParser = MarkdownListOutputParser;\n\n  var string$1 = {};\n\n  Object.defineProperty(string$1, \"__esModule\", {\n    value: true\n  });\n  string$1.StringOutputParser = void 0;\n  const transform_js_1$1 = transform;\n  class StringOutputParser extends transform_js_1$1.BaseTransformOutputParser {\n    constructor() {\n      super(...arguments);\n      Object.defineProperty(this, \"lc_namespace\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: [\"langchain_core\", \"output_parsers\", \"string\"]\n      });\n      Object.defineProperty(this, \"lc_serializable\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: true\n      });\n    }\n    static lc_name() {\n      return \"StrOutputParser\";\n    }\n    parse(text) {\n      return Promise.resolve(text);\n    }\n    getFormatInstructions() {\n      return \"\";\n    }\n    _textContentToString(content) {\n      return content.text;\n    }\n    _imageUrlContentToString(_content) {\n      throw new Error(`Cannot coerce a multimodal \"image_url\" message part into a string.`);\n    }\n    _messageContentComplexToString(content) {\n      switch (content.type) {\n        case \"text\":\n        case \"text_delta\":\n          if ((\"text\" in content)) {\n            return this._textContentToString(content);\n          }\n          break;\n        case \"image_url\":\n          if ((\"image_url\" in content)) {\n            return this._imageUrlContentToString(content);\n          }\n          break;\n        default:\n          throw new Error(`Cannot coerce \"${content.type}\" message part into a string.`);\n      }\n      throw new Error(`Invalid content type: ${content.type}`);\n    }\n    _baseMessageContentToString(content) {\n      return content.reduce((acc, item) => acc + this._messageContentComplexToString(item), \"\");\n    }\n  }\n  string$1.StringOutputParser = StringOutputParser;\n\n  var structured = {};\n\n  Object.defineProperty(structured, \"__esModule\", { value: true });\n  structured.AsymmetricStructuredOutputParser = structured.JsonMarkdownStructuredOutputParser = structured.StructuredOutputParser = void 0;\n  const zod_1$2 = messages$1.lib;\n  const zod_to_json_schema_1$3 = messages$1.cjs;\n  const base_js_1$3 = base;\n  class StructuredOutputParser extends base_js_1$3.BaseOutputParser {\n      static lc_name() {\n          return \"StructuredOutputParser\";\n      }\n      toJSON() {\n          return this.toJSONNotImplemented();\n      }\n      constructor(schema) {\n          super(schema);\n          Object.defineProperty(this, \"schema\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: schema\n          });\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain\", \"output_parsers\", \"structured\"]\n          });\n      }\n      /**\n       * Creates a new StructuredOutputParser from a Zod schema.\n       * @param schema The Zod schema which the output should match\n       * @returns A new instance of StructuredOutputParser.\n       */\n      static fromZodSchema(schema) {\n          return new this(schema);\n      }\n      /**\n       * Creates a new StructuredOutputParser from a set of names and\n       * descriptions.\n       * @param schemas An object where each key is a name and each value is a description\n       * @returns A new instance of StructuredOutputParser.\n       */\n      static fromNamesAndDescriptions(schemas) {\n          const zodSchema = zod_1$2.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, zod_1$2.z.string().describe(description)])));\n          return new this(zodSchema);\n      }\n      /**\n       * Returns a markdown code snippet with a JSON object formatted according\n       * to the schema.\n       * @param options Optional. The options for formatting the instructions\n       * @returns A markdown code snippet with a JSON object formatted according to the schema.\n       */\n      getFormatInstructions() {\n          return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify((0, zod_to_json_schema_1$3.zodToJsonSchema)(this.schema))}\n\\`\\`\\`\n`;\n      }\n      /**\n       * Parses the given text according to the schema.\n       * @param text The text to parse\n       * @returns The parsed output.\n       */\n      async parse(text) {\n          try {\n              const json = text.includes(\"```\")\n                  ? text.trim().split(/```(?:json)?/)[1]\n                  : text.trim();\n              const escapedJson = json\n                  .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n                  const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n                  return `\"${escapedInsideQuotes}\"`;\n              })\n                  .replace(/\\n/g, \"\");\n              return await this.schema.parseAsync(JSON.parse(escapedJson));\n          }\n          catch (e) {\n              throw new base_js_1$3.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n          }\n      }\n  }\n  structured.StructuredOutputParser = StructuredOutputParser;\n  /**\n   * A specific type of `StructuredOutputParser` that parses JSON data\n   * formatted as a markdown code snippet.\n   */\n  class JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n      static lc_name() {\n          return \"JsonMarkdownStructuredOutputParser\";\n      }\n      getFormatInstructions(options) {\n          const interpolationDepth = options?.interpolationDepth ?? 1;\n          if (interpolationDepth < 1) {\n              throw new Error(\"f string interpolation depth must be at least 1\");\n          }\n          return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction((0, zod_to_json_schema_1$3.zodToJsonSchema)(this.schema))\n            .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n            .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n      }\n      _schemaToInstruction(schemaInput, indent = 2) {\n          const schema = schemaInput;\n          if (\"type\" in schema) {\n              let nullable = false;\n              let type;\n              if (Array.isArray(schema.type)) {\n                  const nullIdx = schema.type.findIndex((type) => type === \"null\");\n                  if (nullIdx !== -1) {\n                      nullable = true;\n                      schema.type.splice(nullIdx, 1);\n                  }\n                  type = schema.type.join(\" | \");\n              }\n              else {\n                  type = schema.type;\n              }\n              if (schema.type === \"object\" && schema.properties) {\n                  const description = schema.description\n                      ? ` // ${schema.description}`\n                      : \"\";\n                  const properties = Object.entries(schema.properties)\n                      .map(([key, value]) => {\n                      const isOptional = schema.required?.includes(key)\n                          ? \"\"\n                          : \" (optional)\";\n                      return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n                  })\n                      .join(\"\\n\");\n                  return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n              }\n              if (schema.type === \"array\" && schema.items) {\n                  const description = schema.description\n                      ? ` // ${schema.description}`\n                      : \"\";\n                  return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n              }\n              const isNullable = nullable ? \" (nullable)\" : \"\";\n              const description = schema.description ? ` // ${schema.description}` : \"\";\n              return `${type}${description}${isNullable}`;\n          }\n          if (\"anyOf\" in schema) {\n              return schema.anyOf\n                  .map((s) => this._schemaToInstruction(s, indent))\n                  .join(`\\n${\" \".repeat(indent - 2)}`);\n          }\n          throw new Error(\"unsupported schema type\");\n      }\n      static fromZodSchema(schema) {\n          return new this(schema);\n      }\n      static fromNamesAndDescriptions(schemas) {\n          const zodSchema = zod_1$2.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, zod_1$2.z.string().describe(description)])));\n          return new this(zodSchema);\n      }\n  }\n  structured.JsonMarkdownStructuredOutputParser = JsonMarkdownStructuredOutputParser;\n  /**\n   * A type of `StructuredOutputParser` that handles asymmetric input and\n   * output schemas.\n   */\n  class AsymmetricStructuredOutputParser extends base_js_1$3.BaseOutputParser {\n      constructor({ inputSchema }) {\n          super(...arguments);\n          Object.defineProperty(this, \"structuredInputParser\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n      }\n      async parse(text) {\n          let parsedInput;\n          try {\n              parsedInput = await this.structuredInputParser.parse(text);\n          }\n          catch (e) {\n              throw new base_js_1$3.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n          }\n          return this.outputProcessor(parsedInput);\n      }\n      getFormatInstructions() {\n          return this.structuredInputParser.getFormatInstructions();\n      }\n  }\n  structured.AsymmetricStructuredOutputParser = AsymmetricStructuredOutputParser;\n\n  var json = {};\n\n  var json_patch = {};\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.applyPatch = exports.compare = void 0;\n  \tvar index_js_1 = messages$1.fastJsonPatch;\n  \tObject.defineProperty(exports, \"compare\", { enumerable: true, get: function () { return index_js_1.compare; } });\n  \tObject.defineProperty(exports, \"applyPatch\", { enumerable: true, get: function () { return index_js_1.applyPatch; } }); \n  } (json_patch));\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.parseJsonMarkdown = exports.parsePartialJson = exports.JsonOutputParser = void 0;\n  \tconst transform_js_1 = transform;\n  \tconst json_patch_js_1 = json_patch;\n  \tconst json_js_1 = messages$1.json;\n  \tObject.defineProperty(exports, \"parseJsonMarkdown\", { enumerable: true, get: function () { return json_js_1.parseJsonMarkdown; } });\n  \tObject.defineProperty(exports, \"parsePartialJson\", { enumerable: true, get: function () { return json_js_1.parsePartialJson; } });\n  \t/**\n  \t * Class for parsing the output of an LLM into a JSON object.\n  \t */\n  \tclass JsonOutputParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n  \t    constructor() {\n  \t        super(...arguments);\n  \t        Object.defineProperty(this, \"lc_namespace\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: [\"langchain_core\", \"output_parsers\"]\n  \t        });\n  \t        Object.defineProperty(this, \"lc_serializable\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: true\n  \t        });\n  \t    }\n  \t    static lc_name() {\n  \t        return \"JsonOutputParser\";\n  \t    }\n  \t    _diff(prev, next) {\n  \t        if (!next) {\n  \t            return undefined;\n  \t        }\n  \t        if (!prev) {\n  \t            return [{ op: \"replace\", path: \"\", value: next }];\n  \t        }\n  \t        return (0, json_patch_js_1.compare)(prev, next);\n  \t    }\n  \t    // This should actually return Partial<T>, but there's no way\n  \t    // to specify emitted chunks as instances separate from the main output type.\n  \t    async parsePartialResult(generations) {\n  \t        return (0, json_js_1.parseJsonMarkdown)(generations[0].text);\n  \t    }\n  \t    async parse(text) {\n  \t        return (0, json_js_1.parseJsonMarkdown)(text, JSON.parse);\n  \t    }\n  \t    getFormatInstructions() {\n  \t        return \"\";\n  \t    }\n  \t}\n  \texports.JsonOutputParser = JsonOutputParser; \n  } (json));\n\n  var xml = {};\n\n  var sax$1 = {};\n\n  // @ts-nocheck\n  Object.defineProperty(sax$1, \"__esModule\", { value: true });\n  sax$1.sax = void 0;\n  // Inlined to deal with portability issues\n  // Originally from: https://github.com/isaacs/sax-js\n  const initializeSax = function () {\n      const sax = {};\n      sax.parser = function (strict, opt) {\n          return new SAXParser(strict, opt);\n      };\n      sax.SAXParser = SAXParser;\n      sax.SAXStream = SAXStream;\n      sax.createStream = createStream;\n      // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n      // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n      // since that's the earliest that a buffer overrun could occur.  This way, checks are\n      // as rare as required, but as often as necessary to ensure never crossing this bound.\n      // Furthermore, buffers are only tested at most once per write(), so passing a very\n      // large string into write() might have undesirable effects, but this is manageable by\n      // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n      // edge case, result in creating at most one complete copy of the string passed in.\n      // Set to Infinity to have unlimited buffers.\n      sax.MAX_BUFFER_LENGTH = 64 * 1024;\n      const buffers = [\n          \"comment\",\n          \"sgmlDecl\",\n          \"textNode\",\n          \"tagName\",\n          \"doctype\",\n          \"procInstName\",\n          \"procInstBody\",\n          \"entity\",\n          \"attribName\",\n          \"attribValue\",\n          \"cdata\",\n          \"script\",\n      ];\n      sax.EVENTS = [\n          \"text\",\n          \"processinginstruction\",\n          \"sgmldeclaration\",\n          \"doctype\",\n          \"comment\",\n          \"opentagstart\",\n          \"attribute\",\n          \"opentag\",\n          \"closetag\",\n          \"opencdata\",\n          \"cdata\",\n          \"closecdata\",\n          \"error\",\n          \"end\",\n          \"ready\",\n          \"script\",\n          \"opennamespace\",\n          \"closenamespace\",\n      ];\n      function SAXParser(strict, opt) {\n          if (!(this instanceof SAXParser)) {\n              return new SAXParser(strict, opt);\n          }\n          var parser = this;\n          clearBuffers(parser);\n          parser.q = parser.c = \"\";\n          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n          parser.opt = opt || {};\n          parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n          parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n          parser.tags = [];\n          parser.closed = parser.closedRoot = parser.sawRoot = false;\n          parser.tag = parser.error = null;\n          parser.strict = !!strict;\n          parser.noscript = !!(strict || parser.opt.noscript);\n          parser.state = S.BEGIN;\n          parser.strictEntities = parser.opt.strictEntities;\n          parser.ENTITIES = parser.strictEntities\n              ? Object.create(sax.XML_ENTITIES)\n              : Object.create(sax.ENTITIES);\n          parser.attribList = [];\n          // namespaces form a prototype chain.\n          // it always points at the current tag,\n          // which protos to its parent tag.\n          if (parser.opt.xmlns) {\n              parser.ns = Object.create(rootNS);\n          }\n          // mostly just for error reporting\n          parser.trackPosition = parser.opt.position !== false;\n          if (parser.trackPosition) {\n              parser.position = parser.line = parser.column = 0;\n          }\n          emit(parser, \"onready\");\n      }\n      if (!Object.create) {\n          Object.create = function (o) {\n              function F() { }\n              F.prototype = o;\n              var newf = new F();\n              return newf;\n          };\n      }\n      if (!Object.keys) {\n          Object.keys = function (o) {\n              var a = [];\n              for (var i in o)\n                  if (o.hasOwnProperty(i))\n                      a.push(i);\n              return a;\n          };\n      }\n      function checkBufferLength(parser) {\n          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n          var maxActual = 0;\n          for (var i = 0, l = buffers.length; i < l; i++) {\n              var len = parser[buffers[i]].length;\n              if (len > maxAllowed) {\n                  // Text/cdata nodes can get big, and since they're buffered,\n                  // we can get here under normal conditions.\n                  // Avoid issues by emitting the text node now,\n                  // so at least it won't get any bigger.\n                  switch (buffers[i]) {\n                      case \"textNode\":\n                          closeText(parser);\n                          break;\n                      case \"cdata\":\n                          emitNode(parser, \"oncdata\", parser.cdata);\n                          parser.cdata = \"\";\n                          break;\n                      case \"script\":\n                          emitNode(parser, \"onscript\", parser.script);\n                          parser.script = \"\";\n                          break;\n                      default:\n                          error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n                  }\n              }\n              maxActual = Math.max(maxActual, len);\n          }\n          // schedule the next check for the earliest possible buffer overrun.\n          var m = sax.MAX_BUFFER_LENGTH - maxActual;\n          parser.bufferCheckPosition = m + parser.position;\n      }\n      function clearBuffers(parser) {\n          for (var i = 0, l = buffers.length; i < l; i++) {\n              parser[buffers[i]] = \"\";\n          }\n      }\n      function flushBuffers(parser) {\n          closeText(parser);\n          if (parser.cdata !== \"\") {\n              emitNode(parser, \"oncdata\", parser.cdata);\n              parser.cdata = \"\";\n          }\n          if (parser.script !== \"\") {\n              emitNode(parser, \"onscript\", parser.script);\n              parser.script = \"\";\n          }\n      }\n      SAXParser.prototype = {\n          end: function () {\n              end(this);\n          },\n          write: write,\n          resume: function () {\n              this.error = null;\n              return this;\n          },\n          close: function () {\n              return this.write(null);\n          },\n          flush: function () {\n              flushBuffers(this);\n          },\n      };\n      var Stream = ReadableStream;\n      if (!Stream)\n          Stream = function () { };\n      var streamWraps = sax.EVENTS.filter(function (ev) {\n          return ev !== \"error\" && ev !== \"end\";\n      });\n      function createStream(strict, opt) {\n          return new SAXStream(strict, opt);\n      }\n      function SAXStream(strict, opt) {\n          if (!(this instanceof SAXStream)) {\n              return new SAXStream(strict, opt);\n          }\n          Stream.apply(this);\n          this._parser = new SAXParser(strict, opt);\n          this.writable = true;\n          this.readable = true;\n          var me = this;\n          this._parser.onend = function () {\n              me.emit(\"end\");\n          };\n          this._parser.onerror = function (er) {\n              me.emit(\"error\", er);\n              // if didn't throw, then means error was handled.\n              // go ahead and clear error, so we can write again.\n              me._parser.error = null;\n          };\n          this._decoder = null;\n          streamWraps.forEach(function (ev) {\n              Object.defineProperty(me, \"on\" + ev, {\n                  get: function () {\n                      return me._parser[\"on\" + ev];\n                  },\n                  set: function (h) {\n                      if (!h) {\n                          me.removeAllListeners(ev);\n                          me._parser[\"on\" + ev] = h;\n                          return h;\n                      }\n                      me.on(ev, h);\n                  },\n                  enumerable: true,\n                  configurable: false,\n              });\n          });\n      }\n      SAXStream.prototype = Object.create(Stream.prototype, {\n          constructor: {\n              value: SAXStream,\n          },\n      });\n      SAXStream.prototype.write = function (data) {\n          this._parser.write(data.toString());\n          this.emit(\"data\", data);\n          return true;\n      };\n      SAXStream.prototype.end = function (chunk) {\n          if (chunk && chunk.length) {\n              this.write(chunk);\n          }\n          this._parser.end();\n          return true;\n      };\n      SAXStream.prototype.on = function (ev, handler) {\n          var me = this;\n          if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n              me._parser[\"on\" + ev] = function () {\n                  var args = arguments.length === 1\n                      ? [arguments[0]]\n                      : Array.apply(null, arguments);\n                  args.splice(0, 0, ev);\n                  me.emit.apply(me, args);\n              };\n          }\n          return Stream.prototype.on.call(me, ev, handler);\n      };\n      // this really needs to be replaced with character classes.\n      // XML allows all manner of ridiculous numbers and digits.\n      var CDATA = \"[CDATA[\";\n      var DOCTYPE = \"DOCTYPE\";\n      var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n      var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n      // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n      // This implementation works on strings, a single character at a time\n      // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n      // without a significant breaking change to either this  parser, or the\n      // JavaScript language.  Implementation of an emoji-capable xml parser\n      // is left as an exercise for the reader.\n      var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n      var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n      var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n      var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n      function isWhitespace(c) {\n          return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n      }\n      function isQuote(c) {\n          return c === '\"' || c === \"'\";\n      }\n      function isAttribEnd(c) {\n          return c === \">\" || isWhitespace(c);\n      }\n      function isMatch(regex, c) {\n          return regex.test(c);\n      }\n      function notMatch(regex, c) {\n          return !isMatch(regex, c);\n      }\n      var S = 0;\n      sax.STATE = {\n          BEGIN: S++,\n          BEGIN_WHITESPACE: S++,\n          TEXT: S++,\n          TEXT_ENTITY: S++,\n          OPEN_WAKA: S++,\n          SGML_DECL: S++,\n          SGML_DECL_QUOTED: S++,\n          DOCTYPE: S++,\n          DOCTYPE_QUOTED: S++,\n          DOCTYPE_DTD: S++,\n          DOCTYPE_DTD_QUOTED: S++,\n          COMMENT_STARTING: S++,\n          COMMENT: S++,\n          COMMENT_ENDING: S++,\n          COMMENT_ENDED: S++,\n          CDATA: S++,\n          CDATA_ENDING: S++,\n          CDATA_ENDING_2: S++,\n          PROC_INST: S++,\n          PROC_INST_BODY: S++,\n          PROC_INST_ENDING: S++,\n          OPEN_TAG: S++,\n          OPEN_TAG_SLASH: S++,\n          ATTRIB: S++,\n          ATTRIB_NAME: S++,\n          ATTRIB_NAME_SAW_WHITE: S++,\n          ATTRIB_VALUE: S++,\n          ATTRIB_VALUE_QUOTED: S++,\n          ATTRIB_VALUE_CLOSED: S++,\n          ATTRIB_VALUE_UNQUOTED: S++,\n          ATTRIB_VALUE_ENTITY_Q: S++,\n          ATTRIB_VALUE_ENTITY_U: S++,\n          CLOSE_TAG: S++,\n          CLOSE_TAG_SAW_WHITE: S++,\n          SCRIPT: S++,\n          SCRIPT_ENDING: S++, // <script> ... <\n      };\n      sax.XML_ENTITIES = {\n          amp: \"&\",\n          gt: \">\",\n          lt: \"<\",\n          quot: '\"',\n          apos: \"'\",\n      };\n      sax.ENTITIES = {\n          amp: \"&\",\n          gt: \">\",\n          lt: \"<\",\n          quot: '\"',\n          apos: \"'\",\n          AElig: 198,\n          Aacute: 193,\n          Acirc: 194,\n          Agrave: 192,\n          Aring: 197,\n          Atilde: 195,\n          Auml: 196,\n          Ccedil: 199,\n          ETH: 208,\n          Eacute: 201,\n          Ecirc: 202,\n          Egrave: 200,\n          Euml: 203,\n          Iacute: 205,\n          Icirc: 206,\n          Igrave: 204,\n          Iuml: 207,\n          Ntilde: 209,\n          Oacute: 211,\n          Ocirc: 212,\n          Ograve: 210,\n          Oslash: 216,\n          Otilde: 213,\n          Ouml: 214,\n          THORN: 222,\n          Uacute: 218,\n          Ucirc: 219,\n          Ugrave: 217,\n          Uuml: 220,\n          Yacute: 221,\n          aacute: 225,\n          acirc: 226,\n          aelig: 230,\n          agrave: 224,\n          aring: 229,\n          atilde: 227,\n          auml: 228,\n          ccedil: 231,\n          eacute: 233,\n          ecirc: 234,\n          egrave: 232,\n          eth: 240,\n          euml: 235,\n          iacute: 237,\n          icirc: 238,\n          igrave: 236,\n          iuml: 239,\n          ntilde: 241,\n          oacute: 243,\n          ocirc: 244,\n          ograve: 242,\n          oslash: 248,\n          otilde: 245,\n          ouml: 246,\n          szlig: 223,\n          thorn: 254,\n          uacute: 250,\n          ucirc: 251,\n          ugrave: 249,\n          uuml: 252,\n          yacute: 253,\n          yuml: 255,\n          copy: 169,\n          reg: 174,\n          nbsp: 160,\n          iexcl: 161,\n          cent: 162,\n          pound: 163,\n          curren: 164,\n          yen: 165,\n          brvbar: 166,\n          sect: 167,\n          uml: 168,\n          ordf: 170,\n          laquo: 171,\n          not: 172,\n          shy: 173,\n          macr: 175,\n          deg: 176,\n          plusmn: 177,\n          sup1: 185,\n          sup2: 178,\n          sup3: 179,\n          acute: 180,\n          micro: 181,\n          para: 182,\n          middot: 183,\n          cedil: 184,\n          ordm: 186,\n          raquo: 187,\n          frac14: 188,\n          frac12: 189,\n          frac34: 190,\n          iquest: 191,\n          times: 215,\n          divide: 247,\n          OElig: 338,\n          oelig: 339,\n          Scaron: 352,\n          scaron: 353,\n          Yuml: 376,\n          fnof: 402,\n          circ: 710,\n          tilde: 732,\n          Alpha: 913,\n          Beta: 914,\n          Gamma: 915,\n          Delta: 916,\n          Epsilon: 917,\n          Zeta: 918,\n          Eta: 919,\n          Theta: 920,\n          Iota: 921,\n          Kappa: 922,\n          Lambda: 923,\n          Mu: 924,\n          Nu: 925,\n          Xi: 926,\n          Omicron: 927,\n          Pi: 928,\n          Rho: 929,\n          Sigma: 931,\n          Tau: 932,\n          Upsilon: 933,\n          Phi: 934,\n          Chi: 935,\n          Psi: 936,\n          Omega: 937,\n          alpha: 945,\n          beta: 946,\n          gamma: 947,\n          delta: 948,\n          epsilon: 949,\n          zeta: 950,\n          eta: 951,\n          theta: 952,\n          iota: 953,\n          kappa: 954,\n          lambda: 955,\n          mu: 956,\n          nu: 957,\n          xi: 958,\n          omicron: 959,\n          pi: 960,\n          rho: 961,\n          sigmaf: 962,\n          sigma: 963,\n          tau: 964,\n          upsilon: 965,\n          phi: 966,\n          chi: 967,\n          psi: 968,\n          omega: 969,\n          thetasym: 977,\n          upsih: 978,\n          piv: 982,\n          ensp: 8194,\n          emsp: 8195,\n          thinsp: 8201,\n          zwnj: 8204,\n          zwj: 8205,\n          lrm: 8206,\n          rlm: 8207,\n          ndash: 8211,\n          mdash: 8212,\n          lsquo: 8216,\n          rsquo: 8217,\n          sbquo: 8218,\n          ldquo: 8220,\n          rdquo: 8221,\n          bdquo: 8222,\n          dagger: 8224,\n          Dagger: 8225,\n          bull: 8226,\n          hellip: 8230,\n          permil: 8240,\n          prime: 8242,\n          Prime: 8243,\n          lsaquo: 8249,\n          rsaquo: 8250,\n          oline: 8254,\n          frasl: 8260,\n          euro: 8364,\n          image: 8465,\n          weierp: 8472,\n          real: 8476,\n          trade: 8482,\n          alefsym: 8501,\n          larr: 8592,\n          uarr: 8593,\n          rarr: 8594,\n          darr: 8595,\n          harr: 8596,\n          crarr: 8629,\n          lArr: 8656,\n          uArr: 8657,\n          rArr: 8658,\n          dArr: 8659,\n          hArr: 8660,\n          forall: 8704,\n          part: 8706,\n          exist: 8707,\n          empty: 8709,\n          nabla: 8711,\n          isin: 8712,\n          notin: 8713,\n          ni: 8715,\n          prod: 8719,\n          sum: 8721,\n          minus: 8722,\n          lowast: 8727,\n          radic: 8730,\n          prop: 8733,\n          infin: 8734,\n          ang: 8736,\n          and: 8743,\n          or: 8744,\n          cap: 8745,\n          cup: 8746,\n          int: 8747,\n          there4: 8756,\n          sim: 8764,\n          cong: 8773,\n          asymp: 8776,\n          ne: 8800,\n          equiv: 8801,\n          le: 8804,\n          ge: 8805,\n          sub: 8834,\n          sup: 8835,\n          nsub: 8836,\n          sube: 8838,\n          supe: 8839,\n          oplus: 8853,\n          otimes: 8855,\n          perp: 8869,\n          sdot: 8901,\n          lceil: 8968,\n          rceil: 8969,\n          lfloor: 8970,\n          rfloor: 8971,\n          lang: 9001,\n          rang: 9002,\n          loz: 9674,\n          spades: 9824,\n          clubs: 9827,\n          hearts: 9829,\n          diams: 9830,\n      };\n      Object.keys(sax.ENTITIES).forEach(function (key) {\n          var e = sax.ENTITIES[key];\n          var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n          sax.ENTITIES[key] = s;\n      });\n      for (var s in sax.STATE) {\n          sax.STATE[sax.STATE[s]] = s;\n      }\n      // shorthand\n      S = sax.STATE;\n      function emit(parser, event, data) {\n          parser[event] && parser[event](data);\n      }\n      function emitNode(parser, nodeType, data) {\n          if (parser.textNode)\n              closeText(parser);\n          emit(parser, nodeType, data);\n      }\n      function closeText(parser) {\n          parser.textNode = textopts(parser.opt, parser.textNode);\n          if (parser.textNode)\n              emit(parser, \"ontext\", parser.textNode);\n          parser.textNode = \"\";\n      }\n      function textopts(opt, text) {\n          if (opt.trim)\n              text = text.trim();\n          if (opt.normalize)\n              text = text.replace(/\\s+/g, \" \");\n          return text;\n      }\n      function error(parser, er) {\n          closeText(parser);\n          if (parser.trackPosition) {\n              er +=\n                  \"\\nLine: \" +\n                      parser.line +\n                      \"\\nColumn: \" +\n                      parser.column +\n                      \"\\nChar: \" +\n                      parser.c;\n          }\n          er = new Error(er);\n          parser.error = er;\n          emit(parser, \"onerror\", er);\n          return parser;\n      }\n      function end(parser) {\n          if (parser.sawRoot && !parser.closedRoot)\n              strictFail(parser, \"Unclosed root tag\");\n          if (parser.state !== S.BEGIN &&\n              parser.state !== S.BEGIN_WHITESPACE &&\n              parser.state !== S.TEXT) {\n              error(parser, \"Unexpected end\");\n          }\n          closeText(parser);\n          parser.c = \"\";\n          parser.closed = true;\n          emit(parser, \"onend\");\n          SAXParser.call(parser, parser.strict, parser.opt);\n          return parser;\n      }\n      function strictFail(parser, message) {\n          if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n              throw new Error(\"bad call to strictFail\");\n          }\n          if (parser.strict) {\n              error(parser, message);\n          }\n      }\n      function newTag(parser) {\n          if (!parser.strict)\n              parser.tagName = parser.tagName[parser.looseCase]();\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n          // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n          if (parser.opt.xmlns) {\n              tag.ns = parent.ns;\n          }\n          parser.attribList.length = 0;\n          emitNode(parser, \"onopentagstart\", tag);\n      }\n      function qname(name, attribute) {\n          var i = name.indexOf(\":\");\n          var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n          var prefix = qualName[0];\n          var local = qualName[1];\n          // <x \"xmlns\"=\"http://foo\">\n          if (attribute && name === \"xmlns\") {\n              prefix = \"xmlns\";\n              local = \"\";\n          }\n          return { prefix: prefix, local: local };\n      }\n      function attrib(parser) {\n          if (!parser.strict) {\n              parser.attribName = parser.attribName[parser.looseCase]();\n          }\n          if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n              parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n              parser.attribName = parser.attribValue = \"\";\n              return;\n          }\n          if (parser.opt.xmlns) {\n              var qn = qname(parser.attribName, true);\n              var prefix = qn.prefix;\n              var local = qn.local;\n              if (prefix === \"xmlns\") {\n                  // namespace binding attribute. push the binding into scope\n                  if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                      strictFail(parser, \"xml: prefix must be bound to \" +\n                          XML_NAMESPACE +\n                          \"\\n\" +\n                          \"Actual: \" +\n                          parser.attribValue);\n                  }\n                  else if (local === \"xmlns\" &&\n                      parser.attribValue !== XMLNS_NAMESPACE) {\n                      strictFail(parser, \"xmlns: prefix must be bound to \" +\n                          XMLNS_NAMESPACE +\n                          \"\\n\" +\n                          \"Actual: \" +\n                          parser.attribValue);\n                  }\n                  else {\n                      var tag = parser.tag;\n                      var parent = parser.tags[parser.tags.length - 1] || parser;\n                      if (tag.ns === parent.ns) {\n                          tag.ns = Object.create(parent.ns);\n                      }\n                      tag.ns[local] = parser.attribValue;\n                  }\n              }\n              // defer onattribute events until all attributes have been seen\n              // so any new bindings can take effect. preserve attribute order\n              // so deferred events can be emitted in document order\n              parser.attribList.push([parser.attribName, parser.attribValue]);\n          }\n          else {\n              // in non-xmlns mode, we can emit the event right away\n              parser.tag.attributes[parser.attribName] = parser.attribValue;\n              emitNode(parser, \"onattribute\", {\n                  name: parser.attribName,\n                  value: parser.attribValue,\n              });\n          }\n          parser.attribName = parser.attribValue = \"\";\n      }\n      function openTag(parser, selfClosing) {\n          if (parser.opt.xmlns) {\n              // emit namespace binding events\n              var tag = parser.tag;\n              // add namespace info to tag\n              var qn = qname(parser.tagName);\n              tag.prefix = qn.prefix;\n              tag.local = qn.local;\n              tag.uri = tag.ns[qn.prefix] || \"\";\n              if (tag.prefix && !tag.uri) {\n                  strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n                  tag.uri = qn.prefix;\n              }\n              var parent = parser.tags[parser.tags.length - 1] || parser;\n              if (tag.ns && parent.ns !== tag.ns) {\n                  Object.keys(tag.ns).forEach(function (p) {\n                      emitNode(parser, \"onopennamespace\", {\n                          prefix: p,\n                          uri: tag.ns[p],\n                      });\n                  });\n              }\n              // handle deferred onattribute events\n              // Note: do not apply default ns to attributes:\n              //   http://www.w3.org/TR/REC-xml-names/#defaulting\n              for (var i = 0, l = parser.attribList.length; i < l; i++) {\n                  var nv = parser.attribList[i];\n                  var name = nv[0];\n                  var value = nv[1];\n                  var qualName = qname(name, true);\n                  var prefix = qualName.prefix;\n                  var local = qualName.local;\n                  var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n                  var a = {\n                      name: name,\n                      value: value,\n                      prefix: prefix,\n                      local: local,\n                      uri: uri,\n                  };\n                  // if there's any attributes with an undefined namespace,\n                  // then fail on them now.\n                  if (prefix && prefix !== \"xmlns\" && !uri) {\n                      strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                      a.uri = prefix;\n                  }\n                  parser.tag.attributes[name] = a;\n                  emitNode(parser, \"onattribute\", a);\n              }\n              parser.attribList.length = 0;\n          }\n          parser.tag.isSelfClosing = !!selfClosing;\n          // process the tag\n          parser.sawRoot = true;\n          parser.tags.push(parser.tag);\n          emitNode(parser, \"onopentag\", parser.tag);\n          if (!selfClosing) {\n              // special case for <script> in non-strict mode.\n              if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n                  parser.state = S.SCRIPT;\n              }\n              else {\n                  parser.state = S.TEXT;\n              }\n              parser.tag = null;\n              parser.tagName = \"\";\n          }\n          parser.attribName = parser.attribValue = \"\";\n          parser.attribList.length = 0;\n      }\n      function closeTag(parser) {\n          if (!parser.tagName) {\n              strictFail(parser, \"Weird empty close tag.\");\n              parser.textNode += \"</>\";\n              parser.state = S.TEXT;\n              return;\n          }\n          if (parser.script) {\n              if (parser.tagName !== \"script\") {\n                  parser.script += \"</\" + parser.tagName + \">\";\n                  parser.tagName = \"\";\n                  parser.state = S.SCRIPT;\n                  return;\n              }\n              emitNode(parser, \"onscript\", parser.script);\n              parser.script = \"\";\n          }\n          // first make sure that the closing tag actually exists.\n          // <a><b></c></b></a> will close everything, otherwise.\n          var t = parser.tags.length;\n          var tagName = parser.tagName;\n          if (!parser.strict) {\n              tagName = tagName[parser.looseCase]();\n          }\n          var closeTo = tagName;\n          while (t--) {\n              var close = parser.tags[t];\n              if (close.name !== closeTo) {\n                  // fail the first time in strict mode\n                  strictFail(parser, \"Unexpected close tag\");\n              }\n              else {\n                  break;\n              }\n          }\n          // didn't find it.  we already failed for strict, so just abort.\n          if (t < 0) {\n              strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n              parser.textNode += \"</\" + parser.tagName + \">\";\n              parser.state = S.TEXT;\n              return;\n          }\n          parser.tagName = tagName;\n          var s = parser.tags.length;\n          while (s-- > t) {\n              var tag = (parser.tag = parser.tags.pop());\n              parser.tagName = parser.tag.name;\n              emitNode(parser, \"onclosetag\", parser.tagName);\n              var x = {};\n              for (var i in tag.ns) {\n                  x[i] = tag.ns[i];\n              }\n              var parent = parser.tags[parser.tags.length - 1] || parser;\n              if (parser.opt.xmlns && tag.ns !== parent.ns) {\n                  // remove namespace bindings introduced by tag\n                  Object.keys(tag.ns).forEach(function (p) {\n                      var n = tag.ns[p];\n                      emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n                  });\n              }\n          }\n          if (t === 0)\n              parser.closedRoot = true;\n          parser.tagName = parser.attribValue = parser.attribName = \"\";\n          parser.attribList.length = 0;\n          parser.state = S.TEXT;\n      }\n      function parseEntity(parser) {\n          var entity = parser.entity;\n          var entityLC = entity.toLowerCase();\n          var num;\n          var numStr = \"\";\n          if (parser.ENTITIES[entity]) {\n              return parser.ENTITIES[entity];\n          }\n          if (parser.ENTITIES[entityLC]) {\n              return parser.ENTITIES[entityLC];\n          }\n          entity = entityLC;\n          if (entity.charAt(0) === \"#\") {\n              if (entity.charAt(1) === \"x\") {\n                  entity = entity.slice(2);\n                  num = parseInt(entity, 16);\n                  numStr = num.toString(16);\n              }\n              else {\n                  entity = entity.slice(1);\n                  num = parseInt(entity, 10);\n                  numStr = num.toString(10);\n              }\n          }\n          entity = entity.replace(/^0+/, \"\");\n          if (isNaN(num) || numStr.toLowerCase() !== entity) {\n              strictFail(parser, \"Invalid character entity\");\n              return \"&\" + parser.entity + \";\";\n          }\n          return String.fromCodePoint(num);\n      }\n      function beginWhiteSpace(parser, c) {\n          if (c === \"<\") {\n              parser.state = S.OPEN_WAKA;\n              parser.startTagPosition = parser.position;\n          }\n          else if (!isWhitespace(c)) {\n              // have to process this as a text node.\n              // weird, but happens.\n              strictFail(parser, \"Non-whitespace before first tag.\");\n              parser.textNode = c;\n              parser.state = S.TEXT;\n          }\n      }\n      function charAt(chunk, i) {\n          var result = \"\";\n          if (i < chunk.length) {\n              result = chunk.charAt(i);\n          }\n          return result;\n      }\n      function write(chunk) {\n          var parser = this;\n          if (this.error) {\n              throw this.error;\n          }\n          if (parser.closed) {\n              return error(parser, \"Cannot write after close. Assign an onready handler.\");\n          }\n          if (chunk === null) {\n              return end(parser);\n          }\n          if (typeof chunk === \"object\") {\n              chunk = chunk.toString();\n          }\n          var i = 0;\n          var c = \"\";\n          while (true) {\n              c = charAt(chunk, i++);\n              parser.c = c;\n              if (!c) {\n                  break;\n              }\n              if (parser.trackPosition) {\n                  parser.position++;\n                  if (c === \"\\n\") {\n                      parser.line++;\n                      parser.column = 0;\n                  }\n                  else {\n                      parser.column++;\n                  }\n              }\n              switch (parser.state) {\n                  case S.BEGIN:\n                      parser.state = S.BEGIN_WHITESPACE;\n                      if (c === \"\\uFEFF\") {\n                          continue;\n                      }\n                      beginWhiteSpace(parser, c);\n                      continue;\n                  case S.BEGIN_WHITESPACE:\n                      beginWhiteSpace(parser, c);\n                      continue;\n                  case S.TEXT:\n                      if (parser.sawRoot && !parser.closedRoot) {\n                          var starti = i - 1;\n                          while (c && c !== \"<\" && c !== \"&\") {\n                              c = charAt(chunk, i++);\n                              if (c && parser.trackPosition) {\n                                  parser.position++;\n                                  if (c === \"\\n\") {\n                                      parser.line++;\n                                      parser.column = 0;\n                                  }\n                                  else {\n                                      parser.column++;\n                                  }\n                              }\n                          }\n                          parser.textNode += chunk.substring(starti, i - 1);\n                      }\n                      if (c === \"<\" &&\n                          !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                          parser.state = S.OPEN_WAKA;\n                          parser.startTagPosition = parser.position;\n                      }\n                      else {\n                          if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                              strictFail(parser, \"Text data outside of root node.\");\n                          }\n                          if (c === \"&\") {\n                              parser.state = S.TEXT_ENTITY;\n                          }\n                          else {\n                              parser.textNode += c;\n                          }\n                      }\n                      continue;\n                  case S.SCRIPT:\n                      // only non-strict\n                      if (c === \"<\") {\n                          parser.state = S.SCRIPT_ENDING;\n                      }\n                      else {\n                          parser.script += c;\n                      }\n                      continue;\n                  case S.SCRIPT_ENDING:\n                      if (c === \"/\") {\n                          parser.state = S.CLOSE_TAG;\n                      }\n                      else {\n                          parser.script += \"<\" + c;\n                          parser.state = S.SCRIPT;\n                      }\n                      continue;\n                  case S.OPEN_WAKA:\n                      // either a /, ?, !, or text is coming next.\n                      if (c === \"!\") {\n                          parser.state = S.SGML_DECL;\n                          parser.sgmlDecl = \"\";\n                      }\n                      else if (isWhitespace(c)) ;\n                      else if (isMatch(nameStart, c)) {\n                          parser.state = S.OPEN_TAG;\n                          parser.tagName = c;\n                      }\n                      else if (c === \"/\") {\n                          parser.state = S.CLOSE_TAG;\n                          parser.tagName = \"\";\n                      }\n                      else if (c === \"?\") {\n                          parser.state = S.PROC_INST;\n                          parser.procInstName = parser.procInstBody = \"\";\n                      }\n                      else {\n                          strictFail(parser, \"Unencoded <\");\n                          // if there was some whitespace, then add that in.\n                          if (parser.startTagPosition + 1 < parser.position) {\n                              var pad = parser.position - parser.startTagPosition;\n                              c = new Array(pad).join(\" \") + c;\n                          }\n                          parser.textNode += \"<\" + c;\n                          parser.state = S.TEXT;\n                      }\n                      continue;\n                  case S.SGML_DECL:\n                      if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                          emitNode(parser, \"onopencdata\");\n                          parser.state = S.CDATA;\n                          parser.sgmlDecl = \"\";\n                          parser.cdata = \"\";\n                      }\n                      else if (parser.sgmlDecl + c === \"--\") {\n                          parser.state = S.COMMENT;\n                          parser.comment = \"\";\n                          parser.sgmlDecl = \"\";\n                      }\n                      else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                          parser.state = S.DOCTYPE;\n                          if (parser.doctype || parser.sawRoot) {\n                              strictFail(parser, \"Inappropriately located doctype declaration\");\n                          }\n                          parser.doctype = \"\";\n                          parser.sgmlDecl = \"\";\n                      }\n                      else if (c === \">\") {\n                          emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                          parser.sgmlDecl = \"\";\n                          parser.state = S.TEXT;\n                      }\n                      else if (isQuote(c)) {\n                          parser.state = S.SGML_DECL_QUOTED;\n                          parser.sgmlDecl += c;\n                      }\n                      else {\n                          parser.sgmlDecl += c;\n                      }\n                      continue;\n                  case S.SGML_DECL_QUOTED:\n                      if (c === parser.q) {\n                          parser.state = S.SGML_DECL;\n                          parser.q = \"\";\n                      }\n                      parser.sgmlDecl += c;\n                      continue;\n                  case S.DOCTYPE:\n                      if (c === \">\") {\n                          parser.state = S.TEXT;\n                          emitNode(parser, \"ondoctype\", parser.doctype);\n                          parser.doctype = true; // just remember that we saw it.\n                      }\n                      else {\n                          parser.doctype += c;\n                          if (c === \"[\") {\n                              parser.state = S.DOCTYPE_DTD;\n                          }\n                          else if (isQuote(c)) {\n                              parser.state = S.DOCTYPE_QUOTED;\n                              parser.q = c;\n                          }\n                      }\n                      continue;\n                  case S.DOCTYPE_QUOTED:\n                      parser.doctype += c;\n                      if (c === parser.q) {\n                          parser.q = \"\";\n                          parser.state = S.DOCTYPE;\n                      }\n                      continue;\n                  case S.DOCTYPE_DTD:\n                      parser.doctype += c;\n                      if (c === \"]\") {\n                          parser.state = S.DOCTYPE;\n                      }\n                      else if (isQuote(c)) {\n                          parser.state = S.DOCTYPE_DTD_QUOTED;\n                          parser.q = c;\n                      }\n                      continue;\n                  case S.DOCTYPE_DTD_QUOTED:\n                      parser.doctype += c;\n                      if (c === parser.q) {\n                          parser.state = S.DOCTYPE_DTD;\n                          parser.q = \"\";\n                      }\n                      continue;\n                  case S.COMMENT:\n                      if (c === \"-\") {\n                          parser.state = S.COMMENT_ENDING;\n                      }\n                      else {\n                          parser.comment += c;\n                      }\n                      continue;\n                  case S.COMMENT_ENDING:\n                      if (c === \"-\") {\n                          parser.state = S.COMMENT_ENDED;\n                          parser.comment = textopts(parser.opt, parser.comment);\n                          if (parser.comment) {\n                              emitNode(parser, \"oncomment\", parser.comment);\n                          }\n                          parser.comment = \"\";\n                      }\n                      else {\n                          parser.comment += \"-\" + c;\n                          parser.state = S.COMMENT;\n                      }\n                      continue;\n                  case S.COMMENT_ENDED:\n                      if (c !== \">\") {\n                          strictFail(parser, \"Malformed comment\");\n                          // allow <!-- blah -- bloo --> in non-strict mode,\n                          // which is a comment of \" blah -- bloo \"\n                          parser.comment += \"--\" + c;\n                          parser.state = S.COMMENT;\n                      }\n                      else {\n                          parser.state = S.TEXT;\n                      }\n                      continue;\n                  case S.CDATA:\n                      if (c === \"]\") {\n                          parser.state = S.CDATA_ENDING;\n                      }\n                      else {\n                          parser.cdata += c;\n                      }\n                      continue;\n                  case S.CDATA_ENDING:\n                      if (c === \"]\") {\n                          parser.state = S.CDATA_ENDING_2;\n                      }\n                      else {\n                          parser.cdata += \"]\" + c;\n                          parser.state = S.CDATA;\n                      }\n                      continue;\n                  case S.CDATA_ENDING_2:\n                      if (c === \">\") {\n                          if (parser.cdata) {\n                              emitNode(parser, \"oncdata\", parser.cdata);\n                          }\n                          emitNode(parser, \"onclosecdata\");\n                          parser.cdata = \"\";\n                          parser.state = S.TEXT;\n                      }\n                      else if (c === \"]\") {\n                          parser.cdata += \"]\";\n                      }\n                      else {\n                          parser.cdata += \"]]\" + c;\n                          parser.state = S.CDATA;\n                      }\n                      continue;\n                  case S.PROC_INST:\n                      if (c === \"?\") {\n                          parser.state = S.PROC_INST_ENDING;\n                      }\n                      else if (isWhitespace(c)) {\n                          parser.state = S.PROC_INST_BODY;\n                      }\n                      else {\n                          parser.procInstName += c;\n                      }\n                      continue;\n                  case S.PROC_INST_BODY:\n                      if (!parser.procInstBody && isWhitespace(c)) {\n                          continue;\n                      }\n                      else if (c === \"?\") {\n                          parser.state = S.PROC_INST_ENDING;\n                      }\n                      else {\n                          parser.procInstBody += c;\n                      }\n                      continue;\n                  case S.PROC_INST_ENDING:\n                      if (c === \">\") {\n                          emitNode(parser, \"onprocessinginstruction\", {\n                              name: parser.procInstName,\n                              body: parser.procInstBody,\n                          });\n                          parser.procInstName = parser.procInstBody = \"\";\n                          parser.state = S.TEXT;\n                      }\n                      else {\n                          parser.procInstBody += \"?\" + c;\n                          parser.state = S.PROC_INST_BODY;\n                      }\n                      continue;\n                  case S.OPEN_TAG:\n                      if (isMatch(nameBody, c)) {\n                          parser.tagName += c;\n                      }\n                      else {\n                          newTag(parser);\n                          if (c === \">\") {\n                              openTag(parser);\n                          }\n                          else if (c === \"/\") {\n                              parser.state = S.OPEN_TAG_SLASH;\n                          }\n                          else {\n                              if (!isWhitespace(c)) {\n                                  strictFail(parser, \"Invalid character in tag name\");\n                              }\n                              parser.state = S.ATTRIB;\n                          }\n                      }\n                      continue;\n                  case S.OPEN_TAG_SLASH:\n                      if (c === \">\") {\n                          openTag(parser, true);\n                          closeTag(parser);\n                      }\n                      else {\n                          strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                          parser.state = S.ATTRIB;\n                      }\n                      continue;\n                  case S.ATTRIB:\n                      // haven't read the attribute name yet.\n                      if (isWhitespace(c)) {\n                          continue;\n                      }\n                      else if (c === \">\") {\n                          openTag(parser);\n                      }\n                      else if (c === \"/\") {\n                          parser.state = S.OPEN_TAG_SLASH;\n                      }\n                      else if (isMatch(nameStart, c)) {\n                          parser.attribName = c;\n                          parser.attribValue = \"\";\n                          parser.state = S.ATTRIB_NAME;\n                      }\n                      else {\n                          strictFail(parser, \"Invalid attribute name\");\n                      }\n                      continue;\n                  case S.ATTRIB_NAME:\n                      if (c === \"=\") {\n                          parser.state = S.ATTRIB_VALUE;\n                      }\n                      else if (c === \">\") {\n                          strictFail(parser, \"Attribute without value\");\n                          parser.attribValue = parser.attribName;\n                          attrib(parser);\n                          openTag(parser);\n                      }\n                      else if (isWhitespace(c)) {\n                          parser.state = S.ATTRIB_NAME_SAW_WHITE;\n                      }\n                      else if (isMatch(nameBody, c)) {\n                          parser.attribName += c;\n                      }\n                      else {\n                          strictFail(parser, \"Invalid attribute name\");\n                      }\n                      continue;\n                  case S.ATTRIB_NAME_SAW_WHITE:\n                      if (c === \"=\") {\n                          parser.state = S.ATTRIB_VALUE;\n                      }\n                      else if (isWhitespace(c)) {\n                          continue;\n                      }\n                      else {\n                          strictFail(parser, \"Attribute without value\");\n                          parser.tag.attributes[parser.attribName] = \"\";\n                          parser.attribValue = \"\";\n                          emitNode(parser, \"onattribute\", {\n                              name: parser.attribName,\n                              value: \"\",\n                          });\n                          parser.attribName = \"\";\n                          if (c === \">\") {\n                              openTag(parser);\n                          }\n                          else if (isMatch(nameStart, c)) {\n                              parser.attribName = c;\n                              parser.state = S.ATTRIB_NAME;\n                          }\n                          else {\n                              strictFail(parser, \"Invalid attribute name\");\n                              parser.state = S.ATTRIB;\n                          }\n                      }\n                      continue;\n                  case S.ATTRIB_VALUE:\n                      if (isWhitespace(c)) {\n                          continue;\n                      }\n                      else if (isQuote(c)) {\n                          parser.q = c;\n                          parser.state = S.ATTRIB_VALUE_QUOTED;\n                      }\n                      else {\n                          strictFail(parser, \"Unquoted attribute value\");\n                          parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                          parser.attribValue = c;\n                      }\n                      continue;\n                  case S.ATTRIB_VALUE_QUOTED:\n                      if (c !== parser.q) {\n                          if (c === \"&\") {\n                              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                          }\n                          else {\n                              parser.attribValue += c;\n                          }\n                          continue;\n                      }\n                      attrib(parser);\n                      parser.q = \"\";\n                      parser.state = S.ATTRIB_VALUE_CLOSED;\n                      continue;\n                  case S.ATTRIB_VALUE_CLOSED:\n                      if (isWhitespace(c)) {\n                          parser.state = S.ATTRIB;\n                      }\n                      else if (c === \">\") {\n                          openTag(parser);\n                      }\n                      else if (c === \"/\") {\n                          parser.state = S.OPEN_TAG_SLASH;\n                      }\n                      else if (isMatch(nameStart, c)) {\n                          strictFail(parser, \"No whitespace between attributes\");\n                          parser.attribName = c;\n                          parser.attribValue = \"\";\n                          parser.state = S.ATTRIB_NAME;\n                      }\n                      else {\n                          strictFail(parser, \"Invalid attribute name\");\n                      }\n                      continue;\n                  case S.ATTRIB_VALUE_UNQUOTED:\n                      if (!isAttribEnd(c)) {\n                          if (c === \"&\") {\n                              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                          }\n                          else {\n                              parser.attribValue += c;\n                          }\n                          continue;\n                      }\n                      attrib(parser);\n                      if (c === \">\") {\n                          openTag(parser);\n                      }\n                      else {\n                          parser.state = S.ATTRIB;\n                      }\n                      continue;\n                  case S.CLOSE_TAG:\n                      if (!parser.tagName) {\n                          if (isWhitespace(c)) {\n                              continue;\n                          }\n                          else if (notMatch(nameStart, c)) {\n                              if (parser.script) {\n                                  parser.script += \"</\" + c;\n                                  parser.state = S.SCRIPT;\n                              }\n                              else {\n                                  strictFail(parser, \"Invalid tagname in closing tag.\");\n                              }\n                          }\n                          else {\n                              parser.tagName = c;\n                          }\n                      }\n                      else if (c === \">\") {\n                          closeTag(parser);\n                      }\n                      else if (isMatch(nameBody, c)) {\n                          parser.tagName += c;\n                      }\n                      else if (parser.script) {\n                          parser.script += \"</\" + parser.tagName;\n                          parser.tagName = \"\";\n                          parser.state = S.SCRIPT;\n                      }\n                      else {\n                          if (!isWhitespace(c)) {\n                              strictFail(parser, \"Invalid tagname in closing tag\");\n                          }\n                          parser.state = S.CLOSE_TAG_SAW_WHITE;\n                      }\n                      continue;\n                  case S.CLOSE_TAG_SAW_WHITE:\n                      if (isWhitespace(c)) {\n                          continue;\n                      }\n                      if (c === \">\") {\n                          closeTag(parser);\n                      }\n                      else {\n                          strictFail(parser, \"Invalid characters in closing tag\");\n                      }\n                      continue;\n                  case S.TEXT_ENTITY:\n                  case S.ATTRIB_VALUE_ENTITY_Q:\n                  case S.ATTRIB_VALUE_ENTITY_U:\n                      var returnState;\n                      var buffer;\n                      switch (parser.state) {\n                          case S.TEXT_ENTITY:\n                              returnState = S.TEXT;\n                              buffer = \"textNode\";\n                              break;\n                          case S.ATTRIB_VALUE_ENTITY_Q:\n                              returnState = S.ATTRIB_VALUE_QUOTED;\n                              buffer = \"attribValue\";\n                              break;\n                          case S.ATTRIB_VALUE_ENTITY_U:\n                              returnState = S.ATTRIB_VALUE_UNQUOTED;\n                              buffer = \"attribValue\";\n                              break;\n                      }\n                      if (c === \";\") {\n                          if (parser.opt.unparsedEntities) {\n                              var parsedEntity = parseEntity(parser);\n                              parser.entity = \"\";\n                              parser.state = returnState;\n                              parser.write(parsedEntity);\n                          }\n                          else {\n                              parser[buffer] += parseEntity(parser);\n                              parser.entity = \"\";\n                              parser.state = returnState;\n                          }\n                      }\n                      else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n                          parser.entity += c;\n                      }\n                      else {\n                          strictFail(parser, \"Invalid character in entity name\");\n                          parser[buffer] += \"&\" + parser.entity + c;\n                          parser.entity = \"\";\n                          parser.state = returnState;\n                      }\n                      continue;\n                  default: /* istanbul ignore next */ {\n                      throw new Error(parser, \"Unknown state: \" + parser.state);\n                  }\n              }\n          } // while\n          if (parser.position >= parser.bufferCheckPosition) {\n              checkBufferLength(parser);\n          }\n          return parser;\n      }\n      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n      /* istanbul ignore next */\n      if (!String.fromCodePoint) {\n          (function () {\n              var stringFromCharCode = String.fromCharCode;\n              var floor = Math.floor;\n              var fromCodePoint = function () {\n                  var MAX_SIZE = 0x4000;\n                  var codeUnits = [];\n                  var highSurrogate;\n                  var lowSurrogate;\n                  var index = -1;\n                  var length = arguments.length;\n                  if (!length) {\n                      return \"\";\n                  }\n                  var result = \"\";\n                  while (++index < length) {\n                      var codePoint = Number(arguments[index]);\n                      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                          codePoint < 0 || // not a valid Unicode code point\n                          codePoint > 0x10ffff || // not a valid Unicode code point\n                          floor(codePoint) !== codePoint // not an integer\n                      ) {\n                          throw RangeError(\"Invalid code point: \" + codePoint);\n                      }\n                      if (codePoint <= 0xffff) {\n                          // BMP code point\n                          codeUnits.push(codePoint);\n                      }\n                      else {\n                          // Astral code point; split in surrogate halves\n                          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                          codePoint -= 0x10000;\n                          highSurrogate = (codePoint >> 10) + 0xd800;\n                          lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                          codeUnits.push(highSurrogate, lowSurrogate);\n                      }\n                      if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                          result += stringFromCharCode.apply(null, codeUnits);\n                          codeUnits.length = 0;\n                      }\n                  }\n                  return result;\n              };\n              /* istanbul ignore next */\n              if (Object.defineProperty) {\n                  Object.defineProperty(String, \"fromCodePoint\", {\n                      value: fromCodePoint,\n                      configurable: true,\n                      writable: true,\n                  });\n              }\n              else {\n                  String.fromCodePoint = fromCodePoint;\n              }\n          })();\n      }\n      return sax;\n  };\n  const sax = /** #__PURE__ */ initializeSax();\n  sax$1.sax = sax;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.parseXMLMarkdown = exports.XMLOutputParser = exports.XML_FORMAT_INSTRUCTIONS = void 0;\n  \tconst transform_js_1 = transform;\n  \tconst json_patch_js_1 = json_patch;\n  \tconst sax_js_1 = sax$1;\n  \texports.XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\n  \tclass XMLOutputParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n  \t    constructor(fields) {\n  \t        super(fields);\n  \t        Object.defineProperty(this, \"tags\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"lc_namespace\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: [\"langchain_core\", \"output_parsers\"]\n  \t        });\n  \t        Object.defineProperty(this, \"lc_serializable\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: true\n  \t        });\n  \t        this.tags = fields?.tags;\n  \t    }\n  \t    static lc_name() {\n  \t        return \"XMLOutputParser\";\n  \t    }\n  \t    _diff(prev, next) {\n  \t        if (!next) {\n  \t            return undefined;\n  \t        }\n  \t        if (!prev) {\n  \t            return [{ op: \"replace\", path: \"\", value: next }];\n  \t        }\n  \t        return (0, json_patch_js_1.compare)(prev, next);\n  \t    }\n  \t    async parsePartialResult(generations) {\n  \t        return parseXMLMarkdown(generations[0].text);\n  \t    }\n  \t    async parse(text) {\n  \t        return parseXMLMarkdown(text);\n  \t    }\n  \t    getFormatInstructions() {\n  \t        const withTags = !!(this.tags && this.tags.length > 0);\n  \t        return withTags\n  \t            ? exports.XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n  \t            : exports.XML_FORMAT_INSTRUCTIONS;\n  \t    }\n  \t}\n  \texports.XMLOutputParser = XMLOutputParser;\n  \tconst strip = (text) => text\n  \t    .split(\"\\n\")\n  \t    .map((line) => line.replace(/^\\s+/, \"\"))\n  \t    .join(\"\\n\")\n  \t    .trim();\n  \tconst parseParsedResult = (input) => {\n  \t    if (Object.keys(input).length === 0) {\n  \t        return {};\n  \t    }\n  \t    const result = {};\n  \t    if (input.children.length > 0) {\n  \t        result[input.name] = input.children.map(parseParsedResult);\n  \t        return result;\n  \t    }\n  \t    else {\n  \t        result[input.name] = input.text ?? undefined;\n  \t        return result;\n  \t    }\n  \t};\n  \tfunction parseXMLMarkdown(s) {\n  \t    const cleanedString = strip(s);\n  \t    const parser = sax_js_1.sax.parser(true);\n  \t    let parsedResult = {};\n  \t    const elementStack = [];\n  \t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t    parser.onopentag = (node) => {\n  \t        const element = {\n  \t            name: node.name,\n  \t            attributes: node.attributes,\n  \t            children: [],\n  \t            text: \"\",\n  \t            isSelfClosing: node.isSelfClosing,\n  \t        };\n  \t        if (elementStack.length > 0) {\n  \t            const parentElement = elementStack[elementStack.length - 1];\n  \t            parentElement.children.push(element);\n  \t        }\n  \t        else {\n  \t            parsedResult = element;\n  \t        }\n  \t        if (!node.isSelfClosing) {\n  \t            elementStack.push(element);\n  \t        }\n  \t    };\n  \t    parser.onclosetag = () => {\n  \t        if (elementStack.length > 0) {\n  \t            const lastElement = elementStack.pop();\n  \t            if (elementStack.length === 0 && lastElement) {\n  \t                parsedResult = lastElement;\n  \t            }\n  \t        }\n  \t    };\n  \t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t    parser.ontext = (text) => {\n  \t        if (elementStack.length > 0) {\n  \t            const currentElement = elementStack[elementStack.length - 1];\n  \t            currentElement.text += text;\n  \t        }\n  \t    };\n  \t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t    parser.onattribute = (attr) => {\n  \t        if (elementStack.length > 0) {\n  \t            const currentElement = elementStack[elementStack.length - 1];\n  \t            currentElement.attributes[attr.name] = attr.value;\n  \t        }\n  \t    };\n  \t    // Try to find XML string within triple backticks.\n  \t    const match = /```(xml)?(.*)```/s.exec(cleanedString);\n  \t    const xmlString = match ? match[2] : cleanedString;\n  \t    parser.write(xmlString).close();\n  \t    // Remove the XML declaration if present\n  \t    if (parsedResult && parsedResult.name === \"?xml\") {\n  \t        parsedResult = parsedResult.children[0];\n  \t    }\n  \t    return parseParsedResult(parsedResult);\n  \t}\n  \texports.parseXMLMarkdown = parseXMLMarkdown; \n  } (xml));\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t__exportStar(base, exports);\n  \t__exportStar(bytes, exports);\n  \t__exportStar(list, exports);\n  \t__exportStar(string$1, exports);\n  \t__exportStar(structured, exports);\n  \t__exportStar(transform, exports);\n  \t__exportStar(json, exports);\n  \t__exportStar(xml, exports); \n  } (output_parsers$1));\n\n  var output_parsers = output_parsers$1;\n\n  var openai_tools$1 = {};\n\n  var json_output_tools_parsers = {};\n\n  Object.defineProperty(json_output_tools_parsers, \"__esModule\", { value: true });\n  json_output_tools_parsers.JsonOutputKeyToolsParser = json_output_tools_parsers.JsonOutputToolsParser = json_output_tools_parsers.makeInvalidToolCall = json_output_tools_parsers.convertLangChainToolCallToOpenAI = json_output_tools_parsers.parseToolCall = void 0;\n  const base_js_1$2 = base;\n  const json_js_1 = json;\n  const transform_js_1 = transform;\n  const ai_js_1 = messages$1.ai;\n  function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall, options) {\n      if (rawToolCall.function === undefined) {\n          return undefined;\n      }\n      let functionArgs;\n      if (options?.partial) {\n          try {\n              functionArgs = (0, json_js_1.parsePartialJson)(rawToolCall.function.arguments ?? \"{}\");\n          }\n          catch (e) {\n              return undefined;\n          }\n      }\n      else {\n          try {\n              functionArgs = JSON.parse(rawToolCall.function.arguments);\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          }\n          catch (e) {\n              throw new base_js_1$2.OutputParserException([\n                  `Function \"${rawToolCall.function.name}\" arguments:`,\n                  ``,\n                  rawToolCall.function.arguments,\n                  ``,\n                  `are not valid JSON.`,\n                  `Error: ${e.message}`,\n              ].join(\"\\n\"));\n          }\n      }\n      const parsedToolCall = {\n          name: rawToolCall.function.name,\n          args: functionArgs,\n          type: \"tool_call\",\n      };\n      if (options?.returnId) {\n          parsedToolCall.id = rawToolCall.id;\n      }\n      return parsedToolCall;\n  }\n  json_output_tools_parsers.parseToolCall = parseToolCall;\n  function convertLangChainToolCallToOpenAI(toolCall) {\n      if (toolCall.id === undefined) {\n          throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n      }\n      return {\n          id: toolCall.id,\n          type: \"function\",\n          function: {\n              name: toolCall.name,\n              arguments: JSON.stringify(toolCall.args),\n          },\n      };\n  }\n  json_output_tools_parsers.convertLangChainToolCallToOpenAI = convertLangChainToolCallToOpenAI;\n  function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall, errorMsg) {\n      return {\n          name: rawToolCall.function?.name,\n          args: rawToolCall.function?.arguments,\n          id: rawToolCall.id,\n          error: errorMsg,\n          type: \"invalid_tool_call\",\n      };\n  }\n  json_output_tools_parsers.makeInvalidToolCall = makeInvalidToolCall;\n  /**\n   * Class for parsing the output of a tool-calling LLM into a JSON object.\n   */\n  class JsonOutputToolsParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n      static lc_name() {\n          return \"JsonOutputToolsParser\";\n      }\n      constructor(fields) {\n          super(fields);\n          Object.defineProperty(this, \"returnId\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: false\n          });\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          this.returnId = fields?.returnId ?? this.returnId;\n      }\n      _diff() {\n          throw new Error(\"Not supported.\");\n      }\n      async parse() {\n          throw new Error(\"Not implemented.\");\n      }\n      async parseResult(generations) {\n          const result = await this.parsePartialResult(generations, false);\n          return result;\n      }\n      /**\n       * Parses the output and returns a JSON object. If `argsOnly` is true,\n       * only the arguments of the function call are returned.\n       * @param generations The output of the LLM to parse.\n       * @returns A JSON object representation of the function call or its arguments.\n       */\n      async parsePartialResult(generations, partial = true\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ) {\n          const message = generations[0].message;\n          let toolCalls;\n          if ((0, ai_js_1.isAIMessage)(message) && message.tool_calls?.length) {\n              toolCalls = message.tool_calls.map((toolCall) => {\n                  const { id, ...rest } = toolCall;\n                  if (!this.returnId) {\n                      return rest;\n                  }\n                  return {\n                      id,\n                      ...rest,\n                  };\n              });\n          }\n          else if (message.additional_kwargs.tool_calls !== undefined) {\n              const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));\n              toolCalls = rawToolCalls.map((rawToolCall) => {\n                  return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n              });\n          }\n          if (!toolCalls) {\n              return [];\n          }\n          const parsedToolCalls = [];\n          for (const toolCall of toolCalls) {\n              if (toolCall !== undefined) {\n                  const backwardsCompatibleToolCall = {\n                      type: toolCall.name,\n                      args: toolCall.args,\n                      id: toolCall.id,\n                  };\n                  parsedToolCalls.push(backwardsCompatibleToolCall);\n              }\n          }\n          return parsedToolCalls;\n      }\n  }\n  json_output_tools_parsers.JsonOutputToolsParser = JsonOutputToolsParser;\n  /**\n   * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n   * expecting only a single tool to be called.\n   */\n  class JsonOutputKeyToolsParser extends JsonOutputToolsParser {\n      static lc_name() {\n          return \"JsonOutputKeyToolsParser\";\n      }\n      constructor(params) {\n          super(params);\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n          });\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"returnId\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: false\n          });\n          /** The type of tool calls to return. */\n          Object.defineProperty(this, \"keyName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          /** Whether to return only the first tool call. */\n          Object.defineProperty(this, \"returnSingle\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: false\n          });\n          Object.defineProperty(this, \"zodSchema\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.keyName = params.keyName;\n          this.returnSingle = params.returnSingle ?? this.returnSingle;\n          this.zodSchema = params.zodSchema;\n      }\n      async _validateResult(result) {\n          if (this.zodSchema === undefined) {\n              return result;\n          }\n          const zodParsedResult = await this.zodSchema.safeParseAsync(result);\n          if (zodParsedResult.success) {\n              return zodParsedResult.data;\n          }\n          else {\n              throw new base_js_1$2.OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));\n          }\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      async parsePartialResult(generations) {\n          const results = await super.parsePartialResult(generations);\n          const matchingResults = results.filter((result) => result.type === this.keyName);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          let returnedValues = matchingResults;\n          if (!matchingResults.length) {\n              return undefined;\n          }\n          if (!this.returnId) {\n              returnedValues = matchingResults.map((result) => result.args);\n          }\n          if (this.returnSingle) {\n              return returnedValues[0];\n          }\n          return returnedValues;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      async parseResult(generations) {\n          const results = await super.parsePartialResult(generations, false);\n          const matchingResults = results.filter((result) => result.type === this.keyName);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          let returnedValues = matchingResults;\n          if (!matchingResults.length) {\n              return undefined;\n          }\n          if (!this.returnId) {\n              returnedValues = matchingResults.map((result) => result.args);\n          }\n          if (this.returnSingle) {\n              return this._validateResult(returnedValues[0]);\n          }\n          const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));\n          return toolCallResults;\n      }\n  }\n  json_output_tools_parsers.JsonOutputKeyToolsParser = JsonOutputKeyToolsParser;\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t__exportStar(json_output_tools_parsers, exports); \n  } (openai_tools$1));\n\n  var openai_tools = openai_tools$1;\n\n  var zod = {};\n\n  var zodToJsonSchema$3 = {};\n\n  var Options = {};\n\n  Object.defineProperty(Options, \"__esModule\", { value: true });\n  Options.getDefaultOptions = Options.ignoreOverride = void 0;\n  Options.ignoreOverride = Symbol('Let zodToJsonSchema decide on which parser to use');\n  const defaultOptions = {\n      name: undefined,\n      $refStrategy: 'root',\n      effectStrategy: 'input',\n      pipeStrategy: 'all',\n      dateStrategy: 'format:date-time',\n      mapStrategy: 'entries',\n      nullableStrategy: 'from-target',\n      removeAdditionalStrategy: 'passthrough',\n      definitionPath: 'definitions',\n      target: 'jsonSchema7',\n      strictUnions: false,\n      errorMessages: false,\n      markdownDescription: false,\n      patternStrategy: 'escape',\n      applyRegexFlags: false,\n      emailStrategy: 'format:email',\n      base64Strategy: 'contentEncoding:base64',\n      nameStrategy: 'ref',\n  };\n  const getDefaultOptions = (options) => {\n      // We need to add `definitions` here as we may mutate it\n      return (typeof options === 'string' ?\n          {\n              ...defaultOptions,\n              basePath: ['#'],\n              definitions: {},\n              name: options,\n          }\n          : {\n              ...defaultOptions,\n              basePath: ['#'],\n              definitions: {},\n              ...options,\n          });\n  };\n  Options.getDefaultOptions = getDefaultOptions;\n\n  var Refs = {};\n\n  var util = {};\n\n  Object.defineProperty(util, \"__esModule\", { value: true });\n  util.isEmptyObj = util.zodDef = void 0;\n  const zodDef = (zodSchema) => {\n      return '_def' in zodSchema ? zodSchema._def : zodSchema;\n  };\n  util.zodDef = zodDef;\n  function isEmptyObj(obj) {\n      if (!obj)\n          return true;\n      for (const _k in obj)\n          return false;\n      return true;\n  }\n  util.isEmptyObj = isEmptyObj;\n\n  Object.defineProperty(Refs, \"__esModule\", { value: true });\n  Refs.getRefs = void 0;\n  const Options_1 = Options;\n  const util_1$1 = util;\n  const getRefs = (options) => {\n      const _options = (0, Options_1.getDefaultOptions)(options);\n      const currentPath = _options.name !== undefined ?\n          [..._options.basePath, _options.definitionPath, _options.name]\n          : _options.basePath;\n      return {\n          ..._options,\n          currentPath: currentPath,\n          propertyPath: undefined,\n          seenRefs: new Set(),\n          seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n              (0, util_1$1.zodDef)(def),\n              {\n                  def: (0, util_1$1.zodDef)(def),\n                  path: [..._options.basePath, _options.definitionPath, name],\n                  // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                  jsonSchema: undefined,\n              },\n          ])),\n      };\n  };\n  Refs.getRefs = getRefs;\n\n  var errorMessages = {};\n\n  Object.defineProperty(errorMessages, \"__esModule\", { value: true });\n  errorMessages.setResponseValueAndErrors = errorMessages.addErrorMessage = void 0;\n  function addErrorMessage(res, key, errorMessage, refs) {\n      if (!refs?.errorMessages)\n          return;\n      if (errorMessage) {\n          res.errorMessage = {\n              ...res.errorMessage,\n              [key]: errorMessage,\n          };\n      }\n  }\n  errorMessages.addErrorMessage = addErrorMessage;\n  function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n      res[key] = value;\n      addErrorMessage(res, key, errorMessage, refs);\n  }\n  errorMessages.setResponseValueAndErrors = setResponseValueAndErrors;\n\n  var parseDef = {};\n\n  var any = {};\n\n  Object.defineProperty(any, \"__esModule\", { value: true });\n  any.parseAnyDef = void 0;\n  function parseAnyDef() {\n      return {};\n  }\n  any.parseAnyDef = parseAnyDef;\n\n  var array = {};\n\n  var hasRequiredArray;\n\n  function requireArray () {\n  \tif (hasRequiredArray) return array;\n  \thasRequiredArray = 1;\n  \tObject.defineProperty(array, \"__esModule\", { value: true });\n  \tarray.parseArrayDef = void 0;\n  \tconst zod_1 = messages$1.lib;\n  \tconst errorMessages_1 = errorMessages;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction parseArrayDef(def, refs) {\n  \t    const res = {\n  \t        type: 'array',\n  \t    };\n  \t    if (def.type?._def?.typeName !== zod_1.ZodFirstPartyTypeKind.ZodAny) {\n  \t        res.items = (0, parseDef_1.parseDef)(def.type._def, {\n  \t            ...refs,\n  \t            currentPath: [...refs.currentPath, 'items'],\n  \t        });\n  \t    }\n  \t    if (def.minLength) {\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(res, 'minItems', def.minLength.value, def.minLength.message, refs);\n  \t    }\n  \t    if (def.maxLength) {\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(res, 'maxItems', def.maxLength.value, def.maxLength.message, refs);\n  \t    }\n  \t    if (def.exactLength) {\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(res, 'minItems', def.exactLength.value, def.exactLength.message, refs);\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(res, 'maxItems', def.exactLength.value, def.exactLength.message, refs);\n  \t    }\n  \t    return res;\n  \t}\n  \tarray.parseArrayDef = parseArrayDef;\n  \t\n  \treturn array;\n  }\n\n  var bigint = {};\n\n  Object.defineProperty(bigint, \"__esModule\", { value: true });\n  bigint.parseBigintDef = void 0;\n  const errorMessages_1$2 = errorMessages;\n  function parseBigintDef(def, refs) {\n      const res = {\n          type: 'integer',\n          format: 'int64',\n      };\n      if (!def.checks)\n          return res;\n      for (const check of def.checks) {\n          switch (check.kind) {\n              case 'min':\n                  if (refs.target === 'jsonSchema7') {\n                      if (check.inclusive) {\n                          (0, errorMessages_1$2.setResponseValueAndErrors)(res, 'minimum', check.value, check.message, refs);\n                      }\n                      else {\n                          (0, errorMessages_1$2.setResponseValueAndErrors)(res, 'exclusiveMinimum', check.value, check.message, refs);\n                      }\n                  }\n                  else {\n                      if (!check.inclusive) {\n                          res.exclusiveMinimum = true;\n                      }\n                      (0, errorMessages_1$2.setResponseValueAndErrors)(res, 'minimum', check.value, check.message, refs);\n                  }\n                  break;\n              case 'max':\n                  if (refs.target === 'jsonSchema7') {\n                      if (check.inclusive) {\n                          (0, errorMessages_1$2.setResponseValueAndErrors)(res, 'maximum', check.value, check.message, refs);\n                      }\n                      else {\n                          (0, errorMessages_1$2.setResponseValueAndErrors)(res, 'exclusiveMaximum', check.value, check.message, refs);\n                      }\n                  }\n                  else {\n                      if (!check.inclusive) {\n                          res.exclusiveMaximum = true;\n                      }\n                      (0, errorMessages_1$2.setResponseValueAndErrors)(res, 'maximum', check.value, check.message, refs);\n                  }\n                  break;\n              case 'multipleOf':\n                  (0, errorMessages_1$2.setResponseValueAndErrors)(res, 'multipleOf', check.value, check.message, refs);\n                  break;\n          }\n      }\n      return res;\n  }\n  bigint.parseBigintDef = parseBigintDef;\n\n  var boolean = {};\n\n  Object.defineProperty(boolean, \"__esModule\", { value: true });\n  boolean.parseBooleanDef = void 0;\n  function parseBooleanDef() {\n      return {\n          type: 'boolean',\n      };\n  }\n  boolean.parseBooleanDef = parseBooleanDef;\n\n  var branded = {};\n\n  var hasRequiredBranded;\n\n  function requireBranded () {\n  \tif (hasRequiredBranded) return branded;\n  \thasRequiredBranded = 1;\n  \tObject.defineProperty(branded, \"__esModule\", { value: true });\n  \tbranded.parseBrandedDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction parseBrandedDef(_def, refs) {\n  \t    return (0, parseDef_1.parseDef)(_def.type._def, refs);\n  \t}\n  \tbranded.parseBrandedDef = parseBrandedDef;\n  \t\n  \treturn branded;\n  }\n\n  var _catch = {};\n\n  var hasRequired_catch;\n\n  function require_catch () {\n  \tif (hasRequired_catch) return _catch;\n  \thasRequired_catch = 1;\n  \tObject.defineProperty(_catch, \"__esModule\", { value: true });\n  \t_catch.parseCatchDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst parseCatchDef = (def, refs) => {\n  \t    return (0, parseDef_1.parseDef)(def.innerType._def, refs);\n  \t};\n  \t_catch.parseCatchDef = parseCatchDef;\n  \t\n  \treturn _catch;\n  }\n\n  var date = {};\n\n  Object.defineProperty(date, \"__esModule\", { value: true });\n  date.parseDateDef = void 0;\n  const errorMessages_1$1 = errorMessages;\n  function parseDateDef(def, refs, overrideDateStrategy) {\n      const strategy = overrideDateStrategy ?? refs.dateStrategy;\n      if (Array.isArray(strategy)) {\n          return {\n              anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n          };\n      }\n      switch (strategy) {\n          case 'string':\n          case 'format:date-time':\n              return {\n                  type: 'string',\n                  format: 'date-time',\n              };\n          case 'format:date':\n              return {\n                  type: 'string',\n                  format: 'date',\n              };\n          case 'integer':\n              return integerDateParser(def, refs);\n      }\n  }\n  date.parseDateDef = parseDateDef;\n  const integerDateParser = (def, refs) => {\n      const res = {\n          type: 'integer',\n          format: 'unix-time',\n      };\n      if (refs.target === 'openApi3') {\n          return res;\n      }\n      for (const check of def.checks) {\n          switch (check.kind) {\n              case 'min':\n                  (0, errorMessages_1$1.setResponseValueAndErrors)(res, 'minimum', check.value, // This is in milliseconds\n                  check.message, refs);\n                  break;\n              case 'max':\n                  (0, errorMessages_1$1.setResponseValueAndErrors)(res, 'maximum', check.value, // This is in milliseconds\n                  check.message, refs);\n                  break;\n          }\n      }\n      return res;\n  };\n\n  var _default = {};\n\n  var hasRequired_default;\n\n  function require_default () {\n  \tif (hasRequired_default) return _default;\n  \thasRequired_default = 1;\n  \tObject.defineProperty(_default, \"__esModule\", { value: true });\n  \t_default.parseDefaultDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction parseDefaultDef(_def, refs) {\n  \t    return {\n  \t        ...(0, parseDef_1.parseDef)(_def.innerType._def, refs),\n  \t        default: _def.defaultValue(),\n  \t    };\n  \t}\n  \t_default.parseDefaultDef = parseDefaultDef;\n  \t\n  \treturn _default;\n  }\n\n  var effects = {};\n\n  var hasRequiredEffects;\n\n  function requireEffects () {\n  \tif (hasRequiredEffects) return effects;\n  \thasRequiredEffects = 1;\n  \tObject.defineProperty(effects, \"__esModule\", { value: true });\n  \teffects.parseEffectsDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction parseEffectsDef(_def, refs, forceResolution) {\n  \t    return refs.effectStrategy === 'input' ? (0, parseDef_1.parseDef)(_def.schema._def, refs, forceResolution) : {};\n  \t}\n  \teffects.parseEffectsDef = parseEffectsDef;\n  \t\n  \treturn effects;\n  }\n\n  var _enum = {};\n\n  Object.defineProperty(_enum, \"__esModule\", { value: true });\n  _enum.parseEnumDef = void 0;\n  function parseEnumDef(def) {\n      return {\n          type: 'string',\n          enum: [...def.values],\n      };\n  }\n  _enum.parseEnumDef = parseEnumDef;\n\n  var intersection = {};\n\n  var hasRequiredIntersection;\n\n  function requireIntersection () {\n  \tif (hasRequiredIntersection) return intersection;\n  \thasRequiredIntersection = 1;\n  \tObject.defineProperty(intersection, \"__esModule\", { value: true });\n  \tintersection.parseIntersectionDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst isJsonSchema7AllOfType = (type) => {\n  \t    if ('type' in type && type.type === 'string')\n  \t        return false;\n  \t    return 'allOf' in type;\n  \t};\n  \tfunction parseIntersectionDef(def, refs) {\n  \t    const allOf = [\n  \t        (0, parseDef_1.parseDef)(def.left._def, {\n  \t            ...refs,\n  \t            currentPath: [...refs.currentPath, 'allOf', '0'],\n  \t        }),\n  \t        (0, parseDef_1.parseDef)(def.right._def, {\n  \t            ...refs,\n  \t            currentPath: [...refs.currentPath, 'allOf', '1'],\n  \t        }),\n  \t    ].filter((x) => !!x);\n  \t    let unevaluatedProperties = refs.target === 'jsonSchema2019-09' ? { unevaluatedProperties: false } : undefined;\n  \t    const mergedAllOf = [];\n  \t    // If either of the schemas is an allOf, merge them into a single allOf\n  \t    allOf.forEach((schema) => {\n  \t        if (isJsonSchema7AllOfType(schema)) {\n  \t            mergedAllOf.push(...schema.allOf);\n  \t            if (schema.unevaluatedProperties === undefined) {\n  \t                // If one of the schemas has no unevaluatedProperties set,\n  \t                // the merged schema should also have no unevaluatedProperties set\n  \t                unevaluatedProperties = undefined;\n  \t            }\n  \t        }\n  \t        else {\n  \t            let nestedSchema = schema;\n  \t            if ('additionalProperties' in schema && schema.additionalProperties === false) {\n  \t                const { additionalProperties, ...rest } = schema;\n  \t                nestedSchema = rest;\n  \t            }\n  \t            else {\n  \t                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n  \t                unevaluatedProperties = undefined;\n  \t            }\n  \t            mergedAllOf.push(nestedSchema);\n  \t        }\n  \t    });\n  \t    return mergedAllOf.length ?\n  \t        {\n  \t            allOf: mergedAllOf,\n  \t            ...unevaluatedProperties,\n  \t        }\n  \t        : undefined;\n  \t}\n  \tintersection.parseIntersectionDef = parseIntersectionDef;\n  \t\n  \treturn intersection;\n  }\n\n  var literal = {};\n\n  Object.defineProperty(literal, \"__esModule\", { value: true });\n  literal.parseLiteralDef = void 0;\n  function parseLiteralDef(def, refs) {\n      const parsedType = typeof def.value;\n      if (parsedType !== 'bigint' &&\n          parsedType !== 'number' &&\n          parsedType !== 'boolean' &&\n          parsedType !== 'string') {\n          return {\n              type: Array.isArray(def.value) ? 'array' : 'object',\n          };\n      }\n      if (refs.target === 'openApi3') {\n          return {\n              type: parsedType === 'bigint' ? 'integer' : parsedType,\n              enum: [def.value],\n          };\n      }\n      return {\n          type: parsedType === 'bigint' ? 'integer' : parsedType,\n          const: def.value,\n      };\n  }\n  literal.parseLiteralDef = parseLiteralDef;\n\n  var map = {};\n\n  var record = {};\n\n  var string = {};\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.parseStringDef = exports.zodPatterns = void 0;\n  \tconst errorMessages_1 = errorMessages;\n  \tlet emojiRegex;\n  \t/**\n  \t * Generated from the regular expressions found here as of 2024-05-22:\n  \t * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n  \t *\n  \t * Expressions with /i flag have been changed accordingly.\n  \t */\n  \texports.zodPatterns = {\n  \t    /**\n  \t     * `c` was changed to `[cC]` to replicate /i flag\n  \t     */\n  \t    cuid: /^[cC][^\\s-]{8,}$/,\n  \t    cuid2: /^[0-9a-z]+$/,\n  \t    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  \t    /**\n  \t     * `a-z` was added to replicate /i flag\n  \t     */\n  \t    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  \t    /**\n  \t     * Constructed a valid Unicode RegExp\n  \t     *\n  \t     * Lazily instantiate since this type of regex isn't supported\n  \t     * in all envs (e.g. React Native).\n  \t     *\n  \t     * See:\n  \t     * https://github.com/colinhacks/zod/issues/2433\n  \t     * Fix in Zod:\n  \t     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n  \t     */\n  \t    emoji: () => {\n  \t        if (emojiRegex === undefined) {\n  \t            emojiRegex = RegExp('^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$', 'u');\n  \t        }\n  \t        return emojiRegex;\n  \t    },\n  \t    /**\n  \t     * Unused\n  \t     */\n  \t    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  \t    /**\n  \t     * Unused\n  \t     */\n  \t    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  \t    /**\n  \t     * Unused\n  \t     */\n  \t    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  \t    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  \t    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  \t};\n  \tfunction parseStringDef(def, refs) {\n  \t    const res = {\n  \t        type: 'string',\n  \t    };\n  \t    function processPattern(value) {\n  \t        return refs.patternStrategy === 'escape' ? escapeNonAlphaNumeric(value) : value;\n  \t    }\n  \t    if (def.checks) {\n  \t        for (const check of def.checks) {\n  \t            switch (check.kind) {\n  \t                case 'min':\n  \t                    (0, errorMessages_1.setResponseValueAndErrors)(res, 'minLength', typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n  \t                    break;\n  \t                case 'max':\n  \t                    (0, errorMessages_1.setResponseValueAndErrors)(res, 'maxLength', typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n  \t                    break;\n  \t                case 'email':\n  \t                    switch (refs.emailStrategy) {\n  \t                        case 'format:email':\n  \t                            addFormat(res, 'email', check.message, refs);\n  \t                            break;\n  \t                        case 'format:idn-email':\n  \t                            addFormat(res, 'idn-email', check.message, refs);\n  \t                            break;\n  \t                        case 'pattern:zod':\n  \t                            addPattern(res, exports.zodPatterns.email, check.message, refs);\n  \t                            break;\n  \t                    }\n  \t                    break;\n  \t                case 'url':\n  \t                    addFormat(res, 'uri', check.message, refs);\n  \t                    break;\n  \t                case 'uuid':\n  \t                    addFormat(res, 'uuid', check.message, refs);\n  \t                    break;\n  \t                case 'regex':\n  \t                    addPattern(res, check.regex, check.message, refs);\n  \t                    break;\n  \t                case 'cuid':\n  \t                    addPattern(res, exports.zodPatterns.cuid, check.message, refs);\n  \t                    break;\n  \t                case 'cuid2':\n  \t                    addPattern(res, exports.zodPatterns.cuid2, check.message, refs);\n  \t                    break;\n  \t                case 'startsWith':\n  \t                    addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);\n  \t                    break;\n  \t                case 'endsWith':\n  \t                    addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);\n  \t                    break;\n  \t                case 'datetime':\n  \t                    addFormat(res, 'date-time', check.message, refs);\n  \t                    break;\n  \t                case 'date':\n  \t                    addFormat(res, 'date', check.message, refs);\n  \t                    break;\n  \t                case 'time':\n  \t                    addFormat(res, 'time', check.message, refs);\n  \t                    break;\n  \t                case 'duration':\n  \t                    addFormat(res, 'duration', check.message, refs);\n  \t                    break;\n  \t                case 'length':\n  \t                    (0, errorMessages_1.setResponseValueAndErrors)(res, 'minLength', typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n  \t                    (0, errorMessages_1.setResponseValueAndErrors)(res, 'maxLength', typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n  \t                    break;\n  \t                case 'includes': {\n  \t                    addPattern(res, RegExp(processPattern(check.value)), check.message, refs);\n  \t                    break;\n  \t                }\n  \t                case 'ip': {\n  \t                    if (check.version !== 'v6') {\n  \t                        addFormat(res, 'ipv4', check.message, refs);\n  \t                    }\n  \t                    if (check.version !== 'v4') {\n  \t                        addFormat(res, 'ipv6', check.message, refs);\n  \t                    }\n  \t                    break;\n  \t                }\n  \t                case 'emoji':\n  \t                    addPattern(res, exports.zodPatterns.emoji, check.message, refs);\n  \t                    break;\n  \t                case 'ulid': {\n  \t                    addPattern(res, exports.zodPatterns.ulid, check.message, refs);\n  \t                    break;\n  \t                }\n  \t                case 'base64': {\n  \t                    switch (refs.base64Strategy) {\n  \t                        case 'format:binary': {\n  \t                            addFormat(res, 'binary', check.message, refs);\n  \t                            break;\n  \t                        }\n  \t                        case 'contentEncoding:base64': {\n  \t                            (0, errorMessages_1.setResponseValueAndErrors)(res, 'contentEncoding', 'base64', check.message, refs);\n  \t                            break;\n  \t                        }\n  \t                        case 'pattern:zod': {\n  \t                            addPattern(res, exports.zodPatterns.base64, check.message, refs);\n  \t                            break;\n  \t                        }\n  \t                    }\n  \t                    break;\n  \t                }\n  \t                case 'nanoid': {\n  \t                    addPattern(res, exports.zodPatterns.nanoid, check.message, refs);\n  \t                }\n  \t            }\n  \t        }\n  \t    }\n  \t    return res;\n  \t}\n  \texports.parseStringDef = parseStringDef;\n  \tconst escapeNonAlphaNumeric = (value) => Array.from(value)\n  \t    .map((c) => (/[a-zA-Z0-9]/.test(c) ? c : `\\\\${c}`))\n  \t    .join('');\n  \tconst addFormat = (schema, value, message, refs) => {\n  \t    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n  \t        if (!schema.anyOf) {\n  \t            schema.anyOf = [];\n  \t        }\n  \t        if (schema.format) {\n  \t            schema.anyOf.push({\n  \t                format: schema.format,\n  \t                ...(schema.errorMessage &&\n  \t                    refs.errorMessages && {\n  \t                    errorMessage: { format: schema.errorMessage.format },\n  \t                }),\n  \t            });\n  \t            delete schema.format;\n  \t            if (schema.errorMessage) {\n  \t                delete schema.errorMessage.format;\n  \t                if (Object.keys(schema.errorMessage).length === 0) {\n  \t                    delete schema.errorMessage;\n  \t                }\n  \t            }\n  \t        }\n  \t        schema.anyOf.push({\n  \t            format: value,\n  \t            ...(message && refs.errorMessages && { errorMessage: { format: message } }),\n  \t        });\n  \t    }\n  \t    else {\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(schema, 'format', value, message, refs);\n  \t    }\n  \t};\n  \tconst addPattern = (schema, regex, message, refs) => {\n  \t    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n  \t        if (!schema.allOf) {\n  \t            schema.allOf = [];\n  \t        }\n  \t        if (schema.pattern) {\n  \t            schema.allOf.push({\n  \t                pattern: schema.pattern,\n  \t                ...(schema.errorMessage &&\n  \t                    refs.errorMessages && {\n  \t                    errorMessage: { pattern: schema.errorMessage.pattern },\n  \t                }),\n  \t            });\n  \t            delete schema.pattern;\n  \t            if (schema.errorMessage) {\n  \t                delete schema.errorMessage.pattern;\n  \t                if (Object.keys(schema.errorMessage).length === 0) {\n  \t                    delete schema.errorMessage;\n  \t                }\n  \t            }\n  \t        }\n  \t        schema.allOf.push({\n  \t            pattern: processRegExp(regex, refs),\n  \t            ...(message && refs.errorMessages && { errorMessage: { pattern: message } }),\n  \t        });\n  \t    }\n  \t    else {\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(schema, 'pattern', processRegExp(regex, refs), message, refs);\n  \t    }\n  \t};\n  \t// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\n  \tconst processRegExp = (regexOrFunction, refs) => {\n  \t    const regex = typeof regexOrFunction === 'function' ? regexOrFunction() : regexOrFunction;\n  \t    if (!refs.applyRegexFlags || !regex.flags)\n  \t        return regex.source;\n  \t    // Currently handled flags\n  \t    const flags = {\n  \t        i: regex.flags.includes('i'),\n  \t        m: regex.flags.includes('m'),\n  \t        s: regex.flags.includes('s'), // `.` matches newlines\n  \t    };\n  \t    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  \t    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  \t    let pattern = '';\n  \t    let isEscaped = false;\n  \t    let inCharGroup = false;\n  \t    let inCharRange = false;\n  \t    for (let i = 0; i < source.length; i++) {\n  \t        if (isEscaped) {\n  \t            pattern += source[i];\n  \t            isEscaped = false;\n  \t            continue;\n  \t        }\n  \t        if (flags.i) {\n  \t            if (inCharGroup) {\n  \t                if (source[i].match(/[a-z]/)) {\n  \t                    if (inCharRange) {\n  \t                        pattern += source[i];\n  \t                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n  \t                        inCharRange = false;\n  \t                    }\n  \t                    else if (source[i + 1] === '-' && source[i + 2]?.match(/[a-z]/)) {\n  \t                        pattern += source[i];\n  \t                        inCharRange = true;\n  \t                    }\n  \t                    else {\n  \t                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n  \t                    }\n  \t                    continue;\n  \t                }\n  \t            }\n  \t            else if (source[i].match(/[a-z]/)) {\n  \t                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n  \t                continue;\n  \t            }\n  \t        }\n  \t        if (flags.m) {\n  \t            if (source[i] === '^') {\n  \t                pattern += `(^|(?<=[\\r\\n]))`;\n  \t                continue;\n  \t            }\n  \t            else if (source[i] === '$') {\n  \t                pattern += `($|(?=[\\r\\n]))`;\n  \t                continue;\n  \t            }\n  \t        }\n  \t        if (flags.s && source[i] === '.') {\n  \t            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n  \t            continue;\n  \t        }\n  \t        pattern += source[i];\n  \t        if (source[i] === '\\\\') {\n  \t            isEscaped = true;\n  \t        }\n  \t        else if (inCharGroup && source[i] === ']') {\n  \t            inCharGroup = false;\n  \t        }\n  \t        else if (!inCharGroup && source[i] === '[') {\n  \t            inCharGroup = true;\n  \t        }\n  \t    }\n  \t    try {\n  \t        const regexTest = new RegExp(pattern);\n  \t    }\n  \t    catch {\n  \t        console.warn(`Could not convert regex pattern at ${refs.currentPath.join('/')} to a flag-independent form! Falling back to the flag-ignorant source`);\n  \t        return regex.source;\n  \t    }\n  \t    return pattern;\n  \t};\n  \t\n  } (string));\n\n  var hasRequiredRecord;\n\n  function requireRecord () {\n  \tif (hasRequiredRecord) return record;\n  \thasRequiredRecord = 1;\n  \tObject.defineProperty(record, \"__esModule\", { value: true });\n  \trecord.parseRecordDef = void 0;\n  \tconst zod_1 = messages$1.lib;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst string_1 = string;\n  \tfunction parseRecordDef(def, refs) {\n  \t    if (refs.target === 'openApi3' && def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodEnum) {\n  \t        return {\n  \t            type: 'object',\n  \t            required: def.keyType._def.values,\n  \t            properties: def.keyType._def.values.reduce((acc, key) => ({\n  \t                ...acc,\n  \t                [key]: (0, parseDef_1.parseDef)(def.valueType._def, {\n  \t                    ...refs,\n  \t                    currentPath: [...refs.currentPath, 'properties', key],\n  \t                }) ?? {},\n  \t            }), {}),\n  \t            additionalProperties: false,\n  \t        };\n  \t    }\n  \t    const schema = {\n  \t        type: 'object',\n  \t        additionalProperties: (0, parseDef_1.parseDef)(def.valueType._def, {\n  \t            ...refs,\n  \t            currentPath: [...refs.currentPath, 'additionalProperties'],\n  \t        }) ?? {},\n  \t    };\n  \t    if (refs.target === 'openApi3') {\n  \t        return schema;\n  \t    }\n  \t    if (def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {\n  \t        const keyType = Object.entries((0, string_1.parseStringDef)(def.keyType._def, refs)).reduce((acc, [key, value]) => (key === 'type' ? acc : { ...acc, [key]: value }), {});\n  \t        return {\n  \t            ...schema,\n  \t            propertyNames: keyType,\n  \t        };\n  \t    }\n  \t    else if (def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodEnum) {\n  \t        return {\n  \t            ...schema,\n  \t            propertyNames: {\n  \t                enum: def.keyType._def.values,\n  \t            },\n  \t        };\n  \t    }\n  \t    return schema;\n  \t}\n  \trecord.parseRecordDef = parseRecordDef;\n  \t\n  \treturn record;\n  }\n\n  var hasRequiredMap;\n\n  function requireMap () {\n  \tif (hasRequiredMap) return map;\n  \thasRequiredMap = 1;\n  \tObject.defineProperty(map, \"__esModule\", { value: true });\n  \tmap.parseMapDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst record_1 = requireRecord();\n  \tfunction parseMapDef(def, refs) {\n  \t    if (refs.mapStrategy === 'record') {\n  \t        return (0, record_1.parseRecordDef)(def, refs);\n  \t    }\n  \t    const keys = (0, parseDef_1.parseDef)(def.keyType._def, {\n  \t        ...refs,\n  \t        currentPath: [...refs.currentPath, 'items', 'items', '0'],\n  \t    }) || {};\n  \t    const values = (0, parseDef_1.parseDef)(def.valueType._def, {\n  \t        ...refs,\n  \t        currentPath: [...refs.currentPath, 'items', 'items', '1'],\n  \t    }) || {};\n  \t    return {\n  \t        type: 'array',\n  \t        maxItems: 125,\n  \t        items: {\n  \t            type: 'array',\n  \t            items: [keys, values],\n  \t            minItems: 2,\n  \t            maxItems: 2,\n  \t        },\n  \t    };\n  \t}\n  \tmap.parseMapDef = parseMapDef;\n  \t\n  \treturn map;\n  }\n\n  var nativeEnum = {};\n\n  Object.defineProperty(nativeEnum, \"__esModule\", { value: true });\n  nativeEnum.parseNativeEnumDef = void 0;\n  function parseNativeEnumDef(def) {\n      const object = def.values;\n      const actualKeys = Object.keys(def.values).filter((key) => {\n          return typeof object[object[key]] !== 'number';\n      });\n      const actualValues = actualKeys.map((key) => object[key]);\n      const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n      return {\n          type: parsedTypes.length === 1 ?\n              parsedTypes[0] === 'string' ?\n                  'string'\n                  : 'number'\n              : ['string', 'number'],\n          enum: actualValues,\n      };\n  }\n  nativeEnum.parseNativeEnumDef = parseNativeEnumDef;\n\n  var never = {};\n\n  Object.defineProperty(never, \"__esModule\", { value: true });\n  never.parseNeverDef = void 0;\n  function parseNeverDef() {\n      return {\n          not: {},\n      };\n  }\n  never.parseNeverDef = parseNeverDef;\n\n  var _null = {};\n\n  Object.defineProperty(_null, \"__esModule\", { value: true });\n  _null.parseNullDef = void 0;\n  function parseNullDef(refs) {\n      return refs.target === 'openApi3' ?\n          {\n              enum: ['null'],\n              nullable: true,\n          }\n          : {\n              type: 'null',\n          };\n  }\n  _null.parseNullDef = parseNullDef;\n\n  var nullable = {};\n\n  var union = {};\n\n  var hasRequiredUnion;\n\n  function requireUnion () {\n  \tif (hasRequiredUnion) return union;\n  \thasRequiredUnion = 1;\n  \t(function (exports) {\n  \t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t\texports.parseUnionDef = exports.primitiveMappings = void 0;\n  \t\tconst parseDef_1 = requireParseDef();\n  \t\texports.primitiveMappings = {\n  \t\t    ZodString: 'string',\n  \t\t    ZodNumber: 'number',\n  \t\t    ZodBigInt: 'integer',\n  \t\t    ZodBoolean: 'boolean',\n  \t\t    ZodNull: 'null',\n  \t\t};\n  \t\tfunction parseUnionDef(def, refs) {\n  \t\t    if (refs.target === 'openApi3')\n  \t\t        return asAnyOf(def, refs);\n  \t\t    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  \t\t    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n  \t\t    if (options.every((x) => x._def.typeName in exports.primitiveMappings && (!x._def.checks || !x._def.checks.length))) {\n  \t\t        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n  \t\t        const types = options.reduce((types, x) => {\n  \t\t            const type = exports.primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n  \t\t            return type && !types.includes(type) ? [...types, type] : types;\n  \t\t        }, []);\n  \t\t        return {\n  \t\t            type: types.length > 1 ? types : types[0],\n  \t\t        };\n  \t\t    }\n  \t\t    else if (options.every((x) => x._def.typeName === 'ZodLiteral' && !x.description)) {\n  \t\t        // all options literals\n  \t\t        const types = options.reduce((acc, x) => {\n  \t\t            const type = typeof x._def.value;\n  \t\t            switch (type) {\n  \t\t                case 'string':\n  \t\t                case 'number':\n  \t\t                case 'boolean':\n  \t\t                    return [...acc, type];\n  \t\t                case 'bigint':\n  \t\t                    return [...acc, 'integer'];\n  \t\t                case 'object':\n  \t\t                    if (x._def.value === null)\n  \t\t                        return [...acc, 'null'];\n  \t\t                case 'symbol':\n  \t\t                case 'undefined':\n  \t\t                case 'function':\n  \t\t                default:\n  \t\t                    return acc;\n  \t\t            }\n  \t\t        }, []);\n  \t\t        if (types.length === options.length) {\n  \t\t            // all the literals are primitive, as far as null can be considered primitive\n  \t\t            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n  \t\t            return {\n  \t\t                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n  \t\t                enum: options.reduce((acc, x) => {\n  \t\t                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n  \t\t                }, []),\n  \t\t            };\n  \t\t        }\n  \t\t    }\n  \t\t    else if (options.every((x) => x._def.typeName === 'ZodEnum')) {\n  \t\t        return {\n  \t\t            type: 'string',\n  \t\t            enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x) => !acc.includes(x))], []),\n  \t\t        };\n  \t\t    }\n  \t\t    return asAnyOf(def, refs);\n  \t\t}\n  \t\texports.parseUnionDef = parseUnionDef;\n  \t\tconst asAnyOf = (def, refs) => {\n  \t\t    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options)\n  \t\t        .map((x, i) => (0, parseDef_1.parseDef)(x._def, {\n  \t\t        ...refs,\n  \t\t        currentPath: [...refs.currentPath, 'anyOf', `${i}`],\n  \t\t    }))\n  \t\t        .filter((x) => !!x && (!refs.strictUnions || (typeof x === 'object' && Object.keys(x).length > 0)));\n  \t\t    return anyOf.length ? { anyOf } : undefined;\n  \t\t};\n  \t\t\n  \t} (union));\n  \treturn union;\n  }\n\n  var hasRequiredNullable;\n\n  function requireNullable () {\n  \tif (hasRequiredNullable) return nullable;\n  \thasRequiredNullable = 1;\n  \tObject.defineProperty(nullable, \"__esModule\", { value: true });\n  \tnullable.parseNullableDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst union_1 = requireUnion();\n  \tfunction parseNullableDef(def, refs) {\n  \t    if (['ZodString', 'ZodNumber', 'ZodBigInt', 'ZodBoolean', 'ZodNull'].includes(def.innerType._def.typeName) &&\n  \t        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n  \t        if (refs.target === 'openApi3' || refs.nullableStrategy === 'property') {\n  \t            return {\n  \t                type: union_1.primitiveMappings[def.innerType._def.typeName],\n  \t                nullable: true,\n  \t            };\n  \t        }\n  \t        return {\n  \t            type: [union_1.primitiveMappings[def.innerType._def.typeName], 'null'],\n  \t        };\n  \t    }\n  \t    if (refs.target === 'openApi3') {\n  \t        const base = (0, parseDef_1.parseDef)(def.innerType._def, {\n  \t            ...refs,\n  \t            currentPath: [...refs.currentPath],\n  \t        });\n  \t        if (base && '$ref' in base)\n  \t            return { allOf: [base], nullable: true };\n  \t        return base && { ...base, nullable: true };\n  \t    }\n  \t    const base = (0, parseDef_1.parseDef)(def.innerType._def, {\n  \t        ...refs,\n  \t        currentPath: [...refs.currentPath, 'anyOf', '0'],\n  \t    });\n  \t    return base && { anyOf: [base, { type: 'null' }] };\n  \t}\n  \tnullable.parseNullableDef = parseNullableDef;\n  \t\n  \treturn nullable;\n  }\n\n  var number = {};\n\n  Object.defineProperty(number, \"__esModule\", { value: true });\n  number.parseNumberDef = void 0;\n  const errorMessages_1 = errorMessages;\n  function parseNumberDef(def, refs) {\n      const res = {\n          type: 'number',\n      };\n      if (!def.checks)\n          return res;\n      for (const check of def.checks) {\n          switch (check.kind) {\n              case 'int':\n                  res.type = 'integer';\n                  (0, errorMessages_1.addErrorMessage)(res, 'type', check.message, refs);\n                  break;\n              case 'min':\n                  if (refs.target === 'jsonSchema7') {\n                      if (check.inclusive) {\n                          (0, errorMessages_1.setResponseValueAndErrors)(res, 'minimum', check.value, check.message, refs);\n                      }\n                      else {\n                          (0, errorMessages_1.setResponseValueAndErrors)(res, 'exclusiveMinimum', check.value, check.message, refs);\n                      }\n                  }\n                  else {\n                      if (!check.inclusive) {\n                          res.exclusiveMinimum = true;\n                      }\n                      (0, errorMessages_1.setResponseValueAndErrors)(res, 'minimum', check.value, check.message, refs);\n                  }\n                  break;\n              case 'max':\n                  if (refs.target === 'jsonSchema7') {\n                      if (check.inclusive) {\n                          (0, errorMessages_1.setResponseValueAndErrors)(res, 'maximum', check.value, check.message, refs);\n                      }\n                      else {\n                          (0, errorMessages_1.setResponseValueAndErrors)(res, 'exclusiveMaximum', check.value, check.message, refs);\n                      }\n                  }\n                  else {\n                      if (!check.inclusive) {\n                          res.exclusiveMaximum = true;\n                      }\n                      (0, errorMessages_1.setResponseValueAndErrors)(res, 'maximum', check.value, check.message, refs);\n                  }\n                  break;\n              case 'multipleOf':\n                  (0, errorMessages_1.setResponseValueAndErrors)(res, 'multipleOf', check.value, check.message, refs);\n                  break;\n          }\n      }\n      return res;\n  }\n  number.parseNumberDef = parseNumberDef;\n\n  var object = {};\n\n  var hasRequiredObject;\n\n  function requireObject () {\n  \tif (hasRequiredObject) return object;\n  \thasRequiredObject = 1;\n  \tObject.defineProperty(object, \"__esModule\", { value: true });\n  \tobject.parseObjectDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction decideAdditionalProperties(def, refs) {\n  \t    if (refs.removeAdditionalStrategy === 'strict') {\n  \t        return def.catchall._def.typeName === 'ZodNever' ?\n  \t            def.unknownKeys !== 'strict'\n  \t            : (0, parseDef_1.parseDef)(def.catchall._def, {\n  \t                ...refs,\n  \t                currentPath: [...refs.currentPath, 'additionalProperties'],\n  \t            }) ?? true;\n  \t    }\n  \t    else {\n  \t        return def.catchall._def.typeName === 'ZodNever' ?\n  \t            def.unknownKeys === 'passthrough'\n  \t            : (0, parseDef_1.parseDef)(def.catchall._def, {\n  \t                ...refs,\n  \t                currentPath: [...refs.currentPath, 'additionalProperties'],\n  \t            }) ?? true;\n  \t    }\n  \t}\n  \tfunction parseObjectDef(def, refs) {\n  \t    const result = {\n  \t        type: 'object',\n  \t        ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {\n  \t            if (propDef === undefined || propDef._def === undefined)\n  \t                return acc;\n  \t            const parsedDef = (0, parseDef_1.parseDef)(propDef._def, {\n  \t                ...refs,\n  \t                currentPath: [...refs.currentPath, 'properties', propName],\n  \t                propertyPath: [...refs.currentPath, 'properties', propName],\n  \t            });\n  \t            if (parsedDef === undefined)\n  \t                return acc;\n  \t            return {\n  \t                properties: {\n  \t                    ...acc.properties,\n  \t                    [propName]: parsedDef,\n  \t                },\n  \t                required: propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName],\n  \t            };\n  \t        }, { properties: {}, required: [] }),\n  \t        additionalProperties: decideAdditionalProperties(def, refs),\n  \t    };\n  \t    if (!result.required.length)\n  \t        delete result.required;\n  \t    return result;\n  \t}\n  \tobject.parseObjectDef = parseObjectDef;\n  \t\n  \treturn object;\n  }\n\n  var optional = {};\n\n  var hasRequiredOptional;\n\n  function requireOptional () {\n  \tif (hasRequiredOptional) return optional;\n  \thasRequiredOptional = 1;\n  \tObject.defineProperty(optional, \"__esModule\", { value: true });\n  \toptional.parseOptionalDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst parseOptionalDef = (def, refs) => {\n  \t    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n  \t        return (0, parseDef_1.parseDef)(def.innerType._def, refs);\n  \t    }\n  \t    const innerSchema = (0, parseDef_1.parseDef)(def.innerType._def, {\n  \t        ...refs,\n  \t        currentPath: [...refs.currentPath, 'anyOf', '1'],\n  \t    });\n  \t    return innerSchema ?\n  \t        {\n  \t            anyOf: [\n  \t                {\n  \t                    not: {},\n  \t                },\n  \t                innerSchema,\n  \t            ],\n  \t        }\n  \t        : {};\n  \t};\n  \toptional.parseOptionalDef = parseOptionalDef;\n  \t\n  \treturn optional;\n  }\n\n  var pipeline = {};\n\n  var hasRequiredPipeline;\n\n  function requirePipeline () {\n  \tif (hasRequiredPipeline) return pipeline;\n  \thasRequiredPipeline = 1;\n  \tObject.defineProperty(pipeline, \"__esModule\", { value: true });\n  \tpipeline.parsePipelineDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst parsePipelineDef = (def, refs) => {\n  \t    if (refs.pipeStrategy === 'input') {\n  \t        return (0, parseDef_1.parseDef)(def.in._def, refs);\n  \t    }\n  \t    else if (refs.pipeStrategy === 'output') {\n  \t        return (0, parseDef_1.parseDef)(def.out._def, refs);\n  \t    }\n  \t    const a = (0, parseDef_1.parseDef)(def.in._def, {\n  \t        ...refs,\n  \t        currentPath: [...refs.currentPath, 'allOf', '0'],\n  \t    });\n  \t    const b = (0, parseDef_1.parseDef)(def.out._def, {\n  \t        ...refs,\n  \t        currentPath: [...refs.currentPath, 'allOf', a ? '1' : '0'],\n  \t    });\n  \t    return {\n  \t        allOf: [a, b].filter((x) => x !== undefined),\n  \t    };\n  \t};\n  \tpipeline.parsePipelineDef = parsePipelineDef;\n  \t\n  \treturn pipeline;\n  }\n\n  var promise = {};\n\n  var hasRequiredPromise;\n\n  function requirePromise () {\n  \tif (hasRequiredPromise) return promise;\n  \thasRequiredPromise = 1;\n  \tObject.defineProperty(promise, \"__esModule\", { value: true });\n  \tpromise.parsePromiseDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction parsePromiseDef(def, refs) {\n  \t    return (0, parseDef_1.parseDef)(def.type._def, refs);\n  \t}\n  \tpromise.parsePromiseDef = parsePromiseDef;\n  \t\n  \treturn promise;\n  }\n\n  var set = {};\n\n  var hasRequiredSet;\n\n  function requireSet () {\n  \tif (hasRequiredSet) return set;\n  \thasRequiredSet = 1;\n  \tObject.defineProperty(set, \"__esModule\", { value: true });\n  \tset.parseSetDef = void 0;\n  \tconst errorMessages_1 = errorMessages;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction parseSetDef(def, refs) {\n  \t    const items = (0, parseDef_1.parseDef)(def.valueType._def, {\n  \t        ...refs,\n  \t        currentPath: [...refs.currentPath, 'items'],\n  \t    });\n  \t    const schema = {\n  \t        type: 'array',\n  \t        uniqueItems: true,\n  \t        items,\n  \t    };\n  \t    if (def.minSize) {\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(schema, 'minItems', def.minSize.value, def.minSize.message, refs);\n  \t    }\n  \t    if (def.maxSize) {\n  \t        (0, errorMessages_1.setResponseValueAndErrors)(schema, 'maxItems', def.maxSize.value, def.maxSize.message, refs);\n  \t    }\n  \t    return schema;\n  \t}\n  \tset.parseSetDef = parseSetDef;\n  \t\n  \treturn set;\n  }\n\n  var tuple = {};\n\n  var hasRequiredTuple;\n\n  function requireTuple () {\n  \tif (hasRequiredTuple) return tuple;\n  \thasRequiredTuple = 1;\n  \tObject.defineProperty(tuple, \"__esModule\", { value: true });\n  \ttuple.parseTupleDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tfunction parseTupleDef(def, refs) {\n  \t    if (def.rest) {\n  \t        return {\n  \t            type: 'array',\n  \t            minItems: def.items.length,\n  \t            items: def.items\n  \t                .map((x, i) => (0, parseDef_1.parseDef)(x._def, {\n  \t                ...refs,\n  \t                currentPath: [...refs.currentPath, 'items', `${i}`],\n  \t            }))\n  \t                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n  \t            additionalItems: (0, parseDef_1.parseDef)(def.rest._def, {\n  \t                ...refs,\n  \t                currentPath: [...refs.currentPath, 'additionalItems'],\n  \t            }),\n  \t        };\n  \t    }\n  \t    else {\n  \t        return {\n  \t            type: 'array',\n  \t            minItems: def.items.length,\n  \t            maxItems: def.items.length,\n  \t            items: def.items\n  \t                .map((x, i) => (0, parseDef_1.parseDef)(x._def, {\n  \t                ...refs,\n  \t                currentPath: [...refs.currentPath, 'items', `${i}`],\n  \t            }))\n  \t                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n  \t        };\n  \t    }\n  \t}\n  \ttuple.parseTupleDef = parseTupleDef;\n  \t\n  \treturn tuple;\n  }\n\n  var _undefined = {};\n\n  Object.defineProperty(_undefined, \"__esModule\", { value: true });\n  _undefined.parseUndefinedDef = void 0;\n  function parseUndefinedDef() {\n      return {\n          not: {},\n      };\n  }\n  _undefined.parseUndefinedDef = parseUndefinedDef;\n\n  var unknown = {};\n\n  Object.defineProperty(unknown, \"__esModule\", { value: true });\n  unknown.parseUnknownDef = void 0;\n  function parseUnknownDef() {\n      return {};\n  }\n  unknown.parseUnknownDef = parseUnknownDef;\n\n  var readonly = {};\n\n  var hasRequiredReadonly;\n\n  function requireReadonly () {\n  \tif (hasRequiredReadonly) return readonly;\n  \thasRequiredReadonly = 1;\n  \tObject.defineProperty(readonly, \"__esModule\", { value: true });\n  \treadonly.parseReadonlyDef = void 0;\n  \tconst parseDef_1 = requireParseDef();\n  \tconst parseReadonlyDef = (def, refs) => {\n  \t    return (0, parseDef_1.parseDef)(def.innerType._def, refs);\n  \t};\n  \treadonly.parseReadonlyDef = parseReadonlyDef;\n  \t\n  \treturn readonly;\n  }\n\n  var hasRequiredParseDef;\n  function requireParseDef() {\n    if (hasRequiredParseDef) return parseDef;\n    hasRequiredParseDef = 1;\n    Object.defineProperty(parseDef, \"__esModule\", {\n      value: true\n    });\n    parseDef.parseDef = void 0;\n    const zod_1 = messages$1.lib;\n    const any_1 = any;\n    const array_1 = requireArray();\n    const bigint_1 = bigint;\n    const boolean_1 = boolean;\n    const branded_1 = requireBranded();\n    const catch_1 = require_catch();\n    const date_1 = date;\n    const default_1 = require_default();\n    const effects_1 = requireEffects();\n    const enum_1 = _enum;\n    const intersection_1 = requireIntersection();\n    const literal_1 = literal;\n    const map_1 = requireMap();\n    const nativeEnum_1 = nativeEnum;\n    const never_1 = never;\n    const null_1 = _null;\n    const nullable_1 = requireNullable();\n    const number_1 = number;\n    const object_1 = requireObject();\n    const optional_1 = requireOptional();\n    const pipeline_1 = requirePipeline();\n    const promise_1 = requirePromise();\n    const record_1 = requireRecord();\n    const set_1 = requireSet();\n    const string_1 = string;\n    const tuple_1 = requireTuple();\n    const undefined_1 = _undefined;\n    const union_1 = requireUnion();\n    const unknown_1 = unknown;\n    const readonly_1 = requireReadonly();\n    const Options_1 = Options;\n    function parseDef$1(def, refs, forceResolution = false) {\n      const seenItem = refs.seen.get(def);\n      if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== Options_1.ignoreOverride) {\n          return overrideResult;\n        }\n      }\n      if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n          if ((\"$ref\" in seenSchema)) {\n            refs.seenRefs.add(seenSchema.$ref);\n          }\n          return seenSchema;\n        }\n      }\n      const newItem = {\n        def,\n        path: refs.currentPath,\n        jsonSchema: undefined\n      };\n      refs.seen.set(def, newItem);\n      const jsonSchema = selectParser(def, def.typeName, refs, forceResolution);\n      if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n      }\n      newItem.jsonSchema = jsonSchema;\n      return jsonSchema;\n    }\n    parseDef.parseDef = parseDef$1;\n    const get$ref = (item, refs) => {\n      switch (refs.$refStrategy) {\n        case \"root\":\n          return {\n            $ref: item.path.join(\"/\")\n          };\n        case \"extract-to-root\":\n          const name = item.path.slice(refs.basePath.length + 1).join(\"_\");\n          if (name !== refs.name && refs.nameStrategy === \"duplicate-ref\") {\n            refs.definitions[name] = item.def;\n          }\n          return {\n            $ref: [...refs.basePath, refs.definitionPath, name].join(\"/\")\n          };\n        case \"relative\":\n          return {\n            $ref: getRelativePath(refs.currentPath, item.path)\n          };\n        case \"none\":\n        case \"seen\":\n          {\n            if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n              console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n              return {};\n            }\n            return refs.$refStrategy === \"seen\" ? {} : undefined;\n          }\n      }\n    };\n    const getRelativePath = (pathA, pathB) => {\n      let i = 0;\n      for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i]) break;\n      }\n      return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n    };\n    const selectParser = (def, typeName, refs, forceResolution) => {\n      switch (typeName) {\n        case zod_1.ZodFirstPartyTypeKind.ZodString:\n          return (0, string_1.parseStringDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodNumber:\n          return (0, number_1.parseNumberDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodObject:\n          return (0, object_1.parseObjectDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodBigInt:\n          return (0, bigint_1.parseBigintDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodBoolean:\n          return (0, boolean_1.parseBooleanDef)();\n        case zod_1.ZodFirstPartyTypeKind.ZodDate:\n          return (0, date_1.parseDateDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodUndefined:\n          return (0, undefined_1.parseUndefinedDef)();\n        case zod_1.ZodFirstPartyTypeKind.ZodNull:\n          return (0, null_1.parseNullDef)(refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodArray:\n          return (0, array_1.parseArrayDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodUnion:\n        case zod_1.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n          return (0, union_1.parseUnionDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodIntersection:\n          return (0, intersection_1.parseIntersectionDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodTuple:\n          return (0, tuple_1.parseTupleDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodRecord:\n          return (0, record_1.parseRecordDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodLiteral:\n          return (0, literal_1.parseLiteralDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodEnum:\n          return (0, enum_1.parseEnumDef)(def);\n        case zod_1.ZodFirstPartyTypeKind.ZodNativeEnum:\n          return (0, nativeEnum_1.parseNativeEnumDef)(def);\n        case zod_1.ZodFirstPartyTypeKind.ZodNullable:\n          return (0, nullable_1.parseNullableDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodOptional:\n          return (0, optional_1.parseOptionalDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodMap:\n          return (0, map_1.parseMapDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodSet:\n          return (0, set_1.parseSetDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodLazy:\n          return parseDef$1(def.getter()._def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodPromise:\n          return (0, promise_1.parsePromiseDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodNaN:\n        case zod_1.ZodFirstPartyTypeKind.ZodNever:\n          return (0, never_1.parseNeverDef)();\n        case zod_1.ZodFirstPartyTypeKind.ZodEffects:\n          return (0, effects_1.parseEffectsDef)(def, refs, forceResolution);\n        case zod_1.ZodFirstPartyTypeKind.ZodAny:\n          return (0, any_1.parseAnyDef)();\n        case zod_1.ZodFirstPartyTypeKind.ZodUnknown:\n          return (0, unknown_1.parseUnknownDef)();\n        case zod_1.ZodFirstPartyTypeKind.ZodDefault:\n          return (0, default_1.parseDefaultDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodBranded:\n          return (0, branded_1.parseBrandedDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodReadonly:\n          return (0, readonly_1.parseReadonlyDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodCatch:\n          return (0, catch_1.parseCatchDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodPipeline:\n          return (0, pipeline_1.parsePipelineDef)(def, refs);\n        case zod_1.ZodFirstPartyTypeKind.ZodFunction:\n        case zod_1.ZodFirstPartyTypeKind.ZodVoid:\n        case zod_1.ZodFirstPartyTypeKind.ZodSymbol:\n          return undefined;\n        default:\n          return (_ => undefined)();\n      }\n    };\n    const addMeta = (def, refs, jsonSchema) => {\n      if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n          jsonSchema.markdownDescription = def.description;\n        }\n      }\n      return jsonSchema;\n    };\n    return parseDef;\n  }\n\n  var zodToJsonSchema$2 = {};\n\n  Object.defineProperty(zodToJsonSchema$2, \"__esModule\", { value: true });\n  zodToJsonSchema$2.zodToJsonSchema = void 0;\n  const parseDef_1 = requireParseDef();\n  const Refs_1 = Refs;\n  const util_1 = util;\n  const zodToJsonSchema$1 = (schema, options) => {\n      const refs = (0, Refs_1.getRefs)(options);\n      const name = typeof options === 'string' ? options\n          : options?.nameStrategy === 'title' ? undefined\n              : options?.name;\n      const main = (0, parseDef_1.parseDef)(schema._def, name === undefined ? refs : ({\n          ...refs,\n          currentPath: [...refs.basePath, refs.definitionPath, name],\n      }), false) ?? {};\n      const title = typeof options === 'object' && options.name !== undefined && options.nameStrategy === 'title' ?\n          options.name\n          : undefined;\n      if (title !== undefined) {\n          main.title = title;\n      }\n      const definitions = (() => {\n          if ((0, util_1.isEmptyObj)(refs.definitions)) {\n              return undefined;\n          }\n          const definitions = {};\n          const processedDefinitions = new Set();\n          // the call to `parseDef()` here might itself add more entries to `.definitions`\n          // so we need to continually evaluate definitions until we've resolved all of them\n          //\n          // we have a generous iteration limit here to avoid blowing up the stack if there\n          // are any bugs that would otherwise result in us iterating indefinitely\n          for (let i = 0; i < 500; i++) {\n              const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));\n              if (newDefinitions.length === 0)\n                  break;\n              for (const [key, schema] of newDefinitions) {\n                  definitions[key] =\n                      (0, parseDef_1.parseDef)((0, util_1.zodDef)(schema), { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] }, true) ?? {};\n                  processedDefinitions.add(key);\n              }\n          }\n          return definitions;\n      })();\n      const combined = name === undefined ?\n          definitions ?\n              {\n                  ...main,\n                  [refs.definitionPath]: definitions,\n              }\n              : main\n          : refs.nameStrategy === 'duplicate-ref' ?\n              {\n                  ...main,\n                  ...(definitions || refs.seenRefs.size ?\n                      {\n                          [refs.definitionPath]: {\n                              ...definitions,\n                              // only actually duplicate the schema definition if it was ever referenced\n                              // otherwise the duplication is completely pointless\n                              ...(refs.seenRefs.size ? { [name]: main } : undefined),\n                          },\n                      }\n                      : undefined),\n              }\n              : {\n                  $ref: [...(refs.$refStrategy === 'relative' ? [] : refs.basePath), refs.definitionPath, name].join('/'),\n                  [refs.definitionPath]: {\n                      ...definitions,\n                      [name]: main,\n                  },\n              };\n      if (refs.target === 'jsonSchema7') {\n          combined.$schema = 'http://json-schema.org/draft-07/schema#';\n      }\n      else if (refs.target === 'jsonSchema2019-09') {\n          combined.$schema = 'https://json-schema.org/draft/2019-09/schema#';\n      }\n      return combined;\n  };\n  zodToJsonSchema$2.zodToJsonSchema = zodToJsonSchema$1;\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t__exportStar(Options, exports);\n  \t__exportStar(Refs, exports);\n  \t__exportStar(errorMessages, exports);\n  \t__exportStar(requireParseDef(), exports);\n  \t__exportStar(any, exports);\n  \t__exportStar(requireArray(), exports);\n  \t__exportStar(bigint, exports);\n  \t__exportStar(boolean, exports);\n  \t__exportStar(requireBranded(), exports);\n  \t__exportStar(require_catch(), exports);\n  \t__exportStar(date, exports);\n  \t__exportStar(require_default(), exports);\n  \t__exportStar(requireEffects(), exports);\n  \t__exportStar(_enum, exports);\n  \t__exportStar(requireIntersection(), exports);\n  \t__exportStar(literal, exports);\n  \t__exportStar(requireMap(), exports);\n  \t__exportStar(nativeEnum, exports);\n  \t__exportStar(never, exports);\n  \t__exportStar(_null, exports);\n  \t__exportStar(requireNullable(), exports);\n  \t__exportStar(number, exports);\n  \t__exportStar(requireObject(), exports);\n  \t__exportStar(requireOptional(), exports);\n  \t__exportStar(requirePipeline(), exports);\n  \t__exportStar(requirePromise(), exports);\n  \t__exportStar(requireReadonly(), exports);\n  \t__exportStar(requireRecord(), exports);\n  \t__exportStar(requireSet(), exports);\n  \t__exportStar(string, exports);\n  \t__exportStar(requireTuple(), exports);\n  \t__exportStar(_undefined, exports);\n  \t__exportStar(requireUnion(), exports);\n  \t__exportStar(unknown, exports);\n  \t__exportStar(zodToJsonSchema$2, exports);\n  \tconst zodToJsonSchema_1 = zodToJsonSchema$2;\n  \texports.default = zodToJsonSchema_1.zodToJsonSchema;\n  \t\n  } (zodToJsonSchema$3));\n\n  Object.defineProperty(zod, \"__esModule\", { value: true });\n  zod.zodFunction = zod.zodResponseFormat = void 0;\n  const parser_1 = parser$1;\n  const zod_to_json_schema_1$2 = zodToJsonSchema$3;\n  function zodToJsonSchema(schema, options) {\n      return (0, zod_to_json_schema_1$2.zodToJsonSchema)(schema, {\n          openaiStrictMode: true,\n          name: options.name,\n          nameStrategy: 'duplicate-ref',\n          $refStrategy: 'extract-to-root',\n          nullableStrategy: 'property',\n      });\n  }\n  /**\n   * Creates a chat completion `JSONSchema` response format object from\n   * the given Zod schema.\n   *\n   * If this is passed to the `.parse()`, `.stream()` or `.runTools()`\n   * chat completion methods then the response message will contain a\n   * `.parsed` property that is the result of parsing the content with\n   * the given Zod object.\n   *\n   * ```ts\n   * const completion = await client.beta.chat.completions.parse({\n   *    model: 'gpt-4o-2024-08-06',\n   *    messages: [\n   *      { role: 'system', content: 'You are a helpful math tutor.' },\n   *      { role: 'user', content: 'solve 8x + 31 = 2' },\n   *    ],\n   *    response_format: zodResponseFormat(\n   *      z.object({\n   *        steps: z.array(z.object({\n   *          explanation: z.string(),\n   *          answer: z.string(),\n   *        })),\n   *        final_answer: z.string(),\n   *      }),\n   *      'math_answer',\n   *    ),\n   *  });\n   *  const message = completion.choices[0]?.message;\n   *  if (message?.parsed) {\n   *    console.log(message.parsed);\n   *    console.log(message.parsed.final_answer);\n   * }\n   * ```\n   *\n   * This can be passed directly to the `.create()` method but will not\n   * result in any automatic parsing, you'll have to parse the response yourself.\n   */\n  function zodResponseFormat(zodObject, name, props) {\n      return (0, parser_1.makeParseableResponseFormat)({\n          type: 'json_schema',\n          json_schema: {\n              ...props,\n              name,\n              strict: true,\n              schema: zodToJsonSchema(zodObject, { name }),\n          },\n      }, (content) => zodObject.parse(JSON.parse(content)));\n  }\n  zod.zodResponseFormat = zodResponseFormat;\n  /**\n   * Creates a chat completion `function` tool that can be invoked\n   * automatically by the chat completion `.runTools()` method or automatically\n   * parsed by `.parse()` / `.stream()`.\n   */\n  function zodFunction(options) {\n      // @ts-expect-error TODO\n      return (0, parser_1.makeParseableTool)({\n          type: 'function',\n          function: {\n              name: options.name,\n              parameters: zodToJsonSchema(options.parameters, { name: options.name }),\n              strict: true,\n              ...(options.description ? { description: options.description } : undefined),\n          },\n      }, {\n          callback: options.function,\n          parser: (args) => options.parameters.parse(JSON.parse(args)),\n      });\n  }\n  zod.zodFunction = zodFunction;\n\n  var azure = {};\n\n  Object.defineProperty(azure, \"__esModule\", { value: true });\n  azure.getEndpoint = void 0;\n  /**\n   * This function generates an endpoint URL for (Azure) OpenAI\n   * based on the configuration parameters provided.\n   *\n   * @param {OpenAIEndpointConfig} config - The configuration object for the (Azure) endpoint.\n   *\n   * @property {string} config.azureOpenAIApiDeploymentName - The deployment name of Azure OpenAI.\n   * @property {string} config.azureOpenAIApiInstanceName - The instance name of Azure OpenAI.\n   * @property {string} config.azureOpenAIApiKey - The API Key for Azure OpenAI.\n   * @property {string} config.azureOpenAIBasePath - The base path for Azure OpenAI.\n   * @property {string} config.baseURL - Some other custom base path URL.\n   *\n   * The function operates as follows:\n   * - If both `azureOpenAIBasePath` and `azureOpenAIApiDeploymentName` (plus `azureOpenAIApiKey`) are provided, it returns an URL combining these two parameters (`${azureOpenAIBasePath}/${azureOpenAIApiDeploymentName}`).\n   * - If `azureOpenAIApiKey` is provided, it checks for `azureOpenAIApiInstanceName` and `azureOpenAIApiDeploymentName` and throws an error if any of these is missing. If both are provided, it generates an URL incorporating these parameters.\n   * - If none of the above conditions are met, return any custom `baseURL`.\n   * - The function returns the generated URL as a string, or undefined if no custom paths are specified.\n   *\n   * @throws Will throw an error if the necessary parameters for generating the URL are missing.\n   *\n   * @returns {string | undefined} The generated (Azure) OpenAI endpoint URL.\n   */\n  function getEndpoint(config) {\n      const { azureOpenAIApiDeploymentName, azureOpenAIApiInstanceName, azureOpenAIApiKey, azureOpenAIBasePath, baseURL, azureADTokenProvider, } = config;\n      if ((azureOpenAIApiKey || azureADTokenProvider) &&\n          azureOpenAIBasePath &&\n          azureOpenAIApiDeploymentName) {\n          return `${azureOpenAIBasePath}/${azureOpenAIApiDeploymentName}`;\n      }\n      if (azureOpenAIApiKey || azureADTokenProvider) {\n          if (!azureOpenAIApiInstanceName) {\n              throw new Error(\"azureOpenAIApiInstanceName is required when using azureOpenAIApiKey\");\n          }\n          if (!azureOpenAIApiDeploymentName) {\n              throw new Error(\"azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey\");\n          }\n          return `https://${azureOpenAIApiInstanceName}.openai.azure.com/openai/deployments/${azureOpenAIApiDeploymentName}`;\n      }\n      return baseURL;\n  }\n  azure.getEndpoint = getEndpoint;\n\n  var openai$1 = {};\n\n  var function_calling$1 = {};\n\n  Object.defineProperty(function_calling$1, \"__esModule\", { value: true });\n  function_calling$1.isLangChainTool = function_calling$1.isStructuredToolParams = function_calling$1.isRunnableToolLike = function_calling$1.isStructuredTool = function_calling$1.convertToOpenAITool = function_calling$1.convertToOpenAIFunction = void 0;\n  const zod_to_json_schema_1$1 = messages$1.cjs;\n  const base_js_1$1 = messages$1.base;\n  const is_zod_schema_js_1 = is_zod_schema;\n  /**\n   * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n   * that is compatible with OpenAI function calling. It uses the `zodToJsonSchema`\n   * function to convert the schema of the `StructuredTool` or `RunnableToolLike`\n   * into a JSON schema, which is then used as the parameters for the OpenAI function.\n   *\n   * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n   * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n   */\n  function convertToOpenAIFunction(tool, fields) {\n      // @TODO 0.3.0 Remove the `number` typing\n      const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n      return {\n          name: tool.name,\n          description: tool.description,\n          parameters: (0, zod_to_json_schema_1$1.zodToJsonSchema)(tool.schema),\n          // Do not include the `strict` field if it is `undefined`.\n          ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n      };\n  }\n  function_calling$1.convertToOpenAIFunction = convertToOpenAIFunction;\n  /**\n   * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n   * format that is compatible with OpenAI tool calling. It uses the\n   * `zodToJsonSchema` function to convert the schema of the `StructuredTool`\n   * or `RunnableToolLike` into a JSON schema, which is then used as the\n   * parameters for the OpenAI tool.\n   *\n   * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n   * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n   */\n  function convertToOpenAITool(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tool, fields) {\n      // @TODO 0.3.0 Remove the `number` typing\n      const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n      let toolDef;\n      if (isLangChainTool(tool)) {\n          toolDef = {\n              type: \"function\",\n              function: convertToOpenAIFunction(tool),\n          };\n      }\n      else {\n          toolDef = tool;\n      }\n      if (fieldsCopy?.strict !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          toolDef.function.strict = fieldsCopy.strict;\n      }\n      return toolDef;\n  }\n  function_calling$1.convertToOpenAITool = convertToOpenAITool;\n  /**\n   * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n   *\n   * @param {StructuredToolInterface | Record<string, any> | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n   * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n   */\n  function isStructuredTool(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tool) {\n      return (tool !== undefined &&\n          Array.isArray(tool.lc_namespace));\n  }\n  function_calling$1.isStructuredTool = isStructuredTool;\n  /**\n   * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n   *\n   * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n   * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n   */\n  function isRunnableToolLike(tool) {\n      return (tool !== undefined &&\n          base_js_1$1.Runnable.isRunnable(tool) &&\n          \"lc_name\" in tool.constructor &&\n          typeof tool.constructor.lc_name === \"function\" &&\n          tool.constructor.lc_name() === \"RunnableToolLike\");\n  }\n  function_calling$1.isRunnableToolLike = isRunnableToolLike;\n  /**\n   * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n   *\n   * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n   * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n   */\n  function isStructuredToolParams(tool) {\n      return (!!tool &&\n          typeof tool === \"object\" &&\n          \"name\" in tool &&\n          \"schema\" in tool &&\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (0, is_zod_schema_js_1.isZodSchema)(tool.schema));\n  }\n  function_calling$1.isStructuredToolParams = isStructuredToolParams;\n  /**\n   * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n   * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n   * while still containing the necessary properties to be passed to a LLM for tool calling.\n   *\n   * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n   * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n   */\n  function isLangChainTool(tool) {\n      return (isStructuredToolParams(tool) ||\n          isRunnableToolLike(tool) ||\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          isStructuredTool(tool));\n  }\n  function_calling$1.isLangChainTool = isLangChainTool;\n\n  var function_calling = function_calling$1;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.formatToOpenAIToolChoice = exports.formatToOpenAIAssistantTool = exports.formatToOpenAITool = exports.formatToOpenAIFunction = exports.wrapOpenAIClientError = void 0;\n  \tconst openai_1 = openaiExports;\n  \tconst zod_to_json_schema_1 = messages$1.cjs;\n  \tconst function_calling_1 = function_calling;\n  \tObject.defineProperty(exports, \"formatToOpenAIFunction\", { enumerable: true, get: function () { return function_calling_1.convertToOpenAIFunction; } });\n  \tObject.defineProperty(exports, \"formatToOpenAITool\", { enumerable: true, get: function () { return function_calling_1.convertToOpenAITool; } });\n  \t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \tfunction wrapOpenAIClientError(e) {\n  \t    let error;\n  \t    if (e.constructor.name === openai_1.APIConnectionTimeoutError.name) {\n  \t        error = new Error(e.message);\n  \t        error.name = \"TimeoutError\";\n  \t    }\n  \t    else if (e.constructor.name === openai_1.APIUserAbortError.name) {\n  \t        error = new Error(e.message);\n  \t        error.name = \"AbortError\";\n  \t    }\n  \t    else {\n  \t        error = e;\n  \t    }\n  \t    return error;\n  \t}\n  \texports.wrapOpenAIClientError = wrapOpenAIClientError;\n  \tfunction formatToOpenAIAssistantTool(tool) {\n  \t    return {\n  \t        type: \"function\",\n  \t        function: {\n  \t            name: tool.name,\n  \t            description: tool.description,\n  \t            parameters: (0, zod_to_json_schema_1.zodToJsonSchema)(tool.schema),\n  \t        },\n  \t    };\n  \t}\n  \texports.formatToOpenAIAssistantTool = formatToOpenAIAssistantTool;\n  \tfunction formatToOpenAIToolChoice(toolChoice) {\n  \t    if (!toolChoice) {\n  \t        return undefined;\n  \t    }\n  \t    else if (toolChoice === \"any\" || toolChoice === \"required\") {\n  \t        return \"required\";\n  \t    }\n  \t    else if (toolChoice === \"auto\") {\n  \t        return \"auto\";\n  \t    }\n  \t    else if (toolChoice === \"none\") {\n  \t        return \"none\";\n  \t    }\n  \t    else if (typeof toolChoice === \"string\") {\n  \t        return {\n  \t            type: \"function\",\n  \t            function: {\n  \t                name: toolChoice,\n  \t            },\n  \t        };\n  \t    }\n  \t    else {\n  \t        return toolChoice;\n  \t    }\n  \t}\n  \texports.formatToOpenAIToolChoice = formatToOpenAIToolChoice; \n  } (openai$1));\n\n  var openaiFormatFndef = {};\n\n  Object.defineProperty(openaiFormatFndef, \"__esModule\", { value: true });\n  openaiFormatFndef.formatFunctionDefinitions = void 0;\n  function isAnyOfProp(prop) {\n      return (prop.anyOf !== undefined &&\n          Array.isArray(prop.anyOf));\n  }\n  // When OpenAI use functions in the prompt, they format them as TypeScript definitions rather than OpenAPI JSON schemas.\n  // This function converts the JSON schemas into TypeScript definitions.\n  function formatFunctionDefinitions(functions) {\n      const lines = [\"namespace functions {\", \"\"];\n      for (const f of functions) {\n          if (f.description) {\n              lines.push(`// ${f.description}`);\n          }\n          if (Object.keys(f.parameters.properties ?? {}).length > 0) {\n              lines.push(`type ${f.name} = (_: {`);\n              lines.push(formatObjectProperties(f.parameters, 0));\n              lines.push(\"}) => any;\");\n          }\n          else {\n              lines.push(`type ${f.name} = () => any;`);\n          }\n          lines.push(\"\");\n      }\n      lines.push(\"} // namespace functions\");\n      return lines.join(\"\\n\");\n  }\n  openaiFormatFndef.formatFunctionDefinitions = formatFunctionDefinitions;\n  // Format just the properties of an object (not including the surrounding braces)\n  function formatObjectProperties(obj, indent) {\n      const lines = [];\n      for (const [name, param] of Object.entries(obj.properties ?? {})) {\n          if (param.description && indent < 2) {\n              lines.push(`// ${param.description}`);\n          }\n          if (obj.required?.includes(name)) {\n              lines.push(`${name}: ${formatType(param, indent)},`);\n          }\n          else {\n              lines.push(`${name}?: ${formatType(param, indent)},`);\n          }\n      }\n      return lines.map((line) => \" \".repeat(indent) + line).join(\"\\n\");\n  }\n  // Format a single property type\n  function formatType(param, indent) {\n      if (isAnyOfProp(param)) {\n          return param.anyOf.map((v) => formatType(v, indent)).join(\" | \");\n      }\n      switch (param.type) {\n          case \"string\":\n              if (param.enum) {\n                  return param.enum.map((v) => `\"${v}\"`).join(\" | \");\n              }\n              return \"string\";\n          case \"number\":\n              if (param.enum) {\n                  return param.enum.map((v) => `${v}`).join(\" | \");\n              }\n              return \"number\";\n          case \"integer\":\n              if (param.enum) {\n                  return param.enum.map((v) => `${v}`).join(\" | \");\n              }\n              return \"number\";\n          case \"boolean\":\n              return \"boolean\";\n          case \"null\":\n              return \"null\";\n          case \"object\":\n              return [\"{\", formatObjectProperties(param, indent + 2), \"}\"].join(\"\\n\");\n          case \"array\":\n              if (param.items) {\n                  return `${formatType(param.items, indent)}[]`;\n              }\n              return \"any[]\";\n          default:\n              return \"\";\n      }\n  }\n\n  var tools$3 = {};\n\n  Object.defineProperty(tools$3, \"__esModule\", { value: true });\n  tools$3._convertToOpenAITool = void 0;\n  const function_calling_1 = function_calling;\n  const zod_1$1 = zod;\n  /**\n   * Formats a tool in either OpenAI format, or LangChain structured tool format\n   * into an OpenAI tool format. If the tool is already in OpenAI format, return without\n   * any changes. If it is in LangChain structured tool format, convert it to OpenAI tool format\n   * using OpenAI's `zodFunction` util, falling back to `convertToOpenAIFunction` if the parameters\n   * returned from the `zodFunction` util are not defined.\n   *\n   * @param {BindToolsInput} tool The tool to convert to an OpenAI tool.\n   * @param {Object} [fields] Additional fields to add to the OpenAI tool.\n   * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n   */\n  function _convertToOpenAITool(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tool, fields) {\n      let toolDef;\n      if ((0, function_calling_1.isLangChainTool)(tool)) {\n          const oaiToolDef = (0, zod_1$1.zodFunction)({\n              name: tool.name,\n              parameters: tool.schema,\n              description: tool.description,\n          });\n          if (!oaiToolDef.function.parameters) {\n              // Fallback to the `convertToOpenAIFunction` util if the parameters are not defined.\n              toolDef = {\n                  type: \"function\",\n                  function: (0, function_calling_1.convertToOpenAIFunction)(tool, fields),\n              };\n          }\n          else {\n              toolDef = {\n                  type: oaiToolDef.type,\n                  function: {\n                      name: oaiToolDef.function.name,\n                      description: oaiToolDef.function.description,\n                      parameters: oaiToolDef.function.parameters,\n                      ...(fields?.strict !== undefined ? { strict: fields.strict } : {}),\n                  },\n              };\n          }\n      }\n      else {\n          toolDef = tool;\n      }\n      if (fields?.strict !== undefined) {\n          toolDef.function.strict = fields.strict;\n      }\n      return toolDef;\n  }\n  tools$3._convertToOpenAITool = _convertToOpenAITool;\n\n  Object.defineProperty(chat_models$3, \"__esModule\", { value: true });\n  chat_models$3.ChatOpenAI = chat_models$3._convertMessagesToOpenAIParams = chat_models$3.messageToOpenAIRole = void 0;\n  const openai_1$6 = openaiExports;\n  const messages_1 = messages$1.messages;\n  const outputs_1$1 = outputs;\n  const env_1$3 = env;\n  const chat_models_1 = chat_models$1;\n  const base_1 = base$1;\n  const runnables_1 = runnables;\n  const output_parsers_1 = output_parsers;\n  const openai_tools_1 = openai_tools;\n  const zod_to_json_schema_1 = messages$1.cjs;\n  const zod_1 = zod;\n  const azure_js_1$5 = azure;\n  const openai_js_1$3 = openai$1;\n  const openai_format_fndef_js_1 = openaiFormatFndef;\n  const tools_js_1 = tools$3;\n  function extractGenericMessageCustomRole(message) {\n      if (message.role !== \"system\" &&\n          message.role !== \"assistant\" &&\n          message.role !== \"user\" &&\n          message.role !== \"function\" &&\n          message.role !== \"tool\") {\n          console.warn(`Unknown message role: ${message.role}`);\n      }\n      return message.role;\n  }\n  function messageToOpenAIRole(message) {\n      const type = message._getType();\n      switch (type) {\n          case \"system\":\n              return \"system\";\n          case \"ai\":\n              return \"assistant\";\n          case \"human\":\n              return \"user\";\n          case \"function\":\n              return \"function\";\n          case \"tool\":\n              return \"tool\";\n          case \"generic\": {\n              if (!messages_1.ChatMessage.isInstance(message))\n                  throw new Error(\"Invalid generic chat message\");\n              return extractGenericMessageCustomRole(message);\n          }\n          default:\n              throw new Error(`Unknown message type: ${type}`);\n      }\n  }\n  chat_models$3.messageToOpenAIRole = messageToOpenAIRole;\n  function openAIResponseToChatMessage(message, rawResponse, includeRawResponse) {\n      const rawToolCalls = message.tool_calls;\n      switch (message.role) {\n          case \"assistant\": {\n              const toolCalls = [];\n              const invalidToolCalls = [];\n              for (const rawToolCall of rawToolCalls ?? []) {\n                  try {\n                      toolCalls.push((0, openai_tools_1.parseToolCall)(rawToolCall, { returnId: true }));\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  }\n                  catch (e) {\n                      invalidToolCalls.push((0, openai_tools_1.makeInvalidToolCall)(rawToolCall, e.message));\n                  }\n              }\n              const additional_kwargs = {\n                  function_call: message.function_call,\n                  tool_calls: rawToolCalls,\n              };\n              if (includeRawResponse !== undefined) {\n                  additional_kwargs.__raw_response = rawResponse;\n              }\n              let response_metadata;\n              if (rawResponse.system_fingerprint) {\n                  response_metadata = {\n                      system_fingerprint: rawResponse.system_fingerprint,\n                  };\n              }\n              return new messages_1.AIMessage({\n                  content: message.content || \"\",\n                  tool_calls: toolCalls,\n                  invalid_tool_calls: invalidToolCalls,\n                  additional_kwargs,\n                  response_metadata,\n                  id: rawResponse.id,\n              });\n          }\n          default:\n              return new messages_1.ChatMessage(message.content || \"\", message.role ?? \"unknown\");\n      }\n  }\n  function _convertDeltaToMessageChunk(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  delta, rawResponse, defaultRole, includeRawResponse) {\n      const role = delta.role ?? defaultRole;\n      const content = delta.content ?? \"\";\n      let additional_kwargs;\n      if (delta.function_call) {\n          additional_kwargs = {\n              function_call: delta.function_call,\n          };\n      }\n      else if (delta.tool_calls) {\n          additional_kwargs = {\n              tool_calls: delta.tool_calls,\n          };\n      }\n      else {\n          additional_kwargs = {};\n      }\n      if (includeRawResponse) {\n          additional_kwargs.__raw_response = rawResponse;\n      }\n      if (role === \"user\") {\n          return new messages_1.HumanMessageChunk({ content });\n      }\n      else if (role === \"assistant\") {\n          const toolCallChunks = [];\n          if (Array.isArray(delta.tool_calls)) {\n              for (const rawToolCall of delta.tool_calls) {\n                  toolCallChunks.push({\n                      name: rawToolCall.function?.name,\n                      args: rawToolCall.function?.arguments,\n                      id: rawToolCall.id,\n                      index: rawToolCall.index,\n                      type: \"tool_call_chunk\",\n                  });\n              }\n          }\n          return new messages_1.AIMessageChunk({\n              content,\n              tool_call_chunks: toolCallChunks,\n              additional_kwargs,\n              id: rawResponse.id,\n          });\n      }\n      else if (role === \"system\") {\n          return new messages_1.SystemMessageChunk({ content });\n      }\n      else if (role === \"function\") {\n          return new messages_1.FunctionMessageChunk({\n              content,\n              additional_kwargs,\n              name: delta.name,\n          });\n      }\n      else if (role === \"tool\") {\n          return new messages_1.ToolMessageChunk({\n              content,\n              additional_kwargs,\n              tool_call_id: delta.tool_call_id,\n          });\n      }\n      else {\n          return new messages_1.ChatMessageChunk({ content, role });\n      }\n  }\n  // Used in LangSmith, export is important here\n  function _convertMessagesToOpenAIParams(messages) {\n      // TODO: Function messages do not support array content, fix cast\n      return messages.map((message) => {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const completionParam = {\n              role: messageToOpenAIRole(message),\n              content: message.content,\n          };\n          if (message.name != null) {\n              completionParam.name = message.name;\n          }\n          if (message.additional_kwargs.function_call != null) {\n              completionParam.function_call = message.additional_kwargs.function_call;\n              completionParam.content = null;\n          }\n          if ((0, messages_1.isAIMessage)(message) && !!message.tool_calls?.length) {\n              completionParam.tool_calls = message.tool_calls.map(openai_tools_1.convertLangChainToolCallToOpenAI);\n              completionParam.content = null;\n          }\n          else {\n              if (message.additional_kwargs.tool_calls != null) {\n                  completionParam.tool_calls = message.additional_kwargs.tool_calls;\n              }\n              if (message.tool_call_id != null) {\n                  completionParam.tool_call_id = message.tool_call_id;\n              }\n          }\n          return completionParam;\n      });\n  }\n  chat_models$3._convertMessagesToOpenAIParams = _convertMessagesToOpenAIParams;\n  function _convertChatOpenAIToolTypeToOpenAITool(tool, fields) {\n      if ((0, base_1.isOpenAITool)(tool)) {\n          if (fields?.strict !== undefined) {\n              return {\n                  ...tool,\n                  function: {\n                      ...tool.function,\n                      strict: fields.strict,\n                  },\n              };\n          }\n          return tool;\n      }\n      return (0, tools_js_1._convertToOpenAITool)(tool, fields);\n  }\n  /**\n   * OpenAI chat model integration.\n   *\n   * Setup:\n   * Install `@langchain/openai` and set an environment variable named `OPENAI_API_KEY`.\n   *\n   * ```bash\n   * npm install @langchain/openai\n   * export OPENAI_API_KEY=\"your-api-key\"\n   * ```\n   *\n   * ## [Constructor args](https://api.js.langchain.com/classes/langchain_openai.ChatOpenAI.html#constructor)\n   *\n   * ## [Runtime args](https://api.js.langchain.com/interfaces/langchain_openai.ChatOpenAICallOptions.html)\n   *\n   * Runtime args can be passed as the second argument to any of the base runnable methods `.invoke`. `.stream`, `.batch`, etc.\n   * They can also be passed via `.bind`, or the second arg in `.bindTools`, like shown in the examples below:\n   *\n   * ```typescript\n   * // When calling `.bind`, call options should be passed via the first argument\n   * const llmWithArgsBound = llm.bind({\n   *   stop: [\"\\n\"],\n   *   tools: [...],\n   * });\n   *\n   * // When calling `.bindTools`, call options should be passed via the second argument\n   * const llmWithTools = llm.bindTools(\n   *   [...],\n   *   {\n   *     tool_choice: \"auto\",\n   *   }\n   * );\n   * ```\n   *\n   * ## Examples\n   *\n   * <details open>\n   * <summary><strong>Instantiate</strong></summary>\n   *\n   * ```typescript\n   * import { ChatOpenAI } from '@langchain/openai';\n   *\n   * const llm = new ChatOpenAI({\n   *   model: \"gpt-4o\",\n   *   temperature: 0,\n   *   maxTokens: undefined,\n   *   timeout: undefined,\n   *   maxRetries: 2,\n   *   // apiKey: \"...\",\n   *   // baseUrl: \"...\",\n   *   // organization: \"...\",\n   *   // other params...\n   * });\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Invoking</strong></summary>\n   *\n   * ```typescript\n   * const input = `Translate \"I love programming\" into French.`;\n   *\n   * // Models also accept a list of chat messages or a formatted prompt\n   * const result = await llm.invoke(input);\n   * console.log(result);\n   * ```\n   *\n   * ```txt\n   * AIMessage {\n   *   \"id\": \"chatcmpl-9u4Mpu44CbPjwYFkTbeoZgvzB00Tz\",\n   *   \"content\": \"J'adore la programmation.\",\n   *   \"response_metadata\": {\n   *     \"tokenUsage\": {\n   *       \"completionTokens\": 5,\n   *       \"promptTokens\": 28,\n   *       \"totalTokens\": 33\n   *     },\n   *     \"finish_reason\": \"stop\",\n   *     \"system_fingerprint\": \"fp_3aa7262c27\"\n   *   },\n   *   \"usage_metadata\": {\n   *     \"input_tokens\": 28,\n   *     \"output_tokens\": 5,\n   *     \"total_tokens\": 33\n   *   }\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Streaming Chunks</strong></summary>\n   *\n   * ```typescript\n   * for await (const chunk of await llm.stream(input)) {\n   *   console.log(chunk);\n   * }\n   * ```\n   *\n   * ```txt\n   * AIMessageChunk {\n   *   \"id\": \"chatcmpl-9u4NWB7yUeHCKdLr6jP3HpaOYHTqs\",\n   *   \"content\": \"\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"J\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"'adore\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \" la\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \" programmation\",,\n   * }\n   * AIMessageChunk {\n   *   \"content\": \".\",,\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"\",\n   *   \"response_metadata\": {\n   *     \"finish_reason\": \"stop\",\n   *     \"system_fingerprint\": \"fp_c9aa9c0491\"\n   *   },\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"\",\n   *   \"usage_metadata\": {\n   *     \"input_tokens\": 28,\n   *     \"output_tokens\": 5,\n   *     \"total_tokens\": 33\n   *   }\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Aggregate Streamed Chunks</strong></summary>\n   *\n   * ```typescript\n   * import { AIMessageChunk } from '@langchain/core/messages';\n   * import { concat } from '@langchain/core/utils/stream';\n   *\n   * const stream = await llm.stream(input);\n   * let full: AIMessageChunk | undefined;\n   * for await (const chunk of stream) {\n   *   full = !full ? chunk : concat(full, chunk);\n   * }\n   * console.log(full);\n   * ```\n   *\n   * ```txt\n   * AIMessageChunk {\n   *   \"id\": \"chatcmpl-9u4PnX6Fy7OmK46DASy0bH6cxn5Xu\",\n   *   \"content\": \"J'adore la programmation.\",\n   *   \"response_metadata\": {\n   *     \"prompt\": 0,\n   *     \"completion\": 0,\n   *     \"finish_reason\": \"stop\",\n   *   },\n   *   \"usage_metadata\": {\n   *     \"input_tokens\": 28,\n   *     \"output_tokens\": 5,\n   *     \"total_tokens\": 33\n   *   }\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Bind tools</strong></summary>\n   *\n   * ```typescript\n   * import { z } from 'zod';\n   *\n   * const GetWeather = {\n   *   name: \"GetWeather\",\n   *   description: \"Get the current weather in a given location\",\n   *   schema: z.object({\n   *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n   *   }),\n   * }\n   *\n   * const GetPopulation = {\n   *   name: \"GetPopulation\",\n   *   description: \"Get the current population in a given location\",\n   *   schema: z.object({\n   *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n   *   }),\n   * }\n   *\n   * const llmWithTools = llm.bindTools(\n   *   [GetWeather, GetPopulation],\n   *   {\n   *     // strict: true  // enforce tool args schema is respected\n   *   }\n   * );\n   * const aiMsg = await llmWithTools.invoke(\n   *   \"Which city is hotter today and which is bigger: LA or NY?\"\n   * );\n   * console.log(aiMsg.tool_calls);\n   * ```\n   *\n   * ```txt\n   * [\n   *   {\n   *     name: 'GetWeather',\n   *     args: { location: 'Los Angeles, CA' },\n   *     type: 'tool_call',\n   *     id: 'call_uPU4FiFzoKAtMxfmPnfQL6UK'\n   *   },\n   *   {\n   *     name: 'GetWeather',\n   *     args: { location: 'New York, NY' },\n   *     type: 'tool_call',\n   *     id: 'call_UNkEwuQsHrGYqgDQuH9nPAtX'\n   *   },\n   *   {\n   *     name: 'GetPopulation',\n   *     args: { location: 'Los Angeles, CA' },\n   *     type: 'tool_call',\n   *     id: 'call_kL3OXxaq9OjIKqRTpvjaCH14'\n   *   },\n   *   {\n   *     name: 'GetPopulation',\n   *     args: { location: 'New York, NY' },\n   *     type: 'tool_call',\n   *     id: 'call_s9KQB1UWj45LLGaEnjz0179q'\n   *   }\n   * ]\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Structured Output</strong></summary>\n   *\n   * ```typescript\n   * import { z } from 'zod';\n   *\n   * const Joke = z.object({\n   *   setup: z.string().describe(\"The setup of the joke\"),\n   *   punchline: z.string().describe(\"The punchline to the joke\"),\n   *   rating: z.number().optional().describe(\"How funny the joke is, from 1 to 10\")\n   * }).describe('Joke to tell user.');\n   *\n   * const structuredLlm = llm.withStructuredOutput(Joke, { name: \"Joke\" });\n   * const jokeResult = await structuredLlm.invoke(\"Tell me a joke about cats\");\n   * console.log(jokeResult);\n   * ```\n   *\n   * ```txt\n   * {\n   *   setup: 'Why was the cat sitting on the computer?',\n   *   punchline: 'Because it wanted to keep an eye on the mouse!',\n   *   rating: 7\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>JSON Object Response Format</strong></summary>\n   *\n   * ```typescript\n   * const jsonLlm = llm.bind({ response_format: { type: \"json_object\" } });\n   * const jsonLlmAiMsg = await jsonLlm.invoke(\n   *   \"Return a JSON object with key 'randomInts' and a value of 10 random ints in [0-99]\"\n   * );\n   * console.log(jsonLlmAiMsg.content);\n   * ```\n   *\n   * ```txt\n   * {\n   *   \"randomInts\": [23, 87, 45, 12, 78, 34, 56, 90, 11, 67]\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Multimodal</strong></summary>\n   *\n   * ```typescript\n   * import { HumanMessage } from '@langchain/core/messages';\n   *\n   * const imageUrl = \"https://example.com/image.jpg\";\n   * const imageData = await fetch(imageUrl).then(res => res.arrayBuffer());\n   * const base64Image = Buffer.from(imageData).toString('base64');\n   *\n   * const message = new HumanMessage({\n   *   content: [\n   *     { type: \"text\", text: \"describe the weather in this image\" },\n   *     {\n   *       type: \"image_url\",\n   *       image_url: { url: `data:image/jpeg;base64,${base64Image}` },\n   *     },\n   *   ]\n   * });\n   *\n   * const imageDescriptionAiMsg = await llm.invoke([message]);\n   * console.log(imageDescriptionAiMsg.content);\n   * ```\n   *\n   * ```txt\n   * The weather in the image appears to be clear and sunny. The sky is mostly blue with a few scattered white clouds, indicating fair weather. The bright sunlight is casting shadows on the green, grassy hill, suggesting it is a pleasant day with good visibility. There are no signs of rain or stormy conditions.\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Usage Metadata</strong></summary>\n   *\n   * ```typescript\n   * const aiMsgForMetadata = await llm.invoke(input);\n   * console.log(aiMsgForMetadata.usage_metadata);\n   * ```\n   *\n   * ```txt\n   * { input_tokens: 28, output_tokens: 5, total_tokens: 33 }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Logprobs</strong></summary>\n   *\n   * ```typescript\n   * const logprobsLlm = new ChatOpenAI({ logprobs: true });\n   * const aiMsgForLogprobs = await logprobsLlm.invoke(input);\n   * console.log(aiMsgForLogprobs.response_metadata.logprobs);\n   * ```\n   *\n   * ```txt\n   * {\n   *   content: [\n   *     {\n   *       token: 'J',\n   *       logprob: -0.000050616763,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     {\n   *       token: \"'\",\n   *       logprob: -0.01868736,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     {\n   *       token: 'ad',\n   *       logprob: -0.0000030545007,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     { token: 'ore', logprob: 0, bytes: [Array], top_logprobs: [] },\n   *     {\n   *       token: ' la',\n   *       logprob: -0.515404,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     {\n   *       token: ' programm',\n   *       logprob: -0.0000118755715,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     { token: 'ation', logprob: 0, bytes: [Array], top_logprobs: [] },\n   *     {\n   *       token: '.',\n   *       logprob: -0.0000037697225,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     }\n   *   ],\n   *   refusal: null\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Response Metadata</strong></summary>\n   *\n   * ```typescript\n   * const aiMsgForResponseMetadata = await llm.invoke(input);\n   * console.log(aiMsgForResponseMetadata.response_metadata);\n   * ```\n   *\n   * ```txt\n   * {\n   *   tokenUsage: { completionTokens: 5, promptTokens: 28, totalTokens: 33 },\n   *   finish_reason: 'stop',\n   *   system_fingerprint: 'fp_3aa7262c27'\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>JSON Schema Structured Output</strong></summary>\n   *\n   * ```typescript\n   * const llmForJsonSchema = new ChatOpenAI({\n   *   model: \"gpt-4o-2024-08-06\",\n   * }).withStructuredOutput(\n   *   z.object({\n   *     command: z.string().describe(\"The command to execute\"),\n   *     expectedOutput: z.string().describe(\"The expected output of the command\"),\n   *     options: z\n   *       .array(z.string())\n   *       .describe(\"The options you can pass to the command\"),\n   *   }),\n   *   {\n   *     method: \"jsonSchema\",\n   *     strict: true, // Optional when using the `jsonSchema` method\n   *   }\n   * );\n   *\n   * const jsonSchemaRes = await llmForJsonSchema.invoke(\n   *   \"What is the command to list files in a directory?\"\n   * );\n   * console.log(jsonSchemaRes);\n   * ```\n   *\n   * ```txt\n   * {\n   *   command: 'ls',\n   *   expectedOutput: 'A list of files and subdirectories within the specified directory.',\n   *   options: [\n   *     '-a: include directory entries whose names begin with a dot (.).',\n   *     '-l: use a long listing format.',\n   *     '-h: with -l, print sizes in human readable format (e.g., 1K, 234M, 2G).',\n   *     '-t: sort by time, newest first.',\n   *     '-r: reverse order while sorting.',\n   *     '-S: sort by file size, largest first.',\n   *     '-R: list subdirectories recursively.'\n   *   ]\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   */\n  class ChatOpenAI extends chat_models_1.BaseChatModel {\n      static lc_name() {\n          return \"ChatOpenAI\";\n      }\n      get callKeys() {\n          return [\n              ...super.callKeys,\n              \"options\",\n              \"function_call\",\n              \"functions\",\n              \"tools\",\n              \"tool_choice\",\n              \"promptIndex\",\n              \"response_format\",\n              \"seed\",\n          ];\n      }\n      get lc_secrets() {\n          return {\n              openAIApiKey: \"OPENAI_API_KEY\",\n              apiKey: \"OPENAI_API_KEY\",\n              azureOpenAIApiKey: \"AZURE_OPENAI_API_KEY\",\n              organization: \"OPENAI_ORGANIZATION\",\n          };\n      }\n      get lc_aliases() {\n          return {\n              modelName: \"model\",\n              openAIApiKey: \"openai_api_key\",\n              apiKey: \"openai_api_key\",\n              azureOpenAIApiVersion: \"azure_openai_api_version\",\n              azureOpenAIApiKey: \"azure_openai_api_key\",\n              azureOpenAIApiInstanceName: \"azure_openai_api_instance_name\",\n              azureOpenAIApiDeploymentName: \"azure_openai_api_deployment_name\",\n          };\n      }\n      constructor(fields, \n      /** @deprecated */\n      configuration) {\n          super(fields ?? {});\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"temperature\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 1\n          });\n          Object.defineProperty(this, \"topP\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 1\n          });\n          Object.defineProperty(this, \"frequencyPenalty\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 0\n          });\n          Object.defineProperty(this, \"presencePenalty\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 0\n          });\n          Object.defineProperty(this, \"n\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 1\n          });\n          Object.defineProperty(this, \"logitBias\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"modelName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"gpt-3.5-turbo\"\n          });\n          Object.defineProperty(this, \"model\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"gpt-3.5-turbo\"\n          });\n          Object.defineProperty(this, \"modelKwargs\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"stop\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"stopSequences\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"user\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"timeout\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"streaming\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: false\n          });\n          Object.defineProperty(this, \"streamUsage\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"maxTokens\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"logprobs\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"topLogprobs\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"openAIApiKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"apiKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiVersion\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureADTokenProvider\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiInstanceName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiDeploymentName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIBasePath\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"organization\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"__includeRawResponse\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"client\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"clientConfig\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          /**\n           * Whether the model supports the `strict` argument when passing in tools.\n           * If `undefined` the `strict` argument will not be passed to OpenAI.\n           */\n          Object.defineProperty(this, \"supportsStrictToolCalling\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.openAIApiKey =\n              fields?.apiKey ??\n                  fields?.openAIApiKey ??\n                  fields?.configuration?.apiKey ??\n                  (0, env_1$3.getEnvironmentVariable)(\"OPENAI_API_KEY\");\n          this.apiKey = this.openAIApiKey;\n          this.azureOpenAIApiKey =\n              fields?.azureOpenAIApiKey ??\n                  (0, env_1$3.getEnvironmentVariable)(\"AZURE_OPENAI_API_KEY\");\n          this.azureADTokenProvider = fields?.azureADTokenProvider ?? undefined;\n          if (!this.azureOpenAIApiKey && !this.apiKey && !this.azureADTokenProvider) {\n              throw new Error(\"OpenAI or Azure OpenAI API key or Token Provider not found\");\n          }\n          this.azureOpenAIApiInstanceName =\n              fields?.azureOpenAIApiInstanceName ??\n                  (0, env_1$3.getEnvironmentVariable)(\"AZURE_OPENAI_API_INSTANCE_NAME\");\n          this.azureOpenAIApiDeploymentName =\n              fields?.azureOpenAIApiDeploymentName ??\n                  (0, env_1$3.getEnvironmentVariable)(\"AZURE_OPENAI_API_DEPLOYMENT_NAME\");\n          this.azureOpenAIApiVersion =\n              fields?.azureOpenAIApiVersion ??\n                  (0, env_1$3.getEnvironmentVariable)(\"AZURE_OPENAI_API_VERSION\");\n          this.azureOpenAIBasePath =\n              fields?.azureOpenAIBasePath ??\n                  (0, env_1$3.getEnvironmentVariable)(\"AZURE_OPENAI_BASE_PATH\");\n          this.organization =\n              fields?.configuration?.organization ??\n                  (0, env_1$3.getEnvironmentVariable)(\"OPENAI_ORGANIZATION\");\n          this.modelName = fields?.model ?? fields?.modelName ?? this.model;\n          this.model = this.modelName;\n          this.modelKwargs = fields?.modelKwargs ?? {};\n          this.timeout = fields?.timeout;\n          this.temperature = fields?.temperature ?? this.temperature;\n          this.topP = fields?.topP ?? this.topP;\n          this.frequencyPenalty = fields?.frequencyPenalty ?? this.frequencyPenalty;\n          this.presencePenalty = fields?.presencePenalty ?? this.presencePenalty;\n          this.maxTokens = fields?.maxTokens;\n          this.logprobs = fields?.logprobs;\n          this.topLogprobs = fields?.topLogprobs;\n          this.n = fields?.n ?? this.n;\n          this.logitBias = fields?.logitBias;\n          this.stop = fields?.stopSequences ?? fields?.stop;\n          this.stopSequences = this?.stop;\n          this.user = fields?.user;\n          this.__includeRawResponse = fields?.__includeRawResponse;\n          if (this.azureOpenAIApiKey || this.azureADTokenProvider) {\n              if (!this.azureOpenAIApiInstanceName && !this.azureOpenAIBasePath) {\n                  throw new Error(\"Azure OpenAI API instance name not found\");\n              }\n              if (!this.azureOpenAIApiDeploymentName) {\n                  throw new Error(\"Azure OpenAI API deployment name not found\");\n              }\n              if (!this.azureOpenAIApiVersion) {\n                  throw new Error(\"Azure OpenAI API version not found\");\n              }\n              this.apiKey = this.apiKey ?? \"\";\n              // Streaming usage is not supported by Azure deployments, so default to false\n              this.streamUsage = false;\n          }\n          this.streaming = fields?.streaming ?? false;\n          this.streamUsage = fields?.streamUsage ?? this.streamUsage;\n          this.clientConfig = {\n              apiKey: this.apiKey,\n              organization: this.organization,\n              baseURL: configuration?.basePath ?? fields?.configuration?.basePath,\n              dangerouslyAllowBrowser: true,\n              defaultHeaders: configuration?.baseOptions?.headers ??\n                  fields?.configuration?.baseOptions?.headers,\n              defaultQuery: configuration?.baseOptions?.params ??\n                  fields?.configuration?.baseOptions?.params,\n              ...configuration,\n              ...fields?.configuration,\n          };\n          // If `supportsStrictToolCalling` is explicitly set, use that value.\n          // Else leave undefined so it's not passed to OpenAI.\n          if (fields?.supportsStrictToolCalling !== undefined) {\n              this.supportsStrictToolCalling = fields.supportsStrictToolCalling;\n          }\n      }\n      getLsParams(options) {\n          const params = this.invocationParams(options);\n          return {\n              ls_provider: \"openai\",\n              ls_model_name: this.model,\n              ls_model_type: \"chat\",\n              ls_temperature: params.temperature ?? undefined,\n              ls_max_tokens: params.max_tokens ?? undefined,\n              ls_stop: options.stop,\n          };\n      }\n      bindTools(tools, kwargs) {\n          let strict;\n          if (kwargs?.strict !== undefined) {\n              strict = kwargs.strict;\n          }\n          else if (this.supportsStrictToolCalling !== undefined) {\n              strict = this.supportsStrictToolCalling;\n          }\n          return this.bind({\n              tools: tools.map((tool) => _convertChatOpenAIToolTypeToOpenAITool(tool, { strict })),\n              ...kwargs,\n          });\n      }\n      createResponseFormat(resFormat) {\n          if (resFormat &&\n              resFormat.type === \"json_schema\" &&\n              resFormat.json_schema.schema &&\n              isZodSchema(resFormat.json_schema.schema)) {\n              return (0, zod_1.zodResponseFormat)(resFormat.json_schema.schema, resFormat.json_schema.name, {\n                  description: resFormat.json_schema.description,\n              });\n          }\n          return resFormat;\n      }\n      /**\n       * Get the parameters used to invoke the model\n       */\n      invocationParams(options, extra) {\n          let strict;\n          if (options?.strict !== undefined) {\n              strict = options.strict;\n          }\n          else if (this.supportsStrictToolCalling !== undefined) {\n              strict = this.supportsStrictToolCalling;\n          }\n          let streamOptionsConfig = {};\n          if (options?.stream_options !== undefined) {\n              streamOptionsConfig = { stream_options: options.stream_options };\n          }\n          else if (this.streamUsage && (this.streaming || extra?.streaming)) {\n              streamOptionsConfig = { stream_options: { include_usage: true } };\n          }\n          const params = {\n              model: this.model,\n              temperature: this.temperature,\n              top_p: this.topP,\n              frequency_penalty: this.frequencyPenalty,\n              presence_penalty: this.presencePenalty,\n              max_tokens: this.maxTokens === -1 ? undefined : this.maxTokens,\n              logprobs: this.logprobs,\n              top_logprobs: this.topLogprobs,\n              n: this.n,\n              logit_bias: this.logitBias,\n              stop: options?.stop ?? this.stopSequences,\n              user: this.user,\n              // if include_usage is set or streamUsage then stream must be set to true.\n              stream: this.streaming,\n              functions: options?.functions,\n              function_call: options?.function_call,\n              tools: options?.tools?.length\n                  ? options.tools.map((tool) => _convertChatOpenAIToolTypeToOpenAITool(tool, { strict }))\n                  : undefined,\n              tool_choice: (0, openai_js_1$3.formatToOpenAIToolChoice)(options?.tool_choice),\n              response_format: this.createResponseFormat(options?.response_format),\n              seed: options?.seed,\n              ...streamOptionsConfig,\n              parallel_tool_calls: options?.parallel_tool_calls,\n              ...this.modelKwargs,\n          };\n          return params;\n      }\n      /** @ignore */\n      _identifyingParams() {\n          return {\n              model_name: this.model,\n              ...this.invocationParams(),\n              ...this.clientConfig,\n          };\n      }\n      async *_streamResponseChunks(messages, options, runManager) {\n          if (this.model.includes(\"o1-\")) {\n              console.warn(\"[WARNING]: OpenAI o1 models do not yet support token-level streaming. Streaming will yield single chunk.\");\n              const result = await this._generate(messages, options, runManager);\n              const messageChunk = (0, messages_1.convertToChunk)(result.generations[0].message);\n              yield new outputs_1$1.ChatGenerationChunk({\n                  message: messageChunk,\n                  text: typeof messageChunk.content === \"string\" ? messageChunk.content : \"\",\n              });\n              return;\n          }\n          const messagesMapped = _convertMessagesToOpenAIParams(messages);\n          const params = {\n              ...this.invocationParams(options, {\n                  streaming: true,\n              }),\n              messages: messagesMapped,\n              stream: true,\n          };\n          let defaultRole;\n          if (params.response_format &&\n              params.response_format.type === \"json_schema\") {\n              console.warn(`OpenAI does not yet support streaming with \"response_format\" set to \"json_schema\". Falling back to non-streaming mode.`);\n              const res = await this._generate(messages, options, runManager);\n              const chunk = new outputs_1$1.ChatGenerationChunk({\n                  message: new messages_1.AIMessageChunk({\n                      ...res.generations[0].message,\n                  }),\n                  text: res.generations[0].text,\n                  generationInfo: res.generations[0].generationInfo,\n              });\n              yield chunk;\n              return runManager?.handleLLMNewToken(res.generations[0].text ?? \"\", undefined, undefined, undefined, undefined, { chunk });\n          }\n          const streamIterable = await this.completionWithRetry(params, options);\n          let usage;\n          for await (const data of streamIterable) {\n              const choice = data?.choices[0];\n              if (data.usage) {\n                  usage = data.usage;\n              }\n              if (!choice) {\n                  continue;\n              }\n              const { delta } = choice;\n              if (!delta) {\n                  continue;\n              }\n              const chunk = _convertDeltaToMessageChunk(delta, data, defaultRole, this.__includeRawResponse);\n              defaultRole = delta.role ?? defaultRole;\n              const newTokenIndices = {\n                  prompt: options.promptIndex ?? 0,\n                  completion: choice.index ?? 0,\n              };\n              if (typeof chunk.content !== \"string\") {\n                  console.log(\"[WARNING]: Received non-string content from OpenAI. This is currently not supported.\");\n                  continue;\n              }\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              const generationInfo = { ...newTokenIndices };\n              if (choice.finish_reason != null) {\n                  generationInfo.finish_reason = choice.finish_reason;\n                  // Only include system fingerprint in the last chunk for now\n                  // to avoid concatenation issues\n                  generationInfo.system_fingerprint = data.system_fingerprint;\n              }\n              if (this.logprobs) {\n                  generationInfo.logprobs = choice.logprobs;\n              }\n              const generationChunk = new outputs_1$1.ChatGenerationChunk({\n                  message: chunk,\n                  text: chunk.content,\n                  generationInfo,\n              });\n              yield generationChunk;\n              await runManager?.handleLLMNewToken(generationChunk.text ?? \"\", newTokenIndices, undefined, undefined, undefined, { chunk: generationChunk });\n          }\n          if (usage) {\n              const generationChunk = new outputs_1$1.ChatGenerationChunk({\n                  message: new messages_1.AIMessageChunk({\n                      content: \"\",\n                      usage_metadata: {\n                          input_tokens: usage.prompt_tokens,\n                          output_tokens: usage.completion_tokens,\n                          total_tokens: usage.total_tokens,\n                      },\n                  }),\n                  text: \"\",\n              });\n              yield generationChunk;\n          }\n          if (options.signal?.aborted) {\n              throw new Error(\"AbortError\");\n          }\n      }\n      /**\n       * Get the identifying parameters for the model\n       *\n       */\n      identifyingParams() {\n          return this._identifyingParams();\n      }\n      /** @ignore */\n      async _generate(messages, options, runManager) {\n          const tokenUsage = {};\n          const params = this.invocationParams(options);\n          const messagesMapped = _convertMessagesToOpenAIParams(messages);\n          if (params.stream) {\n              const stream = this._streamResponseChunks(messages, options, runManager);\n              const finalChunks = {};\n              for await (const chunk of stream) {\n                  chunk.message.response_metadata = {\n                      ...chunk.generationInfo,\n                      ...chunk.message.response_metadata,\n                  };\n                  const index = chunk.generationInfo?.completion ?? 0;\n                  if (finalChunks[index] === undefined) {\n                      finalChunks[index] = chunk;\n                  }\n                  else {\n                      finalChunks[index] = finalChunks[index].concat(chunk);\n                  }\n              }\n              const generations = Object.entries(finalChunks)\n                  .sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10))\n                  .map(([_, value]) => value);\n              const { functions, function_call } = this.invocationParams(options);\n              // OpenAI does not support token usage report under stream mode,\n              // fallback to estimation.\n              const promptTokenUsage = await this.getEstimatedTokenCountFromPrompt(messages, functions, function_call);\n              const completionTokenUsage = await this.getNumTokensFromGenerations(generations);\n              tokenUsage.promptTokens = promptTokenUsage;\n              tokenUsage.completionTokens = completionTokenUsage;\n              tokenUsage.totalTokens = promptTokenUsage + completionTokenUsage;\n              return { generations, llmOutput: { estimatedTokenUsage: tokenUsage } };\n          }\n          else {\n              let data;\n              if (options.response_format &&\n                  options.response_format.type === \"json_schema\") {\n                  data = await this.betaParsedCompletionWithRetry({\n                      ...params,\n                      stream: false,\n                      messages: messagesMapped,\n                  }, {\n                      signal: options?.signal,\n                      ...options?.options,\n                  });\n              }\n              else {\n                  data = await this.completionWithRetry({\n                      ...params,\n                      stream: false,\n                      messages: messagesMapped,\n                  }, {\n                      signal: options?.signal,\n                      ...options?.options,\n                  });\n              }\n              const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens, } = data?.usage ?? {};\n              if (completionTokens) {\n                  tokenUsage.completionTokens =\n                      (tokenUsage.completionTokens ?? 0) + completionTokens;\n              }\n              if (promptTokens) {\n                  tokenUsage.promptTokens = (tokenUsage.promptTokens ?? 0) + promptTokens;\n              }\n              if (totalTokens) {\n                  tokenUsage.totalTokens = (tokenUsage.totalTokens ?? 0) + totalTokens;\n              }\n              const generations = [];\n              for (const part of data?.choices ?? []) {\n                  const text = part.message?.content ?? \"\";\n                  const generation = {\n                      text,\n                      message: openAIResponseToChatMessage(part.message ?? { role: \"assistant\" }, data, this.__includeRawResponse),\n                  };\n                  generation.generationInfo = {\n                      ...(part.finish_reason ? { finish_reason: part.finish_reason } : {}),\n                      ...(part.logprobs ? { logprobs: part.logprobs } : {}),\n                  };\n                  if ((0, messages_1.isAIMessage)(generation.message)) {\n                      generation.message.usage_metadata = {\n                          input_tokens: tokenUsage.promptTokens ?? 0,\n                          output_tokens: tokenUsage.completionTokens ?? 0,\n                          total_tokens: tokenUsage.totalTokens ?? 0,\n                      };\n                  }\n                  generations.push(generation);\n              }\n              return {\n                  generations,\n                  llmOutput: { tokenUsage },\n              };\n          }\n      }\n      /**\n       * Estimate the number of tokens a prompt will use.\n       * Modified from: https://github.com/hmarr/openai-chat-tokens/blob/main/src/index.ts\n       */\n      async getEstimatedTokenCountFromPrompt(messages, functions, function_call) {\n          // It appears that if functions are present, the first system message is padded with a trailing newline. This\n          // was inferred by trying lots of combinations of messages and functions and seeing what the token counts were.\n          let tokens = (await this.getNumTokensFromMessages(messages)).totalCount;\n          // If there are functions, add the function definitions as they count towards token usage\n          if (functions && function_call !== \"auto\") {\n              const promptDefinitions = (0, openai_format_fndef_js_1.formatFunctionDefinitions)(functions);\n              tokens += await this.getNumTokens(promptDefinitions);\n              tokens += 9; // Add nine per completion\n          }\n          // If there's a system message _and_ functions are present, subtract four tokens. I assume this is because\n          // functions typically add a system message, but reuse the first one if it's already there. This offsets\n          // the extra 9 tokens added by the function definitions.\n          if (functions && messages.find((m) => m._getType() === \"system\")) {\n              tokens -= 4;\n          }\n          // If function_call is 'none', add one token.\n          // If it's a FunctionCall object, add 4 + the number of tokens in the function name.\n          // If it's undefined or 'auto', don't add anything.\n          if (function_call === \"none\") {\n              tokens += 1;\n          }\n          else if (typeof function_call === \"object\") {\n              tokens += (await this.getNumTokens(function_call.name)) + 4;\n          }\n          return tokens;\n      }\n      /**\n       * Estimate the number of tokens an array of generations have used.\n       */\n      async getNumTokensFromGenerations(generations) {\n          const generationUsages = await Promise.all(generations.map(async (generation) => {\n              if (generation.message.additional_kwargs?.function_call) {\n                  return (await this.getNumTokensFromMessages([generation.message]))\n                      .countPerMessage[0];\n              }\n              else {\n                  return await this.getNumTokens(generation.message.content);\n              }\n          }));\n          return generationUsages.reduce((a, b) => a + b, 0);\n      }\n      async getNumTokensFromMessages(messages) {\n          let totalCount = 0;\n          let tokensPerMessage = 0;\n          let tokensPerName = 0;\n          // From: https://github.com/openai/openai-cookbook/blob/main/examples/How_to_format_inputs_to_ChatGPT_models.ipynb\n          if (this.model === \"gpt-3.5-turbo-0301\") {\n              tokensPerMessage = 4;\n              tokensPerName = -1;\n          }\n          else {\n              tokensPerMessage = 3;\n              tokensPerName = 1;\n          }\n          const countPerMessage = await Promise.all(messages.map(async (message) => {\n              const textCount = await this.getNumTokens(message.content);\n              const roleCount = await this.getNumTokens(messageToOpenAIRole(message));\n              const nameCount = message.name !== undefined\n                  ? tokensPerName + (await this.getNumTokens(message.name))\n                  : 0;\n              let count = textCount + tokensPerMessage + roleCount + nameCount;\n              // From: https://github.com/hmarr/openai-chat-tokens/blob/main/src/index.ts messageTokenEstimate\n              const openAIMessage = message;\n              if (openAIMessage._getType() === \"function\") {\n                  count -= 2;\n              }\n              if (openAIMessage.additional_kwargs?.function_call) {\n                  count += 3;\n              }\n              if (openAIMessage?.additional_kwargs.function_call?.name) {\n                  count += await this.getNumTokens(openAIMessage.additional_kwargs.function_call?.name);\n              }\n              if (openAIMessage.additional_kwargs.function_call?.arguments) {\n                  try {\n                      count += await this.getNumTokens(\n                      // Remove newlines and spaces\n                      JSON.stringify(JSON.parse(openAIMessage.additional_kwargs.function_call?.arguments)));\n                  }\n                  catch (error) {\n                      console.error(\"Error parsing function arguments\", error, JSON.stringify(openAIMessage.additional_kwargs.function_call));\n                      count += await this.getNumTokens(openAIMessage.additional_kwargs.function_call?.arguments);\n                  }\n              }\n              totalCount += count;\n              return count;\n          }));\n          totalCount += 3; // every reply is primed with <|start|>assistant<|message|>\n          return { totalCount, countPerMessage };\n      }\n      async completionWithRetry(request, options) {\n          const requestOptions = this._getClientOptions(options);\n          return this.caller.call(async () => {\n              try {\n                  const res = await this.client.chat.completions.create(request, requestOptions);\n                  return res;\n              }\n              catch (e) {\n                  const error = (0, openai_js_1$3.wrapOpenAIClientError)(e);\n                  throw error;\n              }\n          });\n      }\n      /**\n       * Call the beta chat completions parse endpoint. This should only be called if\n       * response_format is set to \"json_object\".\n       * @param {OpenAIClient.Chat.ChatCompletionCreateParamsNonStreaming} request\n       * @param {OpenAICoreRequestOptions | undefined} options\n       */\n      async betaParsedCompletionWithRetry(request, options\n      // Avoid relying importing a beta type with no official entrypoint\n      ) {\n          const requestOptions = this._getClientOptions(options);\n          return this.caller.call(async () => {\n              try {\n                  const res = await this.client.beta.chat.completions.parse(request, requestOptions);\n                  return res;\n              }\n              catch (e) {\n                  const error = (0, openai_js_1$3.wrapOpenAIClientError)(e);\n                  throw error;\n              }\n          });\n      }\n      _getClientOptions(options) {\n          if (!this.client) {\n              const openAIEndpointConfig = {\n                  azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,\n                  azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,\n                  azureOpenAIApiKey: this.azureOpenAIApiKey,\n                  azureOpenAIBasePath: this.azureOpenAIBasePath,\n                  baseURL: this.clientConfig.baseURL,\n              };\n              const endpoint = (0, azure_js_1$5.getEndpoint)(openAIEndpointConfig);\n              const params = {\n                  ...this.clientConfig,\n                  baseURL: endpoint,\n                  timeout: this.timeout,\n                  maxRetries: 0,\n              };\n              if (!params.baseURL) {\n                  delete params.baseURL;\n              }\n              this.client = new openai_1$6.OpenAI(params);\n          }\n          const requestOptions = {\n              ...this.clientConfig,\n              ...options,\n          };\n          if (this.azureOpenAIApiKey) {\n              requestOptions.headers = {\n                  \"api-key\": this.azureOpenAIApiKey,\n                  ...requestOptions.headers,\n              };\n              requestOptions.query = {\n                  \"api-version\": this.azureOpenAIApiVersion,\n                  ...requestOptions.query,\n              };\n          }\n          return requestOptions;\n      }\n      _llmType() {\n          return \"openai\";\n      }\n      /** @ignore */\n      _combineLLMOutput(...llmOutputs) {\n          return llmOutputs.reduce((acc, llmOutput) => {\n              if (llmOutput && llmOutput.tokenUsage) {\n                  acc.tokenUsage.completionTokens +=\n                      llmOutput.tokenUsage.completionTokens ?? 0;\n                  acc.tokenUsage.promptTokens += llmOutput.tokenUsage.promptTokens ?? 0;\n                  acc.tokenUsage.totalTokens += llmOutput.tokenUsage.totalTokens ?? 0;\n              }\n              return acc;\n          }, {\n              tokenUsage: {\n                  completionTokens: 0,\n                  promptTokens: 0,\n                  totalTokens: 0,\n              },\n          });\n      }\n      withStructuredOutput(outputSchema, config) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          let schema;\n          let name;\n          let method;\n          let includeRaw;\n          if (isStructuredOutputMethodParams(outputSchema)) {\n              schema = outputSchema.schema;\n              name = outputSchema.name;\n              method = outputSchema.method;\n              includeRaw = outputSchema.includeRaw;\n          }\n          else {\n              schema = outputSchema;\n              name = config?.name;\n              method = config?.method;\n              includeRaw = config?.includeRaw;\n          }\n          let llm;\n          let outputParser;\n          if (config?.strict !== undefined && method === \"jsonMode\") {\n              throw new Error(\"Argument `strict` is only supported for `method` = 'function_calling'\");\n          }\n          if (method === \"jsonMode\") {\n              llm = this.bind({\n                  response_format: { type: \"json_object\" },\n              });\n              if (isZodSchema(schema)) {\n                  outputParser = output_parsers_1.StructuredOutputParser.fromZodSchema(schema);\n              }\n              else {\n                  outputParser = new output_parsers_1.JsonOutputParser();\n              }\n          }\n          else if (method === \"jsonSchema\") {\n              llm = this.bind({\n                  response_format: {\n                      type: \"json_schema\",\n                      json_schema: {\n                          name: name ?? \"extract\",\n                          description: schema.description,\n                          schema,\n                          strict: config?.strict,\n                      },\n                  },\n              });\n              if (isZodSchema(schema)) {\n                  outputParser = output_parsers_1.StructuredOutputParser.fromZodSchema(schema);\n              }\n              else {\n                  outputParser = new output_parsers_1.JsonOutputParser();\n              }\n          }\n          else {\n              let functionName = name ?? \"extract\";\n              // Is function calling\n              if (isZodSchema(schema)) {\n                  const asJsonSchema = (0, zod_to_json_schema_1.zodToJsonSchema)(schema);\n                  llm = this.bind({\n                      tools: [\n                          {\n                              type: \"function\",\n                              function: {\n                                  name: functionName,\n                                  description: asJsonSchema.description,\n                                  parameters: asJsonSchema,\n                              },\n                          },\n                      ],\n                      tool_choice: {\n                          type: \"function\",\n                          function: {\n                              name: functionName,\n                          },\n                      },\n                      // Do not pass `strict` argument to OpenAI if `config.strict` is undefined\n                      ...(config?.strict !== undefined ? { strict: config.strict } : {}),\n                  });\n                  outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                      returnSingle: true,\n                      keyName: functionName,\n                      zodSchema: schema,\n                  });\n              }\n              else {\n                  let openAIFunctionDefinition;\n                  if (typeof schema.name === \"string\" &&\n                      typeof schema.parameters === \"object\" &&\n                      schema.parameters != null) {\n                      openAIFunctionDefinition = schema;\n                      functionName = schema.name;\n                  }\n                  else {\n                      functionName = schema.title ?? functionName;\n                      openAIFunctionDefinition = {\n                          name: functionName,\n                          description: schema.description ?? \"\",\n                          parameters: schema,\n                      };\n                  }\n                  llm = this.bind({\n                      tools: [\n                          {\n                              type: \"function\",\n                              function: openAIFunctionDefinition,\n                          },\n                      ],\n                      tool_choice: {\n                          type: \"function\",\n                          function: {\n                              name: functionName,\n                          },\n                      },\n                      // Do not pass `strict` argument to OpenAI if `config.strict` is undefined\n                      ...(config?.strict !== undefined ? { strict: config.strict } : {}),\n                  });\n                  outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                      returnSingle: true,\n                      keyName: functionName,\n                  });\n              }\n          }\n          if (!includeRaw) {\n              return llm.pipe(outputParser);\n          }\n          const parserAssign = runnables_1.RunnablePassthrough.assign({\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              parsed: (input, config) => outputParser.invoke(input.raw, config),\n          });\n          const parserNone = runnables_1.RunnablePassthrough.assign({\n              parsed: () => null,\n          });\n          const parsedWithFallback = parserAssign.withFallbacks({\n              fallbacks: [parserNone],\n          });\n          return runnables_1.RunnableSequence.from([\n              {\n                  raw: llm,\n              },\n              parsedWithFallback,\n          ]);\n      }\n  }\n  chat_models$3.ChatOpenAI = ChatOpenAI;\n  function isZodSchema(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input) {\n      // Check for a characteristic method of Zod schemas\n      return typeof input?.parse === \"function\";\n  }\n  function isStructuredOutputMethodParams(x\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n      return (x !== undefined &&\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          typeof x.schema ===\n              \"object\");\n  }\n\n  var chat_models = {};\n\n  Object.defineProperty(chat_models, \"__esModule\", { value: true });\n  chat_models.AzureChatOpenAI = void 0;\n  const openai_1$5 = openaiExports;\n  const chat_models_js_1$1 = chat_models$3;\n  const azure_js_1$4 = azure;\n  /**\n   * Azure OpenAI chat model integration.\n   *\n   * Setup:\n   * Install `@langchain/openai` and set the following environment variables:\n   *\n   * ```bash\n   * npm install @langchain/openai\n   * export AZURE_OPENAI_API_KEY=\"your-api-key\"\n   * export AZURE_OPENAI_API_DEPLOYMENT_NAME=\"your-deployment-name\"\n   * export AZURE_OPENAI_API_VERSION=\"your-version\"\n   * export AZURE_OPENAI_BASE_PATH=\"your-base-path\"\n   * ```\n   *\n   * ## [Constructor args](https://api.js.langchain.com/classes/langchain_openai.AzureChatOpenAI.html#constructor)\n   *\n   * ## [Runtime args](https://api.js.langchain.com/interfaces/langchain_openai.ChatOpenAICallOptions.html)\n   *\n   * Runtime args can be passed as the second argument to any of the base runnable methods `.invoke`. `.stream`, `.batch`, etc.\n   * They can also be passed via `.bind`, or the second arg in `.bindTools`, like shown in the examples below:\n   *\n   * ```typescript\n   * // When calling `.bind`, call options should be passed via the first argument\n   * const llmWithArgsBound = llm.bind({\n   *   stop: [\"\\n\"],\n   *   tools: [...],\n   * });\n   *\n   * // When calling `.bindTools`, call options should be passed via the second argument\n   * const llmWithTools = llm.bindTools(\n   *   [...],\n   *   {\n   *     tool_choice: \"auto\",\n   *   }\n   * );\n   * ```\n   *\n   * ## Examples\n   *\n   * <details open>\n   * <summary><strong>Instantiate</strong></summary>\n   *\n   * ```typescript\n   * import { AzureChatOpenAI } from '@langchain/openai';\n   *\n   * const llm = new AzureChatOpenAI({\n   *   azureOpenAIApiKey: process.env.AZURE_OPENAI_API_KEY, // In Node.js defaults to process.env.AZURE_OPENAI_API_KEY\n   *   azureOpenAIApiInstanceName: process.env.AZURE_OPENAI_API_INSTANCE_NAME, // In Node.js defaults to process.env.AZURE_OPENAI_API_INSTANCE_NAME\n   *   azureOpenAIApiDeploymentName: process.env.AZURE_OPENAI_API_DEPLOYMENT_NAME, // In Node.js defaults to process.env.AZURE_OPENAI_API_DEPLOYMENT_NAME\n   *   azureOpenAIApiVersion: process.env.AZURE_OPENAI_API_VERSION, // In Node.js defaults to process.env.AZURE_OPENAI_API_VERSION\n   *   temperature: 0,\n   *   maxTokens: undefined,\n   *   timeout: undefined,\n   *   maxRetries: 2,\n   *   // apiKey: \"...\",\n   *   // baseUrl: \"...\",\n   *   // other params...\n   * });\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Invoking</strong></summary>\n   *\n   * ```typescript\n   * const input = `Translate \"I love programming\" into French.`;\n   *\n   * // Models also accept a list of chat messages or a formatted prompt\n   * const result = await llm.invoke(input);\n   * console.log(result);\n   * ```\n   *\n   * ```txt\n   * AIMessage {\n   *   \"id\": \"chatcmpl-9u4Mpu44CbPjwYFkTbeoZgvzB00Tz\",\n   *   \"content\": \"J'adore la programmation.\",\n   *   \"response_metadata\": {\n   *     \"tokenUsage\": {\n   *       \"completionTokens\": 5,\n   *       \"promptTokens\": 28,\n   *       \"totalTokens\": 33\n   *     },\n   *     \"finish_reason\": \"stop\",\n   *     \"system_fingerprint\": \"fp_3aa7262c27\"\n   *   },\n   *   \"usage_metadata\": {\n   *     \"input_tokens\": 28,\n   *     \"output_tokens\": 5,\n   *     \"total_tokens\": 33\n   *   }\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Streaming Chunks</strong></summary>\n   *\n   * ```typescript\n   * for await (const chunk of await llm.stream(input)) {\n   *   console.log(chunk);\n   * }\n   * ```\n   *\n   * ```txt\n   * AIMessageChunk {\n   *   \"id\": \"chatcmpl-9u4NWB7yUeHCKdLr6jP3HpaOYHTqs\",\n   *   \"content\": \"\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"J\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"'adore\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \" la\"\n   * }\n   * AIMessageChunk {\n   *   \"content\": \" programmation\",,\n   * }\n   * AIMessageChunk {\n   *   \"content\": \".\",,\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"\",\n   *   \"response_metadata\": {\n   *     \"finish_reason\": \"stop\",\n   *     \"system_fingerprint\": \"fp_c9aa9c0491\"\n   *   },\n   * }\n   * AIMessageChunk {\n   *   \"content\": \"\",\n   *   \"usage_metadata\": {\n   *     \"input_tokens\": 28,\n   *     \"output_tokens\": 5,\n   *     \"total_tokens\": 33\n   *   }\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Aggregate Streamed Chunks</strong></summary>\n   *\n   * ```typescript\n   * import { AIMessageChunk } from '@langchain/core/messages';\n   * import { concat } from '@langchain/core/utils/stream';\n   *\n   * const stream = await llm.stream(input);\n   * let full: AIMessageChunk | undefined;\n   * for await (const chunk of stream) {\n   *   full = !full ? chunk : concat(full, chunk);\n   * }\n   * console.log(full);\n   * ```\n   *\n   * ```txt\n   * AIMessageChunk {\n   *   \"id\": \"chatcmpl-9u4PnX6Fy7OmK46DASy0bH6cxn5Xu\",\n   *   \"content\": \"J'adore la programmation.\",\n   *   \"response_metadata\": {\n   *     \"prompt\": 0,\n   *     \"completion\": 0,\n   *     \"finish_reason\": \"stop\",\n   *   },\n   *   \"usage_metadata\": {\n   *     \"input_tokens\": 28,\n   *     \"output_tokens\": 5,\n   *     \"total_tokens\": 33\n   *   }\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Bind tools</strong></summary>\n   *\n   * ```typescript\n   * import { z } from 'zod';\n   *\n   * const GetWeather = {\n   *   name: \"GetWeather\",\n   *   description: \"Get the current weather in a given location\",\n   *   schema: z.object({\n   *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n   *   }),\n   * }\n   *\n   * const GetPopulation = {\n   *   name: \"GetPopulation\",\n   *   description: \"Get the current population in a given location\",\n   *   schema: z.object({\n   *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n   *   }),\n   * }\n   *\n   * const llmWithTools = llm.bindTools([GetWeather, GetPopulation]);\n   * const aiMsg = await llmWithTools.invoke(\n   *   \"Which city is hotter today and which is bigger: LA or NY?\"\n   * );\n   * console.log(aiMsg.tool_calls);\n   * ```\n   *\n   * ```txt\n   * [\n   *   {\n   *     name: 'GetWeather',\n   *     args: { location: 'Los Angeles, CA' },\n   *     type: 'tool_call',\n   *     id: 'call_uPU4FiFzoKAtMxfmPnfQL6UK'\n   *   },\n   *   {\n   *     name: 'GetWeather',\n   *     args: { location: 'New York, NY' },\n   *     type: 'tool_call',\n   *     id: 'call_UNkEwuQsHrGYqgDQuH9nPAtX'\n   *   },\n   *   {\n   *     name: 'GetPopulation',\n   *     args: { location: 'Los Angeles, CA' },\n   *     type: 'tool_call',\n   *     id: 'call_kL3OXxaq9OjIKqRTpvjaCH14'\n   *   },\n   *   {\n   *     name: 'GetPopulation',\n   *     args: { location: 'New York, NY' },\n   *     type: 'tool_call',\n   *     id: 'call_s9KQB1UWj45LLGaEnjz0179q'\n   *   }\n   * ]\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Structured Output</strong></summary>\n   *\n   * ```typescript\n   * import { z } from 'zod';\n   *\n   * const Joke = z.object({\n   *   setup: z.string().describe(\"The setup of the joke\"),\n   *   punchline: z.string().describe(\"The punchline to the joke\"),\n   *   rating: z.number().optional().describe(\"How funny the joke is, from 1 to 10\")\n   * }).describe('Joke to tell user.');\n   *\n   * const structuredLlm = llm.withStructuredOutput(Joke, { name: \"Joke\" });\n   * const jokeResult = await structuredLlm.invoke(\"Tell me a joke about cats\");\n   * console.log(jokeResult);\n   * ```\n   *\n   * ```txt\n   * {\n   *   setup: 'Why was the cat sitting on the computer?',\n   *   punchline: 'Because it wanted to keep an eye on the mouse!',\n   *   rating: 7\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>JSON Object Response Format</strong></summary>\n   *\n   * ```typescript\n   * const jsonLlm = llm.bind({ response_format: { type: \"json_object\" } });\n   * const jsonLlmAiMsg = await jsonLlm.invoke(\n   *   \"Return a JSON object with key 'randomInts' and a value of 10 random ints in [0-99]\"\n   * );\n   * console.log(jsonLlmAiMsg.content);\n   * ```\n   *\n   * ```txt\n   * {\n   *   \"randomInts\": [23, 87, 45, 12, 78, 34, 56, 90, 11, 67]\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Multimodal</strong></summary>\n   *\n   * ```typescript\n   * import { HumanMessage } from '@langchain/core/messages';\n   *\n   * const imageUrl = \"https://example.com/image.jpg\";\n   * const imageData = await fetch(imageUrl).then(res => res.arrayBuffer());\n   * const base64Image = Buffer.from(imageData).toString('base64');\n   *\n   * const message = new HumanMessage({\n   *   content: [\n   *     { type: \"text\", text: \"describe the weather in this image\" },\n   *     {\n   *       type: \"image_url\",\n   *       image_url: { url: `data:image/jpeg;base64,${base64Image}` },\n   *     },\n   *   ]\n   * });\n   *\n   * const imageDescriptionAiMsg = await llm.invoke([message]);\n   * console.log(imageDescriptionAiMsg.content);\n   * ```\n   *\n   * ```txt\n   * The weather in the image appears to be clear and sunny. The sky is mostly blue with a few scattered white clouds, indicating fair weather. The bright sunlight is casting shadows on the green, grassy hill, suggesting it is a pleasant day with good visibility. There are no signs of rain or stormy conditions.\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Usage Metadata</strong></summary>\n   *\n   * ```typescript\n   * const aiMsgForMetadata = await llm.invoke(input);\n   * console.log(aiMsgForMetadata.usage_metadata);\n   * ```\n   *\n   * ```txt\n   * { input_tokens: 28, output_tokens: 5, total_tokens: 33 }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Logprobs</strong></summary>\n   *\n   * ```typescript\n   * const logprobsLlm = new ChatOpenAI({ logprobs: true });\n   * const aiMsgForLogprobs = await logprobsLlm.invoke(input);\n   * console.log(aiMsgForLogprobs.response_metadata.logprobs);\n   * ```\n   *\n   * ```txt\n   * {\n   *   content: [\n   *     {\n   *       token: 'J',\n   *       logprob: -0.000050616763,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     {\n   *       token: \"'\",\n   *       logprob: -0.01868736,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     {\n   *       token: 'ad',\n   *       logprob: -0.0000030545007,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     { token: 'ore', logprob: 0, bytes: [Array], top_logprobs: [] },\n   *     {\n   *       token: ' la',\n   *       logprob: -0.515404,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     {\n   *       token: ' programm',\n   *       logprob: -0.0000118755715,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     },\n   *     { token: 'ation', logprob: 0, bytes: [Array], top_logprobs: [] },\n   *     {\n   *       token: '.',\n   *       logprob: -0.0000037697225,\n   *       bytes: [Array],\n   *       top_logprobs: []\n   *     }\n   *   ],\n   *   refusal: null\n   * }\n   * ```\n   * </details>\n   *\n   * <br />\n   *\n   * <details>\n   * <summary><strong>Response Metadata</strong></summary>\n   *\n   * ```typescript\n   * const aiMsgForResponseMetadata = await llm.invoke(input);\n   * console.log(aiMsgForResponseMetadata.response_metadata);\n   * ```\n   *\n   * ```txt\n   * {\n   *   tokenUsage: { completionTokens: 5, promptTokens: 28, totalTokens: 33 },\n   *   finish_reason: 'stop',\n   *   system_fingerprint: 'fp_3aa7262c27'\n   * }\n   * ```\n   * </details>\n   */\n  class AzureChatOpenAI extends chat_models_js_1$1.ChatOpenAI {\n      _llmType() {\n          return \"azure_openai\";\n      }\n      get lc_aliases() {\n          return {\n              openAIApiKey: \"openai_api_key\",\n              openAIApiVersion: \"openai_api_version\",\n              openAIBasePath: \"openai_api_base\",\n          };\n      }\n      constructor(fields) {\n          const newFields = fields ? { ...fields } : fields;\n          if (newFields) {\n              // don't rewrite the fields if they are already set\n              newFields.azureOpenAIApiDeploymentName =\n                  newFields.azureOpenAIApiDeploymentName ?? newFields.deploymentName;\n              newFields.azureOpenAIApiKey =\n                  newFields.azureOpenAIApiKey ?? newFields.openAIApiKey;\n              newFields.azureOpenAIApiVersion =\n                  newFields.azureOpenAIApiVersion ?? newFields.openAIApiVersion;\n          }\n          super(newFields);\n      }\n      getLsParams(options) {\n          const params = super.getLsParams(options);\n          params.ls_provider = \"azure\";\n          return params;\n      }\n      _getClientOptions(options) {\n          if (!this.client) {\n              const openAIEndpointConfig = {\n                  azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,\n                  azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,\n                  azureOpenAIApiKey: this.azureOpenAIApiKey,\n                  azureOpenAIBasePath: this.azureOpenAIBasePath,\n                  azureADTokenProvider: this.azureADTokenProvider,\n                  baseURL: this.clientConfig.baseURL,\n              };\n              const endpoint = (0, azure_js_1$4.getEndpoint)(openAIEndpointConfig);\n              const params = {\n                  ...this.clientConfig,\n                  baseURL: endpoint,\n                  timeout: this.timeout,\n                  maxRetries: 0,\n              };\n              if (!this.azureADTokenProvider) {\n                  params.apiKey = openAIEndpointConfig.azureOpenAIApiKey;\n              }\n              if (!params.baseURL) {\n                  delete params.baseURL;\n              }\n              params.defaultHeaders = {\n                  ...params.defaultHeaders,\n                  \"User-Agent\": params.defaultHeaders?.[\"User-Agent\"]\n                      ? `${params.defaultHeaders[\"User-Agent\"]}: langchainjs-azure-openai-v2`\n                      : `langchainjs-azure-openai-v2`,\n              };\n              this.client = new openai_1$5.AzureOpenAI({\n                  apiVersion: this.azureOpenAIApiVersion,\n                  azureADTokenProvider: this.azureADTokenProvider,\n                  deployment: this.azureOpenAIApiDeploymentName,\n                  ...params,\n              });\n          }\n          const requestOptions = {\n              ...this.clientConfig,\n              ...options,\n          };\n          if (this.azureOpenAIApiKey) {\n              requestOptions.headers = {\n                  \"api-key\": this.azureOpenAIApiKey,\n                  ...requestOptions.headers,\n              };\n              requestOptions.query = {\n                  \"api-version\": this.azureOpenAIApiVersion,\n                  ...requestOptions.query,\n              };\n          }\n          return requestOptions;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      toJSON() {\n          const json = super.toJSON();\n          function isRecord(obj) {\n              return typeof obj === \"object\" && obj != null;\n          }\n          if (isRecord(json) && isRecord(json.kwargs)) {\n              delete json.kwargs.azure_openai_base_path;\n              delete json.kwargs.azure_openai_api_deployment_name;\n              delete json.kwargs.azure_openai_api_key;\n              delete json.kwargs.azure_openai_api_version;\n              delete json.kwargs.azure_open_ai_base_path;\n          }\n          return json;\n      }\n  }\n  chat_models.AzureChatOpenAI = AzureChatOpenAI;\n\n  var llms$3 = {};\n\n  var llms$2 = {};\n\n  Object.defineProperty(llms$2, \"__esModule\", { value: true });\n  llms$2.LLM = llms$2.BaseLLM = void 0;\n  const index_js_1 = messages$1.messages$1;\n  const outputs_js_1 = messages$1.outputs;\n  const manager_js_1 = messages$1.manager;\n  const base_js_1 = base$3;\n  const event_stream_js_1 = messages$1.event_stream;\n  const log_stream_js_1 = messages$1.log_stream;\n  const stream_js_1 = messages$1.stream;\n  /**\n   * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n   */\n  class BaseLLM extends base_js_1.BaseLanguageModel {\n      constructor({ concurrency, ...rest }) {\n          super(concurrency ? { maxConcurrency: concurrency, ...rest } : rest);\n          // Only ever instantiated in main LangChain\n          Object.defineProperty(this, \"lc_namespace\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: [\"langchain\", \"llms\", this._llmType()]\n          });\n      }\n      /**\n       * This method takes an input and options, and returns a string. It\n       * converts the input to a prompt value and generates a result based on\n       * the prompt.\n       * @param input Input for the LLM.\n       * @param options Options for the LLM call.\n       * @returns A string result based on the prompt.\n       */\n      async invoke(input, options) {\n          const promptValue = BaseLLM._convertInputToPromptValue(input);\n          const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n          return result.generations[0][0].text;\n      }\n      // eslint-disable-next-line require-yield\n      async *_streamResponseChunks(_input, _options, _runManager) {\n          throw new Error(\"Not implemented.\");\n      }\n      _separateRunnableConfigFromCallOptionsCompat(options) {\n          // For backwards compat, keep `signal` in both runnableConfig and callOptions\n          const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n          callOptions.signal = runnableConfig.signal;\n          return [runnableConfig, callOptions];\n      }\n      async *_streamIterator(input, options) {\n          // Subclass check required to avoid double callbacks with default implementation\n          if (this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks) {\n              yield this.invoke(input, options);\n          }\n          else {\n              const prompt = BaseLLM._convertInputToPromptValue(input);\n              const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n              const callbackManager_ = await manager_js_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n              const extra = {\n                  options: callOptions,\n                  invocation_params: this?.invocationParams(callOptions),\n                  batch_size: 1,\n              };\n              const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n              let generation = new outputs_js_1.GenerationChunk({\n                  text: \"\",\n              });\n              try {\n                  for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers?.[0])) {\n                      if (!generation) {\n                          generation = chunk;\n                      }\n                      else {\n                          generation = generation.concat(chunk);\n                      }\n                      if (typeof chunk.text === \"string\") {\n                          yield chunk.text;\n                      }\n                  }\n              }\n              catch (err) {\n                  await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                  throw err;\n              }\n              await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                  generations: [[generation]],\n              })));\n          }\n      }\n      /**\n       * This method takes prompt values, options, and callbacks, and generates\n       * a result based on the prompts.\n       * @param promptValues Prompt values for the LLM.\n       * @param options Options for the LLM call.\n       * @param callbacks Callbacks for the LLM call.\n       * @returns An LLMResult based on the prompts.\n       */\n      async generatePrompt(promptValues, options, callbacks) {\n          const prompts = promptValues.map((promptValue) => promptValue.toString());\n          return this.generate(prompts, options, callbacks);\n      }\n      /**\n       * Get the parameters used to invoke the model\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      invocationParams(_options) {\n          return {};\n      }\n      _flattenLLMResult(llmResult) {\n          const llmResults = [];\n          for (let i = 0; i < llmResult.generations.length; i += 1) {\n              const genList = llmResult.generations[i];\n              if (i === 0) {\n                  llmResults.push({\n                      generations: [genList],\n                      llmOutput: llmResult.llmOutput,\n                  });\n              }\n              else {\n                  const llmOutput = llmResult.llmOutput\n                      ? { ...llmResult.llmOutput, tokenUsage: {} }\n                      : undefined;\n                  llmResults.push({\n                      generations: [genList],\n                      llmOutput,\n                  });\n              }\n          }\n          return llmResults;\n      }\n      /** @ignore */\n      async _generateUncached(prompts, parsedOptions, handledOptions) {\n          const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n          const extra = {\n              options: parsedOptions,\n              invocation_params: this?.invocationParams(parsedOptions),\n              batch_size: prompts.length,\n          };\n          const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n          // Even if stream is not explicitly called, check if model is implicitly\n          // called from streamEvents() or streamLog() to get all streamed events.\n          // Bail out if _streamResponseChunks not overridden\n          const hasStreamingHandler = !!runManagers?.[0].handlers.find((handler) => {\n              return (0, event_stream_js_1.isStreamEventsHandler)(handler) || (0, log_stream_js_1.isLogStreamHandler)(handler);\n          });\n          let output;\n          if (hasStreamingHandler &&\n              prompts.length === 1 &&\n              this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks) {\n              try {\n                  const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers?.[0]);\n                  let aggregated;\n                  for await (const chunk of stream) {\n                      if (aggregated === undefined) {\n                          aggregated = chunk;\n                      }\n                      else {\n                          aggregated = (0, stream_js_1.concat)(aggregated, chunk);\n                      }\n                  }\n                  if (aggregated === undefined) {\n                      throw new Error(\"Received empty response from chat model call.\");\n                  }\n                  output = { generations: [[aggregated]], llmOutput: {} };\n                  await runManagers?.[0].handleLLMEnd(output);\n              }\n              catch (e) {\n                  await runManagers?.[0].handleLLMError(e);\n                  throw e;\n              }\n          }\n          else {\n              try {\n                  output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n              }\n              catch (err) {\n                  await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                  throw err;\n              }\n              const flattenedOutputs = this._flattenLLMResult(output);\n              await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));\n          }\n          const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n          // This defines RUN_KEY as a non-enumerable property on the output object\n          // so that it is not serialized when the output is stringified, and so that\n          // it isnt included when listing the keys of the output object.\n          Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n              value: runIds ? { runIds } : undefined,\n              configurable: true,\n          });\n          return output;\n      }\n      async _generateCached({ prompts, cache, llmStringKey, parsedOptions, handledOptions, runId, }) {\n          const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n          const extra = {\n              options: parsedOptions,\n              invocation_params: this?.invocationParams(parsedOptions),\n              batch_size: prompts.length,\n              cached: true,\n          };\n          const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n          // generate results\n          const missingPromptIndices = [];\n          const results = await Promise.allSettled(prompts.map(async (prompt, index) => {\n              const result = await cache.lookup(prompt, llmStringKey);\n              if (result == null) {\n                  missingPromptIndices.push(index);\n              }\n              return result;\n          }));\n          // Map run managers to the results before filtering out null results\n          // Null results are just absent from the cache.\n          const cachedResults = results\n              .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n              .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n              result.status === \"rejected\");\n          // Handle results and call run managers\n          const generations = [];\n          await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n              if (promiseResult.status === \"fulfilled\") {\n                  const result = promiseResult.value;\n                  generations[i] = result;\n                  if (result.length) {\n                      await runManager?.handleLLMNewToken(result[0].text);\n                  }\n                  return runManager?.handleLLMEnd({\n                      generations: [result],\n                  });\n              }\n              else {\n                  // status === \"rejected\"\n                  await runManager?.handleLLMError(promiseResult.reason);\n                  return Promise.reject(promiseResult.reason);\n              }\n          }));\n          const output = {\n              generations,\n              missingPromptIndices,\n          };\n          // This defines RUN_KEY as a non-enumerable property on the output object\n          // so that it is not serialized when the output is stringified, and so that\n          // it isnt included when listing the keys of the output object.\n          Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n              value: runManagers\n                  ? { runIds: runManagers?.map((manager) => manager.runId) }\n                  : undefined,\n              configurable: true,\n          });\n          return output;\n      }\n      /**\n       * Run the LLM on the given prompts and input, handling caching.\n       */\n      async generate(prompts, options, callbacks) {\n          if (!Array.isArray(prompts)) {\n              throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n          }\n          let parsedOptions;\n          if (Array.isArray(options)) {\n              parsedOptions = { stop: options };\n          }\n          else {\n              parsedOptions = options;\n          }\n          const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n          runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n          if (!this.cache) {\n              return this._generateUncached(prompts, callOptions, runnableConfig);\n          }\n          const { cache } = this;\n          const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n          const { generations, missingPromptIndices } = await this._generateCached({\n              prompts,\n              cache,\n              llmStringKey,\n              parsedOptions: callOptions,\n              handledOptions: runnableConfig,\n              runId: runnableConfig.runId,\n          });\n          let llmOutput = {};\n          if (missingPromptIndices.length > 0) {\n              const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig);\n              await Promise.all(results.generations.map(async (generation, index) => {\n                  const promptIndex = missingPromptIndices[index];\n                  generations[promptIndex] = generation;\n                  return cache.update(prompts[promptIndex], llmStringKey, generation);\n              }));\n              llmOutput = results.llmOutput ?? {};\n          }\n          return { generations, llmOutput };\n      }\n      /**\n       * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n       * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.\n       */\n      async call(prompt, options, callbacks) {\n          const { generations } = await this.generate([prompt], options, callbacks);\n          return generations[0][0].text;\n      }\n      /**\n       * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n       *\n       * This method is similar to `call`, but it's used for making predictions\n       * based on the input text.\n       * @param text Input text for the prediction.\n       * @param options Options for the LLM call.\n       * @param callbacks Callbacks for the LLM call.\n       * @returns A prediction based on the input text.\n       */\n      async predict(text, options, callbacks) {\n          return this.call(text, options, callbacks);\n      }\n      /**\n       * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n       *\n       * This method takes a list of messages, options, and callbacks, and\n       * returns a predicted message.\n       * @param messages A list of messages for the prediction.\n       * @param options Options for the LLM call.\n       * @param callbacks Callbacks for the LLM call.\n       * @returns A predicted message based on the list of messages.\n       */\n      async predictMessages(messages, options, callbacks) {\n          const text = (0, index_js_1.getBufferString)(messages);\n          const prediction = await this.call(text, options, callbacks);\n          return new index_js_1.AIMessage(prediction);\n      }\n      /**\n       * Get the identifying parameters of the LLM.\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      _identifyingParams() {\n          return {};\n      }\n      /**\n       * @deprecated\n       * Return a json-like object representing this LLM.\n       */\n      serialize() {\n          return {\n              ...this._identifyingParams(),\n              _type: this._llmType(),\n              _model: this._modelType(),\n          };\n      }\n      _modelType() {\n          return \"base_llm\";\n      }\n  }\n  llms$2.BaseLLM = BaseLLM;\n  /**\n   * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n   *\n   * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n   *\n   * @augments BaseLLM\n   */\n  class LLM extends BaseLLM {\n      async _generate(prompts, options, runManager) {\n          const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, { ...options, promptIndex }, runManager).then((text) => [{ text }])));\n          return { generations };\n      }\n  }\n  llms$2.LLM = LLM;\n\n  var llms$1 = llms$2;\n\n  var chunk_array$1 = {};\n\n  Object.defineProperty(chunk_array$1, \"__esModule\", { value: true });\n  chunk_array$1.chunkArray = void 0;\n  const chunkArray = (arr, chunkSize) => arr.reduce((chunks, elem, index) => {\n      const chunkIndex = Math.floor(index / chunkSize);\n      const chunk = chunks[chunkIndex] || [];\n      // eslint-disable-next-line no-param-reassign\n      chunks[chunkIndex] = chunk.concat([elem]);\n      return chunks;\n  }, []);\n  chunk_array$1.chunkArray = chunkArray;\n\n  var chunk_array = chunk_array$1;\n\n  var legacy = {};\n\n  Object.defineProperty(legacy, \"__esModule\", { value: true });\n  legacy.OpenAIChat = void 0;\n  const openai_1$4 = openaiExports;\n  const outputs_1 = outputs;\n  const env_1$2 = env;\n  const llms_1 = llms$1;\n  const azure_js_1$3 = azure;\n  const openai_js_1$2 = openai$1;\n  /**\n   * @deprecated For legacy compatibility. Use ChatOpenAI instead.\n   *\n   * Wrapper around OpenAI large language models that use the Chat endpoint.\n   *\n   * To use you should have the `openai` package installed, with the\n   * `OPENAI_API_KEY` environment variable set.\n   *\n   * To use with Azure you should have the `openai` package installed, with the\n   * `AZURE_OPENAI_API_KEY`,\n   * `AZURE_OPENAI_API_INSTANCE_NAME`,\n   * `AZURE_OPENAI_API_DEPLOYMENT_NAME`\n   * and `AZURE_OPENAI_API_VERSION` environment variable set.\n   *\n   * @remarks\n   * Any parameters that are valid to be passed to {@link\n   * https://platform.openai.com/docs/api-reference/chat/create |\n   * `openai.createCompletion`} can be passed through {@link modelKwargs}, even\n   * if not explicitly available on this class.\n   *\n   * @augments BaseLLM\n   * @augments OpenAIInput\n   * @augments AzureOpenAIChatInput\n   * @example\n   * ```typescript\n   * const model = new OpenAIChat({\n   *   prefixMessages: [\n   *     {\n   *       role: \"system\",\n   *       content: \"You are a helpful assistant that answers in pirate language\",\n   *     },\n   *   ],\n   *   maxTokens: 50,\n   * });\n   *\n   * const res = await model.invoke(\n   *   \"What would be a good company name for a company that makes colorful socks?\"\n   * );\n   * console.log({ res });\n   * ```\n   */\n  class OpenAIChat extends llms_1.LLM {\n      static lc_name() {\n          return \"OpenAIChat\";\n      }\n      get callKeys() {\n          return [...super.callKeys, \"options\", \"promptIndex\"];\n      }\n      get lc_secrets() {\n          return {\n              openAIApiKey: \"OPENAI_API_KEY\",\n              azureOpenAIApiKey: \"AZURE_OPENAI_API_KEY\",\n              organization: \"OPENAI_ORGANIZATION\",\n          };\n      }\n      get lc_aliases() {\n          return {\n              modelName: \"model\",\n              openAIApiKey: \"openai_api_key\",\n              azureOpenAIApiVersion: \"azure_openai_api_version\",\n              azureOpenAIApiKey: \"azure_openai_api_key\",\n              azureOpenAIApiInstanceName: \"azure_openai_api_instance_name\",\n              azureOpenAIApiDeploymentName: \"azure_openai_api_deployment_name\",\n          };\n      }\n      constructor(fields, \n      /** @deprecated */\n      configuration) {\n          super(fields ?? {});\n          Object.defineProperty(this, \"lc_serializable\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          Object.defineProperty(this, \"temperature\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 1\n          });\n          Object.defineProperty(this, \"topP\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 1\n          });\n          Object.defineProperty(this, \"frequencyPenalty\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 0\n          });\n          Object.defineProperty(this, \"presencePenalty\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 0\n          });\n          Object.defineProperty(this, \"n\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 1\n          });\n          Object.defineProperty(this, \"logitBias\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"maxTokens\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"modelName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"gpt-3.5-turbo\"\n          });\n          Object.defineProperty(this, \"model\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"gpt-3.5-turbo\"\n          });\n          Object.defineProperty(this, \"prefixMessages\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"modelKwargs\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"timeout\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"stop\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"user\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"streaming\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: false\n          });\n          Object.defineProperty(this, \"openAIApiKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiVersion\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiInstanceName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiDeploymentName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIBasePath\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"organization\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"client\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"clientConfig\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.openAIApiKey =\n              fields?.apiKey ??\n                  fields?.openAIApiKey ??\n                  (0, env_1$2.getEnvironmentVariable)(\"OPENAI_API_KEY\");\n          this.azureOpenAIApiKey =\n              fields?.azureOpenAIApiKey ??\n                  (0, env_1$2.getEnvironmentVariable)(\"AZURE_OPENAI_API_KEY\");\n          if (!this.azureOpenAIApiKey && !this.openAIApiKey) {\n              throw new Error(\"OpenAI or Azure OpenAI API key not found\");\n          }\n          this.azureOpenAIApiInstanceName =\n              fields?.azureOpenAIApiInstanceName ??\n                  (0, env_1$2.getEnvironmentVariable)(\"AZURE_OPENAI_API_INSTANCE_NAME\");\n          this.azureOpenAIApiDeploymentName =\n              (fields?.azureOpenAIApiCompletionsDeploymentName ||\n                  fields?.azureOpenAIApiDeploymentName) ??\n                  ((0, env_1$2.getEnvironmentVariable)(\"AZURE_OPENAI_API_COMPLETIONS_DEPLOYMENT_NAME\") ||\n                      (0, env_1$2.getEnvironmentVariable)(\"AZURE_OPENAI_API_DEPLOYMENT_NAME\"));\n          this.azureOpenAIApiVersion =\n              fields?.azureOpenAIApiVersion ??\n                  (0, env_1$2.getEnvironmentVariable)(\"AZURE_OPENAI_API_VERSION\");\n          this.azureOpenAIBasePath =\n              fields?.azureOpenAIBasePath ??\n                  (0, env_1$2.getEnvironmentVariable)(\"AZURE_OPENAI_BASE_PATH\");\n          this.organization =\n              fields?.configuration?.organization ??\n                  (0, env_1$2.getEnvironmentVariable)(\"OPENAI_ORGANIZATION\");\n          this.modelName = fields?.model ?? fields?.modelName ?? this.modelName;\n          this.prefixMessages = fields?.prefixMessages ?? this.prefixMessages;\n          this.modelKwargs = fields?.modelKwargs ?? {};\n          this.timeout = fields?.timeout;\n          this.temperature = fields?.temperature ?? this.temperature;\n          this.topP = fields?.topP ?? this.topP;\n          this.frequencyPenalty = fields?.frequencyPenalty ?? this.frequencyPenalty;\n          this.presencePenalty = fields?.presencePenalty ?? this.presencePenalty;\n          this.n = fields?.n ?? this.n;\n          this.logitBias = fields?.logitBias;\n          this.maxTokens = fields?.maxTokens;\n          this.stop = fields?.stop;\n          this.user = fields?.user;\n          this.streaming = fields?.streaming ?? false;\n          if (this.n > 1) {\n              throw new Error(\"Cannot use n > 1 in OpenAIChat LLM. Use ChatOpenAI Chat Model instead.\");\n          }\n          if (this.azureOpenAIApiKey) {\n              if (!this.azureOpenAIApiInstanceName && !this.azureOpenAIBasePath) {\n                  throw new Error(\"Azure OpenAI API instance name not found\");\n              }\n              if (!this.azureOpenAIApiDeploymentName) {\n                  throw new Error(\"Azure OpenAI API deployment name not found\");\n              }\n              if (!this.azureOpenAIApiVersion) {\n                  throw new Error(\"Azure OpenAI API version not found\");\n              }\n              this.openAIApiKey = this.openAIApiKey ?? \"\";\n          }\n          this.clientConfig = {\n              apiKey: this.openAIApiKey,\n              organization: this.organization,\n              baseURL: configuration?.basePath ?? fields?.configuration?.basePath,\n              dangerouslyAllowBrowser: true,\n              defaultHeaders: configuration?.baseOptions?.headers ??\n                  fields?.configuration?.baseOptions?.headers,\n              defaultQuery: configuration?.baseOptions?.params ??\n                  fields?.configuration?.baseOptions?.params,\n              ...configuration,\n              ...fields?.configuration,\n          };\n      }\n      /**\n       * Get the parameters used to invoke the model\n       */\n      invocationParams(options) {\n          return {\n              model: this.modelName,\n              temperature: this.temperature,\n              top_p: this.topP,\n              frequency_penalty: this.frequencyPenalty,\n              presence_penalty: this.presencePenalty,\n              n: this.n,\n              logit_bias: this.logitBias,\n              max_tokens: this.maxTokens === -1 ? undefined : this.maxTokens,\n              stop: options?.stop ?? this.stop,\n              user: this.user,\n              stream: this.streaming,\n              ...this.modelKwargs,\n          };\n      }\n      /** @ignore */\n      _identifyingParams() {\n          return {\n              model_name: this.modelName,\n              ...this.invocationParams(),\n              ...this.clientConfig,\n          };\n      }\n      /**\n       * Get the identifying parameters for the model\n       */\n      identifyingParams() {\n          return {\n              model_name: this.modelName,\n              ...this.invocationParams(),\n              ...this.clientConfig,\n          };\n      }\n      /**\n       * Formats the messages for the OpenAI API.\n       * @param prompt The prompt to be formatted.\n       * @returns Array of formatted messages.\n       */\n      formatMessages(prompt) {\n          const message = {\n              role: \"user\",\n              content: prompt,\n          };\n          return this.prefixMessages ? [...this.prefixMessages, message] : [message];\n      }\n      async *_streamResponseChunks(prompt, options, runManager) {\n          const params = {\n              ...this.invocationParams(options),\n              messages: this.formatMessages(prompt),\n              stream: true,\n          };\n          const stream = await this.completionWithRetry(params, options);\n          for await (const data of stream) {\n              const choice = data?.choices[0];\n              if (!choice) {\n                  continue;\n              }\n              const { delta } = choice;\n              const generationChunk = new outputs_1.GenerationChunk({\n                  text: delta.content ?? \"\",\n              });\n              yield generationChunk;\n              const newTokenIndices = {\n                  prompt: options.promptIndex ?? 0,\n                  completion: choice.index ?? 0,\n              };\n              // eslint-disable-next-line no-void\n              void runManager?.handleLLMNewToken(generationChunk.text ?? \"\", newTokenIndices);\n          }\n          if (options.signal?.aborted) {\n              throw new Error(\"AbortError\");\n          }\n      }\n      /** @ignore */\n      async _call(prompt, options, runManager) {\n          const params = this.invocationParams(options);\n          if (params.stream) {\n              const stream = await this._streamResponseChunks(prompt, options, runManager);\n              let finalChunk;\n              for await (const chunk of stream) {\n                  if (finalChunk === undefined) {\n                      finalChunk = chunk;\n                  }\n                  else {\n                      finalChunk = finalChunk.concat(chunk);\n                  }\n              }\n              return finalChunk?.text ?? \"\";\n          }\n          else {\n              const response = await this.completionWithRetry({\n                  ...params,\n                  stream: false,\n                  messages: this.formatMessages(prompt),\n              }, {\n                  signal: options.signal,\n                  ...options.options,\n              });\n              return response?.choices[0]?.message?.content ?? \"\";\n          }\n      }\n      async completionWithRetry(request, options) {\n          const requestOptions = this._getClientOptions(options);\n          return this.caller.call(async () => {\n              try {\n                  const res = await this.client.chat.completions.create(request, requestOptions);\n                  return res;\n              }\n              catch (e) {\n                  const error = (0, openai_js_1$2.wrapOpenAIClientError)(e);\n                  throw error;\n              }\n          });\n      }\n      /** @ignore */\n      _getClientOptions(options) {\n          if (!this.client) {\n              const openAIEndpointConfig = {\n                  azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,\n                  azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,\n                  azureOpenAIApiKey: this.azureOpenAIApiKey,\n                  azureOpenAIBasePath: this.azureOpenAIBasePath,\n                  baseURL: this.clientConfig.baseURL,\n              };\n              const endpoint = (0, azure_js_1$3.getEndpoint)(openAIEndpointConfig);\n              const params = {\n                  ...this.clientConfig,\n                  baseURL: endpoint,\n                  timeout: this.timeout,\n                  maxRetries: 0,\n              };\n              if (!params.baseURL) {\n                  delete params.baseURL;\n              }\n              this.client = new openai_1$4.OpenAI(params);\n          }\n          const requestOptions = {\n              ...this.clientConfig,\n              ...options,\n          };\n          if (this.azureOpenAIApiKey) {\n              requestOptions.headers = {\n                  \"api-key\": this.azureOpenAIApiKey,\n                  ...requestOptions.headers,\n              };\n              requestOptions.query = {\n                  \"api-version\": this.azureOpenAIApiVersion,\n                  ...requestOptions.query,\n              };\n          }\n          return requestOptions;\n      }\n      _llmType() {\n          return \"openai\";\n      }\n  }\n  legacy.OpenAIChat = OpenAIChat;\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.OpenAI = exports.OpenAIChat = void 0;\n  \tconst openai_1 = openaiExports;\n  \tconst base_1 = base$1;\n  \tconst outputs_1 = outputs;\n  \tconst env_1 = env;\n  \tconst llms_1 = llms$1;\n  \tconst chunk_array_1 = chunk_array;\n  \tconst azure_js_1 = azure;\n  \tconst legacy_js_1 = legacy;\n  \tObject.defineProperty(exports, \"OpenAIChat\", { enumerable: true, get: function () { return legacy_js_1.OpenAIChat; } });\n  \tconst openai_js_1 = openai$1;\n  \t/**\n  \t * Wrapper around OpenAI large language models.\n  \t *\n  \t * To use you should have the `openai` package installed, with the\n  \t * `OPENAI_API_KEY` environment variable set.\n  \t *\n  \t * To use with Azure you should have the `openai` package installed, with the\n  \t * `AZURE_OPENAI_API_KEY`,\n  \t * `AZURE_OPENAI_API_INSTANCE_NAME`,\n  \t * `AZURE_OPENAI_API_DEPLOYMENT_NAME`\n  \t * and `AZURE_OPENAI_API_VERSION` environment variable set.\n  \t *\n  \t * @remarks\n  \t * Any parameters that are valid to be passed to {@link\n  \t * https://platform.openai.com/docs/api-reference/completions/create |\n  \t * `openai.createCompletion`} can be passed through {@link modelKwargs}, even\n  \t * if not explicitly available on this class.\n  \t * @example\n  \t * ```typescript\n  \t * const model = new OpenAI({\n  \t *   modelName: \"gpt-4\",\n  \t *   temperature: 0.7,\n  \t *   maxTokens: 1000,\n  \t *   maxRetries: 5,\n  \t * });\n  \t *\n  \t * const res = await model.invoke(\n  \t *   \"Question: What would be a good company name for a company that makes colorful socks?\\nAnswer:\"\n  \t * );\n  \t * console.log({ res });\n  \t * ```\n  \t */\n  \tclass OpenAI extends llms_1.BaseLLM {\n  \t    static lc_name() {\n  \t        return \"OpenAI\";\n  \t    }\n  \t    get callKeys() {\n  \t        return [...super.callKeys, \"options\"];\n  \t    }\n  \t    get lc_secrets() {\n  \t        return {\n  \t            openAIApiKey: \"OPENAI_API_KEY\",\n  \t            apiKey: \"OPENAI_API_KEY\",\n  \t            azureOpenAIApiKey: \"AZURE_OPENAI_API_KEY\",\n  \t            organization: \"OPENAI_ORGANIZATION\",\n  \t        };\n  \t    }\n  \t    get lc_aliases() {\n  \t        return {\n  \t            modelName: \"model\",\n  \t            openAIApiKey: \"openai_api_key\",\n  \t            apiKey: \"openai_api_key\",\n  \t            azureOpenAIApiVersion: \"azure_openai_api_version\",\n  \t            azureOpenAIApiKey: \"azure_openai_api_key\",\n  \t            azureOpenAIApiInstanceName: \"azure_openai_api_instance_name\",\n  \t            azureOpenAIApiDeploymentName: \"azure_openai_api_deployment_name\",\n  \t        };\n  \t    }\n  \t    constructor(fields, \n  \t    /** @deprecated */\n  \t    configuration) {\n  \t        let model = fields?.model ?? fields?.modelName;\n  \t        if ((model?.startsWith(\"gpt-3.5-turbo\") || model?.startsWith(\"gpt-4\")) &&\n  \t            !model?.includes(\"-instruct\")) {\n  \t            console.warn([\n  \t                `Your chosen OpenAI model, \"${model}\", is a chat model and not a text-in/text-out LLM.`,\n  \t                `Passing it into the \"OpenAI\" class is deprecated and only permitted for backwards-compatibility. You may experience odd behavior.`,\n  \t                `Please use the \"ChatOpenAI\" class instead.`,\n  \t                \"\",\n  \t                `See this page for more information:`,\n  \t                \"|\",\n  \t                `> https://js.langchain.com/docs/integrations/chat/openai`,\n  \t            ].join(\"\\n\"));\n  \t            // eslint-disable-next-line no-constructor-return\n  \t            return new legacy_js_1.OpenAIChat(fields, configuration);\n  \t        }\n  \t        super(fields ?? {});\n  \t        Object.defineProperty(this, \"lc_serializable\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: true\n  \t        });\n  \t        Object.defineProperty(this, \"temperature\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: 0.7\n  \t        });\n  \t        Object.defineProperty(this, \"maxTokens\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: 256\n  \t        });\n  \t        Object.defineProperty(this, \"topP\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: 1\n  \t        });\n  \t        Object.defineProperty(this, \"frequencyPenalty\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: 0\n  \t        });\n  \t        Object.defineProperty(this, \"presencePenalty\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: 0\n  \t        });\n  \t        Object.defineProperty(this, \"n\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: 1\n  \t        });\n  \t        Object.defineProperty(this, \"bestOf\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"logitBias\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"modelName\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: \"gpt-3.5-turbo-instruct\"\n  \t        });\n  \t        Object.defineProperty(this, \"model\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: \"gpt-3.5-turbo-instruct\"\n  \t        });\n  \t        Object.defineProperty(this, \"modelKwargs\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"batchSize\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: 20\n  \t        });\n  \t        Object.defineProperty(this, \"timeout\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"stop\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"stopSequences\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"user\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"streaming\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: false\n  \t        });\n  \t        Object.defineProperty(this, \"openAIApiKey\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"apiKey\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"azureOpenAIApiVersion\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"azureOpenAIApiKey\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"azureADTokenProvider\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"azureOpenAIApiInstanceName\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"azureOpenAIApiDeploymentName\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"azureOpenAIBasePath\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"organization\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"client\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"clientConfig\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        model = model ?? this.model;\n  \t        this.openAIApiKey =\n  \t            fields?.apiKey ??\n  \t                fields?.openAIApiKey ??\n  \t                (0, env_1.getEnvironmentVariable)(\"OPENAI_API_KEY\");\n  \t        this.apiKey = this.openAIApiKey;\n  \t        this.azureOpenAIApiKey =\n  \t            fields?.azureOpenAIApiKey ??\n  \t                (0, env_1.getEnvironmentVariable)(\"AZURE_OPENAI_API_KEY\");\n  \t        this.azureADTokenProvider = fields?.azureADTokenProvider ?? undefined;\n  \t        if (!this.azureOpenAIApiKey && !this.apiKey && !this.azureADTokenProvider) {\n  \t            throw new Error(\"OpenAI or Azure OpenAI API key or Token Provider not found\");\n  \t        }\n  \t        this.azureOpenAIApiInstanceName =\n  \t            fields?.azureOpenAIApiInstanceName ??\n  \t                (0, env_1.getEnvironmentVariable)(\"AZURE_OPENAI_API_INSTANCE_NAME\");\n  \t        this.azureOpenAIApiDeploymentName =\n  \t            (fields?.azureOpenAIApiCompletionsDeploymentName ||\n  \t                fields?.azureOpenAIApiDeploymentName) ??\n  \t                ((0, env_1.getEnvironmentVariable)(\"AZURE_OPENAI_API_COMPLETIONS_DEPLOYMENT_NAME\") ||\n  \t                    (0, env_1.getEnvironmentVariable)(\"AZURE_OPENAI_API_DEPLOYMENT_NAME\"));\n  \t        this.azureOpenAIApiVersion =\n  \t            fields?.azureOpenAIApiVersion ??\n  \t                (0, env_1.getEnvironmentVariable)(\"AZURE_OPENAI_API_VERSION\");\n  \t        this.azureOpenAIBasePath =\n  \t            fields?.azureOpenAIBasePath ??\n  \t                (0, env_1.getEnvironmentVariable)(\"AZURE_OPENAI_BASE_PATH\");\n  \t        this.organization =\n  \t            fields?.configuration?.organization ??\n  \t                (0, env_1.getEnvironmentVariable)(\"OPENAI_ORGANIZATION\");\n  \t        this.modelName = model;\n  \t        this.model = model;\n  \t        this.modelKwargs = fields?.modelKwargs ?? {};\n  \t        this.batchSize = fields?.batchSize ?? this.batchSize;\n  \t        this.timeout = fields?.timeout;\n  \t        this.temperature = fields?.temperature ?? this.temperature;\n  \t        this.maxTokens = fields?.maxTokens ?? this.maxTokens;\n  \t        this.topP = fields?.topP ?? this.topP;\n  \t        this.frequencyPenalty = fields?.frequencyPenalty ?? this.frequencyPenalty;\n  \t        this.presencePenalty = fields?.presencePenalty ?? this.presencePenalty;\n  \t        this.n = fields?.n ?? this.n;\n  \t        this.bestOf = fields?.bestOf ?? this.bestOf;\n  \t        this.logitBias = fields?.logitBias;\n  \t        this.stop = fields?.stopSequences ?? fields?.stop;\n  \t        this.stopSequences = fields?.stopSequences;\n  \t        this.user = fields?.user;\n  \t        this.streaming = fields?.streaming ?? false;\n  \t        if (this.streaming && this.bestOf && this.bestOf > 1) {\n  \t            throw new Error(\"Cannot stream results when bestOf > 1\");\n  \t        }\n  \t        if (this.azureOpenAIApiKey || this.azureADTokenProvider) {\n  \t            if (!this.azureOpenAIApiInstanceName && !this.azureOpenAIBasePath) {\n  \t                throw new Error(\"Azure OpenAI API instance name not found\");\n  \t            }\n  \t            if (!this.azureOpenAIApiDeploymentName) {\n  \t                throw new Error(\"Azure OpenAI API deployment name not found\");\n  \t            }\n  \t            if (!this.azureOpenAIApiVersion) {\n  \t                throw new Error(\"Azure OpenAI API version not found\");\n  \t            }\n  \t            this.apiKey = this.apiKey ?? \"\";\n  \t        }\n  \t        this.clientConfig = {\n  \t            apiKey: this.apiKey,\n  \t            organization: this.organization,\n  \t            baseURL: configuration?.basePath ?? fields?.configuration?.basePath,\n  \t            dangerouslyAllowBrowser: true,\n  \t            defaultHeaders: configuration?.baseOptions?.headers ??\n  \t                fields?.configuration?.baseOptions?.headers,\n  \t            defaultQuery: configuration?.baseOptions?.params ??\n  \t                fields?.configuration?.baseOptions?.params,\n  \t            ...configuration,\n  \t            ...fields?.configuration,\n  \t        };\n  \t    }\n  \t    /**\n  \t     * Get the parameters used to invoke the model\n  \t     */\n  \t    invocationParams(options) {\n  \t        return {\n  \t            model: this.model,\n  \t            temperature: this.temperature,\n  \t            max_tokens: this.maxTokens,\n  \t            top_p: this.topP,\n  \t            frequency_penalty: this.frequencyPenalty,\n  \t            presence_penalty: this.presencePenalty,\n  \t            n: this.n,\n  \t            best_of: this.bestOf,\n  \t            logit_bias: this.logitBias,\n  \t            stop: options?.stop ?? this.stopSequences,\n  \t            user: this.user,\n  \t            stream: this.streaming,\n  \t            ...this.modelKwargs,\n  \t        };\n  \t    }\n  \t    /** @ignore */\n  \t    _identifyingParams() {\n  \t        return {\n  \t            model_name: this.model,\n  \t            ...this.invocationParams(),\n  \t            ...this.clientConfig,\n  \t        };\n  \t    }\n  \t    /**\n  \t     * Get the identifying parameters for the model\n  \t     */\n  \t    identifyingParams() {\n  \t        return this._identifyingParams();\n  \t    }\n  \t    /**\n  \t     * Call out to OpenAI's endpoint with k unique prompts\n  \t     *\n  \t     * @param [prompts] - The prompts to pass into the model.\n  \t     * @param [options] - Optional list of stop words to use when generating.\n  \t     * @param [runManager] - Optional callback manager to use when generating.\n  \t     *\n  \t     * @returns The full LLM output.\n  \t     *\n  \t     * @example\n  \t     * ```ts\n  \t     * import { OpenAI } from \"langchain/llms/openai\";\n  \t     * const openai = new OpenAI();\n  \t     * const response = await openai.generate([\"Tell me a joke.\"]);\n  \t     * ```\n  \t     */\n  \t    async _generate(prompts, options, runManager) {\n  \t        const subPrompts = (0, chunk_array_1.chunkArray)(prompts, this.batchSize);\n  \t        const choices = [];\n  \t        const tokenUsage = {};\n  \t        const params = this.invocationParams(options);\n  \t        if (params.max_tokens === -1) {\n  \t            if (prompts.length !== 1) {\n  \t                throw new Error(\"max_tokens set to -1 not supported for multiple inputs\");\n  \t            }\n  \t            params.max_tokens = await (0, base_1.calculateMaxTokens)({\n  \t                prompt: prompts[0],\n  \t                // Cast here to allow for other models that may not fit the union\n  \t                modelName: this.model,\n  \t            });\n  \t        }\n  \t        for (let i = 0; i < subPrompts.length; i += 1) {\n  \t            const data = params.stream\n  \t                ? await (async () => {\n  \t                    const choices = [];\n  \t                    let response;\n  \t                    const stream = await this.completionWithRetry({\n  \t                        ...params,\n  \t                        stream: true,\n  \t                        prompt: subPrompts[i],\n  \t                    }, options);\n  \t                    for await (const message of stream) {\n  \t                        // on the first message set the response properties\n  \t                        if (!response) {\n  \t                            response = {\n  \t                                id: message.id,\n  \t                                object: message.object,\n  \t                                created: message.created,\n  \t                                model: message.model,\n  \t                            };\n  \t                        }\n  \t                        // on all messages, update choice\n  \t                        for (const part of message.choices) {\n  \t                            if (!choices[part.index]) {\n  \t                                choices[part.index] = part;\n  \t                            }\n  \t                            else {\n  \t                                const choice = choices[part.index];\n  \t                                choice.text += part.text;\n  \t                                choice.finish_reason = part.finish_reason;\n  \t                                choice.logprobs = part.logprobs;\n  \t                            }\n  \t                            void runManager?.handleLLMNewToken(part.text, {\n  \t                                prompt: Math.floor(part.index / this.n),\n  \t                                completion: part.index % this.n,\n  \t                            });\n  \t                        }\n  \t                    }\n  \t                    if (options.signal?.aborted) {\n  \t                        throw new Error(\"AbortError\");\n  \t                    }\n  \t                    return { ...response, choices };\n  \t                })()\n  \t                : await this.completionWithRetry({\n  \t                    ...params,\n  \t                    stream: false,\n  \t                    prompt: subPrompts[i],\n  \t                }, {\n  \t                    signal: options.signal,\n  \t                    ...options.options,\n  \t                });\n  \t            choices.push(...data.choices);\n  \t            const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens, } = data.usage\n  \t                ? data.usage\n  \t                : {\n  \t                    completion_tokens: undefined,\n  \t                    prompt_tokens: undefined,\n  \t                    total_tokens: undefined,\n  \t                };\n  \t            if (completionTokens) {\n  \t                tokenUsage.completionTokens =\n  \t                    (tokenUsage.completionTokens ?? 0) + completionTokens;\n  \t            }\n  \t            if (promptTokens) {\n  \t                tokenUsage.promptTokens = (tokenUsage.promptTokens ?? 0) + promptTokens;\n  \t            }\n  \t            if (totalTokens) {\n  \t                tokenUsage.totalTokens = (tokenUsage.totalTokens ?? 0) + totalTokens;\n  \t            }\n  \t        }\n  \t        const generations = (0, chunk_array_1.chunkArray)(choices, this.n).map((promptChoices) => promptChoices.map((choice) => ({\n  \t            text: choice.text ?? \"\",\n  \t            generationInfo: {\n  \t                finishReason: choice.finish_reason,\n  \t                logprobs: choice.logprobs,\n  \t            },\n  \t        })));\n  \t        return {\n  \t            generations,\n  \t            llmOutput: { tokenUsage },\n  \t        };\n  \t    }\n  \t    // TODO(jacoblee): Refactor with _generate(..., {stream: true}) implementation?\n  \t    async *_streamResponseChunks(input, options, runManager) {\n  \t        const params = {\n  \t            ...this.invocationParams(options),\n  \t            prompt: input,\n  \t            stream: true,\n  \t        };\n  \t        const stream = await this.completionWithRetry(params, options);\n  \t        for await (const data of stream) {\n  \t            const choice = data?.choices[0];\n  \t            if (!choice) {\n  \t                continue;\n  \t            }\n  \t            const chunk = new outputs_1.GenerationChunk({\n  \t                text: choice.text,\n  \t                generationInfo: {\n  \t                    finishReason: choice.finish_reason,\n  \t                },\n  \t            });\n  \t            yield chunk;\n  \t            // eslint-disable-next-line no-void\n  \t            void runManager?.handleLLMNewToken(chunk.text ?? \"\");\n  \t        }\n  \t        if (options.signal?.aborted) {\n  \t            throw new Error(\"AbortError\");\n  \t        }\n  \t    }\n  \t    async completionWithRetry(request, options) {\n  \t        const requestOptions = this._getClientOptions(options);\n  \t        return this.caller.call(async () => {\n  \t            try {\n  \t                const res = await this.client.completions.create(request, requestOptions);\n  \t                return res;\n  \t            }\n  \t            catch (e) {\n  \t                const error = (0, openai_js_1.wrapOpenAIClientError)(e);\n  \t                throw error;\n  \t            }\n  \t        });\n  \t    }\n  \t    /**\n  \t     * Calls the OpenAI API with retry logic in case of failures.\n  \t     * @param request The request to send to the OpenAI API.\n  \t     * @param options Optional configuration for the API call.\n  \t     * @returns The response from the OpenAI API.\n  \t     */\n  \t    _getClientOptions(options) {\n  \t        if (!this.client) {\n  \t            const openAIEndpointConfig = {\n  \t                azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,\n  \t                azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,\n  \t                azureOpenAIApiKey: this.azureOpenAIApiKey,\n  \t                azureOpenAIBasePath: this.azureOpenAIBasePath,\n  \t                baseURL: this.clientConfig.baseURL,\n  \t            };\n  \t            const endpoint = (0, azure_js_1.getEndpoint)(openAIEndpointConfig);\n  \t            const params = {\n  \t                ...this.clientConfig,\n  \t                baseURL: endpoint,\n  \t                timeout: this.timeout,\n  \t                maxRetries: 0,\n  \t            };\n  \t            if (!params.baseURL) {\n  \t                delete params.baseURL;\n  \t            }\n  \t            this.client = new openai_1.OpenAI(params);\n  \t        }\n  \t        const requestOptions = {\n  \t            ...this.clientConfig,\n  \t            ...options,\n  \t        };\n  \t        if (this.azureOpenAIApiKey) {\n  \t            requestOptions.headers = {\n  \t                \"api-key\": this.azureOpenAIApiKey,\n  \t                ...requestOptions.headers,\n  \t            };\n  \t            requestOptions.query = {\n  \t                \"api-version\": this.azureOpenAIApiVersion,\n  \t                ...requestOptions.query,\n  \t            };\n  \t        }\n  \t        return requestOptions;\n  \t    }\n  \t    _llmType() {\n  \t        return \"openai\";\n  \t    }\n  \t}\n  \texports.OpenAI = OpenAI; \n  } (llms$3));\n\n  var llms = {};\n\n  Object.defineProperty(llms, \"__esModule\", { value: true });\n  llms.AzureOpenAI = void 0;\n  const openai_1$3 = openaiExports;\n  const llms_js_1 = llms$3;\n  const azure_js_1$2 = azure;\n  class AzureOpenAI extends llms_js_1.OpenAI {\n      get lc_aliases() {\n          return {\n              openAIApiKey: \"openai_api_key\",\n              openAIApiVersion: \"openai_api_version\",\n              openAIBasePath: \"openai_api_base\",\n          };\n      }\n      constructor(fields) {\n          const newFields = fields ? { ...fields } : fields;\n          if (newFields) {\n              // don't rewrite the fields if they are already set\n              newFields.azureOpenAIApiDeploymentName =\n                  newFields.azureOpenAIApiDeploymentName ?? newFields.deploymentName;\n              newFields.azureOpenAIApiKey =\n                  newFields.azureOpenAIApiKey ?? newFields.openAIApiKey;\n              newFields.azureOpenAIApiVersion =\n                  newFields.azureOpenAIApiVersion ?? newFields.openAIApiVersion;\n          }\n          super(newFields);\n      }\n      _getClientOptions(options) {\n          if (!this.client) {\n              const openAIEndpointConfig = {\n                  azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,\n                  azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,\n                  azureOpenAIApiKey: this.azureOpenAIApiKey,\n                  azureOpenAIBasePath: this.azureOpenAIBasePath,\n                  azureADTokenProvider: this.azureADTokenProvider,\n                  baseURL: this.clientConfig.baseURL,\n              };\n              const endpoint = (0, azure_js_1$2.getEndpoint)(openAIEndpointConfig);\n              const params = {\n                  ...this.clientConfig,\n                  baseURL: endpoint,\n                  timeout: this.timeout,\n                  maxRetries: 0,\n              };\n              if (!this.azureADTokenProvider) {\n                  params.apiKey = openAIEndpointConfig.azureOpenAIApiKey;\n              }\n              if (!params.baseURL) {\n                  delete params.baseURL;\n              }\n              params.defaultHeaders = {\n                  ...params.defaultHeaders,\n                  \"User-Agent\": params.defaultHeaders?.[\"User-Agent\"]\n                      ? `${params.defaultHeaders[\"User-Agent\"]}: langchainjs-azure-openai-v2`\n                      : `langchainjs-azure-openai-v2`,\n              };\n              this.client = new openai_1$3.AzureOpenAI({\n                  apiVersion: this.azureOpenAIApiVersion,\n                  azureADTokenProvider: this.azureADTokenProvider,\n                  ...params,\n              });\n          }\n          const requestOptions = {\n              ...this.clientConfig,\n              ...options,\n          };\n          if (this.azureOpenAIApiKey) {\n              requestOptions.headers = {\n                  \"api-key\": this.azureOpenAIApiKey,\n                  ...requestOptions.headers,\n              };\n              requestOptions.query = {\n                  \"api-version\": this.azureOpenAIApiVersion,\n                  ...requestOptions.query,\n              };\n          }\n          return requestOptions;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      toJSON() {\n          const json = super.toJSON();\n          function isRecord(obj) {\n              return typeof obj === \"object\" && obj != null;\n          }\n          if (isRecord(json) && isRecord(json.kwargs)) {\n              delete json.kwargs.azure_openai_base_path;\n              delete json.kwargs.azure_openai_api_deployment_name;\n              delete json.kwargs.azure_openai_api_key;\n              delete json.kwargs.azure_openai_api_version;\n              delete json.kwargs.azure_open_ai_base_path;\n          }\n          return json;\n      }\n  }\n  llms.AzureOpenAI = AzureOpenAI;\n\n  var embeddings$3 = {};\n\n  var embeddings$2 = {};\n\n  var embeddings$1 = {};\n\n  Object.defineProperty(embeddings$1, \"__esModule\", { value: true });\n  embeddings$1.Embeddings = void 0;\n  const async_caller_js_1 = messages$1.async_caller;\n  /**\n   * An abstract class that provides methods for embedding documents and\n   * queries using LangChain.\n   */\n  class Embeddings {\n      constructor(params) {\n          /**\n           * The async caller should be used by subclasses to make any async calls,\n           * which will thus benefit from the concurrency and retry logic.\n           */\n          Object.defineProperty(this, \"caller\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n      }\n  }\n  embeddings$1.Embeddings = Embeddings;\n\n  var embeddings = embeddings$1;\n\n  Object.defineProperty(embeddings$2, \"__esModule\", { value: true });\n  embeddings$2.OpenAIEmbeddings = void 0;\n  const openai_1$2 = openaiExports;\n  const env_1$1 = env;\n  const embeddings_1 = embeddings;\n  const chunk_array_1 = chunk_array;\n  const azure_js_1$1 = azure;\n  const openai_js_1$1 = openai$1;\n  /**\n   * Class for generating embeddings using the OpenAI API. Extends the\n   * Embeddings class and implements OpenAIEmbeddingsParams and\n   * AzureOpenAIInput.\n   * @example\n   * ```typescript\n   * // Embed a query using OpenAIEmbeddings to generate embeddings for a given text\n   * const model = new OpenAIEmbeddings();\n   * const res = await model.embedQuery(\n   *   \"What would be a good company name for a company that makes colorful socks?\",\n   * );\n   * console.log({ res });\n   *\n   * ```\n   */\n  class OpenAIEmbeddings extends embeddings_1.Embeddings {\n      constructor(fields, configuration) {\n          const fieldsWithDefaults = { maxConcurrency: 2, ...fields };\n          super(fieldsWithDefaults);\n          Object.defineProperty(this, \"modelName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"text-embedding-ada-002\"\n          });\n          Object.defineProperty(this, \"model\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"text-embedding-ada-002\"\n          });\n          Object.defineProperty(this, \"batchSize\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 512\n          });\n          // TODO: Update to `false` on next minor release (see: https://github.com/langchain-ai/langchainjs/pull/3612)\n          Object.defineProperty(this, \"stripNewLines\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: true\n          });\n          /**\n           * The number of dimensions the resulting output embeddings should have.\n           * Only supported in `text-embedding-3` and later models.\n           */\n          Object.defineProperty(this, \"dimensions\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"timeout\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiVersion\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiKey\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureADTokenProvider\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiInstanceName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIApiDeploymentName\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"azureOpenAIBasePath\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"organization\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"client\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"clientConfig\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          let apiKey = fieldsWithDefaults?.apiKey ??\n              fieldsWithDefaults?.openAIApiKey ??\n              (0, env_1$1.getEnvironmentVariable)(\"OPENAI_API_KEY\");\n          const azureApiKey = fieldsWithDefaults?.azureOpenAIApiKey ??\n              (0, env_1$1.getEnvironmentVariable)(\"AZURE_OPENAI_API_KEY\");\n          this.azureADTokenProvider = fields?.azureADTokenProvider ?? undefined;\n          if (!azureApiKey && !apiKey && !this.azureADTokenProvider) {\n              throw new Error(\"OpenAI or Azure OpenAI API key or Token Provider not found\");\n          }\n          const azureApiInstanceName = fieldsWithDefaults?.azureOpenAIApiInstanceName ??\n              (0, env_1$1.getEnvironmentVariable)(\"AZURE_OPENAI_API_INSTANCE_NAME\");\n          const azureApiDeploymentName = (fieldsWithDefaults?.azureOpenAIApiEmbeddingsDeploymentName ||\n              fieldsWithDefaults?.azureOpenAIApiDeploymentName) ??\n              ((0, env_1$1.getEnvironmentVariable)(\"AZURE_OPENAI_API_EMBEDDINGS_DEPLOYMENT_NAME\") ||\n                  (0, env_1$1.getEnvironmentVariable)(\"AZURE_OPENAI_API_DEPLOYMENT_NAME\"));\n          const azureApiVersion = fieldsWithDefaults?.azureOpenAIApiVersion ??\n              (0, env_1$1.getEnvironmentVariable)(\"AZURE_OPENAI_API_VERSION\");\n          this.azureOpenAIBasePath =\n              fieldsWithDefaults?.azureOpenAIBasePath ??\n                  (0, env_1$1.getEnvironmentVariable)(\"AZURE_OPENAI_BASE_PATH\");\n          this.organization =\n              fieldsWithDefaults?.configuration?.organization ??\n                  (0, env_1$1.getEnvironmentVariable)(\"OPENAI_ORGANIZATION\");\n          this.modelName =\n              fieldsWithDefaults?.model ?? fieldsWithDefaults?.modelName ?? this.model;\n          this.model = this.modelName;\n          this.batchSize =\n              fieldsWithDefaults?.batchSize ?? (azureApiKey ? 1 : this.batchSize);\n          this.stripNewLines =\n              fieldsWithDefaults?.stripNewLines ?? this.stripNewLines;\n          this.timeout = fieldsWithDefaults?.timeout;\n          this.dimensions = fieldsWithDefaults?.dimensions;\n          this.azureOpenAIApiVersion = azureApiVersion;\n          this.azureOpenAIApiKey = azureApiKey;\n          this.azureOpenAIApiInstanceName = azureApiInstanceName;\n          this.azureOpenAIApiDeploymentName = azureApiDeploymentName;\n          if (this.azureOpenAIApiKey || this.azureADTokenProvider) {\n              if (!this.azureOpenAIApiInstanceName && !this.azureOpenAIBasePath) {\n                  throw new Error(\"Azure OpenAI API instance name not found\");\n              }\n              if (!this.azureOpenAIApiDeploymentName) {\n                  throw new Error(\"Azure OpenAI API deployment name not found\");\n              }\n              if (!this.azureOpenAIApiVersion) {\n                  throw new Error(\"Azure OpenAI API version not found\");\n              }\n              apiKey = apiKey ?? \"\";\n          }\n          this.clientConfig = {\n              apiKey,\n              organization: this.organization,\n              baseURL: configuration?.basePath,\n              dangerouslyAllowBrowser: true,\n              defaultHeaders: configuration?.baseOptions?.headers,\n              defaultQuery: configuration?.baseOptions?.params,\n              ...configuration,\n              ...fields?.configuration,\n          };\n      }\n      /**\n       * Method to generate embeddings for an array of documents. Splits the\n       * documents into batches and makes requests to the OpenAI API to generate\n       * embeddings.\n       * @param texts Array of documents to generate embeddings for.\n       * @returns Promise that resolves to a 2D array of embeddings for each document.\n       */\n      async embedDocuments(texts) {\n          const batches = (0, chunk_array_1.chunkArray)(this.stripNewLines ? texts.map((t) => t.replace(/\\n/g, \" \")) : texts, this.batchSize);\n          const batchRequests = batches.map((batch) => {\n              const params = {\n                  model: this.model,\n                  input: batch,\n              };\n              if (this.dimensions) {\n                  params.dimensions = this.dimensions;\n              }\n              return this.embeddingWithRetry(params);\n          });\n          const batchResponses = await Promise.all(batchRequests);\n          const embeddings = [];\n          for (let i = 0; i < batchResponses.length; i += 1) {\n              const batch = batches[i];\n              const { data: batchResponse } = batchResponses[i];\n              for (let j = 0; j < batch.length; j += 1) {\n                  embeddings.push(batchResponse[j].embedding);\n              }\n          }\n          return embeddings;\n      }\n      /**\n       * Method to generate an embedding for a single document. Calls the\n       * embeddingWithRetry method with the document as the input.\n       * @param text Document to generate an embedding for.\n       * @returns Promise that resolves to an embedding for the document.\n       */\n      async embedQuery(text) {\n          const params = {\n              model: this.model,\n              input: this.stripNewLines ? text.replace(/\\n/g, \" \") : text,\n          };\n          if (this.dimensions) {\n              params.dimensions = this.dimensions;\n          }\n          const { data } = await this.embeddingWithRetry(params);\n          return data[0].embedding;\n      }\n      /**\n       * Private method to make a request to the OpenAI API to generate\n       * embeddings. Handles the retry logic and returns the response from the\n       * API.\n       * @param request Request to send to the OpenAI API.\n       * @returns Promise that resolves to the response from the API.\n       */\n      async embeddingWithRetry(request) {\n          if (!this.client) {\n              const openAIEndpointConfig = {\n                  azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,\n                  azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,\n                  azureOpenAIApiKey: this.azureOpenAIApiKey,\n                  azureOpenAIBasePath: this.azureOpenAIBasePath,\n                  baseURL: this.clientConfig.baseURL,\n              };\n              const endpoint = (0, azure_js_1$1.getEndpoint)(openAIEndpointConfig);\n              const params = {\n                  ...this.clientConfig,\n                  baseURL: endpoint,\n                  timeout: this.timeout,\n                  maxRetries: 0,\n              };\n              if (!params.baseURL) {\n                  delete params.baseURL;\n              }\n              this.client = new openai_1$2.OpenAI(params);\n          }\n          const requestOptions = {};\n          if (this.azureOpenAIApiKey) {\n              requestOptions.headers = {\n                  \"api-key\": this.azureOpenAIApiKey,\n                  ...requestOptions.headers,\n              };\n              requestOptions.query = {\n                  \"api-version\": this.azureOpenAIApiVersion,\n                  ...requestOptions.query,\n              };\n          }\n          return this.caller.call(async () => {\n              try {\n                  const res = await this.client.embeddings.create(request, requestOptions);\n                  return res;\n              }\n              catch (e) {\n                  const error = (0, openai_js_1$1.wrapOpenAIClientError)(e);\n                  throw error;\n              }\n          });\n      }\n  }\n  embeddings$2.OpenAIEmbeddings = OpenAIEmbeddings;\n\n  Object.defineProperty(embeddings$3, \"__esModule\", { value: true });\n  embeddings$3.AzureOpenAIEmbeddings = void 0;\n  const openai_1$1 = openaiExports;\n  const embeddings_js_1 = embeddings$2;\n  const azure_js_1 = azure;\n  const openai_js_1 = openai$1;\n  class AzureOpenAIEmbeddings extends embeddings_js_1.OpenAIEmbeddings {\n      constructor(fields, configuration) {\n          const newFields = { ...fields };\n          if (Object.entries(newFields).length) {\n              // don't rewrite the fields if they are already set\n              newFields.azureOpenAIApiDeploymentName =\n                  newFields.azureOpenAIApiDeploymentName ?? newFields.deploymentName;\n              newFields.azureOpenAIApiKey =\n                  newFields.azureOpenAIApiKey ?? newFields.apiKey;\n              newFields.azureOpenAIApiVersion =\n                  newFields.azureOpenAIApiVersion ?? newFields.openAIApiVersion;\n          }\n          super(newFields, configuration);\n      }\n      async embeddingWithRetry(request) {\n          if (!this.client) {\n              const openAIEndpointConfig = {\n                  azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,\n                  azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,\n                  azureOpenAIApiKey: this.azureOpenAIApiKey,\n                  azureOpenAIBasePath: this.azureOpenAIBasePath,\n                  azureADTokenProvider: this.azureADTokenProvider,\n                  baseURL: this.clientConfig.baseURL,\n              };\n              const endpoint = (0, azure_js_1.getEndpoint)(openAIEndpointConfig);\n              const params = {\n                  ...this.clientConfig,\n                  baseURL: endpoint,\n                  timeout: this.timeout,\n                  maxRetries: 0,\n              };\n              if (!this.azureADTokenProvider) {\n                  params.apiKey = openAIEndpointConfig.azureOpenAIApiKey;\n              }\n              if (!params.baseURL) {\n                  delete params.baseURL;\n              }\n              params.defaultHeaders = {\n                  ...params.defaultHeaders,\n                  \"User-Agent\": params.defaultHeaders?.[\"User-Agent\"]\n                      ? `${params.defaultHeaders[\"User-Agent\"]}: langchainjs-azure-openai-v2`\n                      : `langchainjs-azure-openai-v2`,\n              };\n              this.client = new openai_1$1.AzureOpenAI({\n                  apiVersion: this.azureOpenAIApiVersion,\n                  azureADTokenProvider: this.azureADTokenProvider,\n                  deployment: this.azureOpenAIApiDeploymentName,\n                  ...params,\n              });\n          }\n          const requestOptions = {};\n          if (this.azureOpenAIApiKey) {\n              requestOptions.headers = {\n                  \"api-key\": this.azureOpenAIApiKey,\n                  ...requestOptions.headers,\n              };\n              requestOptions.query = {\n                  \"api-version\": this.azureOpenAIApiVersion,\n                  ...requestOptions.query,\n              };\n          }\n          return this.caller.call(async () => {\n              try {\n                  const res = await this.client.embeddings.create(request, requestOptions);\n                  return res;\n              }\n              catch (e) {\n                  const error = (0, openai_js_1.wrapOpenAIClientError)(e);\n                  throw error;\n              }\n          });\n      }\n  }\n  embeddings$3.AzureOpenAIEmbeddings = AzureOpenAIEmbeddings;\n\n  var types = {};\n\n  Object.defineProperty(types, \"__esModule\", { value: true });\n\n  var tools$2 = {};\n\n  var dalle = {};\n\n  var tools$1 = {};\n\n  (function (exports) {\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.tool = exports.BaseToolkit = exports.DynamicStructuredTool = exports.DynamicTool = exports.Tool = exports.StructuredTool = exports.ToolInputParsingException = void 0;\n  \tconst zod_1 = messages$1.lib;\n  \tconst manager_js_1 = messages$1.manager;\n  \tconst base_js_1 = base$3;\n  \tconst config_js_1 = messages$1.config;\n  \tconst tool_js_1 = messages$1.tool;\n  \tconst index_js_1 = messages$1.singletons;\n  \tconst utils_js_1 = messages$1.utils$1;\n  \tObject.defineProperty(exports, \"ToolInputParsingException\", { enumerable: true, get: function () { return utils_js_1.ToolInputParsingException; } });\n  \tconst is_zod_schema_js_1 = is_zod_schema;\n  \t/**\n  \t * Base class for Tools that accept input of any shape defined by a Zod schema.\n  \t */\n  \tclass StructuredTool extends base_js_1.BaseLangChain {\n  \t    get lc_namespace() {\n  \t        return [\"langchain\", \"tools\"];\n  \t    }\n  \t    constructor(fields) {\n  \t        super(fields ?? {});\n  \t        Object.defineProperty(this, \"returnDirect\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: false\n  \t        });\n  \t        // TODO: Make default in 0.3\n  \t        Object.defineProperty(this, \"verboseParsingErrors\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: false\n  \t        });\n  \t        /**\n  \t         * The tool response format.\n  \t         *\n  \t         * If \"content\" then the output of the tool is interpreted as the contents of a\n  \t         * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n  \t         * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n  \t         *\n  \t         * @default \"content\"\n  \t         */\n  \t        Object.defineProperty(this, \"responseFormat\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: \"content\"\n  \t        });\n  \t        this.verboseParsingErrors =\n  \t            fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n  \t        this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n  \t    }\n  \t    /**\n  \t     * Invokes the tool with the provided input and configuration.\n  \t     * @param input The input for the tool.\n  \t     * @param config Optional configuration for the tool.\n  \t     * @returns A Promise that resolves with a string.\n  \t     */\n  \t    async invoke(input, config) {\n  \t        let tool_call_id;\n  \t        let toolInput;\n  \t        if ((0, utils_js_1._isToolCall)(input)) {\n  \t            tool_call_id = input.id;\n  \t            toolInput = input.args;\n  \t        }\n  \t        else {\n  \t            toolInput = input;\n  \t        }\n  \t        const ensuredConfig = (0, config_js_1.ensureConfig)(config);\n  \t        return this.call(toolInput, {\n  \t            ...ensuredConfig,\n  \t            configurable: {\n  \t                ...ensuredConfig.configurable,\n  \t                tool_call_id,\n  \t            },\n  \t        });\n  \t    }\n  \t    /**\n  \t     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n  \t     *\n  \t     * Calls the tool with the provided argument, configuration, and tags. It\n  \t     * parses the input according to the schema, handles any errors, and\n  \t     * manages callbacks.\n  \t     * @param arg The input argument for the tool.\n  \t     * @param configArg Optional configuration or callbacks for the tool.\n  \t     * @param tags Optional tags for the tool.\n  \t     * @returns A Promise that resolves with a string.\n  \t     */\n  \t    async call(arg, configArg, \n  \t    /** @deprecated */\n  \t    tags) {\n  \t        let parsed;\n  \t        try {\n  \t            parsed = await this.schema.parseAsync(arg);\n  \t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t        }\n  \t        catch (e) {\n  \t            let message = `Received tool input did not match expected schema`;\n  \t            if (this.verboseParsingErrors) {\n  \t                message = `${message}\\nDetails: ${e.message}`;\n  \t            }\n  \t            throw new utils_js_1.ToolInputParsingException(message, JSON.stringify(arg));\n  \t        }\n  \t        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n  \t        const callbackManager_ = await manager_js_1.CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n  \t        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof parsed === \"string\" ? parsed : JSON.stringify(parsed), config.runId, undefined, undefined, undefined, config.runName);\n  \t        delete config.runId;\n  \t        let result;\n  \t        try {\n  \t            result = await this._call(parsed, runManager, config);\n  \t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t        }\n  \t        catch (e) {\n  \t            await runManager?.handleToolError(e);\n  \t            throw e;\n  \t        }\n  \t        let content;\n  \t        let artifact;\n  \t        if (this.responseFormat === \"content_and_artifact\") {\n  \t            if (Array.isArray(result) && result.length === 2) {\n  \t                [content, artifact] = result;\n  \t            }\n  \t            else {\n  \t                throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n  \t            }\n  \t        }\n  \t        else {\n  \t            content = result;\n  \t        }\n  \t        let toolCallId;\n  \t        if (config && \"configurable\" in config) {\n  \t            toolCallId = config.configurable\n  \t                .tool_call_id;\n  \t        }\n  \t        const formattedOutput = _formatToolOutput({\n  \t            content,\n  \t            artifact,\n  \t            toolCallId,\n  \t            name: this.name,\n  \t        });\n  \t        await runManager?.handleToolEnd(formattedOutput);\n  \t        return formattedOutput;\n  \t    }\n  \t}\n  \texports.StructuredTool = StructuredTool;\n  \t/**\n  \t * Base class for Tools that accept input as a string.\n  \t */\n  \tclass Tool extends StructuredTool {\n  \t    constructor(fields) {\n  \t        super(fields);\n  \t        Object.defineProperty(this, \"schema\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: zod_1.z\n  \t                .object({ input: zod_1.z.string().optional() })\n  \t                .transform((obj) => obj.input)\n  \t        });\n  \t    }\n  \t    /**\n  \t     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n  \t     *\n  \t     * Calls the tool with the provided argument and callbacks. It handles\n  \t     * string inputs specifically.\n  \t     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n  \t     * @param callbacks Optional callbacks for the tool.\n  \t     * @returns A Promise that resolves with a string.\n  \t     */\n  \t    call(arg, callbacks) {\n  \t        return super.call(typeof arg === \"string\" || !arg ? { input: arg } : arg, callbacks);\n  \t    }\n  \t}\n  \texports.Tool = Tool;\n  \t/**\n  \t * A tool that can be created dynamically from a function, name, and description.\n  \t */\n  \tclass DynamicTool extends Tool {\n  \t    static lc_name() {\n  \t        return \"DynamicTool\";\n  \t    }\n  \t    constructor(fields) {\n  \t        super(fields);\n  \t        Object.defineProperty(this, \"name\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"description\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"func\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        this.name = fields.name;\n  \t        this.description = fields.description;\n  \t        this.func = fields.func;\n  \t        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  \t    }\n  \t    /**\n  \t     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n  \t     */\n  \t    async call(arg, configArg) {\n  \t        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n  \t        if (config.runName === undefined) {\n  \t            config.runName = this.name;\n  \t        }\n  \t        return super.call(arg, config);\n  \t    }\n  \t    /** @ignore */\n  \t    async _call(input, runManager, parentConfig) {\n  \t        return this.func(input, runManager, parentConfig);\n  \t    }\n  \t}\n  \texports.DynamicTool = DynamicTool;\n  \t/**\n  \t * A tool that can be created dynamically from a function, name, and\n  \t * description, designed to work with structured data. It extends the\n  \t * StructuredTool class and overrides the _call method to execute the\n  \t * provided function when the tool is called.\n  \t *\n  \t * Schema can be passed as Zod or JSON schema. The tool will not validate\n  \t * input if JSON schema is passed.\n  \t */\n  \tclass DynamicStructuredTool extends StructuredTool {\n  \t    static lc_name() {\n  \t        return \"DynamicStructuredTool\";\n  \t    }\n  \t    constructor(fields) {\n  \t        super(fields);\n  \t        Object.defineProperty(this, \"name\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"description\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"func\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        Object.defineProperty(this, \"schema\", {\n  \t            enumerable: true,\n  \t            configurable: true,\n  \t            writable: true,\n  \t            value: void 0\n  \t        });\n  \t        this.name = fields.name;\n  \t        this.description = fields.description;\n  \t        this.func = fields.func;\n  \t        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  \t        this.schema = ((0, is_zod_schema_js_1.isZodSchema)(fields.schema) ? fields.schema : zod_1.z.object({}).passthrough());\n  \t    }\n  \t    /**\n  \t     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n  \t     */\n  \t    async call(arg, configArg, \n  \t    /** @deprecated */\n  \t    tags) {\n  \t        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n  \t        if (config.runName === undefined) {\n  \t            config.runName = this.name;\n  \t        }\n  \t        return super.call(arg, config, tags);\n  \t    }\n  \t    _call(arg, runManager, parentConfig) {\n  \t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t        return this.func(arg, runManager, parentConfig);\n  \t    }\n  \t}\n  \texports.DynamicStructuredTool = DynamicStructuredTool;\n  \t/**\n  \t * Abstract base class for toolkits in LangChain. Toolkits are collections\n  \t * of tools that agents can use. Subclasses must implement the `tools`\n  \t * property to provide the specific tools for the toolkit.\n  \t */\n  \tclass BaseToolkit {\n  \t    getTools() {\n  \t        return this.tools;\n  \t    }\n  \t}\n  \texports.BaseToolkit = BaseToolkit;\n  \tfunction tool(func, fields) {\n  \t    // If the schema is not provided, or it's a string schema, create a DynamicTool\n  \t    if (!fields.schema ||\n  \t        ((0, is_zod_schema_js_1.isZodSchema)(fields.schema) &&\n  \t            (!(\"shape\" in fields.schema) || !fields.schema.shape))) {\n  \t        return new DynamicTool({\n  \t            ...fields,\n  \t            description: fields.description ??\n  \t                fields.schema?.description ??\n  \t                `${fields.name} tool`,\n  \t            // TS doesn't restrict the type here based on the guard above\n  \t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t            func: func,\n  \t        });\n  \t    }\n  \t    const description = fields.description ?? fields.schema.description ?? `${fields.name} tool`;\n  \t    return new DynamicStructuredTool({\n  \t        ...fields,\n  \t        description,\n  \t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t        schema: fields.schema,\n  \t        // TODO: Consider moving into DynamicStructuredTool constructor\n  \t        func: async (input, runManager, config) => {\n  \t            return new Promise((resolve, reject) => {\n  \t                const childConfig = (0, config_js_1.patchConfig)(config, {\n  \t                    callbacks: runManager?.getChild(),\n  \t                });\n  \t                void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n  \t                    try {\n  \t                        // TS doesn't restrict the type here based on the guard above\n  \t                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  \t                        resolve(func(input, childConfig));\n  \t                    }\n  \t                    catch (e) {\n  \t                        reject(e);\n  \t                    }\n  \t                });\n  \t            });\n  \t        },\n  \t    });\n  \t}\n  \texports.tool = tool;\n  \tfunction _formatToolOutput(params) {\n  \t    const { content, artifact, toolCallId } = params;\n  \t    if (toolCallId) {\n  \t        if (typeof content === \"string\" ||\n  \t            (Array.isArray(content) &&\n  \t                content.every((item) => typeof item === \"object\"))) {\n  \t            return new tool_js_1.ToolMessage({\n  \t                content,\n  \t                artifact,\n  \t                tool_call_id: toolCallId,\n  \t                name: params.name,\n  \t            });\n  \t        }\n  \t        else {\n  \t            return new tool_js_1.ToolMessage({\n  \t                content: _stringify(content),\n  \t                artifact,\n  \t                tool_call_id: toolCallId,\n  \t                name: params.name,\n  \t            });\n  \t        }\n  \t    }\n  \t    else {\n  \t        return content;\n  \t    }\n  \t}\n  \tfunction _stringify(content) {\n  \t    try {\n  \t        return JSON.stringify(content, null, 2);\n  \t    }\n  \t    catch (_noOp) {\n  \t        return `${content}`;\n  \t    }\n  \t} \n  } (tools$1));\n\n  var tools = tools$1;\n\n  Object.defineProperty(dalle, \"__esModule\", { value: true });\n  dalle.DallEAPIWrapper = void 0;\n  /* eslint-disable no-param-reassign */\n  const env_1 = env;\n  const openai_1 = openaiExports;\n  const tools_1 = tools;\n  /**\n   * A tool for generating images with Open AIs Dall-E 2 or 3 API.\n   */\n  class DallEAPIWrapper extends tools_1.Tool {\n      static lc_name() {\n          return \"DallEAPIWrapper\";\n      }\n      constructor(fields) {\n          // Shim for new base tool param name\n          if (fields?.responseFormat !== undefined &&\n              [\"url\", \"b64_json\"].includes(fields.responseFormat)) {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              fields.dallEResponseFormat = fields.responseFormat;\n              fields.responseFormat = \"content\";\n          }\n          super(fields);\n          Object.defineProperty(this, \"name\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"dalle_api_wrapper\"\n          });\n          Object.defineProperty(this, \"description\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"A wrapper around OpenAI DALL-E API. Useful for when you need to generate images from a text description. Input should be an image description.\"\n          });\n          Object.defineProperty(this, \"client\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          Object.defineProperty(this, \"model\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"dall-e-3\"\n          });\n          Object.defineProperty(this, \"style\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"vivid\"\n          });\n          Object.defineProperty(this, \"quality\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"standard\"\n          });\n          Object.defineProperty(this, \"n\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: 1\n          });\n          Object.defineProperty(this, \"size\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"1024x1024\"\n          });\n          Object.defineProperty(this, \"dallEResponseFormat\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: \"url\"\n          });\n          Object.defineProperty(this, \"user\", {\n              enumerable: true,\n              configurable: true,\n              writable: true,\n              value: void 0\n          });\n          const openAIApiKey = fields?.apiKey ??\n              fields?.openAIApiKey ??\n              (0, env_1.getEnvironmentVariable)(\"OPENAI_API_KEY\");\n          const organization = fields?.organization ?? (0, env_1.getEnvironmentVariable)(\"OPENAI_ORGANIZATION\");\n          const clientConfig = {\n              apiKey: openAIApiKey,\n              organization,\n              dangerouslyAllowBrowser: true,\n              baseUrl: fields?.baseUrl,\n          };\n          this.client = new openai_1.OpenAI(clientConfig);\n          this.model = fields?.model ?? fields?.modelName ?? this.model;\n          this.style = fields?.style ?? this.style;\n          this.quality = fields?.quality ?? this.quality;\n          this.n = fields?.n ?? this.n;\n          this.size = fields?.size ?? this.size;\n          this.dallEResponseFormat =\n              fields?.dallEResponseFormat ?? this.dallEResponseFormat;\n          this.user = fields?.user;\n      }\n      /**\n       * Processes the API response if multiple images are generated.\n       * Returns a list of MessageContentImageUrl objects. If the response\n       * format is `url`, then the `image_url` field will contain the URL.\n       * If it is `b64_json`, then the `image_url` field will contain an object\n       * with a `url` field with the base64 encoded image.\n       *\n       * @param {OpenAIClient.Images.ImagesResponse[]} response The API response\n       * @returns {MessageContentImageUrl[]}\n       */\n      processMultipleGeneratedUrls(response) {\n          if (this.dallEResponseFormat === \"url\") {\n              return response.flatMap((res) => {\n                  const imageUrlContent = res.data\n                      .flatMap((item) => {\n                      if (!item.url)\n                          return [];\n                      return {\n                          type: \"image_url\",\n                          image_url: item.url,\n                      };\n                  })\n                      .filter((item) => item !== undefined &&\n                      item.type === \"image_url\" &&\n                      typeof item.image_url === \"string\" &&\n                      item.image_url !== undefined);\n                  return imageUrlContent;\n              });\n          }\n          else {\n              return response.flatMap((res) => {\n                  const b64Content = res.data\n                      .flatMap((item) => {\n                      if (!item.b64_json)\n                          return [];\n                      return {\n                          type: \"image_url\",\n                          image_url: {\n                              url: item.b64_json,\n                          },\n                      };\n                  })\n                      .filter((item) => item !== undefined &&\n                      item.type === \"image_url\" &&\n                      typeof item.image_url === \"object\" &&\n                      \"url\" in item.image_url &&\n                      typeof item.image_url.url === \"string\" &&\n                      item.image_url.url !== undefined);\n                  return b64Content;\n              });\n          }\n      }\n      /** @ignore */\n      async _call(input) {\n          const generateImageFields = {\n              model: this.model,\n              prompt: input,\n              n: 1,\n              size: this.size,\n              response_format: this.dallEResponseFormat,\n              style: this.style,\n              quality: this.quality,\n              user: this.user,\n          };\n          if (this.n > 1) {\n              const results = await Promise.all(Array.from({ length: this.n }).map(() => this.client.images.generate(generateImageFields)));\n              return this.processMultipleGeneratedUrls(results);\n          }\n          const response = await this.client.images.generate(generateImageFields);\n          let data = \"\";\n          if (this.dallEResponseFormat === \"url\") {\n              [data] = response.data\n                  .map((item) => item.url)\n                  .filter((url) => url !== \"undefined\");\n          }\n          else {\n              [data] = response.data\n                  .map((item) => item.b64_json)\n                  .filter((b64_json) => b64_json !== \"undefined\");\n          }\n          return data;\n      }\n  }\n  dalle.DallEAPIWrapper = DallEAPIWrapper;\n  Object.defineProperty(DallEAPIWrapper, \"toolName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"dalle_api_wrapper\"\n  });\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \t__exportStar(dalle, exports); \n  } (tools$2));\n\n  var prompts = {};\n\n  Object.defineProperty(prompts, \"__esModule\", { value: true });\n  prompts.convertPromptToOpenAI = void 0;\n  const chat_models_js_1 = chat_models$3;\n  /**\n   * Convert a formatted LangChain prompt (e.g. pulled from the hub) into\n   * a format expected by OpenAI's JS SDK.\n   *\n   * Requires the \"@langchain/openai\" package to be installed in addition\n   * to the OpenAI SDK.\n   *\n   * @example\n   * ```ts\n   * import { convertPromptToOpenAI } from \"langsmith/utils/hub/openai\";\n   * import { pull } from \"langchain/hub\";\n   *\n   * import OpenAI from 'openai';\n   *\n   * const prompt = await pull(\"jacob/joke-generator\");\n   * const formattedPrompt = await prompt.invoke({\n   *   topic: \"cats\",\n   * });\n   *\n   * const { messages } = convertPromptToOpenAI(formattedPrompt);\n   *\n   * const openAIClient = new OpenAI();\n   *\n   * const openaiResponse = await openAIClient.chat.completions.create({\n   *   model: \"gpt-4o\",\n   *   messages,\n   * });\n   * ```\n   * @param formattedPrompt\n   * @returns A partial OpenAI payload.\n   */\n  function convertPromptToOpenAI(formattedPrompt) {\n      const messages = formattedPrompt.toChatMessages();\n      return {\n          messages: (0, chat_models_js_1._convertMessagesToOpenAIParams)(messages),\n      };\n  }\n  prompts.convertPromptToOpenAI = convertPromptToOpenAI;\n\n  (function (exports) {\n  \tvar __createBinding = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    var desc = Object.getOwnPropertyDescriptor(m, k);\n  \t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n  \t      desc = { enumerable: true, get: function() { return m[k]; } };\n  \t    }\n  \t    Object.defineProperty(o, k2, desc);\n  \t}) : (function(o, m, k, k2) {\n  \t    if (k2 === undefined) k2 = k;\n  \t    o[k2] = m[k];\n  \t}));\n  \tvar __exportStar = (messages$1.commonjsGlobal && messages$1.commonjsGlobal.__exportStar) || function(m, exports) {\n  \t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  \t};\n  \tObject.defineProperty(exports, \"__esModule\", { value: true });\n  \texports.convertPromptToOpenAI = exports.toFile = exports.OpenAIClient = void 0;\n  \tvar openai_1 = openaiExports;\n  \tObject.defineProperty(exports, \"OpenAIClient\", { enumerable: true, get: function () { return openai_1.OpenAI; } });\n  \tObject.defineProperty(exports, \"toFile\", { enumerable: true, get: function () { return openai_1.toFile; } });\n  \t__exportStar(chat_models$3, exports);\n  \t__exportStar(chat_models, exports);\n  \t__exportStar(llms$3, exports);\n  \t__exportStar(llms, exports);\n  \t__exportStar(embeddings$3, exports);\n  \t__exportStar(embeddings$2, exports);\n  \t__exportStar(types, exports);\n  \t__exportStar(openai$1, exports);\n  \t__exportStar(azure, exports);\n  \t__exportStar(tools$2, exports);\n  \tvar prompts_js_1 = prompts;\n  \tObject.defineProperty(exports, \"convertPromptToOpenAI\", { enumerable: true, get: function () { return prompts_js_1.convertPromptToOpenAI; } }); \n  } (dist));\n\n  var openai = dist;\n\n  try { Object.defineProperty(openai, \"__\" + \"esModule\", { value: true }); openai.default = openai; } catch (ex) {}\n\n  return openai;\n\n}));\n"
    },
    {
      "name": "messages2",
      "originalName": "messages2",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction getAugmentedNamespace(n) {\n\t  if (n.__esModule) return n;\n\t  var f = n.default;\n\t\tif (typeof f == \"function\") {\n\t\t\tvar a = function a () {\n\t\t\t\tif (this instanceof a) {\n\t        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t\t}\n\t\t\t\treturn f.apply(this, arguments);\n\t\t\t};\n\t\t\ta.prototype = f.prototype;\n\t  } else a = {};\n\t  Object.defineProperty(a, '__esModule', {value: true});\n\t\tObject.keys(n).forEach(function (k) {\n\t\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn n[k];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn a;\n\t}\n\n\tvar messages$2 = {};\n\n\tvar ai = {};\n\n\tvar json = {};\n\n\tObject.defineProperty(json, \"__esModule\", { value: true });\n\tjson.parsePartialJson = json.parseJsonMarkdown = void 0;\n\tfunction parseJsonMarkdown(s, parser = parsePartialJson) {\n\t    // eslint-disable-next-line no-param-reassign\n\t    s = s.trim();\n\t    const match = /```(json)?(.*)```/s.exec(s);\n\t    if (!match) {\n\t        return parser(s);\n\t    }\n\t    else {\n\t        return parser(match[2]);\n\t    }\n\t}\n\tjson.parseJsonMarkdown = parseJsonMarkdown;\n\t// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n\t// MIT License\n\tfunction parsePartialJson(s) {\n\t    // If the input is undefined, return null to indicate failure.\n\t    if (typeof s === \"undefined\") {\n\t        return null;\n\t    }\n\t    // Attempt to parse the string as-is.\n\t    try {\n\t        return JSON.parse(s);\n\t    }\n\t    catch (error) {\n\t        // Pass\n\t    }\n\t    // Initialize variables.\n\t    let new_s = \"\";\n\t    const stack = [];\n\t    let isInsideString = false;\n\t    let escaped = false;\n\t    // Process each character in the string one at a time.\n\t    for (let char of s) {\n\t        if (isInsideString) {\n\t            if (char === '\"' && !escaped) {\n\t                isInsideString = false;\n\t            }\n\t            else if (char === \"\\n\" && !escaped) {\n\t                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n\t            }\n\t            else if (char === \"\\\\\") {\n\t                escaped = !escaped;\n\t            }\n\t            else {\n\t                escaped = false;\n\t            }\n\t        }\n\t        else {\n\t            if (char === '\"') {\n\t                isInsideString = true;\n\t                escaped = false;\n\t            }\n\t            else if (char === \"{\") {\n\t                stack.push(\"}\");\n\t            }\n\t            else if (char === \"[\") {\n\t                stack.push(\"]\");\n\t            }\n\t            else if (char === \"}\" || char === \"]\") {\n\t                if (stack && stack[stack.length - 1] === char) {\n\t                    stack.pop();\n\t                }\n\t                else {\n\t                    // Mismatched closing character; the input is malformed.\n\t                    return null;\n\t                }\n\t            }\n\t        }\n\t        // Append the processed character to the new string.\n\t        new_s += char;\n\t    }\n\t    // If we're still inside a string at the end of processing,\n\t    // we need to close the string.\n\t    if (isInsideString) {\n\t        new_s += '\"';\n\t    }\n\t    // Close any remaining open structures in the reverse order that they were opened.\n\t    for (let i = stack.length - 1; i >= 0; i -= 1) {\n\t        new_s += stack[i];\n\t    }\n\t    // Attempt to parse the modified string as JSON.\n\t    try {\n\t        return JSON.parse(new_s);\n\t    }\n\t    catch (error) {\n\t        // If we still can't parse the string as JSON, return null to indicate failure.\n\t        return null;\n\t    }\n\t}\n\tjson.parsePartialJson = parsePartialJson;\n\n\tvar base$3 = {};\n\n\tvar serializable = {};\n\n\tvar map_keys = {};\n\n\tvar decamelize = function (str, sep) {\n\t\tif (typeof str !== 'string') {\n\t\t\tthrow new TypeError('Expected a string');\n\t\t}\n\n\t\tsep = typeof sep === 'undefined' ? '_' : sep;\n\n\t\treturn str\n\t\t\t.replace(/([a-z\\d])([A-Z])/g, '$1' + sep + '$2')\n\t\t\t.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + sep + '$2')\n\t\t\t.toLowerCase();\n\t};\n\n\tvar camelcase = {exports: {}};\n\n\tconst UPPERCASE = /[\\p{Lu}]/u;\n\tconst LOWERCASE = /[\\p{Ll}]/u;\n\tconst LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/gu;\n\tconst IDENTIFIER = /([\\p{Alpha}\\p{N}_]|$)/u;\n\tconst SEPARATORS = /[_.\\- ]+/;\n\n\tconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\n\tconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');\n\tconst NUMBERS_AND_IDENTIFIER = new RegExp('\\\\d+' + IDENTIFIER.source, 'gu');\n\n\tconst preserveCamelCase = (string, toLowerCase, toUpperCase) => {\n\t\tlet isLastCharLower = false;\n\t\tlet isLastCharUpper = false;\n\t\tlet isLastLastCharUpper = false;\n\n\t\tfor (let i = 0; i < string.length; i++) {\n\t\t\tconst character = string[i];\n\n\t\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\t\tstring = string.slice(0, i) + '-' + string.slice(i);\n\t\t\t\tisLastCharLower = false;\n\t\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\t\tisLastCharUpper = true;\n\t\t\t\ti++;\n\t\t\t} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {\n\t\t\t\tstring = string.slice(0, i - 1) + '-' + string.slice(i - 1);\n\t\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\t\tisLastCharUpper = false;\n\t\t\t\tisLastCharLower = true;\n\t\t\t} else {\n\t\t\t\tisLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;\n\t\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\t\tisLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;\n\t\t\t}\n\t\t}\n\n\t\treturn string;\n\t};\n\n\tconst preserveConsecutiveUppercase = (input, toLowerCase) => {\n\t\tLEADING_CAPITAL.lastIndex = 0;\n\n\t\treturn input.replace(LEADING_CAPITAL, m1 => toLowerCase(m1));\n\t};\n\n\tconst postProcess = (input, toUpperCase) => {\n\t\tSEPARATORS_AND_IDENTIFIER.lastIndex = 0;\n\t\tNUMBERS_AND_IDENTIFIER.lastIndex = 0;\n\n\t\treturn input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier))\n\t\t\t.replace(NUMBERS_AND_IDENTIFIER, m => toUpperCase(m));\n\t};\n\n\tconst camelCase = (input, options) => {\n\t\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t\t}\n\n\t\toptions = {\n\t\t\tpascalCase: false,\n\t\t\tpreserveConsecutiveUppercase: false,\n\t\t\t...options\n\t\t};\n\n\t\tif (Array.isArray(input)) {\n\t\t\tinput = input.map(x => x.trim())\n\t\t\t\t.filter(x => x.length)\n\t\t\t\t.join('-');\n\t\t} else {\n\t\t\tinput = input.trim();\n\t\t}\n\n\t\tif (input.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst toLowerCase = options.locale === false ?\n\t\t\tstring => string.toLowerCase() :\n\t\t\tstring => string.toLocaleLowerCase(options.locale);\n\t\tconst toUpperCase = options.locale === false ?\n\t\t\tstring => string.toUpperCase() :\n\t\t\tstring => string.toLocaleUpperCase(options.locale);\n\n\t\tif (input.length === 1) {\n\t\t\treturn options.pascalCase ? toUpperCase(input) : toLowerCase(input);\n\t\t}\n\n\t\tconst hasUpperCase = input !== toLowerCase(input);\n\n\t\tif (hasUpperCase) {\n\t\t\tinput = preserveCamelCase(input, toLowerCase, toUpperCase);\n\t\t}\n\n\t\tinput = input.replace(LEADING_SEPARATORS, '');\n\n\t\tif (options.preserveConsecutiveUppercase) {\n\t\t\tinput = preserveConsecutiveUppercase(input, toLowerCase);\n\t\t} else {\n\t\t\tinput = toLowerCase(input);\n\t\t}\n\n\t\tif (options.pascalCase) {\n\t\t\tinput = toUpperCase(input.charAt(0)) + input.slice(1);\n\t\t}\n\n\t\treturn postProcess(input, toUpperCase);\n\t};\n\n\tcamelcase.exports = camelCase;\n\t// TODO: Remove this for the next major release\n\tcamelcase.exports.default = camelCase;\n\n\tvar camelcaseExports = camelcase.exports;\n\n\tvar __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(map_keys, \"__esModule\", { value: true });\n\tmap_keys.mapKeys = map_keys.keyFromJson = map_keys.keyToJson = void 0;\n\tconst decamelize_1 = __importDefault$6(decamelize);\n\tconst camelcase_1 = __importDefault$6(camelcaseExports);\n\tfunction keyToJson(key, map) {\n\t    return map?.[key] || (0, decamelize_1.default)(key);\n\t}\n\tmap_keys.keyToJson = keyToJson;\n\tfunction keyFromJson(key, map) {\n\t    return map?.[key] || (0, camelcase_1.default)(key);\n\t}\n\tmap_keys.keyFromJson = keyFromJson;\n\tfunction mapKeys(fields, mapper, map) {\n\t    const mapped = {};\n\t    for (const key in fields) {\n\t        if (Object.hasOwn(fields, key)) {\n\t            mapped[mapper(key, map)] = fields[key];\n\t        }\n\t    }\n\t    return mapped;\n\t}\n\tmap_keys.mapKeys = mapKeys;\n\n\tObject.defineProperty(serializable, \"__esModule\", {\n\t  value: true\n\t});\n\tserializable.Serializable = serializable.get_lc_unique_name = void 0;\n\tconst map_keys_js_1 = map_keys;\n\tfunction shallowCopy(obj) {\n\t  return Array.isArray(obj) ? [...obj] : {\n\t    ...obj\n\t  };\n\t}\n\tfunction replaceSecrets(root, secretsMap) {\n\t  const result = shallowCopy(root);\n\t  for (const [path, secretId] of Object.entries(secretsMap)) {\n\t    const [last, ...partsReverse] = path.split(\".\").reverse();\n\t    let current = result;\n\t    for (const part of partsReverse.reverse()) {\n\t      if (current[part] === undefined) {\n\t        break;\n\t      }\n\t      current[part] = shallowCopy(current[part]);\n\t      current = current[part];\n\t    }\n\t    if (current[last] !== undefined) {\n\t      current[last] = {\n\t        lc: 1,\n\t        type: \"secret\",\n\t        id: [secretId]\n\t      };\n\t    }\n\t  }\n\t  return result;\n\t}\n\tfunction get_lc_unique_name(serializableClass) {\n\t  const parentClass = Object.getPrototypeOf(serializableClass);\n\t  const lcNameIsSubclassed = typeof serializableClass.lc_name === \"function\" && (typeof parentClass.lc_name !== \"function\" || serializableClass.lc_name() !== parentClass.lc_name());\n\t  if (lcNameIsSubclassed) {\n\t    return serializableClass.lc_name();\n\t  } else {\n\t    return serializableClass.name;\n\t  }\n\t}\n\tserializable.get_lc_unique_name = get_lc_unique_name;\n\tclass Serializable {\n\t  static lc_name() {\n\t    return this.name;\n\t  }\n\t  get lc_id() {\n\t    return [...this.lc_namespace, get_lc_unique_name(this.constructor)];\n\t  }\n\t  get lc_secrets() {\n\t    return undefined;\n\t  }\n\t  get lc_attributes() {\n\t    return undefined;\n\t  }\n\t  get lc_aliases() {\n\t    return undefined;\n\t  }\n\t  constructor(kwargs, ..._args) {\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: false\n\t    });\n\t    Object.defineProperty(this, \"lc_kwargs\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.lc_kwargs = kwargs || ({});\n\t  }\n\t  toJSON() {\n\t    if (!this.lc_serializable) {\n\t      return this.toJSONNotImplemented();\n\t    }\n\t    if (this.lc_kwargs instanceof Serializable || typeof this.lc_kwargs !== \"object\" || Array.isArray(this.lc_kwargs)) {\n\t      return this.toJSONNotImplemented();\n\t    }\n\t    const aliases = {};\n\t    const secrets = {};\n\t    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n\t      acc[key] = (key in this) ? this[key] : this.lc_kwargs[key];\n\t      return acc;\n\t    }, {});\n\t    for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {\n\t      Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n\t      Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n\t      Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n\t    }\n\t    Object.keys(secrets).forEach(keyPath => {\n\t      let read = this;\n\t      let write = kwargs;\n\t      const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n\t      for (const key of partsReverse.reverse()) {\n\t        if (!((key in read)) || read[key] === undefined) return;\n\t        if (!((key in write)) || write[key] === undefined) {\n\t          if (typeof read[key] === \"object\" && read[key] != null) {\n\t            write[key] = {};\n\t          } else if (Array.isArray(read[key])) {\n\t            write[key] = [];\n\t          }\n\t        }\n\t        read = read[key];\n\t        write = write[key];\n\t      }\n\t      if ((last in read) && read[last] !== undefined) {\n\t        write[last] = write[last] || read[last];\n\t      }\n\t    });\n\t    return {\n\t      lc: 1,\n\t      type: \"constructor\",\n\t      id: this.lc_id,\n\t      kwargs: (0, map_keys_js_1.mapKeys)(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, map_keys_js_1.keyToJson, aliases)\n\t    };\n\t  }\n\t  toJSONNotImplemented() {\n\t    return {\n\t      lc: 1,\n\t      type: \"not_implemented\",\n\t      id: this.lc_id\n\t    };\n\t  }\n\t}\n\tserializable.Serializable = Serializable;\n\n\tObject.defineProperty(base$3, \"__esModule\", { value: true });\n\tbase$3.isBaseMessageChunk = base$3.isBaseMessage = base$3._isMessageFieldWithRole = base$3.BaseMessageChunk = base$3._mergeObj = base$3._mergeLists = base$3._mergeDicts = base$3.isOpenAIToolCallArray = base$3.BaseMessage = base$3._mergeStatus = base$3.mergeContent = void 0;\n\tconst serializable_js_1$2 = serializable;\n\tfunction mergeContent(firstContent, secondContent) {\n\t    // If first content is a string\n\t    if (typeof firstContent === \"string\") {\n\t        if (typeof secondContent === \"string\") {\n\t            return firstContent + secondContent;\n\t        }\n\t        else {\n\t            return [{ type: \"text\", text: firstContent }, ...secondContent];\n\t        }\n\t        // If both are arrays\n\t    }\n\t    else if (Array.isArray(secondContent)) {\n\t        return (_mergeLists(firstContent, secondContent) ?? [\n\t            ...firstContent,\n\t            ...secondContent,\n\t        ]);\n\t    }\n\t    else {\n\t        // Otherwise, add the second content as a new element of the list\n\t        return [...firstContent, { type: \"text\", text: secondContent }];\n\t    }\n\t}\n\tbase$3.mergeContent = mergeContent;\n\t/**\n\t * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n\t * it will return 'success'.\n\t *\n\t * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n\t * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n\t * @returns {\"success\" | \"error\"} The 'merged' value.\n\t */\n\tfunction _mergeStatus(left, right) {\n\t    if (left === \"error\" || right === \"error\") {\n\t        return \"error\";\n\t    }\n\t    return \"success\";\n\t}\n\tbase$3._mergeStatus = _mergeStatus;\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tfunction stringifyWithDepthLimit(obj, depthLimit) {\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    function helper(obj, currentDepth) {\n\t        if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n\t            return obj;\n\t        }\n\t        if (currentDepth >= depthLimit) {\n\t            if (Array.isArray(obj)) {\n\t                return \"[Array]\";\n\t            }\n\t            return \"[Object]\";\n\t        }\n\t        if (Array.isArray(obj)) {\n\t            return obj.map((item) => helper(item, currentDepth + 1));\n\t        }\n\t        const result = {};\n\t        for (const key of Object.keys(obj)) {\n\t            result[key] = helper(obj[key], currentDepth + 1);\n\t        }\n\t        return result;\n\t    }\n\t    return JSON.stringify(helper(obj, 0), null, 2);\n\t}\n\t/**\n\t * Base class for all types of messages in a conversation. It includes\n\t * properties like `content`, `name`, and `additional_kwargs`. It also\n\t * includes methods like `toDict()` and `_getType()`.\n\t */\n\tclass BaseMessage extends serializable_js_1$2.Serializable {\n\t    get lc_aliases() {\n\t        // exclude snake case conversion to pascal case\n\t        return {\n\t            additional_kwargs: \"additional_kwargs\",\n\t            response_metadata: \"response_metadata\",\n\t        };\n\t    }\n\t    /**\n\t     * @deprecated\n\t     * Use {@link BaseMessage.content} instead.\n\t     */\n\t    get text() {\n\t        return typeof this.content === \"string\" ? this.content : \"\";\n\t    }\n\t    constructor(fields, \n\t    /** @deprecated */\n\t    kwargs) {\n\t        if (typeof fields === \"string\") {\n\t            // eslint-disable-next-line no-param-reassign\n\t            fields = {\n\t                content: fields,\n\t                additional_kwargs: kwargs,\n\t                response_metadata: {},\n\t            };\n\t        }\n\t        // Make sure the default value for additional_kwargs is passed into super() for serialization\n\t        if (!fields.additional_kwargs) {\n\t            // eslint-disable-next-line no-param-reassign\n\t            fields.additional_kwargs = {};\n\t        }\n\t        if (!fields.response_metadata) {\n\t            // eslint-disable-next-line no-param-reassign\n\t            fields.response_metadata = {};\n\t        }\n\t        super(fields);\n\t        Object.defineProperty(this, \"lc_namespace\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: [\"langchain_core\", \"messages\"]\n\t        });\n\t        Object.defineProperty(this, \"lc_serializable\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: true\n\t        });\n\t        /** The content of the message. */\n\t        Object.defineProperty(this, \"content\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        /** The name of the message sender in a multi-user chat. */\n\t        Object.defineProperty(this, \"name\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        /** Additional keyword arguments */\n\t        Object.defineProperty(this, \"additional_kwargs\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        /** Response metadata. For example: response headers, logprobs, token counts. */\n\t        Object.defineProperty(this, \"response_metadata\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        /**\n\t         * An optional unique identifier for the message. This should ideally be\n\t         * provided by the provider/model which created the message.\n\t         */\n\t        Object.defineProperty(this, \"id\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.name = fields.name;\n\t        this.content = fields.content;\n\t        this.additional_kwargs = fields.additional_kwargs;\n\t        this.response_metadata = fields.response_metadata;\n\t        this.id = fields.id;\n\t    }\n\t    toDict() {\n\t        return {\n\t            type: this._getType(),\n\t            data: this.toJSON()\n\t                .kwargs,\n\t        };\n\t    }\n\t    static lc_name() {\n\t        return \"BaseMessage\";\n\t    }\n\t    // Can't be protected for silly reasons\n\t    get _printableFields() {\n\t        return {\n\t            id: this.id,\n\t            content: this.content,\n\t            name: this.name,\n\t            additional_kwargs: this.additional_kwargs,\n\t            response_metadata: this.response_metadata,\n\t        };\n\t    }\n\t    // this private method is used to update the ID for the runtime\n\t    // value as well as in lc_kwargs for serialisation\n\t    _updateId(value) {\n\t        this.id = value;\n\t        // lc_attributes wouldn't work here, because jest compares the\n\t        // whole object\n\t        this.lc_kwargs.id = value;\n\t    }\n\t    get [Symbol.toStringTag]() {\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        return this.constructor.lc_name();\n\t    }\n\t    // Override the default behavior of console.log\n\t    [Symbol.for(\"nodejs.util.inspect.custom\")](depth) {\n\t        if (depth === null) {\n\t            return this;\n\t        }\n\t        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        return `${this.constructor.lc_name()} ${printable}`;\n\t    }\n\t}\n\tbase$3.BaseMessage = BaseMessage;\n\tfunction isOpenAIToolCallArray(value) {\n\t    return (Array.isArray(value) &&\n\t        value.every((v) => typeof v.index === \"number\"));\n\t}\n\tbase$3.isOpenAIToolCallArray = isOpenAIToolCallArray;\n\tfunction _mergeDicts(\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tleft, \n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tright\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t) {\n\t    const merged = { ...left };\n\t    for (const [key, value] of Object.entries(right)) {\n\t        if (merged[key] == null) {\n\t            merged[key] = value;\n\t        }\n\t        else if (value == null) {\n\t            continue;\n\t        }\n\t        else if (typeof merged[key] !== typeof value ||\n\t            Array.isArray(merged[key]) !== Array.isArray(value)) {\n\t            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n\t        }\n\t        else if (typeof merged[key] === \"string\") {\n\t            if (key === \"type\") {\n\t                // Do not merge 'type' fields\n\t                continue;\n\t            }\n\t            merged[key] += value;\n\t        }\n\t        else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n\t            merged[key] = _mergeDicts(merged[key], value);\n\t        }\n\t        else if (Array.isArray(merged[key])) {\n\t            merged[key] = _mergeLists(merged[key], value);\n\t        }\n\t        else if (merged[key] === value) {\n\t            continue;\n\t        }\n\t        else {\n\t            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n\t        }\n\t    }\n\t    return merged;\n\t}\n\tbase$3._mergeDicts = _mergeDicts;\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tfunction _mergeLists(left, right) {\n\t    if (left === undefined && right === undefined) {\n\t        return undefined;\n\t    }\n\t    else if (left === undefined || right === undefined) {\n\t        return left || right;\n\t    }\n\t    else {\n\t        const merged = [...left];\n\t        for (const item of right) {\n\t            if (typeof item === \"object\" &&\n\t                \"index\" in item &&\n\t                typeof item.index === \"number\") {\n\t                const toMerge = merged.findIndex((leftItem) => leftItem.index === item.index);\n\t                if (toMerge !== -1) {\n\t                    merged[toMerge] = _mergeDicts(merged[toMerge], item);\n\t                }\n\t                else {\n\t                    merged.push(item);\n\t                }\n\t            }\n\t            else if (typeof item === \"object\" &&\n\t                \"text\" in item &&\n\t                item.text === \"\") {\n\t                // No-op - skip empty text blocks\n\t                continue;\n\t            }\n\t            else {\n\t                merged.push(item);\n\t            }\n\t        }\n\t        return merged;\n\t    }\n\t}\n\tbase$3._mergeLists = _mergeLists;\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tfunction _mergeObj(left, right) {\n\t    if (!left && !right) {\n\t        throw new Error(\"Cannot merge two undefined objects.\");\n\t    }\n\t    if (!left || !right) {\n\t        return left || right;\n\t    }\n\t    else if (typeof left !== typeof right) {\n\t        throw new Error(`Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`);\n\t    }\n\t    else if (typeof left === \"string\" && typeof right === \"string\") {\n\t        return (left + right);\n\t    }\n\t    else if (Array.isArray(left) && Array.isArray(right)) {\n\t        return _mergeLists(left, right);\n\t    }\n\t    else if (typeof left === \"object\" && typeof right === \"object\") {\n\t        return _mergeDicts(left, right);\n\t    }\n\t    else if (left === right) {\n\t        return left;\n\t    }\n\t    else {\n\t        throw new Error(`Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`);\n\t    }\n\t}\n\tbase$3._mergeObj = _mergeObj;\n\t/**\n\t * Represents a chunk of a message, which can be concatenated with other\n\t * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n\t * additional keyword arguments from another `BaseMessageChunk` into this\n\t * one. It also overrides the `__add__()` method to support concatenation\n\t * of `BaseMessageChunk` instances.\n\t */\n\tclass BaseMessageChunk extends BaseMessage {\n\t}\n\tbase$3.BaseMessageChunk = BaseMessageChunk;\n\tfunction _isMessageFieldWithRole(x) {\n\t    return typeof x.role === \"string\";\n\t}\n\tbase$3._isMessageFieldWithRole = _isMessageFieldWithRole;\n\tfunction isBaseMessage(messageLike) {\n\t    return typeof messageLike?._getType === \"function\";\n\t}\n\tbase$3.isBaseMessage = isBaseMessage;\n\tfunction isBaseMessageChunk(messageLike) {\n\t    return (isBaseMessage(messageLike) &&\n\t        typeof messageLike.concat === \"function\");\n\t}\n\tbase$3.isBaseMessageChunk = isBaseMessageChunk;\n\n\tvar tool = {};\n\n\tObject.defineProperty(tool, \"__esModule\", { value: true });\n\ttool.defaultToolCallParser = tool.ToolMessageChunk = tool.ToolMessage = void 0;\n\tconst base_js_1$f = base$3;\n\t/**\n\t * Represents a tool message in a conversation.\n\t */\n\tclass ToolMessage extends base_js_1$f.BaseMessage {\n\t    static lc_name() {\n\t        return \"ToolMessage\";\n\t    }\n\t    get lc_aliases() {\n\t        // exclude snake case conversion to pascal case\n\t        return { tool_call_id: \"tool_call_id\" };\n\t    }\n\t    constructor(fields, tool_call_id, name) {\n\t        if (typeof fields === \"string\") {\n\t            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n\t            fields = { content: fields, name, tool_call_id: tool_call_id };\n\t        }\n\t        super(fields);\n\t        /**\n\t         * Status of the tool invocation.\n\t         * @version 0.2.19\n\t         */\n\t        Object.defineProperty(this, \"status\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"tool_call_id\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        /**\n\t         * Artifact of the Tool execution which is not meant to be sent to the model.\n\t         *\n\t         * Should only be specified if it is different from the message content, e.g. if only\n\t         * a subset of the full tool output is being passed as message content but the full\n\t         * output is needed in other parts of the code.\n\t         */\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        Object.defineProperty(this, \"artifact\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.tool_call_id = fields.tool_call_id;\n\t        this.artifact = fields.artifact;\n\t        this.status = fields.status;\n\t    }\n\t    _getType() {\n\t        return \"tool\";\n\t    }\n\t    static isInstance(message) {\n\t        return message._getType() === \"tool\";\n\t    }\n\t    get _printableFields() {\n\t        return {\n\t            ...super._printableFields,\n\t            tool_call_id: this.tool_call_id,\n\t            artifact: this.artifact,\n\t        };\n\t    }\n\t}\n\ttool.ToolMessage = ToolMessage;\n\t/**\n\t * Represents a chunk of a tool message, which can be concatenated\n\t * with other tool message chunks.\n\t */\n\tclass ToolMessageChunk extends base_js_1$f.BaseMessageChunk {\n\t    constructor(fields) {\n\t        super(fields);\n\t        Object.defineProperty(this, \"tool_call_id\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        /**\n\t         * Status of the tool invocation.\n\t         * @version 0.2.19\n\t         */\n\t        Object.defineProperty(this, \"status\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        /**\n\t         * Artifact of the Tool execution which is not meant to be sent to the model.\n\t         *\n\t         * Should only be specified if it is different from the message content, e.g. if only\n\t         * a subset of the full tool output is being passed as message content but the full\n\t         * output is needed in other parts of the code.\n\t         */\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        Object.defineProperty(this, \"artifact\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.tool_call_id = fields.tool_call_id;\n\t        this.artifact = fields.artifact;\n\t        this.status = fields.status;\n\t    }\n\t    static lc_name() {\n\t        return \"ToolMessageChunk\";\n\t    }\n\t    _getType() {\n\t        return \"tool\";\n\t    }\n\t    concat(chunk) {\n\t        return new ToolMessageChunk({\n\t            content: (0, base_js_1$f.mergeContent)(this.content, chunk.content),\n\t            additional_kwargs: (0, base_js_1$f._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n\t            response_metadata: (0, base_js_1$f._mergeDicts)(this.response_metadata, chunk.response_metadata),\n\t            artifact: (0, base_js_1$f._mergeObj)(this.artifact, chunk.artifact),\n\t            tool_call_id: this.tool_call_id,\n\t            id: this.id ?? chunk.id,\n\t            status: (0, base_js_1$f._mergeStatus)(this.status, chunk.status),\n\t        });\n\t    }\n\t    get _printableFields() {\n\t        return {\n\t            ...super._printableFields,\n\t            tool_call_id: this.tool_call_id,\n\t            artifact: this.artifact,\n\t        };\n\t    }\n\t}\n\ttool.ToolMessageChunk = ToolMessageChunk;\n\tfunction defaultToolCallParser(\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\trawToolCalls) {\n\t    const toolCalls = [];\n\t    const invalidToolCalls = [];\n\t    for (const toolCall of rawToolCalls) {\n\t        if (!toolCall.function) {\n\t            continue;\n\t        }\n\t        else {\n\t            const functionName = toolCall.function.name;\n\t            try {\n\t                const functionArgs = JSON.parse(toolCall.function.arguments);\n\t                const parsed = {\n\t                    name: functionName || \"\",\n\t                    args: functionArgs || {},\n\t                    id: toolCall.id,\n\t                };\n\t                toolCalls.push(parsed);\n\t            }\n\t            catch (error) {\n\t                invalidToolCalls.push({\n\t                    name: functionName,\n\t                    args: toolCall.function.arguments,\n\t                    id: toolCall.id,\n\t                    error: \"Malformed args.\",\n\t                });\n\t            }\n\t        }\n\t    }\n\t    return [toolCalls, invalidToolCalls];\n\t}\n\ttool.defaultToolCallParser = defaultToolCallParser;\n\n\tObject.defineProperty(ai, \"__esModule\", { value: true });\n\tai.AIMessageChunk = ai.isAIMessageChunk = ai.isAIMessage = ai.AIMessage = void 0;\n\tconst json_js_1 = json;\n\tconst base_js_1$e = base$3;\n\tconst tool_js_1$2 = tool;\n\t/**\n\t * Represents an AI message in a conversation.\n\t */\n\tclass AIMessage extends base_js_1$e.BaseMessage {\n\t    get lc_aliases() {\n\t        // exclude snake case conversion to pascal case\n\t        return {\n\t            ...super.lc_aliases,\n\t            tool_calls: \"tool_calls\",\n\t            invalid_tool_calls: \"invalid_tool_calls\",\n\t        };\n\t    }\n\t    constructor(fields, \n\t    /** @deprecated */\n\t    kwargs) {\n\t        let initParams;\n\t        if (typeof fields === \"string\") {\n\t            initParams = {\n\t                content: fields,\n\t                tool_calls: [],\n\t                invalid_tool_calls: [],\n\t                additional_kwargs: kwargs ?? {},\n\t            };\n\t        }\n\t        else {\n\t            initParams = fields;\n\t            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n\t            const toolCalls = initParams.tool_calls;\n\t            if (!(rawToolCalls == null) &&\n\t                rawToolCalls.length > 0 &&\n\t                (toolCalls === undefined || toolCalls.length === 0)) {\n\t                console.warn([\n\t                    \"New LangChain packages are available that more efficiently handle\",\n\t                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n\t                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n\t                    \"yarn add @langchain/openai`, etc.\",\n\t                ].join(\" \"));\n\t            }\n\t            try {\n\t                if (!(rawToolCalls == null) && toolCalls === undefined) {\n\t                    const [toolCalls, invalidToolCalls] = (0, tool_js_1$2.defaultToolCallParser)(rawToolCalls);\n\t                    initParams.tool_calls = toolCalls ?? [];\n\t                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n\t                }\n\t                else {\n\t                    initParams.tool_calls = initParams.tool_calls ?? [];\n\t                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n\t                }\n\t            }\n\t            catch (e) {\n\t                // Do nothing if parsing fails\n\t                initParams.tool_calls = [];\n\t                initParams.invalid_tool_calls = [];\n\t            }\n\t        }\n\t        // Sadly, TypeScript only allows super() calls at root if the class has\n\t        // properties with initializers, so we have to check types twice.\n\t        super(initParams);\n\t        // These are typed as optional to avoid breaking changes and allow for casting\n\t        // from BaseMessage.\n\t        Object.defineProperty(this, \"tool_calls\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: []\n\t        });\n\t        Object.defineProperty(this, \"invalid_tool_calls\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: []\n\t        });\n\t        /**\n\t         * If provided, token usage information associated with the message.\n\t         */\n\t        Object.defineProperty(this, \"usage_metadata\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        if (typeof initParams !== \"string\") {\n\t            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n\t            this.invalid_tool_calls =\n\t                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n\t        }\n\t        this.usage_metadata = initParams.usage_metadata;\n\t    }\n\t    static lc_name() {\n\t        return \"AIMessage\";\n\t    }\n\t    _getType() {\n\t        return \"ai\";\n\t    }\n\t    get _printableFields() {\n\t        return {\n\t            ...super._printableFields,\n\t            tool_calls: this.tool_calls,\n\t            invalid_tool_calls: this.invalid_tool_calls,\n\t            usage_metadata: this.usage_metadata,\n\t        };\n\t    }\n\t}\n\tai.AIMessage = AIMessage;\n\tfunction isAIMessage(x) {\n\t    return x._getType() === \"ai\";\n\t}\n\tai.isAIMessage = isAIMessage;\n\tfunction isAIMessageChunk(x) {\n\t    return x._getType() === \"ai\";\n\t}\n\tai.isAIMessageChunk = isAIMessageChunk;\n\t/**\n\t * Represents a chunk of an AI message, which can be concatenated with\n\t * other AI message chunks.\n\t */\n\tclass AIMessageChunk extends base_js_1$e.BaseMessageChunk {\n\t    constructor(fields) {\n\t        let initParams;\n\t        if (typeof fields === \"string\") {\n\t            initParams = {\n\t                content: fields,\n\t                tool_calls: [],\n\t                invalid_tool_calls: [],\n\t                tool_call_chunks: [],\n\t            };\n\t        }\n\t        else if (fields.tool_call_chunks === undefined) {\n\t            initParams = {\n\t                ...fields,\n\t                tool_calls: fields.tool_calls ?? [],\n\t                invalid_tool_calls: [],\n\t                tool_call_chunks: [],\n\t            };\n\t        }\n\t        else {\n\t            const toolCalls = [];\n\t            const invalidToolCalls = [];\n\t            for (const toolCallChunk of fields.tool_call_chunks) {\n\t                let parsedArgs = {};\n\t                try {\n\t                    parsedArgs = (0, json_js_1.parsePartialJson)(toolCallChunk.args || \"{}\");\n\t                    if (parsedArgs === null ||\n\t                        typeof parsedArgs !== \"object\" ||\n\t                        Array.isArray(parsedArgs)) {\n\t                        throw new Error(\"Malformed tool call chunk args.\");\n\t                    }\n\t                    toolCalls.push({\n\t                        name: toolCallChunk.name ?? \"\",\n\t                        args: parsedArgs,\n\t                        id: toolCallChunk.id,\n\t                        type: \"tool_call\",\n\t                    });\n\t                }\n\t                catch (e) {\n\t                    invalidToolCalls.push({\n\t                        name: toolCallChunk.name,\n\t                        args: toolCallChunk.args,\n\t                        id: toolCallChunk.id,\n\t                        error: \"Malformed args.\",\n\t                        type: \"invalid_tool_call\",\n\t                    });\n\t                }\n\t            }\n\t            initParams = {\n\t                ...fields,\n\t                tool_calls: toolCalls,\n\t                invalid_tool_calls: invalidToolCalls,\n\t            };\n\t        }\n\t        // Sadly, TypeScript only allows super() calls at root if the class has\n\t        // properties with initializers, so we have to check types twice.\n\t        super(initParams);\n\t        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n\t        // These are typed as optional to avoid breaking changes and allow for casting\n\t        // from BaseMessage.\n\t        Object.defineProperty(this, \"tool_calls\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: []\n\t        });\n\t        Object.defineProperty(this, \"invalid_tool_calls\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: []\n\t        });\n\t        Object.defineProperty(this, \"tool_call_chunks\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: []\n\t        });\n\t        /**\n\t         * If provided, token usage information associated with the message.\n\t         */\n\t        Object.defineProperty(this, \"usage_metadata\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.tool_call_chunks =\n\t            initParams.tool_call_chunks ?? this.tool_call_chunks;\n\t        this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n\t        this.invalid_tool_calls =\n\t            initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n\t        this.usage_metadata = initParams.usage_metadata;\n\t    }\n\t    get lc_aliases() {\n\t        // exclude snake case conversion to pascal case\n\t        return {\n\t            ...super.lc_aliases,\n\t            tool_calls: \"tool_calls\",\n\t            invalid_tool_calls: \"invalid_tool_calls\",\n\t            tool_call_chunks: \"tool_call_chunks\",\n\t        };\n\t    }\n\t    static lc_name() {\n\t        return \"AIMessageChunk\";\n\t    }\n\t    _getType() {\n\t        return \"ai\";\n\t    }\n\t    get _printableFields() {\n\t        return {\n\t            ...super._printableFields,\n\t            tool_calls: this.tool_calls,\n\t            tool_call_chunks: this.tool_call_chunks,\n\t            invalid_tool_calls: this.invalid_tool_calls,\n\t            usage_metadata: this.usage_metadata,\n\t        };\n\t    }\n\t    concat(chunk) {\n\t        const combinedFields = {\n\t            content: (0, base_js_1$e.mergeContent)(this.content, chunk.content),\n\t            additional_kwargs: (0, base_js_1$e._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n\t            response_metadata: (0, base_js_1$e._mergeDicts)(this.response_metadata, chunk.response_metadata),\n\t            tool_call_chunks: [],\n\t            id: this.id ?? chunk.id,\n\t        };\n\t        if (this.tool_call_chunks !== undefined ||\n\t            chunk.tool_call_chunks !== undefined) {\n\t            const rawToolCalls = (0, base_js_1$e._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);\n\t            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n\t                combinedFields.tool_call_chunks = rawToolCalls;\n\t            }\n\t        }\n\t        if (this.usage_metadata !== undefined ||\n\t            chunk.usage_metadata !== undefined) {\n\t            const left = this.usage_metadata ?? {\n\t                input_tokens: 0,\n\t                output_tokens: 0,\n\t                total_tokens: 0,\n\t            };\n\t            const right = chunk.usage_metadata ?? {\n\t                input_tokens: 0,\n\t                output_tokens: 0,\n\t                total_tokens: 0,\n\t            };\n\t            const usage_metadata = {\n\t                input_tokens: left.input_tokens + right.input_tokens,\n\t                output_tokens: left.output_tokens + right.output_tokens,\n\t                total_tokens: left.total_tokens + right.total_tokens,\n\t            };\n\t            combinedFields.usage_metadata = usage_metadata;\n\t        }\n\t        return new AIMessageChunk(combinedFields);\n\t    }\n\t}\n\tai.AIMessageChunk = AIMessageChunk;\n\n\tvar chat = {};\n\n\tObject.defineProperty(chat, \"__esModule\", { value: true });\n\tchat.ChatMessageChunk = chat.ChatMessage = void 0;\n\tconst base_js_1$d = base$3;\n\t/**\n\t * Represents a chat message in a conversation.\n\t */\n\tclass ChatMessage extends base_js_1$d.BaseMessage {\n\t    static lc_name() {\n\t        return \"ChatMessage\";\n\t    }\n\t    static _chatMessageClass() {\n\t        return ChatMessage;\n\t    }\n\t    constructor(fields, role) {\n\t        if (typeof fields === \"string\") {\n\t            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n\t            fields = { content: fields, role: role };\n\t        }\n\t        super(fields);\n\t        Object.defineProperty(this, \"role\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.role = fields.role;\n\t    }\n\t    _getType() {\n\t        return \"generic\";\n\t    }\n\t    static isInstance(message) {\n\t        return message._getType() === \"generic\";\n\t    }\n\t    get _printableFields() {\n\t        return {\n\t            ...super._printableFields,\n\t            role: this.role,\n\t        };\n\t    }\n\t}\n\tchat.ChatMessage = ChatMessage;\n\t/**\n\t * Represents a chunk of a chat message, which can be concatenated with\n\t * other chat message chunks.\n\t */\n\tclass ChatMessageChunk extends base_js_1$d.BaseMessageChunk {\n\t    static lc_name() {\n\t        return \"ChatMessageChunk\";\n\t    }\n\t    constructor(fields, role) {\n\t        if (typeof fields === \"string\") {\n\t            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n\t            fields = { content: fields, role: role };\n\t        }\n\t        super(fields);\n\t        Object.defineProperty(this, \"role\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.role = fields.role;\n\t    }\n\t    _getType() {\n\t        return \"generic\";\n\t    }\n\t    concat(chunk) {\n\t        return new ChatMessageChunk({\n\t            content: (0, base_js_1$d.mergeContent)(this.content, chunk.content),\n\t            additional_kwargs: (0, base_js_1$d._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n\t            response_metadata: (0, base_js_1$d._mergeDicts)(this.response_metadata, chunk.response_metadata),\n\t            role: this.role,\n\t            id: this.id ?? chunk.id,\n\t        });\n\t    }\n\t    get _printableFields() {\n\t        return {\n\t            ...super._printableFields,\n\t            role: this.role,\n\t        };\n\t    }\n\t}\n\tchat.ChatMessageChunk = ChatMessageChunk;\n\n\tvar _function = {};\n\n\tObject.defineProperty(_function, \"__esModule\", { value: true });\n\t_function.FunctionMessageChunk = _function.FunctionMessage = void 0;\n\tconst base_js_1$c = base$3;\n\t/**\n\t * Represents a function message in a conversation.\n\t */\n\tclass FunctionMessage extends base_js_1$c.BaseMessage {\n\t    static lc_name() {\n\t        return \"FunctionMessage\";\n\t    }\n\t    constructor(fields, \n\t    /** @deprecated */\n\t    name) {\n\t        if (typeof fields === \"string\") {\n\t            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n\t            fields = { content: fields, name: name };\n\t        }\n\t        super(fields);\n\t    }\n\t    _getType() {\n\t        return \"function\";\n\t    }\n\t}\n\t_function.FunctionMessage = FunctionMessage;\n\t/**\n\t * Represents a chunk of a function message, which can be concatenated\n\t * with other function message chunks.\n\t */\n\tclass FunctionMessageChunk extends base_js_1$c.BaseMessageChunk {\n\t    static lc_name() {\n\t        return \"FunctionMessageChunk\";\n\t    }\n\t    _getType() {\n\t        return \"function\";\n\t    }\n\t    concat(chunk) {\n\t        return new FunctionMessageChunk({\n\t            content: (0, base_js_1$c.mergeContent)(this.content, chunk.content),\n\t            additional_kwargs: (0, base_js_1$c._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n\t            response_metadata: (0, base_js_1$c._mergeDicts)(this.response_metadata, chunk.response_metadata),\n\t            name: this.name ?? \"\",\n\t            id: this.id ?? chunk.id,\n\t        });\n\t    }\n\t}\n\t_function.FunctionMessageChunk = FunctionMessageChunk;\n\n\tvar human = {};\n\n\tObject.defineProperty(human, \"__esModule\", { value: true });\n\thuman.HumanMessageChunk = human.HumanMessage = void 0;\n\tconst base_js_1$b = base$3;\n\t/**\n\t * Represents a human message in a conversation.\n\t */\n\tclass HumanMessage extends base_js_1$b.BaseMessage {\n\t    static lc_name() {\n\t        return \"HumanMessage\";\n\t    }\n\t    _getType() {\n\t        return \"human\";\n\t    }\n\t}\n\thuman.HumanMessage = HumanMessage;\n\t/**\n\t * Represents a chunk of a human message, which can be concatenated with\n\t * other human message chunks.\n\t */\n\tclass HumanMessageChunk extends base_js_1$b.BaseMessageChunk {\n\t    static lc_name() {\n\t        return \"HumanMessageChunk\";\n\t    }\n\t    _getType() {\n\t        return \"human\";\n\t    }\n\t    concat(chunk) {\n\t        return new HumanMessageChunk({\n\t            content: (0, base_js_1$b.mergeContent)(this.content, chunk.content),\n\t            additional_kwargs: (0, base_js_1$b._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n\t            response_metadata: (0, base_js_1$b._mergeDicts)(this.response_metadata, chunk.response_metadata),\n\t            id: this.id ?? chunk.id,\n\t        });\n\t    }\n\t}\n\thuman.HumanMessageChunk = HumanMessageChunk;\n\n\tvar system = {};\n\n\tObject.defineProperty(system, \"__esModule\", { value: true });\n\tsystem.SystemMessageChunk = system.SystemMessage = void 0;\n\tconst base_js_1$a = base$3;\n\t/**\n\t * Represents a system message in a conversation.\n\t */\n\tclass SystemMessage extends base_js_1$a.BaseMessage {\n\t    static lc_name() {\n\t        return \"SystemMessage\";\n\t    }\n\t    _getType() {\n\t        return \"system\";\n\t    }\n\t}\n\tsystem.SystemMessage = SystemMessage;\n\t/**\n\t * Represents a chunk of a system message, which can be concatenated with\n\t * other system message chunks.\n\t */\n\tclass SystemMessageChunk extends base_js_1$a.BaseMessageChunk {\n\t    static lc_name() {\n\t        return \"SystemMessageChunk\";\n\t    }\n\t    _getType() {\n\t        return \"system\";\n\t    }\n\t    concat(chunk) {\n\t        return new SystemMessageChunk({\n\t            content: (0, base_js_1$a.mergeContent)(this.content, chunk.content),\n\t            additional_kwargs: (0, base_js_1$a._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n\t            response_metadata: (0, base_js_1$a._mergeDicts)(this.response_metadata, chunk.response_metadata),\n\t            id: this.id ?? chunk.id,\n\t        });\n\t    }\n\t}\n\tsystem.SystemMessageChunk = SystemMessageChunk;\n\n\tvar utils$2 = {};\n\n\tvar utils$1 = {};\n\n\tObject.defineProperty(utils$1, \"__esModule\", { value: true });\n\tutils$1.ToolInputParsingException = utils$1._isToolCall = void 0;\n\tfunction _isToolCall(toolCall) {\n\t    return !!(toolCall &&\n\t        typeof toolCall === \"object\" &&\n\t        \"type\" in toolCall &&\n\t        toolCall.type === \"tool_call\");\n\t}\n\tutils$1._isToolCall = _isToolCall;\n\t/**\n\t * Custom error class used to handle exceptions related to tool input parsing.\n\t * It extends the built-in `Error` class and adds an optional `output`\n\t * property that can hold the output that caused the exception.\n\t */\n\tclass ToolInputParsingException extends Error {\n\t    constructor(message, output) {\n\t        super(message);\n\t        Object.defineProperty(this, \"output\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.output = output;\n\t    }\n\t}\n\tutils$1.ToolInputParsingException = ToolInputParsingException;\n\n\tObject.defineProperty(utils$2, \"__esModule\", {\n\t  value: true\n\t});\n\tutils$2.convertToChunk = utils$2.mapChatMessagesToStoredMessages = utils$2.mapStoredMessagesToChatMessages = utils$2.mapStoredMessageToChatMessage = utils$2.getBufferString = utils$2.coerceMessageLikeToMessage = void 0;\n\tconst utils_js_1$4 = utils$1;\n\tconst ai_js_1$3 = ai;\n\tconst base_js_1$9 = base$3;\n\tconst chat_js_1$1 = chat;\n\tconst function_js_1$1 = _function;\n\tconst human_js_1$1 = human;\n\tconst system_js_1$1 = system;\n\tconst tool_js_1$1 = tool;\n\tfunction _coerceToolCall(toolCall) {\n\t  if ((0, utils_js_1$4._isToolCall)(toolCall)) {\n\t    return toolCall;\n\t  } else if (typeof toolCall.id === \"string\" && toolCall.type === \"function\" && typeof toolCall.function === \"object\" && toolCall.function !== null && (\"arguments\" in toolCall.function) && typeof toolCall.function.arguments === \"string\" && (\"name\" in toolCall.function) && typeof toolCall.function.name === \"string\") {\n\t    return {\n\t      id: toolCall.id,\n\t      args: JSON.parse(toolCall.function.arguments),\n\t      name: toolCall.function.name,\n\t      type: \"tool_call\"\n\t    };\n\t  } else {\n\t    return toolCall;\n\t  }\n\t}\n\tfunction _constructMessageFromParams(params) {\n\t  const {type, ...rest} = params;\n\t  if (type === \"human\" || type === \"user\") {\n\t    return new human_js_1$1.HumanMessage(rest);\n\t  } else if (type === \"ai\" || type === \"assistant\") {\n\t    const {tool_calls: rawToolCalls, ...other} = rest;\n\t    if (!Array.isArray(rawToolCalls)) {\n\t      return new ai_js_1$3.AIMessage(rest);\n\t    }\n\t    const tool_calls = rawToolCalls.map(_coerceToolCall);\n\t    return new ai_js_1$3.AIMessage({\n\t      ...other,\n\t      tool_calls\n\t    });\n\t  } else if (type === \"system\") {\n\t    return new system_js_1$1.SystemMessage(rest);\n\t  } else if (type === \"tool\" && (\"tool_call_id\" in rest)) {\n\t    return new tool_js_1$1.ToolMessage({\n\t      ...rest,\n\t      content: rest.content,\n\t      tool_call_id: rest.tool_call_id,\n\t      name: rest.name\n\t    });\n\t  } else {\n\t    throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n\t  }\n\t}\n\tfunction coerceMessageLikeToMessage(messageLike) {\n\t  if (typeof messageLike === \"string\") {\n\t    return new human_js_1$1.HumanMessage(messageLike);\n\t  } else if ((0, base_js_1$9.isBaseMessage)(messageLike)) {\n\t    return messageLike;\n\t  }\n\t  if (Array.isArray(messageLike)) {\n\t    const [type, content] = messageLike;\n\t    return _constructMessageFromParams({\n\t      type,\n\t      content\n\t    });\n\t  } else if ((0, base_js_1$9._isMessageFieldWithRole)(messageLike)) {\n\t    const {role: type, ...rest} = messageLike;\n\t    return _constructMessageFromParams({\n\t      ...rest,\n\t      type\n\t    });\n\t  } else {\n\t    return _constructMessageFromParams(messageLike);\n\t  }\n\t}\n\tutils$2.coerceMessageLikeToMessage = coerceMessageLikeToMessage;\n\tfunction getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n\t  const string_messages = [];\n\t  for (const m of messages) {\n\t    let role;\n\t    if (m._getType() === \"human\") {\n\t      role = humanPrefix;\n\t    } else if (m._getType() === \"ai\") {\n\t      role = aiPrefix;\n\t    } else if (m._getType() === \"system\") {\n\t      role = \"System\";\n\t    } else if (m._getType() === \"function\") {\n\t      role = \"Function\";\n\t    } else if (m._getType() === \"tool\") {\n\t      role = \"Tool\";\n\t    } else if (m._getType() === \"generic\") {\n\t      role = m.role;\n\t    } else {\n\t      throw new Error(`Got unsupported message type: ${m._getType()}`);\n\t    }\n\t    const nameStr = m.name ? `${m.name}, ` : \"\";\n\t    const readableContent = typeof m.content === \"string\" ? m.content : JSON.stringify(m.content, null, 2);\n\t    string_messages.push(`${role}: ${nameStr}${readableContent}`);\n\t  }\n\t  return string_messages.join(\"\\n\");\n\t}\n\tutils$2.getBufferString = getBufferString;\n\tfunction mapV1MessageToStoredMessage(message) {\n\t  if (message.data !== undefined) {\n\t    return message;\n\t  } else {\n\t    const v1Message = message;\n\t    return {\n\t      type: v1Message.type,\n\t      data: {\n\t        content: v1Message.text,\n\t        role: v1Message.role,\n\t        name: undefined,\n\t        tool_call_id: undefined\n\t      }\n\t    };\n\t  }\n\t}\n\tfunction mapStoredMessageToChatMessage(message) {\n\t  const storedMessage = mapV1MessageToStoredMessage(message);\n\t  switch (storedMessage.type) {\n\t    case \"human\":\n\t      return new human_js_1$1.HumanMessage(storedMessage.data);\n\t    case \"ai\":\n\t      return new ai_js_1$3.AIMessage(storedMessage.data);\n\t    case \"system\":\n\t      return new system_js_1$1.SystemMessage(storedMessage.data);\n\t    case \"function\":\n\t      if (storedMessage.data.name === undefined) {\n\t        throw new Error(\"Name must be defined for function messages\");\n\t      }\n\t      return new function_js_1$1.FunctionMessage(storedMessage.data);\n\t    case \"tool\":\n\t      if (storedMessage.data.tool_call_id === undefined) {\n\t        throw new Error(\"Tool call ID must be defined for tool messages\");\n\t      }\n\t      return new tool_js_1$1.ToolMessage(storedMessage.data);\n\t    case \"generic\":\n\t      {\n\t        if (storedMessage.data.role === undefined) {\n\t          throw new Error(\"Role must be defined for chat messages\");\n\t        }\n\t        return new chat_js_1$1.ChatMessage(storedMessage.data);\n\t      }\n\t    default:\n\t      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n\t  }\n\t}\n\tutils$2.mapStoredMessageToChatMessage = mapStoredMessageToChatMessage;\n\tfunction mapStoredMessagesToChatMessages(messages) {\n\t  return messages.map(mapStoredMessageToChatMessage);\n\t}\n\tutils$2.mapStoredMessagesToChatMessages = mapStoredMessagesToChatMessages;\n\tfunction mapChatMessagesToStoredMessages(messages) {\n\t  return messages.map(message => message.toDict());\n\t}\n\tutils$2.mapChatMessagesToStoredMessages = mapChatMessagesToStoredMessages;\n\tfunction convertToChunk(message) {\n\t  const type = message._getType();\n\t  if (type === \"human\") {\n\t    return new human_js_1$1.HumanMessageChunk({\n\t      ...message\n\t    });\n\t  } else if (type === \"ai\") {\n\t    let aiChunkFields = {\n\t      ...message\n\t    };\n\t    if ((\"tool_calls\" in aiChunkFields)) {\n\t      aiChunkFields = {\n\t        ...aiChunkFields,\n\t        tool_call_chunks: aiChunkFields.tool_calls?.map(tc => ({\n\t          ...tc,\n\t          type: \"tool_call_chunk\",\n\t          index: undefined,\n\t          args: JSON.stringify(tc.args)\n\t        }))\n\t      };\n\t    }\n\t    return new ai_js_1$3.AIMessageChunk({\n\t      ...aiChunkFields\n\t    });\n\t  } else if (type === \"system\") {\n\t    return new system_js_1$1.SystemMessageChunk({\n\t      ...message\n\t    });\n\t  } else if (type === \"function\") {\n\t    return new function_js_1$1.FunctionMessageChunk({\n\t      ...message\n\t    });\n\t  } else if (chat_js_1$1.ChatMessage.isInstance(message)) {\n\t    return new chat_js_1$1.ChatMessageChunk({\n\t      ...message\n\t    });\n\t  } else {\n\t    throw new Error(\"Unknown message type.\");\n\t  }\n\t}\n\tutils$2.convertToChunk = convertToChunk;\n\n\tvar transformers = {};\n\n\tvar base$2 = {};\n\n\tvar lib = {};\n\n\tvar external = {};\n\n\tvar errors = {};\n\n\tvar en = {};\n\n\tvar util = {};\n\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;\n\t\tvar util;\n\t\t(function (util) {\n\t\t    util.assertEqual = (val) => val;\n\t\t    function assertIs(_arg) { }\n\t\t    util.assertIs = assertIs;\n\t\t    function assertNever(_x) {\n\t\t        throw new Error();\n\t\t    }\n\t\t    util.assertNever = assertNever;\n\t\t    util.arrayToEnum = (items) => {\n\t\t        const obj = {};\n\t\t        for (const item of items) {\n\t\t            obj[item] = item;\n\t\t        }\n\t\t        return obj;\n\t\t    };\n\t\t    util.getValidEnumValues = (obj) => {\n\t\t        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n\t\t        const filtered = {};\n\t\t        for (const k of validKeys) {\n\t\t            filtered[k] = obj[k];\n\t\t        }\n\t\t        return util.objectValues(filtered);\n\t\t    };\n\t\t    util.objectValues = (obj) => {\n\t\t        return util.objectKeys(obj).map(function (e) {\n\t\t            return obj[e];\n\t\t        });\n\t\t    };\n\t\t    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n\t\t        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n\t\t        : (object) => {\n\t\t            const keys = [];\n\t\t            for (const key in object) {\n\t\t                if (Object.prototype.hasOwnProperty.call(object, key)) {\n\t\t                    keys.push(key);\n\t\t                }\n\t\t            }\n\t\t            return keys;\n\t\t        };\n\t\t    util.find = (arr, checker) => {\n\t\t        for (const item of arr) {\n\t\t            if (checker(item))\n\t\t                return item;\n\t\t        }\n\t\t        return undefined;\n\t\t    };\n\t\t    util.isInteger = typeof Number.isInteger === \"function\"\n\t\t        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n\t\t        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n\t\t    function joinValues(array, separator = \" | \") {\n\t\t        return array\n\t\t            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n\t\t            .join(separator);\n\t\t    }\n\t\t    util.joinValues = joinValues;\n\t\t    util.jsonStringifyReplacer = (_, value) => {\n\t\t        if (typeof value === \"bigint\") {\n\t\t            return value.toString();\n\t\t        }\n\t\t        return value;\n\t\t    };\n\t\t})(util = exports.util || (exports.util = {}));\n\t\t(function (objectUtil) {\n\t\t    objectUtil.mergeShapes = (first, second) => {\n\t\t        return {\n\t\t            ...first,\n\t\t            ...second, // second overwrites first\n\t\t        };\n\t\t    };\n\t\t})(exports.objectUtil || (exports.objectUtil = {}));\n\t\texports.ZodParsedType = util.arrayToEnum([\n\t\t    \"string\",\n\t\t    \"nan\",\n\t\t    \"number\",\n\t\t    \"integer\",\n\t\t    \"float\",\n\t\t    \"boolean\",\n\t\t    \"date\",\n\t\t    \"bigint\",\n\t\t    \"symbol\",\n\t\t    \"function\",\n\t\t    \"undefined\",\n\t\t    \"null\",\n\t\t    \"array\",\n\t\t    \"object\",\n\t\t    \"unknown\",\n\t\t    \"promise\",\n\t\t    \"void\",\n\t\t    \"never\",\n\t\t    \"map\",\n\t\t    \"set\",\n\t\t]);\n\t\tconst getParsedType = (data) => {\n\t\t    const t = typeof data;\n\t\t    switch (t) {\n\t\t        case \"undefined\":\n\t\t            return exports.ZodParsedType.undefined;\n\t\t        case \"string\":\n\t\t            return exports.ZodParsedType.string;\n\t\t        case \"number\":\n\t\t            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;\n\t\t        case \"boolean\":\n\t\t            return exports.ZodParsedType.boolean;\n\t\t        case \"function\":\n\t\t            return exports.ZodParsedType.function;\n\t\t        case \"bigint\":\n\t\t            return exports.ZodParsedType.bigint;\n\t\t        case \"symbol\":\n\t\t            return exports.ZodParsedType.symbol;\n\t\t        case \"object\":\n\t\t            if (Array.isArray(data)) {\n\t\t                return exports.ZodParsedType.array;\n\t\t            }\n\t\t            if (data === null) {\n\t\t                return exports.ZodParsedType.null;\n\t\t            }\n\t\t            if (data.then &&\n\t\t                typeof data.then === \"function\" &&\n\t\t                data.catch &&\n\t\t                typeof data.catch === \"function\") {\n\t\t                return exports.ZodParsedType.promise;\n\t\t            }\n\t\t            if (typeof Map !== \"undefined\" && data instanceof Map) {\n\t\t                return exports.ZodParsedType.map;\n\t\t            }\n\t\t            if (typeof Set !== \"undefined\" && data instanceof Set) {\n\t\t                return exports.ZodParsedType.set;\n\t\t            }\n\t\t            if (typeof Date !== \"undefined\" && data instanceof Date) {\n\t\t                return exports.ZodParsedType.date;\n\t\t            }\n\t\t            return exports.ZodParsedType.object;\n\t\t        default:\n\t\t            return exports.ZodParsedType.unknown;\n\t\t    }\n\t\t};\n\t\texports.getParsedType = getParsedType; \n\t} (util));\n\n\tvar ZodError$1 = {};\n\n\tObject.defineProperty(ZodError$1, \"__esModule\", { value: true });\n\tZodError$1.ZodError = ZodError$1.quotelessJson = ZodError$1.ZodIssueCode = void 0;\n\tconst util_1$1 = util;\n\tZodError$1.ZodIssueCode = util_1$1.util.arrayToEnum([\n\t    \"invalid_type\",\n\t    \"invalid_literal\",\n\t    \"custom\",\n\t    \"invalid_union\",\n\t    \"invalid_union_discriminator\",\n\t    \"invalid_enum_value\",\n\t    \"unrecognized_keys\",\n\t    \"invalid_arguments\",\n\t    \"invalid_return_type\",\n\t    \"invalid_date\",\n\t    \"invalid_string\",\n\t    \"too_small\",\n\t    \"too_big\",\n\t    \"invalid_intersection_types\",\n\t    \"not_multiple_of\",\n\t    \"not_finite\",\n\t]);\n\tconst quotelessJson = (obj) => {\n\t    const json = JSON.stringify(obj, null, 2);\n\t    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n\t};\n\tZodError$1.quotelessJson = quotelessJson;\n\tclass ZodError extends Error {\n\t    constructor(issues) {\n\t        super();\n\t        this.issues = [];\n\t        this.addIssue = (sub) => {\n\t            this.issues = [...this.issues, sub];\n\t        };\n\t        this.addIssues = (subs = []) => {\n\t            this.issues = [...this.issues, ...subs];\n\t        };\n\t        const actualProto = new.target.prototype;\n\t        if (Object.setPrototypeOf) {\n\t            // eslint-disable-next-line ban/ban\n\t            Object.setPrototypeOf(this, actualProto);\n\t        }\n\t        else {\n\t            this.__proto__ = actualProto;\n\t        }\n\t        this.name = \"ZodError\";\n\t        this.issues = issues;\n\t    }\n\t    get errors() {\n\t        return this.issues;\n\t    }\n\t    format(_mapper) {\n\t        const mapper = _mapper ||\n\t            function (issue) {\n\t                return issue.message;\n\t            };\n\t        const fieldErrors = { _errors: [] };\n\t        const processError = (error) => {\n\t            for (const issue of error.issues) {\n\t                if (issue.code === \"invalid_union\") {\n\t                    issue.unionErrors.map(processError);\n\t                }\n\t                else if (issue.code === \"invalid_return_type\") {\n\t                    processError(issue.returnTypeError);\n\t                }\n\t                else if (issue.code === \"invalid_arguments\") {\n\t                    processError(issue.argumentsError);\n\t                }\n\t                else if (issue.path.length === 0) {\n\t                    fieldErrors._errors.push(mapper(issue));\n\t                }\n\t                else {\n\t                    let curr = fieldErrors;\n\t                    let i = 0;\n\t                    while (i < issue.path.length) {\n\t                        const el = issue.path[i];\n\t                        const terminal = i === issue.path.length - 1;\n\t                        if (!terminal) {\n\t                            curr[el] = curr[el] || { _errors: [] };\n\t                            // if (typeof el === \"string\") {\n\t                            //   curr[el] = curr[el] || { _errors: [] };\n\t                            // } else if (typeof el === \"number\") {\n\t                            //   const errorArray: any = [];\n\t                            //   errorArray._errors = [];\n\t                            //   curr[el] = curr[el] || errorArray;\n\t                            // }\n\t                        }\n\t                        else {\n\t                            curr[el] = curr[el] || { _errors: [] };\n\t                            curr[el]._errors.push(mapper(issue));\n\t                        }\n\t                        curr = curr[el];\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t        };\n\t        processError(this);\n\t        return fieldErrors;\n\t    }\n\t    static assert(value) {\n\t        if (!(value instanceof ZodError)) {\n\t            throw new Error(`Not a ZodError: ${value}`);\n\t        }\n\t    }\n\t    toString() {\n\t        return this.message;\n\t    }\n\t    get message() {\n\t        return JSON.stringify(this.issues, util_1$1.util.jsonStringifyReplacer, 2);\n\t    }\n\t    get isEmpty() {\n\t        return this.issues.length === 0;\n\t    }\n\t    flatten(mapper = (issue) => issue.message) {\n\t        const fieldErrors = {};\n\t        const formErrors = [];\n\t        for (const sub of this.issues) {\n\t            if (sub.path.length > 0) {\n\t                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n\t                fieldErrors[sub.path[0]].push(mapper(sub));\n\t            }\n\t            else {\n\t                formErrors.push(mapper(sub));\n\t            }\n\t        }\n\t        return { formErrors, fieldErrors };\n\t    }\n\t    get formErrors() {\n\t        return this.flatten();\n\t    }\n\t}\n\tZodError$1.ZodError = ZodError;\n\tZodError.create = (issues) => {\n\t    const error = new ZodError(issues);\n\t    return error;\n\t};\n\n\tObject.defineProperty(en, \"__esModule\", { value: true });\n\tconst util_1 = util;\n\tconst ZodError_1 = ZodError$1;\n\tconst errorMap = (issue, _ctx) => {\n\t    let message;\n\t    switch (issue.code) {\n\t        case ZodError_1.ZodIssueCode.invalid_type:\n\t            if (issue.received === util_1.ZodParsedType.undefined) {\n\t                message = \"Required\";\n\t            }\n\t            else {\n\t                message = `Expected ${issue.expected}, received ${issue.received}`;\n\t            }\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_literal:\n\t            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.unrecognized_keys:\n\t            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, \", \")}`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_union:\n\t            message = `Invalid input`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_union_discriminator:\n\t            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_enum_value:\n\t            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_arguments:\n\t            message = `Invalid function arguments`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_return_type:\n\t            message = `Invalid function return type`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_date:\n\t            message = `Invalid date`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_string:\n\t            if (typeof issue.validation === \"object\") {\n\t                if (\"includes\" in issue.validation) {\n\t                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n\t                    if (typeof issue.validation.position === \"number\") {\n\t                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n\t                    }\n\t                }\n\t                else if (\"startsWith\" in issue.validation) {\n\t                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n\t                }\n\t                else if (\"endsWith\" in issue.validation) {\n\t                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n\t                }\n\t                else {\n\t                    util_1.util.assertNever(issue.validation);\n\t                }\n\t            }\n\t            else if (issue.validation !== \"regex\") {\n\t                message = `Invalid ${issue.validation}`;\n\t            }\n\t            else {\n\t                message = \"Invalid\";\n\t            }\n\t            break;\n\t        case ZodError_1.ZodIssueCode.too_small:\n\t            if (issue.type === \"array\")\n\t                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n\t            else if (issue.type === \"string\")\n\t                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n\t            else if (issue.type === \"number\")\n\t                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n\t            else if (issue.type === \"date\")\n\t                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n\t            else\n\t                message = \"Invalid input\";\n\t            break;\n\t        case ZodError_1.ZodIssueCode.too_big:\n\t            if (issue.type === \"array\")\n\t                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n\t            else if (issue.type === \"string\")\n\t                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n\t            else if (issue.type === \"number\")\n\t                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n\t            else if (issue.type === \"bigint\")\n\t                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n\t            else if (issue.type === \"date\")\n\t                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n\t            else\n\t                message = \"Invalid input\";\n\t            break;\n\t        case ZodError_1.ZodIssueCode.custom:\n\t            message = `Invalid input`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.invalid_intersection_types:\n\t            message = `Intersection results could not be merged`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.not_multiple_of:\n\t            message = `Number must be a multiple of ${issue.multipleOf}`;\n\t            break;\n\t        case ZodError_1.ZodIssueCode.not_finite:\n\t            message = \"Number must be finite\";\n\t            break;\n\t        default:\n\t            message = _ctx.defaultError;\n\t            util_1.util.assertNever(issue);\n\t    }\n\t    return { message };\n\t};\n\ten.default = errorMap;\n\n\tvar __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(errors, \"__esModule\", { value: true });\n\terrors.getErrorMap = errors.setErrorMap = errors.defaultErrorMap = void 0;\n\tconst en_1 = __importDefault$5(en);\n\terrors.defaultErrorMap = en_1.default;\n\tlet overrideErrorMap = en_1.default;\n\tfunction setErrorMap(map) {\n\t    overrideErrorMap = map;\n\t}\n\terrors.setErrorMap = setErrorMap;\n\tfunction getErrorMap() {\n\t    return overrideErrorMap;\n\t}\n\terrors.getErrorMap = getErrorMap;\n\n\tvar parseUtil = {};\n\n\t(function (exports) {\n\t\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;\n\t\tconst errors_1 = errors;\n\t\tconst en_1 = __importDefault(en);\n\t\tconst makeIssue = (params) => {\n\t\t    const { data, path, errorMaps, issueData } = params;\n\t\t    const fullPath = [...path, ...(issueData.path || [])];\n\t\t    const fullIssue = {\n\t\t        ...issueData,\n\t\t        path: fullPath,\n\t\t    };\n\t\t    if (issueData.message !== undefined) {\n\t\t        return {\n\t\t            ...issueData,\n\t\t            path: fullPath,\n\t\t            message: issueData.message,\n\t\t        };\n\t\t    }\n\t\t    let errorMessage = \"\";\n\t\t    const maps = errorMaps\n\t\t        .filter((m) => !!m)\n\t\t        .slice()\n\t\t        .reverse();\n\t\t    for (const map of maps) {\n\t\t        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n\t\t    }\n\t\t    return {\n\t\t        ...issueData,\n\t\t        path: fullPath,\n\t\t        message: errorMessage,\n\t\t    };\n\t\t};\n\t\texports.makeIssue = makeIssue;\n\t\texports.EMPTY_PATH = [];\n\t\tfunction addIssueToContext(ctx, issueData) {\n\t\t    const overrideMap = (0, errors_1.getErrorMap)();\n\t\t    const issue = (0, exports.makeIssue)({\n\t\t        issueData: issueData,\n\t\t        data: ctx.data,\n\t\t        path: ctx.path,\n\t\t        errorMaps: [\n\t\t            ctx.common.contextualErrorMap,\n\t\t            ctx.schemaErrorMap,\n\t\t            overrideMap,\n\t\t            overrideMap === en_1.default ? undefined : en_1.default, // then global default map\n\t\t        ].filter((x) => !!x),\n\t\t    });\n\t\t    ctx.common.issues.push(issue);\n\t\t}\n\t\texports.addIssueToContext = addIssueToContext;\n\t\tclass ParseStatus {\n\t\t    constructor() {\n\t\t        this.value = \"valid\";\n\t\t    }\n\t\t    dirty() {\n\t\t        if (this.value === \"valid\")\n\t\t            this.value = \"dirty\";\n\t\t    }\n\t\t    abort() {\n\t\t        if (this.value !== \"aborted\")\n\t\t            this.value = \"aborted\";\n\t\t    }\n\t\t    static mergeArray(status, results) {\n\t\t        const arrayValue = [];\n\t\t        for (const s of results) {\n\t\t            if (s.status === \"aborted\")\n\t\t                return exports.INVALID;\n\t\t            if (s.status === \"dirty\")\n\t\t                status.dirty();\n\t\t            arrayValue.push(s.value);\n\t\t        }\n\t\t        return { status: status.value, value: arrayValue };\n\t\t    }\n\t\t    static async mergeObjectAsync(status, pairs) {\n\t\t        const syncPairs = [];\n\t\t        for (const pair of pairs) {\n\t\t            const key = await pair.key;\n\t\t            const value = await pair.value;\n\t\t            syncPairs.push({\n\t\t                key,\n\t\t                value,\n\t\t            });\n\t\t        }\n\t\t        return ParseStatus.mergeObjectSync(status, syncPairs);\n\t\t    }\n\t\t    static mergeObjectSync(status, pairs) {\n\t\t        const finalObject = {};\n\t\t        for (const pair of pairs) {\n\t\t            const { key, value } = pair;\n\t\t            if (key.status === \"aborted\")\n\t\t                return exports.INVALID;\n\t\t            if (value.status === \"aborted\")\n\t\t                return exports.INVALID;\n\t\t            if (key.status === \"dirty\")\n\t\t                status.dirty();\n\t\t            if (value.status === \"dirty\")\n\t\t                status.dirty();\n\t\t            if (key.value !== \"__proto__\" &&\n\t\t                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n\t\t                finalObject[key.value] = value.value;\n\t\t            }\n\t\t        }\n\t\t        return { status: status.value, value: finalObject };\n\t\t    }\n\t\t}\n\t\texports.ParseStatus = ParseStatus;\n\t\texports.INVALID = Object.freeze({\n\t\t    status: \"aborted\",\n\t\t});\n\t\tconst DIRTY = (value) => ({ status: \"dirty\", value });\n\t\texports.DIRTY = DIRTY;\n\t\tconst OK = (value) => ({ status: \"valid\", value });\n\t\texports.OK = OK;\n\t\tconst isAborted = (x) => x.status === \"aborted\";\n\t\texports.isAborted = isAborted;\n\t\tconst isDirty = (x) => x.status === \"dirty\";\n\t\texports.isDirty = isDirty;\n\t\tconst isValid = (x) => x.status === \"valid\";\n\t\texports.isValid = isValid;\n\t\tconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\t\texports.isAsync = isAsync; \n\t} (parseUtil));\n\n\tvar typeAliases = {};\n\n\tObject.defineProperty(typeAliases, \"__esModule\", { value: true });\n\n\tvar types = {};\n\n\tvar errorUtil = {};\n\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.errorUtil = void 0;\n\t\t(function (errorUtil) {\n\t\t    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n\t\t    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n\t\t})(exports.errorUtil || (exports.errorUtil = {})); \n\t} (errorUtil));\n\n\t(function (exports) {\n\t\tvar __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n\t\t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n\t\t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n\t\t    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n\t\t};\n\t\tvar __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n\t\t    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n\t\t    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n\t\t    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n\t\t    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n\t\t};\n\t\tvar _ZodEnum_cache, _ZodNativeEnum_cache;\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.datetimeRegex = exports.ZodType = void 0;\n\t\texports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = exports.date = void 0;\n\t\tconst errors_1 = errors;\n\t\tconst errorUtil_1 = errorUtil;\n\t\tconst parseUtil_1 = parseUtil;\n\t\tconst util_1 = util;\n\t\tconst ZodError_1 = ZodError$1;\n\t\tclass ParseInputLazyPath {\n\t\t    constructor(parent, value, path, key) {\n\t\t        this._cachedPath = [];\n\t\t        this.parent = parent;\n\t\t        this.data = value;\n\t\t        this._path = path;\n\t\t        this._key = key;\n\t\t    }\n\t\t    get path() {\n\t\t        if (!this._cachedPath.length) {\n\t\t            if (this._key instanceof Array) {\n\t\t                this._cachedPath.push(...this._path, ...this._key);\n\t\t            }\n\t\t            else {\n\t\t                this._cachedPath.push(...this._path, this._key);\n\t\t            }\n\t\t        }\n\t\t        return this._cachedPath;\n\t\t    }\n\t\t}\n\t\tconst handleResult = (ctx, result) => {\n\t\t    if ((0, parseUtil_1.isValid)(result)) {\n\t\t        return { success: true, data: result.value };\n\t\t    }\n\t\t    else {\n\t\t        if (!ctx.common.issues.length) {\n\t\t            throw new Error(\"Validation failed but no issues detected.\");\n\t\t        }\n\t\t        return {\n\t\t            success: false,\n\t\t            get error() {\n\t\t                if (this._error)\n\t\t                    return this._error;\n\t\t                const error = new ZodError_1.ZodError(ctx.common.issues);\n\t\t                this._error = error;\n\t\t                return this._error;\n\t\t            },\n\t\t        };\n\t\t    }\n\t\t};\n\t\tfunction processCreateParams(params) {\n\t\t    if (!params)\n\t\t        return {};\n\t\t    const { errorMap, invalid_type_error, required_error, description } = params;\n\t\t    if (errorMap && (invalid_type_error || required_error)) {\n\t\t        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n\t\t    }\n\t\t    if (errorMap)\n\t\t        return { errorMap: errorMap, description };\n\t\t    const customMap = (iss, ctx) => {\n\t\t        var _a, _b;\n\t\t        const { message } = params;\n\t\t        if (iss.code === \"invalid_enum_value\") {\n\t\t            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };\n\t\t        }\n\t\t        if (typeof ctx.data === \"undefined\") {\n\t\t            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\n\t\t        }\n\t\t        if (iss.code !== \"invalid_type\")\n\t\t            return { message: ctx.defaultError };\n\t\t        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\n\t\t    };\n\t\t    return { errorMap: customMap, description };\n\t\t}\n\t\tclass ZodType {\n\t\t    constructor(def) {\n\t\t        /** Alias of safeParseAsync */\n\t\t        this.spa = this.safeParseAsync;\n\t\t        this._def = def;\n\t\t        this.parse = this.parse.bind(this);\n\t\t        this.safeParse = this.safeParse.bind(this);\n\t\t        this.parseAsync = this.parseAsync.bind(this);\n\t\t        this.safeParseAsync = this.safeParseAsync.bind(this);\n\t\t        this.spa = this.spa.bind(this);\n\t\t        this.refine = this.refine.bind(this);\n\t\t        this.refinement = this.refinement.bind(this);\n\t\t        this.superRefine = this.superRefine.bind(this);\n\t\t        this.optional = this.optional.bind(this);\n\t\t        this.nullable = this.nullable.bind(this);\n\t\t        this.nullish = this.nullish.bind(this);\n\t\t        this.array = this.array.bind(this);\n\t\t        this.promise = this.promise.bind(this);\n\t\t        this.or = this.or.bind(this);\n\t\t        this.and = this.and.bind(this);\n\t\t        this.transform = this.transform.bind(this);\n\t\t        this.brand = this.brand.bind(this);\n\t\t        this.default = this.default.bind(this);\n\t\t        this.catch = this.catch.bind(this);\n\t\t        this.describe = this.describe.bind(this);\n\t\t        this.pipe = this.pipe.bind(this);\n\t\t        this.readonly = this.readonly.bind(this);\n\t\t        this.isNullable = this.isNullable.bind(this);\n\t\t        this.isOptional = this.isOptional.bind(this);\n\t\t    }\n\t\t    get description() {\n\t\t        return this._def.description;\n\t\t    }\n\t\t    _getType(input) {\n\t\t        return (0, util_1.getParsedType)(input.data);\n\t\t    }\n\t\t    _getOrReturnCtx(input, ctx) {\n\t\t        return (ctx || {\n\t\t            common: input.parent.common,\n\t\t            data: input.data,\n\t\t            parsedType: (0, util_1.getParsedType)(input.data),\n\t\t            schemaErrorMap: this._def.errorMap,\n\t\t            path: input.path,\n\t\t            parent: input.parent,\n\t\t        });\n\t\t    }\n\t\t    _processInputParams(input) {\n\t\t        return {\n\t\t            status: new parseUtil_1.ParseStatus(),\n\t\t            ctx: {\n\t\t                common: input.parent.common,\n\t\t                data: input.data,\n\t\t                parsedType: (0, util_1.getParsedType)(input.data),\n\t\t                schemaErrorMap: this._def.errorMap,\n\t\t                path: input.path,\n\t\t                parent: input.parent,\n\t\t            },\n\t\t        };\n\t\t    }\n\t\t    _parseSync(input) {\n\t\t        const result = this._parse(input);\n\t\t        if ((0, parseUtil_1.isAsync)(result)) {\n\t\t            throw new Error(\"Synchronous parse encountered promise.\");\n\t\t        }\n\t\t        return result;\n\t\t    }\n\t\t    _parseAsync(input) {\n\t\t        const result = this._parse(input);\n\t\t        return Promise.resolve(result);\n\t\t    }\n\t\t    parse(data, params) {\n\t\t        const result = this.safeParse(data, params);\n\t\t        if (result.success)\n\t\t            return result.data;\n\t\t        throw result.error;\n\t\t    }\n\t\t    safeParse(data, params) {\n\t\t        var _a;\n\t\t        const ctx = {\n\t\t            common: {\n\t\t                issues: [],\n\t\t                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n\t\t                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n\t\t            },\n\t\t            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n\t\t            schemaErrorMap: this._def.errorMap,\n\t\t            parent: null,\n\t\t            data,\n\t\t            parsedType: (0, util_1.getParsedType)(data),\n\t\t        };\n\t\t        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n\t\t        return handleResult(ctx, result);\n\t\t    }\n\t\t    async parseAsync(data, params) {\n\t\t        const result = await this.safeParseAsync(data, params);\n\t\t        if (result.success)\n\t\t            return result.data;\n\t\t        throw result.error;\n\t\t    }\n\t\t    async safeParseAsync(data, params) {\n\t\t        const ctx = {\n\t\t            common: {\n\t\t                issues: [],\n\t\t                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n\t\t                async: true,\n\t\t            },\n\t\t            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n\t\t            schemaErrorMap: this._def.errorMap,\n\t\t            parent: null,\n\t\t            data,\n\t\t            parsedType: (0, util_1.getParsedType)(data),\n\t\t        };\n\t\t        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n\t\t        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)\n\t\t            ? maybeAsyncResult\n\t\t            : Promise.resolve(maybeAsyncResult));\n\t\t        return handleResult(ctx, result);\n\t\t    }\n\t\t    refine(check, message) {\n\t\t        const getIssueProperties = (val) => {\n\t\t            if (typeof message === \"string\" || typeof message === \"undefined\") {\n\t\t                return { message };\n\t\t            }\n\t\t            else if (typeof message === \"function\") {\n\t\t                return message(val);\n\t\t            }\n\t\t            else {\n\t\t                return message;\n\t\t            }\n\t\t        };\n\t\t        return this._refinement((val, ctx) => {\n\t\t            const result = check(val);\n\t\t            const setError = () => ctx.addIssue({\n\t\t                code: ZodError_1.ZodIssueCode.custom,\n\t\t                ...getIssueProperties(val),\n\t\t            });\n\t\t            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t                return result.then((data) => {\n\t\t                    if (!data) {\n\t\t                        setError();\n\t\t                        return false;\n\t\t                    }\n\t\t                    else {\n\t\t                        return true;\n\t\t                    }\n\t\t                });\n\t\t            }\n\t\t            if (!result) {\n\t\t                setError();\n\t\t                return false;\n\t\t            }\n\t\t            else {\n\t\t                return true;\n\t\t            }\n\t\t        });\n\t\t    }\n\t\t    refinement(check, refinementData) {\n\t\t        return this._refinement((val, ctx) => {\n\t\t            if (!check(val)) {\n\t\t                ctx.addIssue(typeof refinementData === \"function\"\n\t\t                    ? refinementData(val, ctx)\n\t\t                    : refinementData);\n\t\t                return false;\n\t\t            }\n\t\t            else {\n\t\t                return true;\n\t\t            }\n\t\t        });\n\t\t    }\n\t\t    _refinement(refinement) {\n\t\t        return new ZodEffects({\n\t\t            schema: this,\n\t\t            typeName: ZodFirstPartyTypeKind.ZodEffects,\n\t\t            effect: { type: \"refinement\", refinement },\n\t\t        });\n\t\t    }\n\t\t    superRefine(refinement) {\n\t\t        return this._refinement(refinement);\n\t\t    }\n\t\t    optional() {\n\t\t        return ZodOptional.create(this, this._def);\n\t\t    }\n\t\t    nullable() {\n\t\t        return ZodNullable.create(this, this._def);\n\t\t    }\n\t\t    nullish() {\n\t\t        return this.nullable().optional();\n\t\t    }\n\t\t    array() {\n\t\t        return ZodArray.create(this, this._def);\n\t\t    }\n\t\t    promise() {\n\t\t        return ZodPromise.create(this, this._def);\n\t\t    }\n\t\t    or(option) {\n\t\t        return ZodUnion.create([this, option], this._def);\n\t\t    }\n\t\t    and(incoming) {\n\t\t        return ZodIntersection.create(this, incoming, this._def);\n\t\t    }\n\t\t    transform(transform) {\n\t\t        return new ZodEffects({\n\t\t            ...processCreateParams(this._def),\n\t\t            schema: this,\n\t\t            typeName: ZodFirstPartyTypeKind.ZodEffects,\n\t\t            effect: { type: \"transform\", transform },\n\t\t        });\n\t\t    }\n\t\t    default(def) {\n\t\t        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n\t\t        return new ZodDefault({\n\t\t            ...processCreateParams(this._def),\n\t\t            innerType: this,\n\t\t            defaultValue: defaultValueFunc,\n\t\t            typeName: ZodFirstPartyTypeKind.ZodDefault,\n\t\t        });\n\t\t    }\n\t\t    brand() {\n\t\t        return new ZodBranded({\n\t\t            typeName: ZodFirstPartyTypeKind.ZodBranded,\n\t\t            type: this,\n\t\t            ...processCreateParams(this._def),\n\t\t        });\n\t\t    }\n\t\t    catch(def) {\n\t\t        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n\t\t        return new ZodCatch({\n\t\t            ...processCreateParams(this._def),\n\t\t            innerType: this,\n\t\t            catchValue: catchValueFunc,\n\t\t            typeName: ZodFirstPartyTypeKind.ZodCatch,\n\t\t        });\n\t\t    }\n\t\t    describe(description) {\n\t\t        const This = this.constructor;\n\t\t        return new This({\n\t\t            ...this._def,\n\t\t            description,\n\t\t        });\n\t\t    }\n\t\t    pipe(target) {\n\t\t        return ZodPipeline.create(this, target);\n\t\t    }\n\t\t    readonly() {\n\t\t        return ZodReadonly.create(this);\n\t\t    }\n\t\t    isOptional() {\n\t\t        return this.safeParse(undefined).success;\n\t\t    }\n\t\t    isNullable() {\n\t\t        return this.safeParse(null).success;\n\t\t    }\n\t\t}\n\t\texports.ZodType = ZodType;\n\t\texports.Schema = ZodType;\n\t\texports.ZodSchema = ZodType;\n\t\tconst cuidRegex = /^c[^\\s-]{8,}$/i;\n\t\tconst cuid2Regex = /^[0-9a-z]+$/;\n\t\tconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\n\t\t// const uuidRegex =\n\t\t//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\t\tconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n\t\tconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\n\t\tconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n\t\t// from https://stackoverflow.com/a/46181/1550155\n\t\t// old version: too slow, didn't support unicode\n\t\t// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n\t\t//old email regex\n\t\t// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n\t\t// eslint-disable-next-line\n\t\t// const emailRegex =\n\t\t//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n\t\t// const emailRegex =\n\t\t//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\t\t// const emailRegex =\n\t\t//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\n\t\tconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n\t\t// const emailRegex =\n\t\t//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n\t\t// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\n\t\tconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\n\t\tlet emojiRegex;\n\t\t// faster, simpler, safer\n\t\tconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\n\t\tconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n\t\t// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\n\t\tconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n\t\t// simple\n\t\t// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n\t\t// no leap year validation\n\t\t// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n\t\t// with leap year validation\n\t\tconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\n\t\tconst dateRegex = new RegExp(`^${dateRegexSource}$`);\n\t\tfunction timeRegexSource(args) {\n\t\t    // let regex = `\\\\d{2}:\\\\d{2}:\\\\d{2}`;\n\t\t    let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\n\t\t    if (args.precision) {\n\t\t        regex = `${regex}\\\\.\\\\d{${args.precision}}`;\n\t\t    }\n\t\t    else if (args.precision == null) {\n\t\t        regex = `${regex}(\\\\.\\\\d+)?`;\n\t\t    }\n\t\t    return regex;\n\t\t}\n\t\tfunction timeRegex(args) {\n\t\t    return new RegExp(`^${timeRegexSource(args)}$`);\n\t\t}\n\t\t// Adapted from https://stackoverflow.com/a/3143231\n\t\tfunction datetimeRegex(args) {\n\t\t    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n\t\t    const opts = [];\n\t\t    opts.push(args.local ? `Z?` : `Z`);\n\t\t    if (args.offset)\n\t\t        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n\t\t    regex = `${regex}(${opts.join(\"|\")})`;\n\t\t    return new RegExp(`^${regex}$`);\n\t\t}\n\t\texports.datetimeRegex = datetimeRegex;\n\t\tfunction isValidIP(ip, version) {\n\t\t    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n\t\t        return true;\n\t\t    }\n\t\t    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n\t\t        return true;\n\t\t    }\n\t\t    return false;\n\t\t}\n\t\tclass ZodString extends ZodType {\n\t\t    _parse(input) {\n\t\t        if (this._def.coerce) {\n\t\t            input.data = String(input.data);\n\t\t        }\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.string) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.string,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const status = new parseUtil_1.ParseStatus();\n\t\t        let ctx = undefined;\n\t\t        for (const check of this._def.checks) {\n\t\t            if (check.kind === \"min\") {\n\t\t                if (input.data.length < check.value) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_small,\n\t\t                        minimum: check.value,\n\t\t                        type: \"string\",\n\t\t                        inclusive: true,\n\t\t                        exact: false,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"max\") {\n\t\t                if (input.data.length > check.value) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_big,\n\t\t                        maximum: check.value,\n\t\t                        type: \"string\",\n\t\t                        inclusive: true,\n\t\t                        exact: false,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"length\") {\n\t\t                const tooBig = input.data.length > check.value;\n\t\t                const tooSmall = input.data.length < check.value;\n\t\t                if (tooBig || tooSmall) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    if (tooBig) {\n\t\t                        (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                            code: ZodError_1.ZodIssueCode.too_big,\n\t\t                            maximum: check.value,\n\t\t                            type: \"string\",\n\t\t                            inclusive: true,\n\t\t                            exact: true,\n\t\t                            message: check.message,\n\t\t                        });\n\t\t                    }\n\t\t                    else if (tooSmall) {\n\t\t                        (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                            code: ZodError_1.ZodIssueCode.too_small,\n\t\t                            minimum: check.value,\n\t\t                            type: \"string\",\n\t\t                            inclusive: true,\n\t\t                            exact: true,\n\t\t                            message: check.message,\n\t\t                        });\n\t\t                    }\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"email\") {\n\t\t                if (!emailRegex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"email\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"emoji\") {\n\t\t                if (!emojiRegex) {\n\t\t                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n\t\t                }\n\t\t                if (!emojiRegex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"emoji\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"uuid\") {\n\t\t                if (!uuidRegex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"uuid\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"nanoid\") {\n\t\t                if (!nanoidRegex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"nanoid\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"cuid\") {\n\t\t                if (!cuidRegex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"cuid\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"cuid2\") {\n\t\t                if (!cuid2Regex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"cuid2\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"ulid\") {\n\t\t                if (!ulidRegex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"ulid\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"url\") {\n\t\t                try {\n\t\t                    new URL(input.data);\n\t\t                }\n\t\t                catch (_a) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"url\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"regex\") {\n\t\t                check.regex.lastIndex = 0;\n\t\t                const testResult = check.regex.test(input.data);\n\t\t                if (!testResult) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"regex\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"trim\") {\n\t\t                input.data = input.data.trim();\n\t\t            }\n\t\t            else if (check.kind === \"includes\") {\n\t\t                if (!input.data.includes(check.value, check.position)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        validation: { includes: check.value, position: check.position },\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"toLowerCase\") {\n\t\t                input.data = input.data.toLowerCase();\n\t\t            }\n\t\t            else if (check.kind === \"toUpperCase\") {\n\t\t                input.data = input.data.toUpperCase();\n\t\t            }\n\t\t            else if (check.kind === \"startsWith\") {\n\t\t                if (!input.data.startsWith(check.value)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        validation: { startsWith: check.value },\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"endsWith\") {\n\t\t                if (!input.data.endsWith(check.value)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        validation: { endsWith: check.value },\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"datetime\") {\n\t\t                const regex = datetimeRegex(check);\n\t\t                if (!regex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        validation: \"datetime\",\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"date\") {\n\t\t                const regex = dateRegex;\n\t\t                if (!regex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        validation: \"date\",\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"time\") {\n\t\t                const regex = timeRegex(check);\n\t\t                if (!regex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        validation: \"time\",\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"duration\") {\n\t\t                if (!durationRegex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"duration\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"ip\") {\n\t\t                if (!isValidIP(input.data, check.version)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"ip\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"base64\") {\n\t\t                if (!base64Regex.test(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        validation: \"base64\",\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                util_1.util.assertNever(check);\n\t\t            }\n\t\t        }\n\t\t        return { status: status.value, value: input.data };\n\t\t    }\n\t\t    _regex(regex, validation, message) {\n\t\t        return this.refinement((data) => regex.test(data), {\n\t\t            validation,\n\t\t            code: ZodError_1.ZodIssueCode.invalid_string,\n\t\t            ...errorUtil_1.errorUtil.errToObj(message),\n\t\t        });\n\t\t    }\n\t\t    _addCheck(check) {\n\t\t        return new ZodString({\n\t\t            ...this._def,\n\t\t            checks: [...this._def.checks, check],\n\t\t        });\n\t\t    }\n\t\t    email(message) {\n\t\t        return this._addCheck({ kind: \"email\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    url(message) {\n\t\t        return this._addCheck({ kind: \"url\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    emoji(message) {\n\t\t        return this._addCheck({ kind: \"emoji\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    uuid(message) {\n\t\t        return this._addCheck({ kind: \"uuid\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    nanoid(message) {\n\t\t        return this._addCheck({ kind: \"nanoid\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    cuid(message) {\n\t\t        return this._addCheck({ kind: \"cuid\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    cuid2(message) {\n\t\t        return this._addCheck({ kind: \"cuid2\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    ulid(message) {\n\t\t        return this._addCheck({ kind: \"ulid\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    base64(message) {\n\t\t        return this._addCheck({ kind: \"base64\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    ip(options) {\n\t\t        return this._addCheck({ kind: \"ip\", ...errorUtil_1.errorUtil.errToObj(options) });\n\t\t    }\n\t\t    datetime(options) {\n\t\t        var _a, _b;\n\t\t        if (typeof options === \"string\") {\n\t\t            return this._addCheck({\n\t\t                kind: \"datetime\",\n\t\t                precision: null,\n\t\t                offset: false,\n\t\t                local: false,\n\t\t                message: options,\n\t\t            });\n\t\t        }\n\t\t        return this._addCheck({\n\t\t            kind: \"datetime\",\n\t\t            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n\t\t            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n\t\t            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n\t\t            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n\t\t        });\n\t\t    }\n\t\t    date(message) {\n\t\t        return this._addCheck({ kind: \"date\", message });\n\t\t    }\n\t\t    time(options) {\n\t\t        if (typeof options === \"string\") {\n\t\t            return this._addCheck({\n\t\t                kind: \"time\",\n\t\t                precision: null,\n\t\t                message: options,\n\t\t            });\n\t\t        }\n\t\t        return this._addCheck({\n\t\t            kind: \"time\",\n\t\t            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n\t\t            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n\t\t        });\n\t\t    }\n\t\t    duration(message) {\n\t\t        return this._addCheck({ kind: \"duration\", ...errorUtil_1.errorUtil.errToObj(message) });\n\t\t    }\n\t\t    regex(regex, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"regex\",\n\t\t            regex: regex,\n\t\t            ...errorUtil_1.errorUtil.errToObj(message),\n\t\t        });\n\t\t    }\n\t\t    includes(value, options) {\n\t\t        return this._addCheck({\n\t\t            kind: \"includes\",\n\t\t            value: value,\n\t\t            position: options === null || options === void 0 ? void 0 : options.position,\n\t\t            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n\t\t        });\n\t\t    }\n\t\t    startsWith(value, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"startsWith\",\n\t\t            value: value,\n\t\t            ...errorUtil_1.errorUtil.errToObj(message),\n\t\t        });\n\t\t    }\n\t\t    endsWith(value, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"endsWith\",\n\t\t            value: value,\n\t\t            ...errorUtil_1.errorUtil.errToObj(message),\n\t\t        });\n\t\t    }\n\t\t    min(minLength, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"min\",\n\t\t            value: minLength,\n\t\t            ...errorUtil_1.errorUtil.errToObj(message),\n\t\t        });\n\t\t    }\n\t\t    max(maxLength, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"max\",\n\t\t            value: maxLength,\n\t\t            ...errorUtil_1.errorUtil.errToObj(message),\n\t\t        });\n\t\t    }\n\t\t    length(len, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"length\",\n\t\t            value: len,\n\t\t            ...errorUtil_1.errorUtil.errToObj(message),\n\t\t        });\n\t\t    }\n\t\t    /**\n\t\t     * @deprecated Use z.string().min(1) instead.\n\t\t     * @see {@link ZodString.min}\n\t\t     */\n\t\t    nonempty(message) {\n\t\t        return this.min(1, errorUtil_1.errorUtil.errToObj(message));\n\t\t    }\n\t\t    trim() {\n\t\t        return new ZodString({\n\t\t            ...this._def,\n\t\t            checks: [...this._def.checks, { kind: \"trim\" }],\n\t\t        });\n\t\t    }\n\t\t    toLowerCase() {\n\t\t        return new ZodString({\n\t\t            ...this._def,\n\t\t            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n\t\t        });\n\t\t    }\n\t\t    toUpperCase() {\n\t\t        return new ZodString({\n\t\t            ...this._def,\n\t\t            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n\t\t        });\n\t\t    }\n\t\t    get isDatetime() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n\t\t    }\n\t\t    get isDate() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n\t\t    }\n\t\t    get isTime() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n\t\t    }\n\t\t    get isDuration() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n\t\t    }\n\t\t    get isEmail() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n\t\t    }\n\t\t    get isURL() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n\t\t    }\n\t\t    get isEmoji() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n\t\t    }\n\t\t    get isUUID() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n\t\t    }\n\t\t    get isNANOID() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n\t\t    }\n\t\t    get isCUID() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n\t\t    }\n\t\t    get isCUID2() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n\t\t    }\n\t\t    get isULID() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n\t\t    }\n\t\t    get isIP() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n\t\t    }\n\t\t    get isBase64() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n\t\t    }\n\t\t    get minLength() {\n\t\t        let min = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"min\") {\n\t\t                if (min === null || ch.value > min)\n\t\t                    min = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return min;\n\t\t    }\n\t\t    get maxLength() {\n\t\t        let max = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"max\") {\n\t\t                if (max === null || ch.value < max)\n\t\t                    max = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return max;\n\t\t    }\n\t\t}\n\t\texports.ZodString = ZodString;\n\t\tZodString.create = (params) => {\n\t\t    var _a;\n\t\t    return new ZodString({\n\t\t        checks: [],\n\t\t        typeName: ZodFirstPartyTypeKind.ZodString,\n\t\t        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\t// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\n\t\tfunction floatSafeRemainder(val, step) {\n\t\t    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n\t\t    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n\t\t    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n\t\t    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n\t\t    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n\t\t    return (valInt % stepInt) / Math.pow(10, decCount);\n\t\t}\n\t\tclass ZodNumber extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        this.min = this.gte;\n\t\t        this.max = this.lte;\n\t\t        this.step = this.multipleOf;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        if (this._def.coerce) {\n\t\t            input.data = Number(input.data);\n\t\t        }\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.number) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.number,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        let ctx = undefined;\n\t\t        const status = new parseUtil_1.ParseStatus();\n\t\t        for (const check of this._def.checks) {\n\t\t            if (check.kind === \"int\") {\n\t\t                if (!util_1.util.isInteger(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                        expected: \"integer\",\n\t\t                        received: \"float\",\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"min\") {\n\t\t                const tooSmall = check.inclusive\n\t\t                    ? input.data < check.value\n\t\t                    : input.data <= check.value;\n\t\t                if (tooSmall) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_small,\n\t\t                        minimum: check.value,\n\t\t                        type: \"number\",\n\t\t                        inclusive: check.inclusive,\n\t\t                        exact: false,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"max\") {\n\t\t                const tooBig = check.inclusive\n\t\t                    ? input.data > check.value\n\t\t                    : input.data >= check.value;\n\t\t                if (tooBig) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_big,\n\t\t                        maximum: check.value,\n\t\t                        type: \"number\",\n\t\t                        inclusive: check.inclusive,\n\t\t                        exact: false,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"multipleOf\") {\n\t\t                if (floatSafeRemainder(input.data, check.value) !== 0) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.not_multiple_of,\n\t\t                        multipleOf: check.value,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"finite\") {\n\t\t                if (!Number.isFinite(input.data)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.not_finite,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                util_1.util.assertNever(check);\n\t\t            }\n\t\t        }\n\t\t        return { status: status.value, value: input.data };\n\t\t    }\n\t\t    gte(value, message) {\n\t\t        return this.setLimit(\"min\", value, true, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    gt(value, message) {\n\t\t        return this.setLimit(\"min\", value, false, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    lte(value, message) {\n\t\t        return this.setLimit(\"max\", value, true, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    lt(value, message) {\n\t\t        return this.setLimit(\"max\", value, false, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    setLimit(kind, value, inclusive, message) {\n\t\t        return new ZodNumber({\n\t\t            ...this._def,\n\t\t            checks: [\n\t\t                ...this._def.checks,\n\t\t                {\n\t\t                    kind,\n\t\t                    value,\n\t\t                    inclusive,\n\t\t                    message: errorUtil_1.errorUtil.toString(message),\n\t\t                },\n\t\t            ],\n\t\t        });\n\t\t    }\n\t\t    _addCheck(check) {\n\t\t        return new ZodNumber({\n\t\t            ...this._def,\n\t\t            checks: [...this._def.checks, check],\n\t\t        });\n\t\t    }\n\t\t    int(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"int\",\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    positive(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"min\",\n\t\t            value: 0,\n\t\t            inclusive: false,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    negative(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"max\",\n\t\t            value: 0,\n\t\t            inclusive: false,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    nonpositive(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"max\",\n\t\t            value: 0,\n\t\t            inclusive: true,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    nonnegative(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"min\",\n\t\t            value: 0,\n\t\t            inclusive: true,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    multipleOf(value, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"multipleOf\",\n\t\t            value: value,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    finite(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"finite\",\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    safe(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"min\",\n\t\t            inclusive: true,\n\t\t            value: Number.MIN_SAFE_INTEGER,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        })._addCheck({\n\t\t            kind: \"max\",\n\t\t            inclusive: true,\n\t\t            value: Number.MAX_SAFE_INTEGER,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    get minValue() {\n\t\t        let min = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"min\") {\n\t\t                if (min === null || ch.value > min)\n\t\t                    min = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return min;\n\t\t    }\n\t\t    get maxValue() {\n\t\t        let max = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"max\") {\n\t\t                if (max === null || ch.value < max)\n\t\t                    max = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return max;\n\t\t    }\n\t\t    get isInt() {\n\t\t        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n\t\t            (ch.kind === \"multipleOf\" && util_1.util.isInteger(ch.value)));\n\t\t    }\n\t\t    get isFinite() {\n\t\t        let max = null, min = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"finite\" ||\n\t\t                ch.kind === \"int\" ||\n\t\t                ch.kind === \"multipleOf\") {\n\t\t                return true;\n\t\t            }\n\t\t            else if (ch.kind === \"min\") {\n\t\t                if (min === null || ch.value > min)\n\t\t                    min = ch.value;\n\t\t            }\n\t\t            else if (ch.kind === \"max\") {\n\t\t                if (max === null || ch.value < max)\n\t\t                    max = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return Number.isFinite(min) && Number.isFinite(max);\n\t\t    }\n\t\t}\n\t\texports.ZodNumber = ZodNumber;\n\t\tZodNumber.create = (params) => {\n\t\t    return new ZodNumber({\n\t\t        checks: [],\n\t\t        typeName: ZodFirstPartyTypeKind.ZodNumber,\n\t\t        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodBigInt extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        this.min = this.gte;\n\t\t        this.max = this.lte;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        if (this._def.coerce) {\n\t\t            input.data = BigInt(input.data);\n\t\t        }\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.bigint) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.bigint,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        let ctx = undefined;\n\t\t        const status = new parseUtil_1.ParseStatus();\n\t\t        for (const check of this._def.checks) {\n\t\t            if (check.kind === \"min\") {\n\t\t                const tooSmall = check.inclusive\n\t\t                    ? input.data < check.value\n\t\t                    : input.data <= check.value;\n\t\t                if (tooSmall) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_small,\n\t\t                        type: \"bigint\",\n\t\t                        minimum: check.value,\n\t\t                        inclusive: check.inclusive,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"max\") {\n\t\t                const tooBig = check.inclusive\n\t\t                    ? input.data > check.value\n\t\t                    : input.data >= check.value;\n\t\t                if (tooBig) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_big,\n\t\t                        type: \"bigint\",\n\t\t                        maximum: check.value,\n\t\t                        inclusive: check.inclusive,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"multipleOf\") {\n\t\t                if (input.data % check.value !== BigInt(0)) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.not_multiple_of,\n\t\t                        multipleOf: check.value,\n\t\t                        message: check.message,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                util_1.util.assertNever(check);\n\t\t            }\n\t\t        }\n\t\t        return { status: status.value, value: input.data };\n\t\t    }\n\t\t    gte(value, message) {\n\t\t        return this.setLimit(\"min\", value, true, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    gt(value, message) {\n\t\t        return this.setLimit(\"min\", value, false, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    lte(value, message) {\n\t\t        return this.setLimit(\"max\", value, true, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    lt(value, message) {\n\t\t        return this.setLimit(\"max\", value, false, errorUtil_1.errorUtil.toString(message));\n\t\t    }\n\t\t    setLimit(kind, value, inclusive, message) {\n\t\t        return new ZodBigInt({\n\t\t            ...this._def,\n\t\t            checks: [\n\t\t                ...this._def.checks,\n\t\t                {\n\t\t                    kind,\n\t\t                    value,\n\t\t                    inclusive,\n\t\t                    message: errorUtil_1.errorUtil.toString(message),\n\t\t                },\n\t\t            ],\n\t\t        });\n\t\t    }\n\t\t    _addCheck(check) {\n\t\t        return new ZodBigInt({\n\t\t            ...this._def,\n\t\t            checks: [...this._def.checks, check],\n\t\t        });\n\t\t    }\n\t\t    positive(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"min\",\n\t\t            value: BigInt(0),\n\t\t            inclusive: false,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    negative(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"max\",\n\t\t            value: BigInt(0),\n\t\t            inclusive: false,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    nonpositive(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"max\",\n\t\t            value: BigInt(0),\n\t\t            inclusive: true,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    nonnegative(message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"min\",\n\t\t            value: BigInt(0),\n\t\t            inclusive: true,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    multipleOf(value, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"multipleOf\",\n\t\t            value,\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    get minValue() {\n\t\t        let min = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"min\") {\n\t\t                if (min === null || ch.value > min)\n\t\t                    min = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return min;\n\t\t    }\n\t\t    get maxValue() {\n\t\t        let max = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"max\") {\n\t\t                if (max === null || ch.value < max)\n\t\t                    max = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return max;\n\t\t    }\n\t\t}\n\t\texports.ZodBigInt = ZodBigInt;\n\t\tZodBigInt.create = (params) => {\n\t\t    var _a;\n\t\t    return new ZodBigInt({\n\t\t        checks: [],\n\t\t        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n\t\t        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodBoolean extends ZodType {\n\t\t    _parse(input) {\n\t\t        if (this._def.coerce) {\n\t\t            input.data = Boolean(input.data);\n\t\t        }\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.boolean) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.boolean,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t}\n\t\texports.ZodBoolean = ZodBoolean;\n\t\tZodBoolean.create = (params) => {\n\t\t    return new ZodBoolean({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n\t\t        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodDate extends ZodType {\n\t\t    _parse(input) {\n\t\t        if (this._def.coerce) {\n\t\t            input.data = new Date(input.data);\n\t\t        }\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.date) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.date,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        if (isNaN(input.data.getTime())) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_date,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const status = new parseUtil_1.ParseStatus();\n\t\t        let ctx = undefined;\n\t\t        for (const check of this._def.checks) {\n\t\t            if (check.kind === \"min\") {\n\t\t                if (input.data.getTime() < check.value) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_small,\n\t\t                        message: check.message,\n\t\t                        inclusive: true,\n\t\t                        exact: false,\n\t\t                        minimum: check.value,\n\t\t                        type: \"date\",\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (check.kind === \"max\") {\n\t\t                if (input.data.getTime() > check.value) {\n\t\t                    ctx = this._getOrReturnCtx(input, ctx);\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.too_big,\n\t\t                        message: check.message,\n\t\t                        inclusive: true,\n\t\t                        exact: false,\n\t\t                        maximum: check.value,\n\t\t                        type: \"date\",\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                util_1.util.assertNever(check);\n\t\t            }\n\t\t        }\n\t\t        return {\n\t\t            status: status.value,\n\t\t            value: new Date(input.data.getTime()),\n\t\t        };\n\t\t    }\n\t\t    _addCheck(check) {\n\t\t        return new ZodDate({\n\t\t            ...this._def,\n\t\t            checks: [...this._def.checks, check],\n\t\t        });\n\t\t    }\n\t\t    min(minDate, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"min\",\n\t\t            value: minDate.getTime(),\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    max(maxDate, message) {\n\t\t        return this._addCheck({\n\t\t            kind: \"max\",\n\t\t            value: maxDate.getTime(),\n\t\t            message: errorUtil_1.errorUtil.toString(message),\n\t\t        });\n\t\t    }\n\t\t    get minDate() {\n\t\t        let min = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"min\") {\n\t\t                if (min === null || ch.value > min)\n\t\t                    min = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return min != null ? new Date(min) : null;\n\t\t    }\n\t\t    get maxDate() {\n\t\t        let max = null;\n\t\t        for (const ch of this._def.checks) {\n\t\t            if (ch.kind === \"max\") {\n\t\t                if (max === null || ch.value < max)\n\t\t                    max = ch.value;\n\t\t            }\n\t\t        }\n\t\t        return max != null ? new Date(max) : null;\n\t\t    }\n\t\t}\n\t\texports.ZodDate = ZodDate;\n\t\tZodDate.create = (params) => {\n\t\t    return new ZodDate({\n\t\t        checks: [],\n\t\t        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodDate,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodSymbol extends ZodType {\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.symbol) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.symbol,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t}\n\t\texports.ZodSymbol = ZodSymbol;\n\t\tZodSymbol.create = (params) => {\n\t\t    return new ZodSymbol({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodUndefined extends ZodType {\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.undefined) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.undefined,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t}\n\t\texports.ZodUndefined = ZodUndefined;\n\t\tZodUndefined.create = (params) => {\n\t\t    return new ZodUndefined({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodNull extends ZodType {\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.null) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.null,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t}\n\t\texports.ZodNull = ZodNull;\n\t\tZodNull.create = (params) => {\n\t\t    return new ZodNull({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodNull,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodAny extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n\t\t        this._any = true;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t}\n\t\texports.ZodAny = ZodAny;\n\t\tZodAny.create = (params) => {\n\t\t    return new ZodAny({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodAny,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodUnknown extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        // required\n\t\t        this._unknown = true;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t}\n\t\texports.ZodUnknown = ZodUnknown;\n\t\tZodUnknown.create = (params) => {\n\t\t    return new ZodUnknown({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodNever extends ZodType {\n\t\t    _parse(input) {\n\t\t        const ctx = this._getOrReturnCtx(input);\n\t\t        (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t            code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t            expected: util_1.ZodParsedType.never,\n\t\t            received: ctx.parsedType,\n\t\t        });\n\t\t        return parseUtil_1.INVALID;\n\t\t    }\n\t\t}\n\t\texports.ZodNever = ZodNever;\n\t\tZodNever.create = (params) => {\n\t\t    return new ZodNever({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodNever,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodVoid extends ZodType {\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.undefined) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.void,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t}\n\t\texports.ZodVoid = ZodVoid;\n\t\tZodVoid.create = (params) => {\n\t\t    return new ZodVoid({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodVoid,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodArray extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { ctx, status } = this._processInputParams(input);\n\t\t        const def = this._def;\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.array) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.array,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        if (def.exactLength !== null) {\n\t\t            const tooBig = ctx.data.length > def.exactLength.value;\n\t\t            const tooSmall = ctx.data.length < def.exactLength.value;\n\t\t            if (tooBig || tooSmall) {\n\t\t                (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,\n\t\t                    minimum: (tooSmall ? def.exactLength.value : undefined),\n\t\t                    maximum: (tooBig ? def.exactLength.value : undefined),\n\t\t                    type: \"array\",\n\t\t                    inclusive: true,\n\t\t                    exact: true,\n\t\t                    message: def.exactLength.message,\n\t\t                });\n\t\t                status.dirty();\n\t\t            }\n\t\t        }\n\t\t        if (def.minLength !== null) {\n\t\t            if (ctx.data.length < def.minLength.value) {\n\t\t                (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                    code: ZodError_1.ZodIssueCode.too_small,\n\t\t                    minimum: def.minLength.value,\n\t\t                    type: \"array\",\n\t\t                    inclusive: true,\n\t\t                    exact: false,\n\t\t                    message: def.minLength.message,\n\t\t                });\n\t\t                status.dirty();\n\t\t            }\n\t\t        }\n\t\t        if (def.maxLength !== null) {\n\t\t            if (ctx.data.length > def.maxLength.value) {\n\t\t                (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                    code: ZodError_1.ZodIssueCode.too_big,\n\t\t                    maximum: def.maxLength.value,\n\t\t                    type: \"array\",\n\t\t                    inclusive: true,\n\t\t                    exact: false,\n\t\t                    message: def.maxLength.message,\n\t\t                });\n\t\t                status.dirty();\n\t\t            }\n\t\t        }\n\t\t        if (ctx.common.async) {\n\t\t            return Promise.all([...ctx.data].map((item, i) => {\n\t\t                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n\t\t            })).then((result) => {\n\t\t                return parseUtil_1.ParseStatus.mergeArray(status, result);\n\t\t            });\n\t\t        }\n\t\t        const result = [...ctx.data].map((item, i) => {\n\t\t            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n\t\t        });\n\t\t        return parseUtil_1.ParseStatus.mergeArray(status, result);\n\t\t    }\n\t\t    get element() {\n\t\t        return this._def.type;\n\t\t    }\n\t\t    min(minLength, message) {\n\t\t        return new ZodArray({\n\t\t            ...this._def,\n\t\t            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },\n\t\t        });\n\t\t    }\n\t\t    max(maxLength, message) {\n\t\t        return new ZodArray({\n\t\t            ...this._def,\n\t\t            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },\n\t\t        });\n\t\t    }\n\t\t    length(len, message) {\n\t\t        return new ZodArray({\n\t\t            ...this._def,\n\t\t            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },\n\t\t        });\n\t\t    }\n\t\t    nonempty(message) {\n\t\t        return this.min(1, message);\n\t\t    }\n\t\t}\n\t\texports.ZodArray = ZodArray;\n\t\tZodArray.create = (schema, params) => {\n\t\t    return new ZodArray({\n\t\t        type: schema,\n\t\t        minLength: null,\n\t\t        maxLength: null,\n\t\t        exactLength: null,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodArray,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tfunction deepPartialify(schema) {\n\t\t    if (schema instanceof ZodObject) {\n\t\t        const newShape = {};\n\t\t        for (const key in schema.shape) {\n\t\t            const fieldSchema = schema.shape[key];\n\t\t            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n\t\t        }\n\t\t        return new ZodObject({\n\t\t            ...schema._def,\n\t\t            shape: () => newShape,\n\t\t        });\n\t\t    }\n\t\t    else if (schema instanceof ZodArray) {\n\t\t        return new ZodArray({\n\t\t            ...schema._def,\n\t\t            type: deepPartialify(schema.element),\n\t\t        });\n\t\t    }\n\t\t    else if (schema instanceof ZodOptional) {\n\t\t        return ZodOptional.create(deepPartialify(schema.unwrap()));\n\t\t    }\n\t\t    else if (schema instanceof ZodNullable) {\n\t\t        return ZodNullable.create(deepPartialify(schema.unwrap()));\n\t\t    }\n\t\t    else if (schema instanceof ZodTuple) {\n\t\t        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n\t\t    }\n\t\t    else {\n\t\t        return schema;\n\t\t    }\n\t\t}\n\t\tclass ZodObject extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        this._cached = null;\n\t\t        /**\n\t\t         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n\t\t         * If you want to pass through unknown properties, use `.passthrough()` instead.\n\t\t         */\n\t\t        this.nonstrict = this.passthrough;\n\t\t        // extend<\n\t\t        //   Augmentation extends ZodRawShape,\n\t\t        //   NewOutput extends util.flatten<{\n\t\t        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n\t\t        //       ? Augmentation[k][\"_output\"]\n\t\t        //       : k extends keyof Output\n\t\t        //       ? Output[k]\n\t\t        //       : never;\n\t\t        //   }>,\n\t\t        //   NewInput extends util.flatten<{\n\t\t        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n\t\t        //       ? Augmentation[k][\"_input\"]\n\t\t        //       : k extends keyof Input\n\t\t        //       ? Input[k]\n\t\t        //       : never;\n\t\t        //   }>\n\t\t        // >(\n\t\t        //   augmentation: Augmentation\n\t\t        // ): ZodObject<\n\t\t        //   extendShape<T, Augmentation>,\n\t\t        //   UnknownKeys,\n\t\t        //   Catchall,\n\t\t        //   NewOutput,\n\t\t        //   NewInput\n\t\t        // > {\n\t\t        //   return new ZodObject({\n\t\t        //     ...this._def,\n\t\t        //     shape: () => ({\n\t\t        //       ...this._def.shape(),\n\t\t        //       ...augmentation,\n\t\t        //     }),\n\t\t        //   }) as any;\n\t\t        // }\n\t\t        /**\n\t\t         * @deprecated Use `.extend` instead\n\t\t         *  */\n\t\t        this.augment = this.extend;\n\t\t    }\n\t\t    _getCached() {\n\t\t        if (this._cached !== null)\n\t\t            return this._cached;\n\t\t        const shape = this._def.shape();\n\t\t        const keys = util_1.util.objectKeys(shape);\n\t\t        return (this._cached = { shape, keys });\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.object) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.object,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        const { shape, keys: shapeKeys } = this._getCached();\n\t\t        const extraKeys = [];\n\t\t        if (!(this._def.catchall instanceof ZodNever &&\n\t\t            this._def.unknownKeys === \"strip\")) {\n\t\t            for (const key in ctx.data) {\n\t\t                if (!shapeKeys.includes(key)) {\n\t\t                    extraKeys.push(key);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        const pairs = [];\n\t\t        for (const key of shapeKeys) {\n\t\t            const keyValidator = shape[key];\n\t\t            const value = ctx.data[key];\n\t\t            pairs.push({\n\t\t                key: { status: \"valid\", value: key },\n\t\t                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n\t\t                alwaysSet: key in ctx.data,\n\t\t            });\n\t\t        }\n\t\t        if (this._def.catchall instanceof ZodNever) {\n\t\t            const unknownKeys = this._def.unknownKeys;\n\t\t            if (unknownKeys === \"passthrough\") {\n\t\t                for (const key of extraKeys) {\n\t\t                    pairs.push({\n\t\t                        key: { status: \"valid\", value: key },\n\t\t                        value: { status: \"valid\", value: ctx.data[key] },\n\t\t                    });\n\t\t                }\n\t\t            }\n\t\t            else if (unknownKeys === \"strict\") {\n\t\t                if (extraKeys.length > 0) {\n\t\t                    (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                        code: ZodError_1.ZodIssueCode.unrecognized_keys,\n\t\t                        keys: extraKeys,\n\t\t                    });\n\t\t                    status.dirty();\n\t\t                }\n\t\t            }\n\t\t            else if (unknownKeys === \"strip\") ;\n\t\t            else {\n\t\t                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            // run catchall validation\n\t\t            const catchall = this._def.catchall;\n\t\t            for (const key of extraKeys) {\n\t\t                const value = ctx.data[key];\n\t\t                pairs.push({\n\t\t                    key: { status: \"valid\", value: key },\n\t\t                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n\t\t                    ),\n\t\t                    alwaysSet: key in ctx.data,\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t        if (ctx.common.async) {\n\t\t            return Promise.resolve()\n\t\t                .then(async () => {\n\t\t                const syncPairs = [];\n\t\t                for (const pair of pairs) {\n\t\t                    const key = await pair.key;\n\t\t                    const value = await pair.value;\n\t\t                    syncPairs.push({\n\t\t                        key,\n\t\t                        value,\n\t\t                        alwaysSet: pair.alwaysSet,\n\t\t                    });\n\t\t                }\n\t\t                return syncPairs;\n\t\t            })\n\t\t                .then((syncPairs) => {\n\t\t                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);\n\t\t        }\n\t\t    }\n\t\t    get shape() {\n\t\t        return this._def.shape();\n\t\t    }\n\t\t    strict(message) {\n\t\t        errorUtil_1.errorUtil.errToObj;\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            unknownKeys: \"strict\",\n\t\t            ...(message !== undefined\n\t\t                ? {\n\t\t                    errorMap: (issue, ctx) => {\n\t\t                        var _a, _b, _c, _d;\n\t\t                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n\t\t                        if (issue.code === \"unrecognized_keys\")\n\t\t                            return {\n\t\t                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n\t\t                            };\n\t\t                        return {\n\t\t                            message: defaultError,\n\t\t                        };\n\t\t                    },\n\t\t                }\n\t\t                : {}),\n\t\t        });\n\t\t    }\n\t\t    strip() {\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            unknownKeys: \"strip\",\n\t\t        });\n\t\t    }\n\t\t    passthrough() {\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            unknownKeys: \"passthrough\",\n\t\t        });\n\t\t    }\n\t\t    // const AugmentFactory =\n\t\t    //   <Def extends ZodObjectDef>(def: Def) =>\n\t\t    //   <Augmentation extends ZodRawShape>(\n\t\t    //     augmentation: Augmentation\n\t\t    //   ): ZodObject<\n\t\t    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n\t\t    //     Def[\"unknownKeys\"],\n\t\t    //     Def[\"catchall\"]\n\t\t    //   > => {\n\t\t    //     return new ZodObject({\n\t\t    //       ...def,\n\t\t    //       shape: () => ({\n\t\t    //         ...def.shape(),\n\t\t    //         ...augmentation,\n\t\t    //       }),\n\t\t    //     }) as any;\n\t\t    //   };\n\t\t    extend(augmentation) {\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            shape: () => ({\n\t\t                ...this._def.shape(),\n\t\t                ...augmentation,\n\t\t            }),\n\t\t        });\n\t\t    }\n\t\t    /**\n\t\t     * Prior to zod@1.0.12 there was a bug in the\n\t\t     * inferred type of merged objects. Please\n\t\t     * upgrade if you are experiencing issues.\n\t\t     */\n\t\t    merge(merging) {\n\t\t        const merged = new ZodObject({\n\t\t            unknownKeys: merging._def.unknownKeys,\n\t\t            catchall: merging._def.catchall,\n\t\t            shape: () => ({\n\t\t                ...this._def.shape(),\n\t\t                ...merging._def.shape(),\n\t\t            }),\n\t\t            typeName: ZodFirstPartyTypeKind.ZodObject,\n\t\t        });\n\t\t        return merged;\n\t\t    }\n\t\t    // merge<\n\t\t    //   Incoming extends AnyZodObject,\n\t\t    //   Augmentation extends Incoming[\"shape\"],\n\t\t    //   NewOutput extends {\n\t\t    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n\t\t    //       ? Augmentation[k][\"_output\"]\n\t\t    //       : k extends keyof Output\n\t\t    //       ? Output[k]\n\t\t    //       : never;\n\t\t    //   },\n\t\t    //   NewInput extends {\n\t\t    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n\t\t    //       ? Augmentation[k][\"_input\"]\n\t\t    //       : k extends keyof Input\n\t\t    //       ? Input[k]\n\t\t    //       : never;\n\t\t    //   }\n\t\t    // >(\n\t\t    //   merging: Incoming\n\t\t    // ): ZodObject<\n\t\t    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n\t\t    //   Incoming[\"_def\"][\"unknownKeys\"],\n\t\t    //   Incoming[\"_def\"][\"catchall\"],\n\t\t    //   NewOutput,\n\t\t    //   NewInput\n\t\t    // > {\n\t\t    //   const merged: any = new ZodObject({\n\t\t    //     unknownKeys: merging._def.unknownKeys,\n\t\t    //     catchall: merging._def.catchall,\n\t\t    //     shape: () =>\n\t\t    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n\t\t    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n\t\t    //   }) as any;\n\t\t    //   return merged;\n\t\t    // }\n\t\t    setKey(key, schema) {\n\t\t        return this.augment({ [key]: schema });\n\t\t    }\n\t\t    // merge<Incoming extends AnyZodObject>(\n\t\t    //   merging: Incoming\n\t\t    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n\t\t    // ZodObject<\n\t\t    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n\t\t    //   Incoming[\"_def\"][\"unknownKeys\"],\n\t\t    //   Incoming[\"_def\"][\"catchall\"]\n\t\t    // > {\n\t\t    //   // const mergedShape = objectUtil.mergeShapes(\n\t\t    //   //   this._def.shape(),\n\t\t    //   //   merging._def.shape()\n\t\t    //   // );\n\t\t    //   const merged: any = new ZodObject({\n\t\t    //     unknownKeys: merging._def.unknownKeys,\n\t\t    //     catchall: merging._def.catchall,\n\t\t    //     shape: () =>\n\t\t    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n\t\t    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n\t\t    //   }) as any;\n\t\t    //   return merged;\n\t\t    // }\n\t\t    catchall(index) {\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            catchall: index,\n\t\t        });\n\t\t    }\n\t\t    pick(mask) {\n\t\t        const shape = {};\n\t\t        util_1.util.objectKeys(mask).forEach((key) => {\n\t\t            if (mask[key] && this.shape[key]) {\n\t\t                shape[key] = this.shape[key];\n\t\t            }\n\t\t        });\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            shape: () => shape,\n\t\t        });\n\t\t    }\n\t\t    omit(mask) {\n\t\t        const shape = {};\n\t\t        util_1.util.objectKeys(this.shape).forEach((key) => {\n\t\t            if (!mask[key]) {\n\t\t                shape[key] = this.shape[key];\n\t\t            }\n\t\t        });\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            shape: () => shape,\n\t\t        });\n\t\t    }\n\t\t    /**\n\t\t     * @deprecated\n\t\t     */\n\t\t    deepPartial() {\n\t\t        return deepPartialify(this);\n\t\t    }\n\t\t    partial(mask) {\n\t\t        const newShape = {};\n\t\t        util_1.util.objectKeys(this.shape).forEach((key) => {\n\t\t            const fieldSchema = this.shape[key];\n\t\t            if (mask && !mask[key]) {\n\t\t                newShape[key] = fieldSchema;\n\t\t            }\n\t\t            else {\n\t\t                newShape[key] = fieldSchema.optional();\n\t\t            }\n\t\t        });\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            shape: () => newShape,\n\t\t        });\n\t\t    }\n\t\t    required(mask) {\n\t\t        const newShape = {};\n\t\t        util_1.util.objectKeys(this.shape).forEach((key) => {\n\t\t            if (mask && !mask[key]) {\n\t\t                newShape[key] = this.shape[key];\n\t\t            }\n\t\t            else {\n\t\t                const fieldSchema = this.shape[key];\n\t\t                let newField = fieldSchema;\n\t\t                while (newField instanceof ZodOptional) {\n\t\t                    newField = newField._def.innerType;\n\t\t                }\n\t\t                newShape[key] = newField;\n\t\t            }\n\t\t        });\n\t\t        return new ZodObject({\n\t\t            ...this._def,\n\t\t            shape: () => newShape,\n\t\t        });\n\t\t    }\n\t\t    keyof() {\n\t\t        return createZodEnum(util_1.util.objectKeys(this.shape));\n\t\t    }\n\t\t}\n\t\texports.ZodObject = ZodObject;\n\t\tZodObject.create = (shape, params) => {\n\t\t    return new ZodObject({\n\t\t        shape: () => shape,\n\t\t        unknownKeys: \"strip\",\n\t\t        catchall: ZodNever.create(),\n\t\t        typeName: ZodFirstPartyTypeKind.ZodObject,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tZodObject.strictCreate = (shape, params) => {\n\t\t    return new ZodObject({\n\t\t        shape: () => shape,\n\t\t        unknownKeys: \"strict\",\n\t\t        catchall: ZodNever.create(),\n\t\t        typeName: ZodFirstPartyTypeKind.ZodObject,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tZodObject.lazycreate = (shape, params) => {\n\t\t    return new ZodObject({\n\t\t        shape,\n\t\t        unknownKeys: \"strip\",\n\t\t        catchall: ZodNever.create(),\n\t\t        typeName: ZodFirstPartyTypeKind.ZodObject,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodUnion extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        const options = this._def.options;\n\t\t        function handleResults(results) {\n\t\t            // return first issue-free validation if it exists\n\t\t            for (const result of results) {\n\t\t                if (result.result.status === \"valid\") {\n\t\t                    return result.result;\n\t\t                }\n\t\t            }\n\t\t            for (const result of results) {\n\t\t                if (result.result.status === \"dirty\") {\n\t\t                    // add issues from dirty option\n\t\t                    ctx.common.issues.push(...result.ctx.common.issues);\n\t\t                    return result.result;\n\t\t                }\n\t\t            }\n\t\t            // return invalid\n\t\t            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_union,\n\t\t                unionErrors,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        if (ctx.common.async) {\n\t\t            return Promise.all(options.map(async (option) => {\n\t\t                const childCtx = {\n\t\t                    ...ctx,\n\t\t                    common: {\n\t\t                        ...ctx.common,\n\t\t                        issues: [],\n\t\t                    },\n\t\t                    parent: null,\n\t\t                };\n\t\t                return {\n\t\t                    result: await option._parseAsync({\n\t\t                        data: ctx.data,\n\t\t                        path: ctx.path,\n\t\t                        parent: childCtx,\n\t\t                    }),\n\t\t                    ctx: childCtx,\n\t\t                };\n\t\t            })).then(handleResults);\n\t\t        }\n\t\t        else {\n\t\t            let dirty = undefined;\n\t\t            const issues = [];\n\t\t            for (const option of options) {\n\t\t                const childCtx = {\n\t\t                    ...ctx,\n\t\t                    common: {\n\t\t                        ...ctx.common,\n\t\t                        issues: [],\n\t\t                    },\n\t\t                    parent: null,\n\t\t                };\n\t\t                const result = option._parseSync({\n\t\t                    data: ctx.data,\n\t\t                    path: ctx.path,\n\t\t                    parent: childCtx,\n\t\t                });\n\t\t                if (result.status === \"valid\") {\n\t\t                    return result;\n\t\t                }\n\t\t                else if (result.status === \"dirty\" && !dirty) {\n\t\t                    dirty = { result, ctx: childCtx };\n\t\t                }\n\t\t                if (childCtx.common.issues.length) {\n\t\t                    issues.push(childCtx.common.issues);\n\t\t                }\n\t\t            }\n\t\t            if (dirty) {\n\t\t                ctx.common.issues.push(...dirty.ctx.common.issues);\n\t\t                return dirty.result;\n\t\t            }\n\t\t            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_union,\n\t\t                unionErrors,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t    }\n\t\t    get options() {\n\t\t        return this._def.options;\n\t\t    }\n\t\t}\n\t\texports.ZodUnion = ZodUnion;\n\t\tZodUnion.create = (types, params) => {\n\t\t    return new ZodUnion({\n\t\t        options: types,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodUnion,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\t/////////////////////////////////////////////////////\n\t\t/////////////////////////////////////////////////////\n\t\t//////////                                 //////////\n\t\t//////////      ZodDiscriminatedUnion      //////////\n\t\t//////////                                 //////////\n\t\t/////////////////////////////////////////////////////\n\t\t/////////////////////////////////////////////////////\n\t\tconst getDiscriminator = (type) => {\n\t\t    if (type instanceof ZodLazy) {\n\t\t        return getDiscriminator(type.schema);\n\t\t    }\n\t\t    else if (type instanceof ZodEffects) {\n\t\t        return getDiscriminator(type.innerType());\n\t\t    }\n\t\t    else if (type instanceof ZodLiteral) {\n\t\t        return [type.value];\n\t\t    }\n\t\t    else if (type instanceof ZodEnum) {\n\t\t        return type.options;\n\t\t    }\n\t\t    else if (type instanceof ZodNativeEnum) {\n\t\t        // eslint-disable-next-line ban/ban\n\t\t        return util_1.util.objectValues(type.enum);\n\t\t    }\n\t\t    else if (type instanceof ZodDefault) {\n\t\t        return getDiscriminator(type._def.innerType);\n\t\t    }\n\t\t    else if (type instanceof ZodUndefined) {\n\t\t        return [undefined];\n\t\t    }\n\t\t    else if (type instanceof ZodNull) {\n\t\t        return [null];\n\t\t    }\n\t\t    else if (type instanceof ZodOptional) {\n\t\t        return [undefined, ...getDiscriminator(type.unwrap())];\n\t\t    }\n\t\t    else if (type instanceof ZodNullable) {\n\t\t        return [null, ...getDiscriminator(type.unwrap())];\n\t\t    }\n\t\t    else if (type instanceof ZodBranded) {\n\t\t        return getDiscriminator(type.unwrap());\n\t\t    }\n\t\t    else if (type instanceof ZodReadonly) {\n\t\t        return getDiscriminator(type.unwrap());\n\t\t    }\n\t\t    else if (type instanceof ZodCatch) {\n\t\t        return getDiscriminator(type._def.innerType);\n\t\t    }\n\t\t    else {\n\t\t        return [];\n\t\t    }\n\t\t};\n\t\tclass ZodDiscriminatedUnion extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.object) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.object,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const discriminator = this.discriminator;\n\t\t        const discriminatorValue = ctx.data[discriminator];\n\t\t        const option = this.optionsMap.get(discriminatorValue);\n\t\t        if (!option) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,\n\t\t                options: Array.from(this.optionsMap.keys()),\n\t\t                path: [discriminator],\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        if (ctx.common.async) {\n\t\t            return option._parseAsync({\n\t\t                data: ctx.data,\n\t\t                path: ctx.path,\n\t\t                parent: ctx,\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            return option._parseSync({\n\t\t                data: ctx.data,\n\t\t                path: ctx.path,\n\t\t                parent: ctx,\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    get discriminator() {\n\t\t        return this._def.discriminator;\n\t\t    }\n\t\t    get options() {\n\t\t        return this._def.options;\n\t\t    }\n\t\t    get optionsMap() {\n\t\t        return this._def.optionsMap;\n\t\t    }\n\t\t    /**\n\t\t     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n\t\t     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n\t\t     * have a different value for each object in the union.\n\t\t     * @param discriminator the name of the discriminator property\n\t\t     * @param types an array of object schemas\n\t\t     * @param params\n\t\t     */\n\t\t    static create(discriminator, options, params) {\n\t\t        // Get all the valid discriminator values\n\t\t        const optionsMap = new Map();\n\t\t        // try {\n\t\t        for (const type of options) {\n\t\t            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n\t\t            if (!discriminatorValues.length) {\n\t\t                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n\t\t            }\n\t\t            for (const value of discriminatorValues) {\n\t\t                if (optionsMap.has(value)) {\n\t\t                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n\t\t                }\n\t\t                optionsMap.set(value, type);\n\t\t            }\n\t\t        }\n\t\t        return new ZodDiscriminatedUnion({\n\t\t            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n\t\t            discriminator,\n\t\t            options,\n\t\t            optionsMap,\n\t\t            ...processCreateParams(params),\n\t\t        });\n\t\t    }\n\t\t}\n\t\texports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;\n\t\tfunction mergeValues(a, b) {\n\t\t    const aType = (0, util_1.getParsedType)(a);\n\t\t    const bType = (0, util_1.getParsedType)(b);\n\t\t    if (a === b) {\n\t\t        return { valid: true, data: a };\n\t\t    }\n\t\t    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {\n\t\t        const bKeys = util_1.util.objectKeys(b);\n\t\t        const sharedKeys = util_1.util\n\t\t            .objectKeys(a)\n\t\t            .filter((key) => bKeys.indexOf(key) !== -1);\n\t\t        const newObj = { ...a, ...b };\n\t\t        for (const key of sharedKeys) {\n\t\t            const sharedValue = mergeValues(a[key], b[key]);\n\t\t            if (!sharedValue.valid) {\n\t\t                return { valid: false };\n\t\t            }\n\t\t            newObj[key] = sharedValue.data;\n\t\t        }\n\t\t        return { valid: true, data: newObj };\n\t\t    }\n\t\t    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {\n\t\t        if (a.length !== b.length) {\n\t\t            return { valid: false };\n\t\t        }\n\t\t        const newArray = [];\n\t\t        for (let index = 0; index < a.length; index++) {\n\t\t            const itemA = a[index];\n\t\t            const itemB = b[index];\n\t\t            const sharedValue = mergeValues(itemA, itemB);\n\t\t            if (!sharedValue.valid) {\n\t\t                return { valid: false };\n\t\t            }\n\t\t            newArray.push(sharedValue.data);\n\t\t        }\n\t\t        return { valid: true, data: newArray };\n\t\t    }\n\t\t    else if (aType === util_1.ZodParsedType.date &&\n\t\t        bType === util_1.ZodParsedType.date &&\n\t\t        +a === +b) {\n\t\t        return { valid: true, data: a };\n\t\t    }\n\t\t    else {\n\t\t        return { valid: false };\n\t\t    }\n\t\t}\n\t\tclass ZodIntersection extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        const handleParsed = (parsedLeft, parsedRight) => {\n\t\t            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {\n\t\t                return parseUtil_1.INVALID;\n\t\t            }\n\t\t            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n\t\t            if (!merged.valid) {\n\t\t                (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,\n\t\t                });\n\t\t                return parseUtil_1.INVALID;\n\t\t            }\n\t\t            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {\n\t\t                status.dirty();\n\t\t            }\n\t\t            return { status: status.value, value: merged.data };\n\t\t        };\n\t\t        if (ctx.common.async) {\n\t\t            return Promise.all([\n\t\t                this._def.left._parseAsync({\n\t\t                    data: ctx.data,\n\t\t                    path: ctx.path,\n\t\t                    parent: ctx,\n\t\t                }),\n\t\t                this._def.right._parseAsync({\n\t\t                    data: ctx.data,\n\t\t                    path: ctx.path,\n\t\t                    parent: ctx,\n\t\t                }),\n\t\t            ]).then(([left, right]) => handleParsed(left, right));\n\t\t        }\n\t\t        else {\n\t\t            return handleParsed(this._def.left._parseSync({\n\t\t                data: ctx.data,\n\t\t                path: ctx.path,\n\t\t                parent: ctx,\n\t\t            }), this._def.right._parseSync({\n\t\t                data: ctx.data,\n\t\t                path: ctx.path,\n\t\t                parent: ctx,\n\t\t            }));\n\t\t        }\n\t\t    }\n\t\t}\n\t\texports.ZodIntersection = ZodIntersection;\n\t\tZodIntersection.create = (left, right, params) => {\n\t\t    return new ZodIntersection({\n\t\t        left: left,\n\t\t        right: right,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodTuple extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.array) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.array,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        if (ctx.data.length < this._def.items.length) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.too_small,\n\t\t                minimum: this._def.items.length,\n\t\t                inclusive: true,\n\t\t                exact: false,\n\t\t                type: \"array\",\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const rest = this._def.rest;\n\t\t        if (!rest && ctx.data.length > this._def.items.length) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.too_big,\n\t\t                maximum: this._def.items.length,\n\t\t                inclusive: true,\n\t\t                exact: false,\n\t\t                type: \"array\",\n\t\t            });\n\t\t            status.dirty();\n\t\t        }\n\t\t        const items = [...ctx.data]\n\t\t            .map((item, itemIndex) => {\n\t\t            const schema = this._def.items[itemIndex] || this._def.rest;\n\t\t            if (!schema)\n\t\t                return null;\n\t\t            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n\t\t        })\n\t\t            .filter((x) => !!x); // filter nulls\n\t\t        if (ctx.common.async) {\n\t\t            return Promise.all(items).then((results) => {\n\t\t                return parseUtil_1.ParseStatus.mergeArray(status, results);\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            return parseUtil_1.ParseStatus.mergeArray(status, items);\n\t\t        }\n\t\t    }\n\t\t    get items() {\n\t\t        return this._def.items;\n\t\t    }\n\t\t    rest(rest) {\n\t\t        return new ZodTuple({\n\t\t            ...this._def,\n\t\t            rest,\n\t\t        });\n\t\t    }\n\t\t}\n\t\texports.ZodTuple = ZodTuple;\n\t\tZodTuple.create = (schemas, params) => {\n\t\t    if (!Array.isArray(schemas)) {\n\t\t        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n\t\t    }\n\t\t    return new ZodTuple({\n\t\t        items: schemas,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodTuple,\n\t\t        rest: null,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodRecord extends ZodType {\n\t\t    get keySchema() {\n\t\t        return this._def.keyType;\n\t\t    }\n\t\t    get valueSchema() {\n\t\t        return this._def.valueType;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.object) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.object,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const pairs = [];\n\t\t        const keyType = this._def.keyType;\n\t\t        const valueType = this._def.valueType;\n\t\t        for (const key in ctx.data) {\n\t\t            pairs.push({\n\t\t                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n\t\t                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n\t\t                alwaysSet: key in ctx.data,\n\t\t            });\n\t\t        }\n\t\t        if (ctx.common.async) {\n\t\t            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);\n\t\t        }\n\t\t        else {\n\t\t            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);\n\t\t        }\n\t\t    }\n\t\t    get element() {\n\t\t        return this._def.valueType;\n\t\t    }\n\t\t    static create(first, second, third) {\n\t\t        if (second instanceof ZodType) {\n\t\t            return new ZodRecord({\n\t\t                keyType: first,\n\t\t                valueType: second,\n\t\t                typeName: ZodFirstPartyTypeKind.ZodRecord,\n\t\t                ...processCreateParams(third),\n\t\t            });\n\t\t        }\n\t\t        return new ZodRecord({\n\t\t            keyType: ZodString.create(),\n\t\t            valueType: first,\n\t\t            typeName: ZodFirstPartyTypeKind.ZodRecord,\n\t\t            ...processCreateParams(second),\n\t\t        });\n\t\t    }\n\t\t}\n\t\texports.ZodRecord = ZodRecord;\n\t\tclass ZodMap extends ZodType {\n\t\t    get keySchema() {\n\t\t        return this._def.keyType;\n\t\t    }\n\t\t    get valueSchema() {\n\t\t        return this._def.valueType;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.map) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.map,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const keyType = this._def.keyType;\n\t\t        const valueType = this._def.valueType;\n\t\t        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n\t\t            return {\n\t\t                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n\t\t                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n\t\t            };\n\t\t        });\n\t\t        if (ctx.common.async) {\n\t\t            const finalMap = new Map();\n\t\t            return Promise.resolve().then(async () => {\n\t\t                for (const pair of pairs) {\n\t\t                    const key = await pair.key;\n\t\t                    const value = await pair.value;\n\t\t                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n\t\t                        return parseUtil_1.INVALID;\n\t\t                    }\n\t\t                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n\t\t                        status.dirty();\n\t\t                    }\n\t\t                    finalMap.set(key.value, value.value);\n\t\t                }\n\t\t                return { status: status.value, value: finalMap };\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            const finalMap = new Map();\n\t\t            for (const pair of pairs) {\n\t\t                const key = pair.key;\n\t\t                const value = pair.value;\n\t\t                if (key.status === \"aborted\" || value.status === \"aborted\") {\n\t\t                    return parseUtil_1.INVALID;\n\t\t                }\n\t\t                if (key.status === \"dirty\" || value.status === \"dirty\") {\n\t\t                    status.dirty();\n\t\t                }\n\t\t                finalMap.set(key.value, value.value);\n\t\t            }\n\t\t            return { status: status.value, value: finalMap };\n\t\t        }\n\t\t    }\n\t\t}\n\t\texports.ZodMap = ZodMap;\n\t\tZodMap.create = (keyType, valueType, params) => {\n\t\t    return new ZodMap({\n\t\t        valueType,\n\t\t        keyType,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodMap,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodSet extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.set) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.set,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const def = this._def;\n\t\t        if (def.minSize !== null) {\n\t\t            if (ctx.data.size < def.minSize.value) {\n\t\t                (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                    code: ZodError_1.ZodIssueCode.too_small,\n\t\t                    minimum: def.minSize.value,\n\t\t                    type: \"set\",\n\t\t                    inclusive: true,\n\t\t                    exact: false,\n\t\t                    message: def.minSize.message,\n\t\t                });\n\t\t                status.dirty();\n\t\t            }\n\t\t        }\n\t\t        if (def.maxSize !== null) {\n\t\t            if (ctx.data.size > def.maxSize.value) {\n\t\t                (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                    code: ZodError_1.ZodIssueCode.too_big,\n\t\t                    maximum: def.maxSize.value,\n\t\t                    type: \"set\",\n\t\t                    inclusive: true,\n\t\t                    exact: false,\n\t\t                    message: def.maxSize.message,\n\t\t                });\n\t\t                status.dirty();\n\t\t            }\n\t\t        }\n\t\t        const valueType = this._def.valueType;\n\t\t        function finalizeSet(elements) {\n\t\t            const parsedSet = new Set();\n\t\t            for (const element of elements) {\n\t\t                if (element.status === \"aborted\")\n\t\t                    return parseUtil_1.INVALID;\n\t\t                if (element.status === \"dirty\")\n\t\t                    status.dirty();\n\t\t                parsedSet.add(element.value);\n\t\t            }\n\t\t            return { status: status.value, value: parsedSet };\n\t\t        }\n\t\t        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n\t\t        if (ctx.common.async) {\n\t\t            return Promise.all(elements).then((elements) => finalizeSet(elements));\n\t\t        }\n\t\t        else {\n\t\t            return finalizeSet(elements);\n\t\t        }\n\t\t    }\n\t\t    min(minSize, message) {\n\t\t        return new ZodSet({\n\t\t            ...this._def,\n\t\t            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },\n\t\t        });\n\t\t    }\n\t\t    max(maxSize, message) {\n\t\t        return new ZodSet({\n\t\t            ...this._def,\n\t\t            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },\n\t\t        });\n\t\t    }\n\t\t    size(size, message) {\n\t\t        return this.min(size, message).max(size, message);\n\t\t    }\n\t\t    nonempty(message) {\n\t\t        return this.min(1, message);\n\t\t    }\n\t\t}\n\t\texports.ZodSet = ZodSet;\n\t\tZodSet.create = (valueType, params) => {\n\t\t    return new ZodSet({\n\t\t        valueType,\n\t\t        minSize: null,\n\t\t        maxSize: null,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodSet,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodFunction extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        this.validate = this.implement;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.function) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.function,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        function makeArgsIssue(args, error) {\n\t\t            return (0, parseUtil_1.makeIssue)({\n\t\t                data: args,\n\t\t                path: ctx.path,\n\t\t                errorMaps: [\n\t\t                    ctx.common.contextualErrorMap,\n\t\t                    ctx.schemaErrorMap,\n\t\t                    (0, errors_1.getErrorMap)(),\n\t\t                    errors_1.defaultErrorMap,\n\t\t                ].filter((x) => !!x),\n\t\t                issueData: {\n\t\t                    code: ZodError_1.ZodIssueCode.invalid_arguments,\n\t\t                    argumentsError: error,\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t        function makeReturnsIssue(returns, error) {\n\t\t            return (0, parseUtil_1.makeIssue)({\n\t\t                data: returns,\n\t\t                path: ctx.path,\n\t\t                errorMaps: [\n\t\t                    ctx.common.contextualErrorMap,\n\t\t                    ctx.schemaErrorMap,\n\t\t                    (0, errors_1.getErrorMap)(),\n\t\t                    errors_1.defaultErrorMap,\n\t\t                ].filter((x) => !!x),\n\t\t                issueData: {\n\t\t                    code: ZodError_1.ZodIssueCode.invalid_return_type,\n\t\t                    returnTypeError: error,\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t        const params = { errorMap: ctx.common.contextualErrorMap };\n\t\t        const fn = ctx.data;\n\t\t        if (this._def.returns instanceof ZodPromise) {\n\t\t            // Would love a way to avoid disabling this rule, but we need\n\t\t            // an alias (using an arrow function was what caused 2651).\n\t\t            // eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t            const me = this;\n\t\t            return (0, parseUtil_1.OK)(async function (...args) {\n\t\t                const error = new ZodError_1.ZodError([]);\n\t\t                const parsedArgs = await me._def.args\n\t\t                    .parseAsync(args, params)\n\t\t                    .catch((e) => {\n\t\t                    error.addIssue(makeArgsIssue(args, e));\n\t\t                    throw error;\n\t\t                });\n\t\t                const result = await Reflect.apply(fn, this, parsedArgs);\n\t\t                const parsedReturns = await me._def.returns._def.type\n\t\t                    .parseAsync(result, params)\n\t\t                    .catch((e) => {\n\t\t                    error.addIssue(makeReturnsIssue(result, e));\n\t\t                    throw error;\n\t\t                });\n\t\t                return parsedReturns;\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            // Would love a way to avoid disabling this rule, but we need\n\t\t            // an alias (using an arrow function was what caused 2651).\n\t\t            // eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t            const me = this;\n\t\t            return (0, parseUtil_1.OK)(function (...args) {\n\t\t                const parsedArgs = me._def.args.safeParse(args, params);\n\t\t                if (!parsedArgs.success) {\n\t\t                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);\n\t\t                }\n\t\t                const result = Reflect.apply(fn, this, parsedArgs.data);\n\t\t                const parsedReturns = me._def.returns.safeParse(result, params);\n\t\t                if (!parsedReturns.success) {\n\t\t                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n\t\t                }\n\t\t                return parsedReturns.data;\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    parameters() {\n\t\t        return this._def.args;\n\t\t    }\n\t\t    returnType() {\n\t\t        return this._def.returns;\n\t\t    }\n\t\t    args(...items) {\n\t\t        return new ZodFunction({\n\t\t            ...this._def,\n\t\t            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n\t\t        });\n\t\t    }\n\t\t    returns(returnType) {\n\t\t        return new ZodFunction({\n\t\t            ...this._def,\n\t\t            returns: returnType,\n\t\t        });\n\t\t    }\n\t\t    implement(func) {\n\t\t        const validatedFunc = this.parse(func);\n\t\t        return validatedFunc;\n\t\t    }\n\t\t    strictImplement(func) {\n\t\t        const validatedFunc = this.parse(func);\n\t\t        return validatedFunc;\n\t\t    }\n\t\t    static create(args, returns, params) {\n\t\t        return new ZodFunction({\n\t\t            args: (args\n\t\t                ? args\n\t\t                : ZodTuple.create([]).rest(ZodUnknown.create())),\n\t\t            returns: returns || ZodUnknown.create(),\n\t\t            typeName: ZodFirstPartyTypeKind.ZodFunction,\n\t\t            ...processCreateParams(params),\n\t\t        });\n\t\t    }\n\t\t}\n\t\texports.ZodFunction = ZodFunction;\n\t\tclass ZodLazy extends ZodType {\n\t\t    get schema() {\n\t\t        return this._def.getter();\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        const lazySchema = this._def.getter();\n\t\t        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n\t\t    }\n\t\t}\n\t\texports.ZodLazy = ZodLazy;\n\t\tZodLazy.create = (getter, params) => {\n\t\t    return new ZodLazy({\n\t\t        getter: getter,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodLazy,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodLiteral extends ZodType {\n\t\t    _parse(input) {\n\t\t        if (input.data !== this._def.value) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                received: ctx.data,\n\t\t                code: ZodError_1.ZodIssueCode.invalid_literal,\n\t\t                expected: this._def.value,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return { status: \"valid\", value: input.data };\n\t\t    }\n\t\t    get value() {\n\t\t        return this._def.value;\n\t\t    }\n\t\t}\n\t\texports.ZodLiteral = ZodLiteral;\n\t\tZodLiteral.create = (value, params) => {\n\t\t    return new ZodLiteral({\n\t\t        value: value,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tfunction createZodEnum(values, params) {\n\t\t    return new ZodEnum({\n\t\t        values,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodEnum,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t}\n\t\tclass ZodEnum extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        _ZodEnum_cache.set(this, void 0);\n\t\t    }\n\t\t    _parse(input) {\n\t\t        if (typeof input.data !== \"string\") {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            const expectedValues = this._def.values;\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                expected: util_1.util.joinValues(expectedValues),\n\t\t                received: ctx.parsedType,\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n\t\t            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n\t\t        }\n\t\t        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            const expectedValues = this._def.values;\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                received: ctx.data,\n\t\t                code: ZodError_1.ZodIssueCode.invalid_enum_value,\n\t\t                options: expectedValues,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t    get options() {\n\t\t        return this._def.values;\n\t\t    }\n\t\t    get enum() {\n\t\t        const enumValues = {};\n\t\t        for (const val of this._def.values) {\n\t\t            enumValues[val] = val;\n\t\t        }\n\t\t        return enumValues;\n\t\t    }\n\t\t    get Values() {\n\t\t        const enumValues = {};\n\t\t        for (const val of this._def.values) {\n\t\t            enumValues[val] = val;\n\t\t        }\n\t\t        return enumValues;\n\t\t    }\n\t\t    get Enum() {\n\t\t        const enumValues = {};\n\t\t        for (const val of this._def.values) {\n\t\t            enumValues[val] = val;\n\t\t        }\n\t\t        return enumValues;\n\t\t    }\n\t\t    extract(values, newDef = this._def) {\n\t\t        return ZodEnum.create(values, {\n\t\t            ...this._def,\n\t\t            ...newDef,\n\t\t        });\n\t\t    }\n\t\t    exclude(values, newDef = this._def) {\n\t\t        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n\t\t            ...this._def,\n\t\t            ...newDef,\n\t\t        });\n\t\t    }\n\t\t}\n\t\texports.ZodEnum = ZodEnum;\n\t\t_ZodEnum_cache = new WeakMap();\n\t\tZodEnum.create = createZodEnum;\n\t\tclass ZodNativeEnum extends ZodType {\n\t\t    constructor() {\n\t\t        super(...arguments);\n\t\t        _ZodNativeEnum_cache.set(this, void 0);\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);\n\t\t        const ctx = this._getOrReturnCtx(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.string &&\n\t\t            ctx.parsedType !== util_1.ZodParsedType.number) {\n\t\t            const expectedValues = util_1.util.objectValues(nativeEnumValues);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                expected: util_1.util.joinValues(expectedValues),\n\t\t                received: ctx.parsedType,\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n\t\t            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util_1.util.getValidEnumValues(this._def.values)), \"f\");\n\t\t        }\n\t\t        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n\t\t            const expectedValues = util_1.util.objectValues(nativeEnumValues);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                received: ctx.data,\n\t\t                code: ZodError_1.ZodIssueCode.invalid_enum_value,\n\t\t                options: expectedValues,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return (0, parseUtil_1.OK)(input.data);\n\t\t    }\n\t\t    get enum() {\n\t\t        return this._def.values;\n\t\t    }\n\t\t}\n\t\texports.ZodNativeEnum = ZodNativeEnum;\n\t\t_ZodNativeEnum_cache = new WeakMap();\n\t\tZodNativeEnum.create = (values, params) => {\n\t\t    return new ZodNativeEnum({\n\t\t        values: values,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodPromise extends ZodType {\n\t\t    unwrap() {\n\t\t        return this._def.type;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        if (ctx.parsedType !== util_1.ZodParsedType.promise &&\n\t\t            ctx.common.async === false) {\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.promise,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        const promisified = ctx.parsedType === util_1.ZodParsedType.promise\n\t\t            ? ctx.data\n\t\t            : Promise.resolve(ctx.data);\n\t\t        return (0, parseUtil_1.OK)(promisified.then((data) => {\n\t\t            return this._def.type.parseAsync(data, {\n\t\t                path: ctx.path,\n\t\t                errorMap: ctx.common.contextualErrorMap,\n\t\t            });\n\t\t        }));\n\t\t    }\n\t\t}\n\t\texports.ZodPromise = ZodPromise;\n\t\tZodPromise.create = (schema, params) => {\n\t\t    return new ZodPromise({\n\t\t        type: schema,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodPromise,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodEffects extends ZodType {\n\t\t    innerType() {\n\t\t        return this._def.schema;\n\t\t    }\n\t\t    sourceType() {\n\t\t        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n\t\t            ? this._def.schema.sourceType()\n\t\t            : this._def.schema;\n\t\t    }\n\t\t    _parse(input) {\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        const effect = this._def.effect || null;\n\t\t        const checkCtx = {\n\t\t            addIssue: (arg) => {\n\t\t                (0, parseUtil_1.addIssueToContext)(ctx, arg);\n\t\t                if (arg.fatal) {\n\t\t                    status.abort();\n\t\t                }\n\t\t                else {\n\t\t                    status.dirty();\n\t\t                }\n\t\t            },\n\t\t            get path() {\n\t\t                return ctx.path;\n\t\t            },\n\t\t        };\n\t\t        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n\t\t        if (effect.type === \"preprocess\") {\n\t\t            const processed = effect.transform(ctx.data, checkCtx);\n\t\t            if (ctx.common.async) {\n\t\t                return Promise.resolve(processed).then(async (processed) => {\n\t\t                    if (status.value === \"aborted\")\n\t\t                        return parseUtil_1.INVALID;\n\t\t                    const result = await this._def.schema._parseAsync({\n\t\t                        data: processed,\n\t\t                        path: ctx.path,\n\t\t                        parent: ctx,\n\t\t                    });\n\t\t                    if (result.status === \"aborted\")\n\t\t                        return parseUtil_1.INVALID;\n\t\t                    if (result.status === \"dirty\")\n\t\t                        return (0, parseUtil_1.DIRTY)(result.value);\n\t\t                    if (status.value === \"dirty\")\n\t\t                        return (0, parseUtil_1.DIRTY)(result.value);\n\t\t                    return result;\n\t\t                });\n\t\t            }\n\t\t            else {\n\t\t                if (status.value === \"aborted\")\n\t\t                    return parseUtil_1.INVALID;\n\t\t                const result = this._def.schema._parseSync({\n\t\t                    data: processed,\n\t\t                    path: ctx.path,\n\t\t                    parent: ctx,\n\t\t                });\n\t\t                if (result.status === \"aborted\")\n\t\t                    return parseUtil_1.INVALID;\n\t\t                if (result.status === \"dirty\")\n\t\t                    return (0, parseUtil_1.DIRTY)(result.value);\n\t\t                if (status.value === \"dirty\")\n\t\t                    return (0, parseUtil_1.DIRTY)(result.value);\n\t\t                return result;\n\t\t            }\n\t\t        }\n\t\t        if (effect.type === \"refinement\") {\n\t\t            const executeRefinement = (acc) => {\n\t\t                const result = effect.refinement(acc, checkCtx);\n\t\t                if (ctx.common.async) {\n\t\t                    return Promise.resolve(result);\n\t\t                }\n\t\t                if (result instanceof Promise) {\n\t\t                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n\t\t                }\n\t\t                return acc;\n\t\t            };\n\t\t            if (ctx.common.async === false) {\n\t\t                const inner = this._def.schema._parseSync({\n\t\t                    data: ctx.data,\n\t\t                    path: ctx.path,\n\t\t                    parent: ctx,\n\t\t                });\n\t\t                if (inner.status === \"aborted\")\n\t\t                    return parseUtil_1.INVALID;\n\t\t                if (inner.status === \"dirty\")\n\t\t                    status.dirty();\n\t\t                // return value is ignored\n\t\t                executeRefinement(inner.value);\n\t\t                return { status: status.value, value: inner.value };\n\t\t            }\n\t\t            else {\n\t\t                return this._def.schema\n\t\t                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n\t\t                    .then((inner) => {\n\t\t                    if (inner.status === \"aborted\")\n\t\t                        return parseUtil_1.INVALID;\n\t\t                    if (inner.status === \"dirty\")\n\t\t                        status.dirty();\n\t\t                    return executeRefinement(inner.value).then(() => {\n\t\t                        return { status: status.value, value: inner.value };\n\t\t                    });\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t        if (effect.type === \"transform\") {\n\t\t            if (ctx.common.async === false) {\n\t\t                const base = this._def.schema._parseSync({\n\t\t                    data: ctx.data,\n\t\t                    path: ctx.path,\n\t\t                    parent: ctx,\n\t\t                });\n\t\t                if (!(0, parseUtil_1.isValid)(base))\n\t\t                    return base;\n\t\t                const result = effect.transform(base.value, checkCtx);\n\t\t                if (result instanceof Promise) {\n\t\t                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n\t\t                }\n\t\t                return { status: status.value, value: result };\n\t\t            }\n\t\t            else {\n\t\t                return this._def.schema\n\t\t                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n\t\t                    .then((base) => {\n\t\t                    if (!(0, parseUtil_1.isValid)(base))\n\t\t                        return base;\n\t\t                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t        util_1.util.assertNever(effect);\n\t\t    }\n\t\t}\n\t\texports.ZodEffects = ZodEffects;\n\t\texports.ZodTransformer = ZodEffects;\n\t\tZodEffects.create = (schema, effect, params) => {\n\t\t    return new ZodEffects({\n\t\t        schema,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodEffects,\n\t\t        effect,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n\t\t    return new ZodEffects({\n\t\t        schema,\n\t\t        effect: { type: \"preprocess\", transform: preprocess },\n\t\t        typeName: ZodFirstPartyTypeKind.ZodEffects,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodOptional extends ZodType {\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType === util_1.ZodParsedType.undefined) {\n\t\t            return (0, parseUtil_1.OK)(undefined);\n\t\t        }\n\t\t        return this._def.innerType._parse(input);\n\t\t    }\n\t\t    unwrap() {\n\t\t        return this._def.innerType;\n\t\t    }\n\t\t}\n\t\texports.ZodOptional = ZodOptional;\n\t\tZodOptional.create = (type, params) => {\n\t\t    return new ZodOptional({\n\t\t        innerType: type,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodOptional,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodNullable extends ZodType {\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType === util_1.ZodParsedType.null) {\n\t\t            return (0, parseUtil_1.OK)(null);\n\t\t        }\n\t\t        return this._def.innerType._parse(input);\n\t\t    }\n\t\t    unwrap() {\n\t\t        return this._def.innerType;\n\t\t    }\n\t\t}\n\t\texports.ZodNullable = ZodNullable;\n\t\tZodNullable.create = (type, params) => {\n\t\t    return new ZodNullable({\n\t\t        innerType: type,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodNullable,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodDefault extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        let data = ctx.data;\n\t\t        if (ctx.parsedType === util_1.ZodParsedType.undefined) {\n\t\t            data = this._def.defaultValue();\n\t\t        }\n\t\t        return this._def.innerType._parse({\n\t\t            data,\n\t\t            path: ctx.path,\n\t\t            parent: ctx,\n\t\t        });\n\t\t    }\n\t\t    removeDefault() {\n\t\t        return this._def.innerType;\n\t\t    }\n\t\t}\n\t\texports.ZodDefault = ZodDefault;\n\t\tZodDefault.create = (type, params) => {\n\t\t    return new ZodDefault({\n\t\t        innerType: type,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodDefault,\n\t\t        defaultValue: typeof params.default === \"function\"\n\t\t            ? params.default\n\t\t            : () => params.default,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodCatch extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        // newCtx is used to not collect issues from inner types in ctx\n\t\t        const newCtx = {\n\t\t            ...ctx,\n\t\t            common: {\n\t\t                ...ctx.common,\n\t\t                issues: [],\n\t\t            },\n\t\t        };\n\t\t        const result = this._def.innerType._parse({\n\t\t            data: newCtx.data,\n\t\t            path: newCtx.path,\n\t\t            parent: {\n\t\t                ...newCtx,\n\t\t            },\n\t\t        });\n\t\t        if ((0, parseUtil_1.isAsync)(result)) {\n\t\t            return result.then((result) => {\n\t\t                return {\n\t\t                    status: \"valid\",\n\t\t                    value: result.status === \"valid\"\n\t\t                        ? result.value\n\t\t                        : this._def.catchValue({\n\t\t                            get error() {\n\t\t                                return new ZodError_1.ZodError(newCtx.common.issues);\n\t\t                            },\n\t\t                            input: newCtx.data,\n\t\t                        }),\n\t\t                };\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            return {\n\t\t                status: \"valid\",\n\t\t                value: result.status === \"valid\"\n\t\t                    ? result.value\n\t\t                    : this._def.catchValue({\n\t\t                        get error() {\n\t\t                            return new ZodError_1.ZodError(newCtx.common.issues);\n\t\t                        },\n\t\t                        input: newCtx.data,\n\t\t                    }),\n\t\t            };\n\t\t        }\n\t\t    }\n\t\t    removeCatch() {\n\t\t        return this._def.innerType;\n\t\t    }\n\t\t}\n\t\texports.ZodCatch = ZodCatch;\n\t\tZodCatch.create = (type, params) => {\n\t\t    return new ZodCatch({\n\t\t        innerType: type,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodCatch,\n\t\t        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tclass ZodNaN extends ZodType {\n\t\t    _parse(input) {\n\t\t        const parsedType = this._getType(input);\n\t\t        if (parsedType !== util_1.ZodParsedType.nan) {\n\t\t            const ctx = this._getOrReturnCtx(input);\n\t\t            (0, parseUtil_1.addIssueToContext)(ctx, {\n\t\t                code: ZodError_1.ZodIssueCode.invalid_type,\n\t\t                expected: util_1.ZodParsedType.nan,\n\t\t                received: ctx.parsedType,\n\t\t            });\n\t\t            return parseUtil_1.INVALID;\n\t\t        }\n\t\t        return { status: \"valid\", value: input.data };\n\t\t    }\n\t\t}\n\t\texports.ZodNaN = ZodNaN;\n\t\tZodNaN.create = (params) => {\n\t\t    return new ZodNaN({\n\t\t        typeName: ZodFirstPartyTypeKind.ZodNaN,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\texports.BRAND = Symbol(\"zod_brand\");\n\t\tclass ZodBranded extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { ctx } = this._processInputParams(input);\n\t\t        const data = ctx.data;\n\t\t        return this._def.type._parse({\n\t\t            data,\n\t\t            path: ctx.path,\n\t\t            parent: ctx,\n\t\t        });\n\t\t    }\n\t\t    unwrap() {\n\t\t        return this._def.type;\n\t\t    }\n\t\t}\n\t\texports.ZodBranded = ZodBranded;\n\t\tclass ZodPipeline extends ZodType {\n\t\t    _parse(input) {\n\t\t        const { status, ctx } = this._processInputParams(input);\n\t\t        if (ctx.common.async) {\n\t\t            const handleAsync = async () => {\n\t\t                const inResult = await this._def.in._parseAsync({\n\t\t                    data: ctx.data,\n\t\t                    path: ctx.path,\n\t\t                    parent: ctx,\n\t\t                });\n\t\t                if (inResult.status === \"aborted\")\n\t\t                    return parseUtil_1.INVALID;\n\t\t                if (inResult.status === \"dirty\") {\n\t\t                    status.dirty();\n\t\t                    return (0, parseUtil_1.DIRTY)(inResult.value);\n\t\t                }\n\t\t                else {\n\t\t                    return this._def.out._parseAsync({\n\t\t                        data: inResult.value,\n\t\t                        path: ctx.path,\n\t\t                        parent: ctx,\n\t\t                    });\n\t\t                }\n\t\t            };\n\t\t            return handleAsync();\n\t\t        }\n\t\t        else {\n\t\t            const inResult = this._def.in._parseSync({\n\t\t                data: ctx.data,\n\t\t                path: ctx.path,\n\t\t                parent: ctx,\n\t\t            });\n\t\t            if (inResult.status === \"aborted\")\n\t\t                return parseUtil_1.INVALID;\n\t\t            if (inResult.status === \"dirty\") {\n\t\t                status.dirty();\n\t\t                return {\n\t\t                    status: \"dirty\",\n\t\t                    value: inResult.value,\n\t\t                };\n\t\t            }\n\t\t            else {\n\t\t                return this._def.out._parseSync({\n\t\t                    data: inResult.value,\n\t\t                    path: ctx.path,\n\t\t                    parent: ctx,\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    static create(a, b) {\n\t\t        return new ZodPipeline({\n\t\t            in: a,\n\t\t            out: b,\n\t\t            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n\t\t        });\n\t\t    }\n\t\t}\n\t\texports.ZodPipeline = ZodPipeline;\n\t\tclass ZodReadonly extends ZodType {\n\t\t    _parse(input) {\n\t\t        const result = this._def.innerType._parse(input);\n\t\t        const freeze = (data) => {\n\t\t            if ((0, parseUtil_1.isValid)(data)) {\n\t\t                data.value = Object.freeze(data.value);\n\t\t            }\n\t\t            return data;\n\t\t        };\n\t\t        return (0, parseUtil_1.isAsync)(result)\n\t\t            ? result.then((data) => freeze(data))\n\t\t            : freeze(result);\n\t\t    }\n\t\t    unwrap() {\n\t\t        return this._def.innerType;\n\t\t    }\n\t\t}\n\t\texports.ZodReadonly = ZodReadonly;\n\t\tZodReadonly.create = (type, params) => {\n\t\t    return new ZodReadonly({\n\t\t        innerType: type,\n\t\t        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n\t\t        ...processCreateParams(params),\n\t\t    });\n\t\t};\n\t\tfunction custom(check, params = {}, \n\t\t/**\n\t\t * @deprecated\n\t\t *\n\t\t * Pass `fatal` into the params object instead:\n\t\t *\n\t\t * ```ts\n\t\t * z.string().custom((val) => val.length > 5, { fatal: false })\n\t\t * ```\n\t\t *\n\t\t */\n\t\tfatal) {\n\t\t    if (check)\n\t\t        return ZodAny.create().superRefine((data, ctx) => {\n\t\t            var _a, _b;\n\t\t            if (!check(data)) {\n\t\t                const p = typeof params === \"function\"\n\t\t                    ? params(data)\n\t\t                    : typeof params === \"string\"\n\t\t                        ? { message: params }\n\t\t                        : params;\n\t\t                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n\t\t                const p2 = typeof p === \"string\" ? { message: p } : p;\n\t\t                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n\t\t            }\n\t\t        });\n\t\t    return ZodAny.create();\n\t\t}\n\t\texports.custom = custom;\n\t\texports.late = {\n\t\t    object: ZodObject.lazycreate,\n\t\t};\n\t\tvar ZodFirstPartyTypeKind;\n\t\t(function (ZodFirstPartyTypeKind) {\n\t\t    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n\t\t    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n\t\t    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n\t\t    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n\t\t    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n\t\t    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n\t\t    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n\t\t    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n\t\t    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n\t\t    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n\t\t    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n\t\t    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n\t\t    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n\t\t    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n\t\t    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n\t\t    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n\t\t    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n\t\t    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n\t\t    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n\t\t    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n\t\t    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n\t\t    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n\t\t    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n\t\t    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n\t\t    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n\t\t    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n\t\t    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n\t\t    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n\t\t    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n\t\t    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n\t\t    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n\t\t    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n\t\t    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n\t\t    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n\t\t    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n\t\t    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n\t\t})(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));\n\t\tconst instanceOfType = (\n\t\t// const instanceOfType = <T extends new (...args: any[]) => any>(\n\t\tcls, params = {\n\t\t    message: `Input not instance of ${cls.name}`,\n\t\t}) => custom((data) => data instanceof cls, params);\n\t\texports.instanceof = instanceOfType;\n\t\tconst stringType = ZodString.create;\n\t\texports.string = stringType;\n\t\tconst numberType = ZodNumber.create;\n\t\texports.number = numberType;\n\t\tconst nanType = ZodNaN.create;\n\t\texports.nan = nanType;\n\t\tconst bigIntType = ZodBigInt.create;\n\t\texports.bigint = bigIntType;\n\t\tconst booleanType = ZodBoolean.create;\n\t\texports.boolean = booleanType;\n\t\tconst dateType = ZodDate.create;\n\t\texports.date = dateType;\n\t\tconst symbolType = ZodSymbol.create;\n\t\texports.symbol = symbolType;\n\t\tconst undefinedType = ZodUndefined.create;\n\t\texports.undefined = undefinedType;\n\t\tconst nullType = ZodNull.create;\n\t\texports.null = nullType;\n\t\tconst anyType = ZodAny.create;\n\t\texports.any = anyType;\n\t\tconst unknownType = ZodUnknown.create;\n\t\texports.unknown = unknownType;\n\t\tconst neverType = ZodNever.create;\n\t\texports.never = neverType;\n\t\tconst voidType = ZodVoid.create;\n\t\texports.void = voidType;\n\t\tconst arrayType = ZodArray.create;\n\t\texports.array = arrayType;\n\t\tconst objectType = ZodObject.create;\n\t\texports.object = objectType;\n\t\tconst strictObjectType = ZodObject.strictCreate;\n\t\texports.strictObject = strictObjectType;\n\t\tconst unionType = ZodUnion.create;\n\t\texports.union = unionType;\n\t\tconst discriminatedUnionType = ZodDiscriminatedUnion.create;\n\t\texports.discriminatedUnion = discriminatedUnionType;\n\t\tconst intersectionType = ZodIntersection.create;\n\t\texports.intersection = intersectionType;\n\t\tconst tupleType = ZodTuple.create;\n\t\texports.tuple = tupleType;\n\t\tconst recordType = ZodRecord.create;\n\t\texports.record = recordType;\n\t\tconst mapType = ZodMap.create;\n\t\texports.map = mapType;\n\t\tconst setType = ZodSet.create;\n\t\texports.set = setType;\n\t\tconst functionType = ZodFunction.create;\n\t\texports.function = functionType;\n\t\tconst lazyType = ZodLazy.create;\n\t\texports.lazy = lazyType;\n\t\tconst literalType = ZodLiteral.create;\n\t\texports.literal = literalType;\n\t\tconst enumType = ZodEnum.create;\n\t\texports.enum = enumType;\n\t\tconst nativeEnumType = ZodNativeEnum.create;\n\t\texports.nativeEnum = nativeEnumType;\n\t\tconst promiseType = ZodPromise.create;\n\t\texports.promise = promiseType;\n\t\tconst effectsType = ZodEffects.create;\n\t\texports.effect = effectsType;\n\t\texports.transformer = effectsType;\n\t\tconst optionalType = ZodOptional.create;\n\t\texports.optional = optionalType;\n\t\tconst nullableType = ZodNullable.create;\n\t\texports.nullable = nullableType;\n\t\tconst preprocessType = ZodEffects.createWithPreprocess;\n\t\texports.preprocess = preprocessType;\n\t\tconst pipelineType = ZodPipeline.create;\n\t\texports.pipeline = pipelineType;\n\t\tconst ostring = () => stringType().optional();\n\t\texports.ostring = ostring;\n\t\tconst onumber = () => numberType().optional();\n\t\texports.onumber = onumber;\n\t\tconst oboolean = () => booleanType().optional();\n\t\texports.oboolean = oboolean;\n\t\texports.coerce = {\n\t\t    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n\t\t    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n\t\t    boolean: ((arg) => ZodBoolean.create({\n\t\t        ...arg,\n\t\t        coerce: true,\n\t\t    })),\n\t\t    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n\t\t    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n\t\t};\n\t\texports.NEVER = parseUtil_1.INVALID; \n\t} (types));\n\n\t(function (exports) {\n\t\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {\n\t\t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\t__exportStar(errors, exports);\n\t\t__exportStar(parseUtil, exports);\n\t\t__exportStar(typeAliases, exports);\n\t\t__exportStar(util, exports);\n\t\t__exportStar(types, exports);\n\t\t__exportStar(ZodError$1, exports); \n\t} (external));\n\n\t(function (exports) {\n\t\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t\t}) : function(o, v) {\n\t\t    o[\"default\"] = v;\n\t\t});\n\t\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t\t    if (mod && mod.__esModule) return mod;\n\t\t    var result = {};\n\t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t\t    __setModuleDefault(result, mod);\n\t\t    return result;\n\t\t};\n\t\tvar __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {\n\t\t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.z = void 0;\n\t\tconst z = __importStar(external);\n\t\texports.z = z;\n\t\t__exportStar(external, exports);\n\t\texports.default = z; \n\t} (lib));\n\n\tvar pRetry$1 = {exports: {}};\n\n\tvar retry$2 = {};\n\n\tfunction RetryOperation(timeouts, options) {\n\t  // Compatibility for the old (timeouts, retryForever) signature\n\t  if (typeof options === 'boolean') {\n\t    options = { forever: options };\n\t  }\n\n\t  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n\t  this._timeouts = timeouts;\n\t  this._options = options || {};\n\t  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n\t  this._fn = null;\n\t  this._errors = [];\n\t  this._attempts = 1;\n\t  this._operationTimeout = null;\n\t  this._operationTimeoutCb = null;\n\t  this._timeout = null;\n\t  this._operationStart = null;\n\t  this._timer = null;\n\n\t  if (this._options.forever) {\n\t    this._cachedTimeouts = this._timeouts.slice(0);\n\t  }\n\t}\n\tvar retry_operation = RetryOperation;\n\n\tRetryOperation.prototype.reset = function() {\n\t  this._attempts = 1;\n\t  this._timeouts = this._originalTimeouts.slice(0);\n\t};\n\n\tRetryOperation.prototype.stop = function() {\n\t  if (this._timeout) {\n\t    clearTimeout(this._timeout);\n\t  }\n\t  if (this._timer) {\n\t    clearTimeout(this._timer);\n\t  }\n\n\t  this._timeouts       = [];\n\t  this._cachedTimeouts = null;\n\t};\n\n\tRetryOperation.prototype.retry = function(err) {\n\t  if (this._timeout) {\n\t    clearTimeout(this._timeout);\n\t  }\n\n\t  if (!err) {\n\t    return false;\n\t  }\n\t  var currentTime = new Date().getTime();\n\t  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n\t    this._errors.push(err);\n\t    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n\t    return false;\n\t  }\n\n\t  this._errors.push(err);\n\n\t  var timeout = this._timeouts.shift();\n\t  if (timeout === undefined) {\n\t    if (this._cachedTimeouts) {\n\t      // retry forever, only keep last error\n\t      this._errors.splice(0, this._errors.length - 1);\n\t      timeout = this._cachedTimeouts.slice(-1);\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\n\t  var self = this;\n\t  this._timer = setTimeout(function() {\n\t    self._attempts++;\n\n\t    if (self._operationTimeoutCb) {\n\t      self._timeout = setTimeout(function() {\n\t        self._operationTimeoutCb(self._attempts);\n\t      }, self._operationTimeout);\n\n\t      if (self._options.unref) {\n\t          self._timeout.unref();\n\t      }\n\t    }\n\n\t    self._fn(self._attempts);\n\t  }, timeout);\n\n\t  if (this._options.unref) {\n\t      this._timer.unref();\n\t  }\n\n\t  return true;\n\t};\n\n\tRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n\t  this._fn = fn;\n\n\t  if (timeoutOps) {\n\t    if (timeoutOps.timeout) {\n\t      this._operationTimeout = timeoutOps.timeout;\n\t    }\n\t    if (timeoutOps.cb) {\n\t      this._operationTimeoutCb = timeoutOps.cb;\n\t    }\n\t  }\n\n\t  var self = this;\n\t  if (this._operationTimeoutCb) {\n\t    this._timeout = setTimeout(function() {\n\t      self._operationTimeoutCb();\n\t    }, self._operationTimeout);\n\t  }\n\n\t  this._operationStart = new Date().getTime();\n\n\t  this._fn(this._attempts);\n\t};\n\n\tRetryOperation.prototype.try = function(fn) {\n\t  console.log('Using RetryOperation.try() is deprecated');\n\t  this.attempt(fn);\n\t};\n\n\tRetryOperation.prototype.start = function(fn) {\n\t  console.log('Using RetryOperation.start() is deprecated');\n\t  this.attempt(fn);\n\t};\n\n\tRetryOperation.prototype.start = RetryOperation.prototype.try;\n\n\tRetryOperation.prototype.errors = function() {\n\t  return this._errors;\n\t};\n\n\tRetryOperation.prototype.attempts = function() {\n\t  return this._attempts;\n\t};\n\n\tRetryOperation.prototype.mainError = function() {\n\t  if (this._errors.length === 0) {\n\t    return null;\n\t  }\n\n\t  var counts = {};\n\t  var mainError = null;\n\t  var mainErrorCount = 0;\n\n\t  for (var i = 0; i < this._errors.length; i++) {\n\t    var error = this._errors[i];\n\t    var message = error.message;\n\t    var count = (counts[message] || 0) + 1;\n\n\t    counts[message] = count;\n\n\t    if (count >= mainErrorCount) {\n\t      mainError = error;\n\t      mainErrorCount = count;\n\t    }\n\t  }\n\n\t  return mainError;\n\t};\n\n\t(function (exports) {\n\t\tvar RetryOperation = retry_operation;\n\n\t\texports.operation = function(options) {\n\t\t  var timeouts = exports.timeouts(options);\n\t\t  return new RetryOperation(timeouts, {\n\t\t      forever: options && (options.forever || options.retries === Infinity),\n\t\t      unref: options && options.unref,\n\t\t      maxRetryTime: options && options.maxRetryTime\n\t\t  });\n\t\t};\n\n\t\texports.timeouts = function(options) {\n\t\t  if (options instanceof Array) {\n\t\t    return [].concat(options);\n\t\t  }\n\n\t\t  var opts = {\n\t\t    retries: 10,\n\t\t    factor: 2,\n\t\t    minTimeout: 1 * 1000,\n\t\t    maxTimeout: Infinity,\n\t\t    randomize: false\n\t\t  };\n\t\t  for (var key in options) {\n\t\t    opts[key] = options[key];\n\t\t  }\n\n\t\t  if (opts.minTimeout > opts.maxTimeout) {\n\t\t    throw new Error('minTimeout is greater than maxTimeout');\n\t\t  }\n\n\t\t  var timeouts = [];\n\t\t  for (var i = 0; i < opts.retries; i++) {\n\t\t    timeouts.push(this.createTimeout(i, opts));\n\t\t  }\n\n\t\t  if (options && options.forever && !timeouts.length) {\n\t\t    timeouts.push(this.createTimeout(i, opts));\n\t\t  }\n\n\t\t  // sort the array numerically ascending\n\t\t  timeouts.sort(function(a,b) {\n\t\t    return a - b;\n\t\t  });\n\n\t\t  return timeouts;\n\t\t};\n\n\t\texports.createTimeout = function(attempt, opts) {\n\t\t  var random = (opts.randomize)\n\t\t    ? (Math.random() + 1)\n\t\t    : 1;\n\n\t\t  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n\t\t  timeout = Math.min(timeout, opts.maxTimeout);\n\n\t\t  return timeout;\n\t\t};\n\n\t\texports.wrap = function(obj, options, methods) {\n\t\t  if (options instanceof Array) {\n\t\t    methods = options;\n\t\t    options = null;\n\t\t  }\n\n\t\t  if (!methods) {\n\t\t    methods = [];\n\t\t    for (var key in obj) {\n\t\t      if (typeof obj[key] === 'function') {\n\t\t        methods.push(key);\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  for (var i = 0; i < methods.length; i++) {\n\t\t    var method   = methods[i];\n\t\t    var original = obj[method];\n\n\t\t    obj[method] = function retryWrapper(original) {\n\t\t      var op       = exports.operation(options);\n\t\t      var args     = Array.prototype.slice.call(arguments, 1);\n\t\t      var callback = args.pop();\n\n\t\t      args.push(function(err) {\n\t\t        if (op.retry(err)) {\n\t\t          return;\n\t\t        }\n\t\t        if (err) {\n\t\t          arguments[0] = op.mainError();\n\t\t        }\n\t\t        callback.apply(this, arguments);\n\t\t      });\n\n\t\t      op.attempt(function() {\n\t\t        original.apply(obj, args);\n\t\t      });\n\t\t    }.bind(obj, original);\n\t\t    obj[method].options = options;\n\t\t  }\n\t\t}; \n\t} (retry$2));\n\n\tvar retry$1 = retry$2;\n\n\tconst retry = retry$1;\n\n\tconst networkErrorMsgs = [\n\t\t'Failed to fetch', // Chrome\n\t\t'NetworkError when attempting to fetch resource.', // Firefox\n\t\t'The Internet connection appears to be offline.', // Safari\n\t\t'Network request failed' // `cross-fetch`\n\t];\n\n\tclass AbortError extends Error {\n\t\tconstructor(message) {\n\t\t\tsuper();\n\n\t\t\tif (message instanceof Error) {\n\t\t\t\tthis.originalError = message;\n\t\t\t\t({message} = message);\n\t\t\t} else {\n\t\t\t\tthis.originalError = new Error(message);\n\t\t\t\tthis.originalError.stack = this.stack;\n\t\t\t}\n\n\t\t\tthis.name = 'AbortError';\n\t\t\tthis.message = message;\n\t\t}\n\t}\n\n\tconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\t\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\t\terror.attemptNumber = attemptNumber;\n\t\terror.retriesLeft = retriesLeft;\n\t\treturn error;\n\t};\n\n\tconst isNetworkError = errorMessage => networkErrorMsgs.includes(errorMessage);\n\n\tconst pRetry = (input, options) => new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\tonFailedAttempt: () => {},\n\t\t\tretries: 10,\n\t\t\t...options\n\t\t};\n\n\t\tconst operation = retry.operation(options);\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tresolve(await input(attemptNumber));\n\t\t\t} catch (error) {\n\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\treject(new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error.originalError);\n\t\t\t\t} else if (error instanceof TypeError && !isNetworkError(error.message)) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait options.onFailedAttempt(error);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\treject(operation.mainError());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\tpRetry$1.exports = pRetry;\n\t// TODO: remove this in the next major version\n\tpRetry$1.exports.default = pRetry;\n\n\tpRetry$1.exports.AbortError = AbortError;\n\n\tvar pRetryExports = pRetry$1.exports;\n\n\tvar max = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n\n\tvar nil = '00000000-0000-0000-0000-000000000000';\n\n\tvar REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n\n\tfunction validate(uuid) {\n\t  return typeof uuid === 'string' && REGEX.test(uuid);\n\t}\n\n\tfunction parse$7(uuid) {\n\t  if (!validate(uuid)) {\n\t    throw TypeError('Invalid UUID');\n\t  }\n\t  var v;\n\t  var arr = new Uint8Array(16);\n\n\t  // Parse ########-....-....-....-............\n\t  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n\t  arr[1] = v >>> 16 & 0xff;\n\t  arr[2] = v >>> 8 & 0xff;\n\t  arr[3] = v & 0xff;\n\n\t  // Parse ........-####-....-....-............\n\t  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n\t  arr[5] = v & 0xff;\n\n\t  // Parse ........-....-####-....-............\n\t  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n\t  arr[7] = v & 0xff;\n\n\t  // Parse ........-....-....-####-............\n\t  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n\t  arr[9] = v & 0xff;\n\n\t  // Parse ........-....-....-....-############\n\t  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\t  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n\t  arr[11] = v / 0x100000000 & 0xff;\n\t  arr[12] = v >>> 24 & 0xff;\n\t  arr[13] = v >>> 16 & 0xff;\n\t  arr[14] = v >>> 8 & 0xff;\n\t  arr[15] = v & 0xff;\n\t  return arr;\n\t}\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex.push((i + 0x100).toString(16).slice(1));\n\t}\n\tfunction unsafeStringify(arr, offset = 0) {\n\t  // Note: Be careful editing this code!  It's been tuned for performance\n\t  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n\t  //\n\t  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n\t  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n\t  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n\t}\n\tfunction stringify$1(arr, offset = 0) {\n\t  var uuid = unsafeStringify(arr, offset);\n\t  // Consistency check for valid UUID.  If this throws, it's likely due to one\n\t  // of the following:\n\t  // - One or more input array values don't map to a hex octet (leading to\n\t  // \"undefined\" in the uuid)\n\t  // - Invalid input values for the RFC `version` or `variant` fields\n\t  if (!validate(uuid)) {\n\t    throw TypeError('Stringified UUID is invalid');\n\t  }\n\t  return uuid;\n\t}\n\n\t// Unique ID creation requires a high quality random # generator. In the browser we therefore\n\t// require the crypto API and do not support built-in fallback to lower quality random number\n\t// generators (like Math.random()).\n\n\tvar getRandomValues;\n\tvar rnds8 = new Uint8Array(16);\n\tfunction rng() {\n\t  // lazy load so that environments that need to polyfill have a chance to do so\n\t  if (!getRandomValues) {\n\t    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n\t    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\t    if (!getRandomValues) {\n\t      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n\t    }\n\t  }\n\t  return getRandomValues(rnds8);\n\t}\n\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\n\tvar _nodeId;\n\tvar _clockseq;\n\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0;\n\tvar _lastNSecs = 0;\n\n\t// See https://github.com/uuidjs/uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || new Array(16);\n\t  options = options || {};\n\t  var node = options.node;\n\t  var clockseq = options.clockseq;\n\n\t  // v1 only: Use cached `node` and `clockseq` values\n\t  if (!options._v6) {\n\t    if (!node) {\n\t      node = _nodeId;\n\t    }\n\t    if (clockseq == null) {\n\t      clockseq = _clockseq;\n\t    }\n\t  }\n\n\t  // Handle cases where we need entropy.  We do this lazily to minimize issues\n\t  // related to insufficient system entropy.  See #189\n\t  if (node == null || clockseq == null) {\n\t    var seedBytes = options.random || (options.rng || rng)();\n\n\t    // Randomize node\n\t    if (node == null) {\n\t      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n\t      // v1 only: cache node value for reuse\n\t      if (!_nodeId && !options._v6) {\n\t        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n\t        node[0] |= 0x01; // Set multicast bit\n\n\t        _nodeId = node;\n\t      }\n\t    }\n\n\t    // Randomize clockseq\n\t    if (clockseq == null) {\n\t      // Per 4.2.2, randomize (14 bit) clockseq\n\t      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n\t      if (_clockseq === undefined && !options._v6) {\n\t        _clockseq = clockseq;\n\t      }\n\t    }\n\t  }\n\n\t  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n\t  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n\t  }\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\n\t  // `time_mid`\n\t  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\n\t  // `node`\n\t  for (var n = 0; n < 6; ++n) {\n\t    b[i + n] = node[n];\n\t  }\n\t  return buf || unsafeStringify(b);\n\t}\n\n\t/**\n\t * Convert a v1 UUID to a v6 UUID\n\t *\n\t * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n\t * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n\t * (string or Uint8Array)\n\t */\n\tfunction v1ToV6(uuid) {\n\t  var v1Bytes = typeof uuid === 'string' ? parse$7(uuid) : uuid;\n\t  var v6Bytes = _v1ToV6(v1Bytes);\n\t  return typeof uuid === 'string' ? unsafeStringify(v6Bytes) : v6Bytes;\n\t}\n\n\t// Do the field transformation needed for v1 -> v6\n\tfunction _v1ToV6(v1Bytes, randomize = false) {\n\t  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n\t}\n\n\tfunction stringToBytes(str) {\n\t  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n\t  var bytes = [];\n\t  for (var i = 0; i < str.length; ++i) {\n\t    bytes.push(str.charCodeAt(i));\n\t  }\n\t  return bytes;\n\t}\n\tvar DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n\tvar URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n\tfunction v35(name, version, hashfunc) {\n\t  function generateUUID(value, namespace, buf, offset) {\n\t    var _namespace;\n\t    if (typeof value === 'string') {\n\t      value = stringToBytes(value);\n\t    }\n\t    if (typeof namespace === 'string') {\n\t      namespace = parse$7(namespace);\n\t    }\n\t    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n\t      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n\t    }\n\n\t    // Compute hash of namespace and value, Per 4.3\n\t    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n\t    // hashfunc([...namespace, ... value])`\n\t    var bytes = new Uint8Array(16 + value.length);\n\t    bytes.set(namespace);\n\t    bytes.set(value, namespace.length);\n\t    bytes = hashfunc(bytes);\n\t    bytes[6] = bytes[6] & 0x0f | version;\n\t    bytes[8] = bytes[8] & 0x3f | 0x80;\n\t    if (buf) {\n\t      offset = offset || 0;\n\t      for (var i = 0; i < 16; ++i) {\n\t        buf[offset + i] = bytes[i];\n\t      }\n\t      return buf;\n\t    }\n\t    return unsafeStringify(bytes);\n\t  }\n\n\t  // Function#name is not settable on some platforms (#270)\n\t  try {\n\t    generateUUID.name = name;\n\t  } catch (err) {}\n\n\t  // For CommonJS default export support\n\t  generateUUID.DNS = DNS;\n\t  generateUUID.URL = URL$1;\n\t  return generateUUID;\n\t}\n\n\t/*\n\t * Browser-compatible JavaScript MD5\n\t *\n\t * Modification of JavaScript MD5\n\t * https://github.com/blueimp/JavaScript-MD5\n\t *\n\t * Copyright 2011, Sebastian Tschan\n\t * https://blueimp.net\n\t *\n\t * Licensed under the MIT license:\n\t * https://opensource.org/licenses/MIT\n\t *\n\t * Based on\n\t * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n\t * Digest Algorithm, as defined in RFC 1321.\n\t * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n\t * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n\t * Distributed under the BSD License\n\t * See http://pajhome.org.uk/crypt/md5 for more info.\n\t */\n\tfunction md5(bytes) {\n\t  if (typeof bytes === 'string') {\n\t    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n\t    bytes = new Uint8Array(msg.length);\n\t    for (var i = 0; i < msg.length; ++i) {\n\t      bytes[i] = msg.charCodeAt(i);\n\t    }\n\t  }\n\t  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n\t}\n\n\t/*\n\t * Convert an array of little-endian words to an array of bytes\n\t */\n\tfunction md5ToHexEncodedArray(input) {\n\t  var output = [];\n\t  var length32 = input.length * 32;\n\t  var hexTab = '0123456789abcdef';\n\t  for (var i = 0; i < length32; i += 8) {\n\t    var x = input[i >> 5] >>> i % 32 & 0xff;\n\t    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n\t    output.push(hex);\n\t  }\n\t  return output;\n\t}\n\n\t/**\n\t * Calculate output length with padding and bit length\n\t */\n\tfunction getOutputLength(inputLength8) {\n\t  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n\t}\n\n\t/*\n\t * Calculate the MD5 of an array of little-endian words, and a bit length.\n\t */\n\tfunction wordsToMd5(x, len) {\n\t  /* append padding */\n\t  x[len >> 5] |= 0x80 << len % 32;\n\t  x[getOutputLength(len) - 1] = len;\n\t  var a = 1732584193;\n\t  var b = -271733879;\n\t  var c = -1732584194;\n\t  var d = 271733878;\n\t  for (var i = 0; i < x.length; i += 16) {\n\t    var olda = a;\n\t    var oldb = b;\n\t    var oldc = c;\n\t    var oldd = d;\n\t    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n\t    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n\t    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n\t    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n\t    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n\t    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n\t    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n\t    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n\t    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n\t    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n\t    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n\t    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n\t    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n\t    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n\t    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n\t    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\t    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n\t    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n\t    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n\t    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n\t    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n\t    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n\t    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n\t    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n\t    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n\t    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n\t    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n\t    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n\t    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n\t    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n\t    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n\t    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\t    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n\t    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n\t    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n\t    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n\t    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n\t    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n\t    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n\t    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n\t    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n\t    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n\t    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n\t    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n\t    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n\t    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n\t    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n\t    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n\t    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n\t    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n\t    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n\t    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n\t    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n\t    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n\t    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n\t    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n\t    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n\t    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n\t    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n\t    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n\t    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n\t    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n\t    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n\t    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n\t    a = safeAdd(a, olda);\n\t    b = safeAdd(b, oldb);\n\t    c = safeAdd(c, oldc);\n\t    d = safeAdd(d, oldd);\n\t  }\n\t  return [a, b, c, d];\n\t}\n\n\t/*\n\t * Convert an array bytes to an array of little-endian words\n\t * Characters >255 have their high-byte silently ignored.\n\t */\n\tfunction bytesToWords(input) {\n\t  if (input.length === 0) {\n\t    return [];\n\t  }\n\t  var length8 = input.length * 8;\n\t  var output = new Uint32Array(getOutputLength(length8));\n\t  for (var i = 0; i < length8; i += 8) {\n\t    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n\t  }\n\t  return output;\n\t}\n\n\t/*\n\t * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n\t * to work around bugs in some JS interpreters.\n\t */\n\tfunction safeAdd(x, y) {\n\t  var lsw = (x & 0xffff) + (y & 0xffff);\n\t  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t  return msw << 16 | lsw & 0xffff;\n\t}\n\n\t/*\n\t * Bitwise rotate a 32-bit number to the left.\n\t */\n\tfunction bitRotateLeft(num, cnt) {\n\t  return num << cnt | num >>> 32 - cnt;\n\t}\n\n\t/*\n\t * These functions implement the four basic operations the algorithm uses.\n\t */\n\tfunction md5cmn(q, a, b, x, s, t) {\n\t  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n\t}\n\tfunction md5ff(a, b, c, d, x, s, t) {\n\t  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n\t}\n\tfunction md5gg(a, b, c, d, x, s, t) {\n\t  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n\t}\n\tfunction md5hh(a, b, c, d, x, s, t) {\n\t  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n\t}\n\tfunction md5ii(a, b, c, d, x, s, t) {\n\t  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n\t}\n\n\tvar v3 = v35('v3', 0x30, md5);\n\n\tvar randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n\tvar native = {\n\t  randomUUID\n\t};\n\n\tfunction v4(options, buf, offset) {\n\t  if (native.randomUUID && !buf && !options) {\n\t    return native.randomUUID();\n\t  }\n\t  options = options || {};\n\t  var rnds = options.random || (options.rng || rng)();\n\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = rnds[6] & 0x0f | 0x40;\n\t  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    offset = offset || 0;\n\t    for (var i = 0; i < 16; ++i) {\n\t      buf[offset + i] = rnds[i];\n\t    }\n\t    return buf;\n\t  }\n\t  return unsafeStringify(rnds);\n\t}\n\n\t// Adapted from Chris Veness' SHA1 code at\n\t// http://www.movable-type.co.uk/scripts/sha1.html\n\tfunction f(s, x, y, z) {\n\t  switch (s) {\n\t    case 0:\n\t      return x & y ^ ~x & z;\n\t    case 1:\n\t      return x ^ y ^ z;\n\t    case 2:\n\t      return x & y ^ x & z ^ y & z;\n\t    case 3:\n\t      return x ^ y ^ z;\n\t  }\n\t}\n\tfunction ROTL(x, n) {\n\t  return x << n | x >>> 32 - n;\n\t}\n\tfunction sha1(bytes) {\n\t  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n\t  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\t  if (typeof bytes === 'string') {\n\t    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n\t    bytes = [];\n\t    for (var i = 0; i < msg.length; ++i) {\n\t      bytes.push(msg.charCodeAt(i));\n\t    }\n\t  } else if (!Array.isArray(bytes)) {\n\t    // Convert Array-like to Array\n\t    bytes = Array.prototype.slice.call(bytes);\n\t  }\n\t  bytes.push(0x80);\n\t  var l = bytes.length / 4 + 2;\n\t  var N = Math.ceil(l / 16);\n\t  var M = new Array(N);\n\t  for (var _i = 0; _i < N; ++_i) {\n\t    var arr = new Uint32Array(16);\n\t    for (var j = 0; j < 16; ++j) {\n\t      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n\t    }\n\t    M[_i] = arr;\n\t  }\n\t  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n\t  M[N - 1][14] = Math.floor(M[N - 1][14]);\n\t  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\t  for (var _i2 = 0; _i2 < N; ++_i2) {\n\t    var W = new Uint32Array(80);\n\t    for (var t = 0; t < 16; ++t) {\n\t      W[t] = M[_i2][t];\n\t    }\n\t    for (var _t = 16; _t < 80; ++_t) {\n\t      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n\t    }\n\t    var a = H[0];\n\t    var b = H[1];\n\t    var c = H[2];\n\t    var d = H[3];\n\t    var e = H[4];\n\t    for (var _t2 = 0; _t2 < 80; ++_t2) {\n\t      var s = Math.floor(_t2 / 20);\n\t      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n\t      e = d;\n\t      d = c;\n\t      c = ROTL(b, 30) >>> 0;\n\t      b = a;\n\t      a = T;\n\t    }\n\t    H[0] = H[0] + a >>> 0;\n\t    H[1] = H[1] + b >>> 0;\n\t    H[2] = H[2] + c >>> 0;\n\t    H[3] = H[3] + d >>> 0;\n\t    H[4] = H[4] + e >>> 0;\n\t  }\n\t  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n\t}\n\n\tvar v5 = v35('v5', 0x50, sha1);\n\n\tfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n\tfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n\tfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\n\tfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\n\tfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\t/**\n\t *\n\t * @param {object} options\n\t * @param {Uint8Array=} buf\n\t * @param {number=} offset\n\t * @returns\n\t */\n\tfunction v6(options = {}, buf, offset = 0) {\n\t  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n\t  // with slightly different behavior around how the clock_seq and node fields\n\t  // are randomized, which is why we call v1 with _v6: true.\n\t  var bytes = v1(_objectSpread(_objectSpread({}, options), {}, {\n\t    _v6: true\n\t  }), new Uint8Array(16));\n\n\t  // Reorder the fields to v6 layout.\n\t  bytes = v1ToV6(bytes);\n\n\t  // Return as a byte array if requested\n\t  if (buf) {\n\t    for (var i = 0; i < 16; i++) {\n\t      buf[offset + i] = bytes[i];\n\t    }\n\t    return buf;\n\t  }\n\t  return unsafeStringify(bytes);\n\t}\n\n\t/**\n\t * Convert a v6 UUID to a v1 UUID\n\t *\n\t * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6\n\t * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg\n\t * (string or Uint8Array)\n\t */\n\tfunction v6ToV1(uuid) {\n\t  var v6Bytes = typeof uuid === 'string' ? parse$7(uuid) : uuid;\n\t  var v1Bytes = _v6ToV1(v6Bytes);\n\t  return typeof uuid === 'string' ? unsafeStringify(v1Bytes) : v1Bytes;\n\t}\n\n\t// Do the field transformation needed for v6 -> v1\n\tfunction _v6ToV1(v6Bytes) {\n\t  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n\t}\n\n\t/**\n\t * UUID V7 - Unix Epoch time-based UUID\n\t *\n\t * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n\t * implementation of V7 is based on the accepted, though not yet approved,\n\t * revisions.\n\t *\n\t * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n\t * IDentifiers (UUIDs)\n\n\t *\n\t * Sample V7 value:\n\t * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n\t *\n\t * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n\t *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n\t *\n\t *   0                   1                   2                   3 0 1 2 3 4 5 6\n\t *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                          unix_ts_ms                           |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |          unix_ts_ms           |  ver  |        seq_hi         |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |var|               seq_low               |        rand         |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                             rand                              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n\t * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n\t * was selected as any bitwise operations in node are done as _signed_ 32 bit\n\t * ints. we exclude the sign bit.\n\t */\n\n\tvar _seqLow = null;\n\tvar _seqHigh = null;\n\tvar _msecs = 0;\n\tfunction v7(options, buf, offset) {\n\t  options = options || {};\n\n\t  // initialize buffer and pointer\n\t  var i = buf && offset || 0;\n\t  var b = buf || new Uint8Array(16);\n\n\t  // rnds is Uint8Array(16) filled with random bytes\n\t  var rnds = options.random || (options.rng || rng)();\n\n\t  // milliseconds since unix epoch, 1970-01-01 00:00\n\t  var msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n\t  // seq is user provided 31 bit counter\n\t  var seq = options.seq !== undefined ? options.seq : null;\n\n\t  // initialize local seq high/low parts\n\t  var seqHigh = _seqHigh;\n\t  var seqLow = _seqLow;\n\n\t  // check if clock has advanced and user has not provided msecs\n\t  if (msecs > _msecs && options.msecs === undefined) {\n\t    _msecs = msecs;\n\n\t    // unless user provided seq, reset seq parts\n\t    if (seq !== null) {\n\t      seqHigh = null;\n\t      seqLow = null;\n\t    }\n\t  }\n\n\t  // if we have a user provided seq\n\t  if (seq !== null) {\n\t    // trim provided seq to 31 bits of value, avoiding overflow\n\t    if (seq > 0x7fffffff) {\n\t      seq = 0x7fffffff;\n\t    }\n\n\t    // split provided seq into high/low parts\n\t    seqHigh = seq >>> 19 & 0xfff;\n\t    seqLow = seq & 0x7ffff;\n\t  }\n\n\t  // randomly initialize seq\n\t  if (seqHigh === null || seqLow === null) {\n\t    seqHigh = rnds[6] & 0x7f;\n\t    seqHigh = seqHigh << 8 | rnds[7];\n\t    seqLow = rnds[8] & 0x3f; // pad for var\n\t    seqLow = seqLow << 8 | rnds[9];\n\t    seqLow = seqLow << 5 | rnds[10] >>> 3;\n\t  }\n\n\t  // increment seq if within msecs window\n\t  if (msecs + 10000 > _msecs && seq === null) {\n\t    if (++seqLow > 0x7ffff) {\n\t      seqLow = 0;\n\t      if (++seqHigh > 0xfff) {\n\t        seqHigh = 0;\n\n\t        // increment internal _msecs. this allows us to continue incrementing\n\t        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n\t        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n\t        _msecs++;\n\t      }\n\t    }\n\t  } else {\n\t    // resetting; we have advanced more than\n\t    // 10k milliseconds beyond system clock\n\t    _msecs = msecs;\n\t  }\n\t  _seqHigh = seqHigh;\n\t  _seqLow = seqLow;\n\n\t  // [bytes 0-5] 48 bits of local timestamp\n\t  b[i++] = _msecs / 0x10000000000 & 0xff;\n\t  b[i++] = _msecs / 0x100000000 & 0xff;\n\t  b[i++] = _msecs / 0x1000000 & 0xff;\n\t  b[i++] = _msecs / 0x10000 & 0xff;\n\t  b[i++] = _msecs / 0x100 & 0xff;\n\t  b[i++] = _msecs & 0xff;\n\n\t  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n\t  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n\t  // [byte 7] remaining 8 bits of seq_hi\n\t  b[i++] = seqHigh & 0xff;\n\n\t  // [byte 8] - variant (2 bits), first 6 bits seq_low\n\t  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n\t  // [byte 9] 8 bits seq_low\n\t  b[i++] = seqLow >>> 5 & 0xff;\n\n\t  // [byte 10] remaining 5 bits seq_low, 3 bits random\n\t  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n\t  // [bytes 11-15] always random\n\t  b[i++] = rnds[11];\n\t  b[i++] = rnds[12];\n\t  b[i++] = rnds[13];\n\t  b[i++] = rnds[14];\n\t  b[i++] = rnds[15];\n\t  return buf || unsafeStringify(b);\n\t}\n\n\tfunction version$1(uuid) {\n\t  if (!validate(uuid)) {\n\t    throw TypeError('Invalid UUID');\n\t  }\n\t  return parseInt(uuid.slice(14, 15), 16);\n\t}\n\n\tvar esmBrowser = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tMAX: max,\n\t\tNIL: nil,\n\t\tparse: parse$7,\n\t\tstringify: stringify$1,\n\t\tv1: v1,\n\t\tv1ToV6: v1ToV6,\n\t\tv3: v3,\n\t\tv4: v4,\n\t\tv5: v5,\n\t\tv6: v6,\n\t\tv6ToV1: v6ToV1,\n\t\tv7: v7,\n\t\tvalidate: validate,\n\t\tversion: version$1\n\t});\n\n\tvar require$$2 = /*@__PURE__*/getAugmentedNamespace(esmBrowser);\n\n\tvar traceable$1 = {};\n\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.isTraceableFunction = exports.ROOT = exports.withRunTree = exports.getCurrentRunTree = exports.AsyncLocalStorageProviderSingleton = void 0;\n\t\tclass MockAsyncLocalStorage {\n\t\t    getStore() {\n\t\t        return undefined;\n\t\t    }\n\t\t    run(_, callback) {\n\t\t        return callback();\n\t\t    }\n\t\t}\n\t\tconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\n\t\tconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\n\t\tclass AsyncLocalStorageProvider {\n\t\t    getInstance() {\n\t\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n\t\t    }\n\t\t    initializeGlobalInstance(instance) {\n\t\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t        if (globalThis[TRACING_ALS_KEY] === undefined) {\n\t\t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t            globalThis[TRACING_ALS_KEY] = instance;\n\t\t        }\n\t\t    }\n\t\t}\n\t\texports.AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\t\t/**\n\t\t * Return the current run tree from within a traceable-wrapped function.\n\t\t * Will throw an error if called outside of a traceable function.\n\t\t *\n\t\t * @returns The run tree for the given context.\n\t\t */\n\t\tconst getCurrentRunTree = () => {\n\t\t    const runTree = exports.AsyncLocalStorageProviderSingleton.getInstance().getStore();\n\t\t    if (runTree === undefined) {\n\t\t        throw new Error([\n\t\t            \"Could not get the current run tree.\",\n\t\t            \"\",\n\t\t            \"Please make sure you are calling this method within a traceable function or the tracing is enabled.\",\n\t\t        ].join(\"\\n\"));\n\t\t    }\n\t\t    return runTree;\n\t\t};\n\t\texports.getCurrentRunTree = getCurrentRunTree;\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tfunction withRunTree(runTree, fn) {\n\t\t    const storage = exports.AsyncLocalStorageProviderSingleton.getInstance();\n\t\t    return new Promise((resolve, reject) => {\n\t\t        storage.run(runTree, () => void Promise.resolve(fn()).then(resolve).catch(reject));\n\t\t    });\n\t\t}\n\t\texports.withRunTree = withRunTree;\n\t\texports.ROOT = Symbol.for(\"langsmith:traceable:root\");\n\t\tfunction isTraceableFunction(x\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t) {\n\t\t    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n\t\t}\n\t\texports.isTraceableFunction = isTraceableFunction; \n\t} (traceable$1));\n\n\tvar traceable = traceable$1;\n\n\tvar log_stream = {};\n\n\tvar fastJsonPatch = {};\n\n\tvar core = {};\n\n\tvar helpers = {};\n\n\t// @ts-nocheck\n\tObject.defineProperty(helpers, \"__esModule\", { value: true });\n\thelpers.PatchError = helpers.hasUndefined = helpers.getPath = helpers._getPathRecursive = helpers.unescapePathComponent = helpers.escapePathComponent = helpers.isInteger = helpers._deepClone = helpers._objectKeys = helpers.hasOwnProperty = void 0;\n\t// Inlined because of ESM import issues\n\t/*!\n\t * https://github.com/Starcounter-Jack/JSON-Patch\n\t * (c) 2017-2022 Joachim Wester\n\t * MIT licensed\n\t */\n\tconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwnProperty(obj, key) {\n\t    return _hasOwnProperty.call(obj, key);\n\t}\n\thelpers.hasOwnProperty = hasOwnProperty;\n\tfunction _objectKeys(obj) {\n\t    if (Array.isArray(obj)) {\n\t        const keys = new Array(obj.length);\n\t        for (let k = 0; k < keys.length; k++) {\n\t            keys[k] = \"\" + k;\n\t        }\n\t        return keys;\n\t    }\n\t    if (Object.keys) {\n\t        return Object.keys(obj);\n\t    }\n\t    let keys = [];\n\t    for (let i in obj) {\n\t        if (hasOwnProperty(obj, i)) {\n\t            keys.push(i);\n\t        }\n\t    }\n\t    return keys;\n\t}\n\thelpers._objectKeys = _objectKeys;\n\t/**\n\t * Deeply clone the object.\n\t * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n\t * @param  {any} obj value to clone\n\t * @return {any} cloned obj\n\t */\n\tfunction _deepClone(obj) {\n\t    switch (typeof obj) {\n\t        case \"object\":\n\t            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n\t        case \"undefined\":\n\t            return null; //this is how JSON.stringify behaves for array items\n\t        default:\n\t            return obj; //no need to clone primitives\n\t    }\n\t}\n\thelpers._deepClone = _deepClone;\n\t//3x faster than cached /^\\d+$/.test(str)\n\tfunction isInteger(str) {\n\t    let i = 0;\n\t    const len = str.length;\n\t    let charCode;\n\t    while (i < len) {\n\t        charCode = str.charCodeAt(i);\n\t        if (charCode >= 48 && charCode <= 57) {\n\t            i++;\n\t            continue;\n\t        }\n\t        return false;\n\t    }\n\t    return true;\n\t}\n\thelpers.isInteger = isInteger;\n\t/**\n\t * Escapes a json pointer path\n\t * @param path The raw pointer\n\t * @return the Escaped path\n\t */\n\tfunction escapePathComponent(path) {\n\t    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n\t        return path;\n\t    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n\t}\n\thelpers.escapePathComponent = escapePathComponent;\n\t/**\n\t * Unescapes a json pointer path\n\t * @param path The escaped pointer\n\t * @return The unescaped path\n\t */\n\tfunction unescapePathComponent(path) {\n\t    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n\t}\n\thelpers.unescapePathComponent = unescapePathComponent;\n\tfunction _getPathRecursive(root, obj) {\n\t    let found;\n\t    for (let key in root) {\n\t        if (hasOwnProperty(root, key)) {\n\t            if (root[key] === obj) {\n\t                return escapePathComponent(key) + \"/\";\n\t            }\n\t            else if (typeof root[key] === \"object\") {\n\t                found = _getPathRecursive(root[key], obj);\n\t                if (found != \"\") {\n\t                    return escapePathComponent(key) + \"/\" + found;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return \"\";\n\t}\n\thelpers._getPathRecursive = _getPathRecursive;\n\tfunction getPath(root, obj) {\n\t    if (root === obj) {\n\t        return \"/\";\n\t    }\n\t    const path = _getPathRecursive(root, obj);\n\t    if (path === \"\") {\n\t        throw new Error(\"Object not found in root\");\n\t    }\n\t    return `/${path}`;\n\t}\n\thelpers.getPath = getPath;\n\t/**\n\t * Recursively checks whether an object has any undefined values inside.\n\t */\n\tfunction hasUndefined(obj) {\n\t    if (obj === undefined) {\n\t        return true;\n\t    }\n\t    if (obj) {\n\t        if (Array.isArray(obj)) {\n\t            for (let i = 0, len = obj.length; i < len; i++) {\n\t                if (hasUndefined(obj[i])) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        else if (typeof obj === \"object\") {\n\t            const objKeys = _objectKeys(obj);\n\t            const objKeysLength = objKeys.length;\n\t            for (var i = 0; i < objKeysLength; i++) {\n\t                if (hasUndefined(obj[objKeys[i]])) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return false;\n\t}\n\thelpers.hasUndefined = hasUndefined;\n\tfunction patchErrorMessageFormatter(message, args) {\n\t    const messageParts = [message];\n\t    for (const key in args) {\n\t        const value = typeof args[key] === \"object\"\n\t            ? JSON.stringify(args[key], null, 2)\n\t            : args[key]; // pretty print\n\t        if (typeof value !== \"undefined\") {\n\t            messageParts.push(`${key}: ${value}`);\n\t        }\n\t    }\n\t    return messageParts.join(\"\\n\");\n\t}\n\tclass PatchError extends Error {\n\t    constructor(message, name, index, operation, tree) {\n\t        super(patchErrorMessageFormatter(message, { name, index, operation, tree }));\n\t        Object.defineProperty(this, \"name\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: name\n\t        });\n\t        Object.defineProperty(this, \"index\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: index\n\t        });\n\t        Object.defineProperty(this, \"operation\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: operation\n\t        });\n\t        Object.defineProperty(this, \"tree\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: tree\n\t        });\n\t        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n\t        this.message = patchErrorMessageFormatter(message, {\n\t            name,\n\t            index,\n\t            operation,\n\t            tree,\n\t        });\n\t    }\n\t}\n\thelpers.PatchError = PatchError;\n\n\t(function (exports) {\n\t\t// @ts-nocheck\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports._areEquals = exports.validate = exports.validator = exports.applyReducer = exports.applyPatch = exports.applyOperation = exports.getValueByPointer = exports.deepClone = exports.JsonPatchError = void 0;\n\t\tconst helpers_js_1 = helpers;\n\t\texports.JsonPatchError = helpers_js_1.PatchError;\n\t\texports.deepClone = helpers_js_1._deepClone;\n\t\t/* We use a Javascript hash to store each\n\t\t function. Each hash entry (property) uses\n\t\t the operation identifiers specified in rfc6902.\n\t\t In this way, we can map each patch operation\n\t\t to its dedicated function in efficient way.\n\t\t */\n\t\t/* The operations applicable to an object */\n\t\tconst objOps = {\n\t\t    add: function (obj, key, document) {\n\t\t        obj[key] = this.value;\n\t\t        return { newDocument: document };\n\t\t    },\n\t\t    remove: function (obj, key, document) {\n\t\t        var removed = obj[key];\n\t\t        delete obj[key];\n\t\t        return { newDocument: document, removed };\n\t\t    },\n\t\t    replace: function (obj, key, document) {\n\t\t        var removed = obj[key];\n\t\t        obj[key] = this.value;\n\t\t        return { newDocument: document, removed };\n\t\t    },\n\t\t    move: function (obj, key, document) {\n\t\t        /* in case move target overwrites an existing value,\n\t\t        return the removed value, this can be taxing performance-wise,\n\t\t        and is potentially unneeded */\n\t\t        let removed = getValueByPointer(document, this.path);\n\t\t        if (removed) {\n\t\t            removed = (0, helpers_js_1._deepClone)(removed);\n\t\t        }\n\t\t        const originalValue = applyOperation(document, {\n\t\t            op: \"remove\",\n\t\t            path: this.from,\n\t\t        }).removed;\n\t\t        applyOperation(document, {\n\t\t            op: \"add\",\n\t\t            path: this.path,\n\t\t            value: originalValue,\n\t\t        });\n\t\t        return { newDocument: document, removed };\n\t\t    },\n\t\t    copy: function (obj, key, document) {\n\t\t        const valueToCopy = getValueByPointer(document, this.from);\n\t\t        // enforce copy by value so further operations don't affect source (see issue #177)\n\t\t        applyOperation(document, {\n\t\t            op: \"add\",\n\t\t            path: this.path,\n\t\t            value: (0, helpers_js_1._deepClone)(valueToCopy),\n\t\t        });\n\t\t        return { newDocument: document };\n\t\t    },\n\t\t    test: function (obj, key, document) {\n\t\t        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n\t\t    },\n\t\t    _get: function (obj, key, document) {\n\t\t        this.value = obj[key];\n\t\t        return { newDocument: document };\n\t\t    },\n\t\t};\n\t\t/* The operations applicable to an array. Many are the same as for the object */\n\t\tvar arrOps = {\n\t\t    add: function (arr, i, document) {\n\t\t        if ((0, helpers_js_1.isInteger)(i)) {\n\t\t            arr.splice(i, 0, this.value);\n\t\t        }\n\t\t        else {\n\t\t            // array props\n\t\t            arr[i] = this.value;\n\t\t        }\n\t\t        // this may be needed when using '-' in an array\n\t\t        return { newDocument: document, index: i };\n\t\t    },\n\t\t    remove: function (arr, i, document) {\n\t\t        var removedList = arr.splice(i, 1);\n\t\t        return { newDocument: document, removed: removedList[0] };\n\t\t    },\n\t\t    replace: function (arr, i, document) {\n\t\t        var removed = arr[i];\n\t\t        arr[i] = this.value;\n\t\t        return { newDocument: document, removed };\n\t\t    },\n\t\t    move: objOps.move,\n\t\t    copy: objOps.copy,\n\t\t    test: objOps.test,\n\t\t    _get: objOps._get,\n\t\t};\n\t\t/**\n\t\t * Retrieves a value from a JSON document by a JSON pointer.\n\t\t * Returns the value.\n\t\t *\n\t\t * @param document The document to get the value from\n\t\t * @param pointer an escaped JSON pointer\n\t\t * @return The retrieved value\n\t\t */\n\t\tfunction getValueByPointer(document, pointer) {\n\t\t    if (pointer == \"\") {\n\t\t        return document;\n\t\t    }\n\t\t    var getOriginalDestination = { op: \"_get\", path: pointer };\n\t\t    applyOperation(document, getOriginalDestination);\n\t\t    return getOriginalDestination.value;\n\t\t}\n\t\texports.getValueByPointer = getValueByPointer;\n\t\t/**\n\t\t * Apply a single JSON Patch Operation on a JSON document.\n\t\t * Returns the {newDocument, result} of the operation.\n\t\t * It modifies the `document` and `operation` objects - it gets the values by reference.\n\t\t * If you would like to avoid touching your values, clone them:\n\t\t * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n\t\t *\n\t\t * @param document The document to patch\n\t\t * @param operation The operation to apply\n\t\t * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n\t\t * @param mutateDocument Whether to mutate the original document or clone it before applying\n\t\t * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n\t\t * @return `{newDocument, result}` after the operation\n\t\t */\n\t\tfunction applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {\n\t\t    if (validateOperation) {\n\t\t        if (typeof validateOperation == \"function\") {\n\t\t            validateOperation(operation, 0, document, operation.path);\n\t\t        }\n\t\t        else {\n\t\t            validator(operation, 0);\n\t\t        }\n\t\t    }\n\t\t    /* ROOT OPERATIONS */\n\t\t    if (operation.path === \"\") {\n\t\t        let returnValue = { newDocument: document };\n\t\t        if (operation.op === \"add\") {\n\t\t            returnValue.newDocument = operation.value;\n\t\t            return returnValue;\n\t\t        }\n\t\t        else if (operation.op === \"replace\") {\n\t\t            returnValue.newDocument = operation.value;\n\t\t            returnValue.removed = document; //document we removed\n\t\t            return returnValue;\n\t\t        }\n\t\t        else if (operation.op === \"move\" || operation.op === \"copy\") {\n\t\t            // it's a move or copy to root\n\t\t            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n\t\t            if (operation.op === \"move\") {\n\t\t                // report removed item\n\t\t                returnValue.removed = document;\n\t\t            }\n\t\t            return returnValue;\n\t\t        }\n\t\t        else if (operation.op === \"test\") {\n\t\t            returnValue.test = _areEquals(document, operation.value);\n\t\t            if (returnValue.test === false) {\n\t\t                throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n\t\t            }\n\t\t            returnValue.newDocument = document;\n\t\t            return returnValue;\n\t\t        }\n\t\t        else if (operation.op === \"remove\") {\n\t\t            // a remove on root\n\t\t            returnValue.removed = document;\n\t\t            returnValue.newDocument = null;\n\t\t            return returnValue;\n\t\t        }\n\t\t        else if (operation.op === \"_get\") {\n\t\t            operation.value = document;\n\t\t            return returnValue;\n\t\t        }\n\t\t        else {\n\t\t            /* bad operation */\n\t\t            if (validateOperation) {\n\t\t                throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n\t\t            }\n\t\t            else {\n\t\t                return returnValue;\n\t\t            }\n\t\t        }\n\t\t    } /* END ROOT OPERATIONS */\n\t\t    else {\n\t\t        if (!mutateDocument) {\n\t\t            document = (0, helpers_js_1._deepClone)(document);\n\t\t        }\n\t\t        const path = operation.path || \"\";\n\t\t        const keys = path.split(\"/\");\n\t\t        let obj = document;\n\t\t        let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n\t\t        let len = keys.length;\n\t\t        let existingPathFragment = undefined;\n\t\t        let key;\n\t\t        let validateFunction;\n\t\t        if (typeof validateOperation == \"function\") {\n\t\t            validateFunction = validateOperation;\n\t\t        }\n\t\t        else {\n\t\t            validateFunction = validator;\n\t\t        }\n\t\t        while (true) {\n\t\t            key = keys[t];\n\t\t            if (key && key.indexOf(\"~\") != -1) {\n\t\t                key = (0, helpers_js_1.unescapePathComponent)(key);\n\t\t            }\n\t\t            if (banPrototypeModifications &&\n\t\t                (key == \"__proto__\" ||\n\t\t                    (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))) {\n\t\t                throw new TypeError(\"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\");\n\t\t            }\n\t\t            if (validateOperation) {\n\t\t                if (existingPathFragment === undefined) {\n\t\t                    if (obj[key] === undefined) {\n\t\t                        existingPathFragment = keys.slice(0, t).join(\"/\");\n\t\t                    }\n\t\t                    else if (t == len - 1) {\n\t\t                        existingPathFragment = operation.path;\n\t\t                    }\n\t\t                    if (existingPathFragment !== undefined) {\n\t\t                        validateFunction(operation, 0, document, existingPathFragment);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            t++;\n\t\t            if (Array.isArray(obj)) {\n\t\t                if (key === \"-\") {\n\t\t                    key = obj.length;\n\t\t                }\n\t\t                else {\n\t\t                    if (validateOperation && !(0, helpers_js_1.isInteger)(key)) {\n\t\t                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n\t\t                    } // only parse key when it's an integer for `arr.prop` to work\n\t\t                    else if ((0, helpers_js_1.isInteger)(key)) {\n\t\t                        key = ~~key;\n\t\t                    }\n\t\t                }\n\t\t                if (t >= len) {\n\t\t                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n\t\t                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n\t\t                    }\n\t\t                    const returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n\t\t                    if (returnValue.test === false) {\n\t\t                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n\t\t                    }\n\t\t                    return returnValue;\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                if (t >= len) {\n\t\t                    const returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n\t\t                    if (returnValue.test === false) {\n\t\t                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n\t\t                    }\n\t\t                    return returnValue;\n\t\t                }\n\t\t            }\n\t\t            obj = obj[key];\n\t\t            // If we have more keys in the path, but the next value isn't a non-null object,\n\t\t            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n\t\t            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n\t\t                throw new exports.JsonPatchError(\"Cannot perform operation at the desired path\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n\t\texports.applyOperation = applyOperation;\n\t\t/**\n\t\t * Apply a full JSON Patch array on a JSON document.\n\t\t * Returns the {newDocument, result} of the patch.\n\t\t * It modifies the `document` object and `patch` - it gets the values by reference.\n\t\t * If you would like to avoid touching your values, clone them:\n\t\t * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n\t\t *\n\t\t * @param document The document to patch\n\t\t * @param patch The patch to apply\n\t\t * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n\t\t * @param mutateDocument Whether to mutate the original document or clone it before applying\n\t\t * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n\t\t * @return An array of `{newDocument, result}` after the patch\n\t\t */\n\t\tfunction applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {\n\t\t    if (validateOperation) {\n\t\t        if (!Array.isArray(patch)) {\n\t\t            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n\t\t        }\n\t\t    }\n\t\t    if (!mutateDocument) {\n\t\t        document = (0, helpers_js_1._deepClone)(document);\n\t\t    }\n\t\t    const results = new Array(patch.length);\n\t\t    for (let i = 0, length = patch.length; i < length; i++) {\n\t\t        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n\t\t        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n\t\t        document = results[i].newDocument; // in case root was replaced\n\t\t    }\n\t\t    results.newDocument = document;\n\t\t    return results;\n\t\t}\n\t\texports.applyPatch = applyPatch;\n\t\t/**\n\t\t * Apply a single JSON Patch Operation on a JSON document.\n\t\t * Returns the updated document.\n\t\t * Suitable as a reducer.\n\t\t *\n\t\t * @param document The document to patch\n\t\t * @param operation The operation to apply\n\t\t * @return The updated document\n\t\t */\n\t\tfunction applyReducer(document, operation, index) {\n\t\t    const operationResult = applyOperation(document, operation);\n\t\t    if (operationResult.test === false) {\n\t\t        // failed test\n\t\t        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n\t\t    }\n\t\t    return operationResult.newDocument;\n\t\t}\n\t\texports.applyReducer = applyReducer;\n\t\t/**\n\t\t * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n\t\t * @param {object} operation - operation object (patch)\n\t\t * @param {number} index - index of operation in the sequence\n\t\t * @param {object} [document] - object where the operation is supposed to be applied\n\t\t * @param {string} [existingPathFragment] - comes along with `document`\n\t\t */\n\t\tfunction validator(operation, index, document, existingPathFragment) {\n\t\t    if (typeof operation !== \"object\" ||\n\t\t        operation === null ||\n\t\t        Array.isArray(operation)) {\n\t\t        throw new exports.JsonPatchError(\"Operation is not an object\", \"OPERATION_NOT_AN_OBJECT\", index, operation, document);\n\t\t    }\n\t\t    else if (!objOps[operation.op]) {\n\t\t        throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n\t\t    }\n\t\t    else if (typeof operation.path !== \"string\") {\n\t\t        throw new exports.JsonPatchError(\"Operation `path` property is not a string\", \"OPERATION_PATH_INVALID\", index, operation, document);\n\t\t    }\n\t\t    else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n\t\t        // paths that aren't empty string should start with \"/\"\n\t\t        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', \"OPERATION_PATH_INVALID\", index, operation, document);\n\t\t    }\n\t\t    else if ((operation.op === \"move\" || operation.op === \"copy\") &&\n\t\t        typeof operation.from !== \"string\") {\n\t\t        throw new exports.JsonPatchError(\"Operation `from` property is not present (applicable in `move` and `copy` operations)\", \"OPERATION_FROM_REQUIRED\", index, operation, document);\n\t\t    }\n\t\t    else if ((operation.op === \"add\" ||\n\t\t        operation.op === \"replace\" ||\n\t\t        operation.op === \"test\") &&\n\t\t        operation.value === undefined) {\n\t\t        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_REQUIRED\", index, operation, document);\n\t\t    }\n\t\t    else if ((operation.op === \"add\" ||\n\t\t        operation.op === \"replace\" ||\n\t\t        operation.op === \"test\") &&\n\t\t        (0, helpers_js_1.hasUndefined)(operation.value)) {\n\t\t        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\", index, operation, document);\n\t\t    }\n\t\t    else if (document) {\n\t\t        if (operation.op == \"add\") {\n\t\t            var pathLen = operation.path.split(\"/\").length;\n\t\t            var existingPathLen = existingPathFragment.split(\"/\").length;\n\t\t            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n\t\t                throw new exports.JsonPatchError(\"Cannot perform an `add` operation at the desired path\", \"OPERATION_PATH_CANNOT_ADD\", index, operation, document);\n\t\t            }\n\t\t        }\n\t\t        else if (operation.op === \"replace\" ||\n\t\t            operation.op === \"remove\" ||\n\t\t            operation.op === \"_get\") {\n\t\t            if (operation.path !== existingPathFragment) {\n\t\t                throw new exports.JsonPatchError(\"Cannot perform the operation at a path that does not exist\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n\t\t            }\n\t\t        }\n\t\t        else if (operation.op === \"move\" || operation.op === \"copy\") {\n\t\t            var existingValue = {\n\t\t                op: \"_get\",\n\t\t                path: operation.from,\n\t\t                value: undefined,\n\t\t            };\n\t\t            var error = validate([existingValue], document);\n\t\t            if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n\t\t                throw new exports.JsonPatchError(\"Cannot perform the operation from a path that does not exist\", \"OPERATION_FROM_UNRESOLVABLE\", index, operation, document);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n\t\texports.validator = validator;\n\t\t/**\n\t\t * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n\t\t * If error is encountered, returns a JsonPatchError object\n\t\t * @param sequence\n\t\t * @param document\n\t\t * @returns {JsonPatchError|undefined}\n\t\t */\n\t\tfunction validate(sequence, document, externalValidator) {\n\t\t    try {\n\t\t        if (!Array.isArray(sequence)) {\n\t\t            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n\t\t        }\n\t\t        if (document) {\n\t\t            //clone document and sequence so that we can safely try applying operations\n\t\t            applyPatch((0, helpers_js_1._deepClone)(document), (0, helpers_js_1._deepClone)(sequence), externalValidator || true);\n\t\t        }\n\t\t        else {\n\t\t            externalValidator = externalValidator || validator;\n\t\t            for (var i = 0; i < sequence.length; i++) {\n\t\t                externalValidator(sequence[i], i, document, undefined);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    catch (e) {\n\t\t        if (e instanceof exports.JsonPatchError) {\n\t\t            return e;\n\t\t        }\n\t\t        else {\n\t\t            throw e;\n\t\t        }\n\t\t    }\n\t\t}\n\t\texports.validate = validate;\n\t\t// based on https://github.com/epoberezkin/fast-deep-equal\n\t\t// MIT License\n\t\t// Copyright (c) 2017 Evgeny Poberezkin\n\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t\t// of this software and associated documentation files (the \"Software\"), to deal\n\t\t// in the Software without restriction, including without limitation the rights\n\t\t// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t\t// copies of the Software, and to permit persons to whom the Software is\n\t\t// furnished to do so, subject to the following conditions:\n\t\t// The above copyright notice and this permission notice shall be included in all\n\t\t// copies or substantial portions of the Software.\n\t\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t\t// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t\t// SOFTWARE.\n\t\tfunction _areEquals(a, b) {\n\t\t    if (a === b)\n\t\t        return true;\n\t\t    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n\t\t        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n\t\t        if (arrA && arrB) {\n\t\t            length = a.length;\n\t\t            if (length != b.length)\n\t\t                return false;\n\t\t            for (i = length; i-- !== 0;)\n\t\t                if (!_areEquals(a[i], b[i]))\n\t\t                    return false;\n\t\t            return true;\n\t\t        }\n\t\t        if (arrA != arrB)\n\t\t            return false;\n\t\t        var keys = Object.keys(a);\n\t\t        length = keys.length;\n\t\t        if (length !== Object.keys(b).length)\n\t\t            return false;\n\t\t        for (i = length; i-- !== 0;)\n\t\t            if (!b.hasOwnProperty(keys[i]))\n\t\t                return false;\n\t\t        for (i = length; i-- !== 0;) {\n\t\t            key = keys[i];\n\t\t            if (!_areEquals(a[key], b[key]))\n\t\t                return false;\n\t\t        }\n\t\t        return true;\n\t\t    }\n\t\t    return a !== a && b !== b;\n\t\t}\n\t\texports._areEquals = _areEquals; \n\t} (core));\n\n\tvar duplex = {};\n\n\t// @ts-nocheck\n\tObject.defineProperty(duplex, \"__esModule\", { value: true });\n\tduplex.compare = duplex.generate = duplex.observe = duplex.unobserve = void 0;\n\t// Inlined because of ESM import issues\n\t/*!\n\t * https://github.com/Starcounter-Jack/JSON-Patch\n\t * (c) 2013-2021 Joachim Wester\n\t * MIT license\n\t */\n\tconst helpers_js_1 = helpers;\n\tconst core_js_1 = core;\n\tvar beforeDict = new WeakMap();\n\tclass Mirror {\n\t    constructor(obj) {\n\t        Object.defineProperty(this, \"obj\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"observers\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: new Map()\n\t        });\n\t        Object.defineProperty(this, \"value\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.obj = obj;\n\t    }\n\t}\n\tclass ObserverInfo {\n\t    constructor(callback, observer) {\n\t        Object.defineProperty(this, \"callback\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"observer\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.callback = callback;\n\t        this.observer = observer;\n\t    }\n\t}\n\tfunction getMirror(obj) {\n\t    return beforeDict.get(obj);\n\t}\n\tfunction getObserverFromMirror(mirror, callback) {\n\t    return mirror.observers.get(callback);\n\t}\n\tfunction removeObserverFromMirror(mirror, observer) {\n\t    mirror.observers.delete(observer.callback);\n\t}\n\t/**\n\t * Detach an observer from an object\n\t */\n\tfunction unobserve(root, observer) {\n\t    observer.unobserve();\n\t}\n\tduplex.unobserve = unobserve;\n\t/**\n\t * Observes changes made to an object, which can then be retrieved using generate\n\t */\n\tfunction observe(obj, callback) {\n\t    var patches = [];\n\t    var observer;\n\t    var mirror = getMirror(obj);\n\t    if (!mirror) {\n\t        mirror = new Mirror(obj);\n\t        beforeDict.set(obj, mirror);\n\t    }\n\t    else {\n\t        const observerInfo = getObserverFromMirror(mirror, callback);\n\t        observer = observerInfo && observerInfo.observer;\n\t    }\n\t    if (observer) {\n\t        return observer;\n\t    }\n\t    observer = {};\n\t    mirror.value = (0, helpers_js_1._deepClone)(obj);\n\t    if (callback) {\n\t        observer.callback = callback;\n\t        observer.next = null;\n\t        var dirtyCheck = () => {\n\t            generate(observer);\n\t        };\n\t        var fastCheck = () => {\n\t            clearTimeout(observer.next);\n\t            observer.next = setTimeout(dirtyCheck);\n\t        };\n\t        if (typeof window !== \"undefined\") {\n\t            //not Node\n\t            window.addEventListener(\"mouseup\", fastCheck);\n\t            window.addEventListener(\"keyup\", fastCheck);\n\t            window.addEventListener(\"mousedown\", fastCheck);\n\t            window.addEventListener(\"keydown\", fastCheck);\n\t            window.addEventListener(\"change\", fastCheck);\n\t        }\n\t    }\n\t    observer.patches = patches;\n\t    observer.object = obj;\n\t    observer.unobserve = () => {\n\t        generate(observer);\n\t        clearTimeout(observer.next);\n\t        removeObserverFromMirror(mirror, observer);\n\t        if (typeof window !== \"undefined\") {\n\t            window.removeEventListener(\"mouseup\", fastCheck);\n\t            window.removeEventListener(\"keyup\", fastCheck);\n\t            window.removeEventListener(\"mousedown\", fastCheck);\n\t            window.removeEventListener(\"keydown\", fastCheck);\n\t            window.removeEventListener(\"change\", fastCheck);\n\t        }\n\t    };\n\t    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n\t    return observer;\n\t}\n\tduplex.observe = observe;\n\t/**\n\t * Generate an array of patches from an observer\n\t */\n\tfunction generate(observer, invertible = false) {\n\t    var mirror = beforeDict.get(observer.object);\n\t    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n\t    if (observer.patches.length) {\n\t        (0, core_js_1.applyPatch)(mirror.value, observer.patches);\n\t    }\n\t    var temp = observer.patches;\n\t    if (temp.length > 0) {\n\t        observer.patches = [];\n\t        if (observer.callback) {\n\t            observer.callback(temp);\n\t        }\n\t    }\n\t    return temp;\n\t}\n\tduplex.generate = generate;\n\t// Dirty check if obj is different from mirror, generate patches and update mirror\n\tfunction _generate(mirror, obj, patches, path, invertible) {\n\t    if (obj === mirror) {\n\t        return;\n\t    }\n\t    if (typeof obj.toJSON === \"function\") {\n\t        obj = obj.toJSON();\n\t    }\n\t    var newKeys = (0, helpers_js_1._objectKeys)(obj);\n\t    var oldKeys = (0, helpers_js_1._objectKeys)(mirror);\n\t    var deleted = false;\n\t    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n\t    for (var t = oldKeys.length - 1; t >= 0; t--) {\n\t        var key = oldKeys[t];\n\t        var oldVal = mirror[key];\n\t        if ((0, helpers_js_1.hasOwnProperty)(obj, key) &&\n\t            !(obj[key] === undefined &&\n\t                oldVal !== undefined &&\n\t                Array.isArray(obj) === false)) {\n\t            var newVal = obj[key];\n\t            if (typeof oldVal == \"object\" &&\n\t                oldVal != null &&\n\t                typeof newVal == \"object\" &&\n\t                newVal != null &&\n\t                Array.isArray(oldVal) === Array.isArray(newVal)) {\n\t                _generate(oldVal, newVal, patches, path + \"/\" + (0, helpers_js_1.escapePathComponent)(key), invertible);\n\t            }\n\t            else {\n\t                if (oldVal !== newVal) {\n\t                    if (invertible) {\n\t                        patches.push({\n\t                            op: \"test\",\n\t                            path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n\t                            value: (0, helpers_js_1._deepClone)(oldVal),\n\t                        });\n\t                    }\n\t                    patches.push({\n\t                        op: \"replace\",\n\t                        path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n\t                        value: (0, helpers_js_1._deepClone)(newVal),\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n\t            if (invertible) {\n\t                patches.push({\n\t                    op: \"test\",\n\t                    path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n\t                    value: (0, helpers_js_1._deepClone)(oldVal),\n\t                });\n\t            }\n\t            patches.push({\n\t                op: \"remove\",\n\t                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n\t            });\n\t            deleted = true; // property has been deleted\n\t        }\n\t        else {\n\t            if (invertible) {\n\t                patches.push({ op: \"test\", path, value: mirror });\n\t            }\n\t            patches.push({ op: \"replace\", path, value: obj });\n\t        }\n\t    }\n\t    if (!deleted && newKeys.length == oldKeys.length) {\n\t        return;\n\t    }\n\t    for (var t = 0; t < newKeys.length; t++) {\n\t        var key = newKeys[t];\n\t        if (!(0, helpers_js_1.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {\n\t            patches.push({\n\t                op: \"add\",\n\t                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n\t                value: (0, helpers_js_1._deepClone)(obj[key]),\n\t            });\n\t        }\n\t    }\n\t}\n\t/**\n\t * Create an array of patches from the differences in two objects\n\t */\n\tfunction compare$c(tree1, tree2, invertible = false) {\n\t    var patches = [];\n\t    _generate(tree1, tree2, patches, \"\", invertible);\n\t    return patches;\n\t}\n\tduplex.compare = compare$c;\n\n\t(function (exports) {\n\t\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t\t    }\n\t\t    Object.defineProperty(o, k2, desc);\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t\t}) : function(o, v) {\n\t\t    o[\"default\"] = v;\n\t\t});\n\t\tvar __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {\n\t\t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n\t\t};\n\t\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t\t    if (mod && mod.__esModule) return mod;\n\t\t    var result = {};\n\t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t\t    __setModuleDefault(result, mod);\n\t\t    return result;\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.unescapePathComponent = exports.escapePathComponent = exports.deepClone = exports.JsonPatchError = void 0;\n\t\t__exportStar(core, exports);\n\t\t__exportStar(duplex, exports);\n\t\tvar helpers_js_1 = helpers;\n\t\tObject.defineProperty(exports, \"JsonPatchError\", { enumerable: true, get: function () { return helpers_js_1.PatchError; } });\n\t\tObject.defineProperty(exports, \"deepClone\", { enumerable: true, get: function () { return helpers_js_1._deepClone; } });\n\t\tObject.defineProperty(exports, \"escapePathComponent\", { enumerable: true, get: function () { return helpers_js_1.escapePathComponent; } });\n\t\tObject.defineProperty(exports, \"unescapePathComponent\", { enumerable: true, get: function () { return helpers_js_1.unescapePathComponent; } });\n\t\t/**\n\t\t * Default export for backwards compat\n\t\t */\n\t\tconst core$1 = __importStar(core);\n\t\tconst helpers_js_2 = helpers;\n\t\texports.default = {\n\t\t    ...core$1,\n\t\t    // ...duplex,\n\t\t    JsonPatchError: helpers_js_2.PatchError,\n\t\t    deepClone: helpers_js_2._deepClone,\n\t\t    escapePathComponent: helpers_js_2.escapePathComponent,\n\t\t    unescapePathComponent: helpers_js_2.unescapePathComponent,\n\t\t}; \n\t} (fastJsonPatch));\n\n\tvar base$1 = {};\n\n\tvar base = {};\n\n\tvar global$1 = (typeof global !== \"undefined\" ? global :\n\t  typeof self !== \"undefined\" ? self :\n\t  typeof window !== \"undefined\" ? window : {});\n\n\t// shim for using process in browser\n\t// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\tvar cachedSetTimeout = defaultSetTimout;\n\tvar cachedClearTimeout = defaultClearTimeout;\n\tif (typeof global$1.setTimeout === 'function') {\n\t    cachedSetTimeout = setTimeout;\n\t}\n\tif (typeof global$1.clearTimeout === 'function') {\n\t    cachedClearTimeout = clearTimeout;\n\t}\n\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\n\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\n\n\n\t}\n\tvar queue$1 = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue$1 = currentQueue.concat(queue$1);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue$1.length) {\n\t        drainQueue();\n\t    }\n\t}\n\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\n\t    var len = queue$1.length;\n\t    while(len) {\n\t        currentQueue = queue$1;\n\t        queue$1 = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue$1.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\tfunction nextTick(fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue$1.push(new Item(fun, args));\n\t    if (queue$1.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t}\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tvar title = 'browser';\n\tvar platform = 'browser';\n\tvar browser = true;\n\tvar env$3 = {};\n\tvar argv = [];\n\tvar version = ''; // empty string to avoid regexp issues\n\tvar versions = {};\n\tvar release = {};\n\tvar config$1 = {};\n\n\tfunction noop() {}\n\n\tvar on = noop;\n\tvar addListener = noop;\n\tvar once = noop;\n\tvar off = noop;\n\tvar removeListener = noop;\n\tvar removeAllListeners = noop;\n\tvar emit = noop;\n\n\tfunction binding(name) {\n\t    throw new Error('process.binding is not supported');\n\t}\n\n\tfunction cwd () { return '/' }\n\tfunction chdir (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t}function umask() { return 0; }\n\n\t// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\n\tvar performance = global$1.performance || {};\n\tvar performanceNow =\n\t  performance.now        ||\n\t  performance.mozNow     ||\n\t  performance.msNow      ||\n\t  performance.oNow       ||\n\t  performance.webkitNow  ||\n\t  function(){ return (new Date()).getTime() };\n\n\t// generate timestamp or delta\n\t// see http://nodejs.org/api/process.html#process_process_hrtime\n\tfunction hrtime(previousTimestamp){\n\t  var clocktime = performanceNow.call(performance)*1e-3;\n\t  var seconds = Math.floor(clocktime);\n\t  var nanoseconds = Math.floor((clocktime%1)*1e9);\n\t  if (previousTimestamp) {\n\t    seconds = seconds - previousTimestamp[0];\n\t    nanoseconds = nanoseconds - previousTimestamp[1];\n\t    if (nanoseconds<0) {\n\t      seconds--;\n\t      nanoseconds += 1e9;\n\t    }\n\t  }\n\t  return [seconds,nanoseconds]\n\t}\n\n\tvar startTime = new Date();\n\tfunction uptime() {\n\t  var currentTime = new Date();\n\t  var dif = currentTime - startTime;\n\t  return dif / 1000;\n\t}\n\n\tvar browser$1 = {\n\t  nextTick: nextTick,\n\t  title: title,\n\t  browser: browser,\n\t  env: env$3,\n\t  argv: argv,\n\t  version: version,\n\t  versions: versions,\n\t  on: on,\n\t  addListener: addListener,\n\t  once: once,\n\t  off: off,\n\t  removeListener: removeListener,\n\t  removeAllListeners: removeAllListeners,\n\t  emit: emit,\n\t  binding: binding,\n\t  cwd: cwd,\n\t  chdir: chdir,\n\t  umask: umask,\n\t  hrtime: hrtime,\n\t  platform: platform,\n\t  release: release,\n\t  config: config$1,\n\t  uptime: uptime\n\t};\n\n\tvar env$2 = {};\n\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.getEnvironmentVariable = exports.getRuntimeEnvironment = exports.getEnv = exports.isNode = exports.isDeno = exports.isJsDom = exports.isWebWorker = exports.isBrowser = void 0;\n\t\tconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\t\texports.isBrowser = isBrowser;\n\t\tconst isWebWorker = () => typeof globalThis === \"object\" &&\n\t\t    globalThis.constructor &&\n\t\t    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\n\t\texports.isWebWorker = isWebWorker;\n\t\tconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n\t\t    (typeof navigator !== \"undefined\" &&\n\t\t        (navigator.userAgent.includes(\"Node.js\") ||\n\t\t            navigator.userAgent.includes(\"jsdom\")));\n\t\texports.isJsDom = isJsDom;\n\t\t// Supabase Edge Function provides a `Deno` global object\n\t\t// without `version` property\n\t\tconst isDeno = () => typeof Deno !== \"undefined\";\n\t\texports.isDeno = isDeno;\n\t\t// Mark not-as-node if in Supabase Edge Function\n\t\tconst isNode = () => typeof browser$1 !== \"undefined\" &&\n\t\t    typeof browser$1.versions !== \"undefined\" &&\n\t\t    typeof \"18.15.0\" !== \"undefined\" &&\n\t\t    !(0, exports.isDeno)();\n\t\texports.isNode = isNode;\n\t\tconst getEnv = () => {\n\t\t    let env;\n\t\t    if ((0, exports.isBrowser)()) {\n\t\t        env = \"browser\";\n\t\t    }\n\t\t    else if ((0, exports.isNode)()) {\n\t\t        env = \"node\";\n\t\t    }\n\t\t    else if ((0, exports.isWebWorker)()) {\n\t\t        env = \"webworker\";\n\t\t    }\n\t\t    else if ((0, exports.isJsDom)()) {\n\t\t        env = \"jsdom\";\n\t\t    }\n\t\t    else if ((0, exports.isDeno)()) {\n\t\t        env = \"deno\";\n\t\t    }\n\t\t    else {\n\t\t        env = \"other\";\n\t\t    }\n\t\t    return env;\n\t\t};\n\t\texports.getEnv = getEnv;\n\t\tlet runtimeEnvironment;\n\t\tasync function getRuntimeEnvironment() {\n\t\t    if (runtimeEnvironment === undefined) {\n\t\t        const env = (0, exports.getEnv)();\n\t\t        runtimeEnvironment = {\n\t\t            library: \"langchain-js\",\n\t\t            runtime: env,\n\t\t        };\n\t\t    }\n\t\t    return runtimeEnvironment;\n\t\t}\n\t\texports.getRuntimeEnvironment = getRuntimeEnvironment;\n\t\tfunction getEnvironmentVariable(name) {\n\t\t    // Certain Deno setups will throw an error if you try to access environment variables\n\t\t    // https://github.com/langchain-ai/langchainjs/issues/1412\n\t\t    try {\n\t\t        return typeof browser$1 !== \"undefined\"\n\t\t            ? // eslint-disable-next-line no-process-env\n\t\t                browser$1.env?.[name]\n\t\t            : undefined;\n\t\t    }\n\t\t    catch (e) {\n\t\t        return undefined;\n\t\t    }\n\t\t}\n\t\texports.getEnvironmentVariable = getEnvironmentVariable; \n\t} (env$2));\n\n\tvar __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t    }\n\t    Object.defineProperty(o, k2, desc);\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);\n\t    __setModuleDefault$1(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(base, \"__esModule\", { value: true });\n\tbase.BaseCallbackHandler = void 0;\n\tconst uuid$1 = __importStar$1(require$$2);\n\tconst serializable_js_1$1 = serializable;\n\tconst env_js_1$3 = env$2;\n\t/**\n\t * Abstract class that provides a set of optional methods that can be\n\t * overridden in derived classes to handle various events during the\n\t * execution of a LangChain application.\n\t */\n\tclass BaseCallbackHandlerMethodsClass {\n\t}\n\t/**\n\t * Abstract base class for creating callback handlers in the LangChain\n\t * framework. It provides a set of optional methods that can be overridden\n\t * in derived classes to handle various events during the execution of a\n\t * LangChain application.\n\t */\n\tclass BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {\n\t    get lc_namespace() {\n\t        return [\"langchain_core\", \"callbacks\", this.name];\n\t    }\n\t    get lc_secrets() {\n\t        return undefined;\n\t    }\n\t    get lc_attributes() {\n\t        return undefined;\n\t    }\n\t    get lc_aliases() {\n\t        return undefined;\n\t    }\n\t    /**\n\t     * The name of the serializable. Override to provide an alias or\n\t     * to preserve the serialized module name in minified environments.\n\t     *\n\t     * Implemented as a static method to support loading logic.\n\t     */\n\t    static lc_name() {\n\t        return this.name;\n\t    }\n\t    /**\n\t     * The final serialized identifier for the module.\n\t     */\n\t    get lc_id() {\n\t        return [\n\t            ...this.lc_namespace,\n\t            (0, serializable_js_1$1.get_lc_unique_name)(this.constructor),\n\t        ];\n\t    }\n\t    constructor(input) {\n\t        super();\n\t        Object.defineProperty(this, \"lc_serializable\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        Object.defineProperty(this, \"lc_kwargs\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"ignoreLLM\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        Object.defineProperty(this, \"ignoreChain\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        Object.defineProperty(this, \"ignoreAgent\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        Object.defineProperty(this, \"ignoreRetriever\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        Object.defineProperty(this, \"ignoreCustomEvent\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        Object.defineProperty(this, \"raiseError\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        Object.defineProperty(this, \"awaitHandlers\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: (0, env_js_1$3.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n\t        });\n\t        this.lc_kwargs = input || {};\n\t        if (input) {\n\t            this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n\t            this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n\t            this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n\t            this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n\t            this.ignoreCustomEvent =\n\t                input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n\t            this.raiseError = input.raiseError ?? this.raiseError;\n\t            this.awaitHandlers =\n\t                this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n\t        }\n\t    }\n\t    copy() {\n\t        return new this.constructor(this);\n\t    }\n\t    toJSON() {\n\t        return serializable_js_1$1.Serializable.prototype.toJSON.call(this);\n\t    }\n\t    toJSONNotImplemented() {\n\t        return serializable_js_1$1.Serializable.prototype.toJSONNotImplemented.call(this);\n\t    }\n\t    static fromMethods(methods) {\n\t        class Handler extends BaseCallbackHandler {\n\t            constructor() {\n\t                super();\n\t                Object.defineProperty(this, \"name\", {\n\t                    enumerable: true,\n\t                    configurable: true,\n\t                    writable: true,\n\t                    value: uuid$1.v4()\n\t                });\n\t                Object.assign(this, methods);\n\t            }\n\t        }\n\t        return new Handler();\n\t    }\n\t}\n\tbase.BaseCallbackHandler = BaseCallbackHandler;\n\n\tObject.defineProperty(base$1, \"__esModule\", { value: true });\n\tbase$1.BaseTracer = base$1.isBaseTracer = void 0;\n\tconst base_js_1$8 = base;\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tfunction _coerceToDict$2(value, defaultKey) {\n\t    return value && !Array.isArray(value) && typeof value === \"object\"\n\t        ? value\n\t        : { [defaultKey]: value };\n\t}\n\tfunction stripNonAlphanumeric(input) {\n\t    return input.replace(/[-:.]/g, \"\");\n\t}\n\tfunction convertToDottedOrderFormat(epoch, runId, executionOrder) {\n\t    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n\t    return (stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId);\n\t}\n\tfunction isBaseTracer(x) {\n\t    return typeof x._addRunToRunMap === \"function\";\n\t}\n\tbase$1.isBaseTracer = isBaseTracer;\n\tclass BaseTracer extends base_js_1$8.BaseCallbackHandler {\n\t    constructor(_fields) {\n\t        super(...arguments);\n\t        Object.defineProperty(this, \"runMap\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: new Map()\n\t        });\n\t    }\n\t    copy() {\n\t        return this;\n\t    }\n\t    stringifyError(error) {\n\t        // eslint-disable-next-line no-instanceof/no-instanceof\n\t        if (error instanceof Error) {\n\t            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n\t        }\n\t        if (typeof error === \"string\") {\n\t            return error;\n\t        }\n\t        return `${error}`;\n\t    }\n\t    _addChildRun(parentRun, childRun) {\n\t        parentRun.child_runs.push(childRun);\n\t    }\n\t    _addRunToRunMap(run) {\n\t        const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);\n\t        const storedRun = { ...run };\n\t        if (storedRun.parent_run_id !== undefined) {\n\t            const parentRun = this.runMap.get(storedRun.parent_run_id);\n\t            if (parentRun) {\n\t                this._addChildRun(parentRun, storedRun);\n\t                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n\t                storedRun.trace_id = parentRun.trace_id;\n\t                if (parentRun.dotted_order !== undefined) {\n\t                    storedRun.dotted_order = [\n\t                        parentRun.dotted_order,\n\t                        currentDottedOrder,\n\t                    ].join(\".\");\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            storedRun.trace_id = storedRun.id;\n\t            storedRun.dotted_order = currentDottedOrder;\n\t        }\n\t        this.runMap.set(storedRun.id, storedRun);\n\t        return storedRun;\n\t    }\n\t    async _endTrace(run) {\n\t        const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n\t        if (parentRun) {\n\t            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n\t        }\n\t        else {\n\t            await this.persistRun(run);\n\t        }\n\t        this.runMap.delete(run.id);\n\t        await this.onRunUpdate?.(run);\n\t    }\n\t    _getExecutionOrder(parentRunId) {\n\t        const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n\t        // If a run has no parent then execution order is 1\n\t        if (!parentRun) {\n\t            return 1;\n\t        }\n\t        return parentRun.child_execution_order + 1;\n\t    }\n\t    /**\n\t     * Create and add a run to the run map for LLM start events.\n\t     * This must sometimes be done synchronously to avoid race conditions\n\t     * when callbacks are backgrounded, so we expose it as a separate method here.\n\t     */\n\t    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n\t        const execution_order = this._getExecutionOrder(parentRunId);\n\t        const start_time = Date.now();\n\t        const finalExtraParams = metadata\n\t            ? { ...extraParams, metadata }\n\t            : extraParams;\n\t        const run = {\n\t            id: runId,\n\t            name: name ?? llm.id[llm.id.length - 1],\n\t            parent_run_id: parentRunId,\n\t            start_time,\n\t            serialized: llm,\n\t            events: [\n\t                {\n\t                    name: \"start\",\n\t                    time: new Date(start_time).toISOString(),\n\t                },\n\t            ],\n\t            inputs: { prompts },\n\t            execution_order,\n\t            child_runs: [],\n\t            child_execution_order: execution_order,\n\t            run_type: \"llm\",\n\t            extra: finalExtraParams ?? {},\n\t            tags: tags || [],\n\t        };\n\t        return this._addRunToRunMap(run);\n\t    }\n\t    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n\t        const run = this.runMap.get(runId) ??\n\t            this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n\t        await this.onRunCreate?.(run);\n\t        await this.onLLMStart?.(run);\n\t        return run;\n\t    }\n\t    /**\n\t     * Create and add a run to the run map for chat model start events.\n\t     * This must sometimes be done synchronously to avoid race conditions\n\t     * when callbacks are backgrounded, so we expose it as a separate method here.\n\t     */\n\t    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n\t        const execution_order = this._getExecutionOrder(parentRunId);\n\t        const start_time = Date.now();\n\t        const finalExtraParams = metadata\n\t            ? { ...extraParams, metadata }\n\t            : extraParams;\n\t        const run = {\n\t            id: runId,\n\t            name: name ?? llm.id[llm.id.length - 1],\n\t            parent_run_id: parentRunId,\n\t            start_time,\n\t            serialized: llm,\n\t            events: [\n\t                {\n\t                    name: \"start\",\n\t                    time: new Date(start_time).toISOString(),\n\t                },\n\t            ],\n\t            inputs: { messages },\n\t            execution_order,\n\t            child_runs: [],\n\t            child_execution_order: execution_order,\n\t            run_type: \"llm\",\n\t            extra: finalExtraParams ?? {},\n\t            tags: tags || [],\n\t        };\n\t        return this._addRunToRunMap(run);\n\t    }\n\t    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n\t        const run = this.runMap.get(runId) ??\n\t            this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n\t        await this.onRunCreate?.(run);\n\t        await this.onLLMStart?.(run);\n\t        return run;\n\t    }\n\t    async handleLLMEnd(output, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"llm\") {\n\t            throw new Error(\"No LLM run to end.\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.outputs = output;\n\t        run.events.push({\n\t            name: \"end\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        await this.onLLMEnd?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    async handleLLMError(error, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"llm\") {\n\t            throw new Error(\"No LLM run to end.\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.error = this.stringifyError(error);\n\t        run.events.push({\n\t            name: \"error\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        await this.onLLMError?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    /**\n\t     * Create and add a run to the run map for chain start events.\n\t     * This must sometimes be done synchronously to avoid race conditions\n\t     * when callbacks are backgrounded, so we expose it as a separate method here.\n\t     */\n\t    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n\t        const execution_order = this._getExecutionOrder(parentRunId);\n\t        const start_time = Date.now();\n\t        const run = {\n\t            id: runId,\n\t            name: name ?? chain.id[chain.id.length - 1],\n\t            parent_run_id: parentRunId,\n\t            start_time,\n\t            serialized: chain,\n\t            events: [\n\t                {\n\t                    name: \"start\",\n\t                    time: new Date(start_time).toISOString(),\n\t                },\n\t            ],\n\t            inputs,\n\t            execution_order,\n\t            child_execution_order: execution_order,\n\t            run_type: runType ?? \"chain\",\n\t            child_runs: [],\n\t            extra: metadata ? { metadata } : {},\n\t            tags: tags || [],\n\t        };\n\t        return this._addRunToRunMap(run);\n\t    }\n\t    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n\t        const run = this.runMap.get(runId) ??\n\t            this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n\t        await this.onRunCreate?.(run);\n\t        await this.onChainStart?.(run);\n\t        return run;\n\t    }\n\t    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run) {\n\t            throw new Error(\"No chain run to end.\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.outputs = _coerceToDict$2(outputs, \"output\");\n\t        run.events.push({\n\t            name: \"end\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        if (kwargs?.inputs !== undefined) {\n\t            run.inputs = _coerceToDict$2(kwargs.inputs, \"input\");\n\t        }\n\t        await this.onChainEnd?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run) {\n\t            throw new Error(\"No chain run to end.\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.error = this.stringifyError(error);\n\t        run.events.push({\n\t            name: \"error\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        if (kwargs?.inputs !== undefined) {\n\t            run.inputs = _coerceToDict$2(kwargs.inputs, \"input\");\n\t        }\n\t        await this.onChainError?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    /**\n\t     * Create and add a run to the run map for tool start events.\n\t     * This must sometimes be done synchronously to avoid race conditions\n\t     * when callbacks are backgrounded, so we expose it as a separate method here.\n\t     */\n\t    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n\t        const execution_order = this._getExecutionOrder(parentRunId);\n\t        const start_time = Date.now();\n\t        const run = {\n\t            id: runId,\n\t            name: name ?? tool.id[tool.id.length - 1],\n\t            parent_run_id: parentRunId,\n\t            start_time,\n\t            serialized: tool,\n\t            events: [\n\t                {\n\t                    name: \"start\",\n\t                    time: new Date(start_time).toISOString(),\n\t                },\n\t            ],\n\t            inputs: { input },\n\t            execution_order,\n\t            child_execution_order: execution_order,\n\t            run_type: \"tool\",\n\t            child_runs: [],\n\t            extra: metadata ? { metadata } : {},\n\t            tags: tags || [],\n\t        };\n\t        return this._addRunToRunMap(run);\n\t    }\n\t    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n\t        const run = this.runMap.get(runId) ??\n\t            this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n\t        await this.onRunCreate?.(run);\n\t        await this.onToolStart?.(run);\n\t        return run;\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    async handleToolEnd(output, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"tool\") {\n\t            throw new Error(\"No tool run to end\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.outputs = { output };\n\t        run.events.push({\n\t            name: \"end\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        await this.onToolEnd?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    async handleToolError(error, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"tool\") {\n\t            throw new Error(\"No tool run to end\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.error = this.stringifyError(error);\n\t        run.events.push({\n\t            name: \"error\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        await this.onToolError?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    async handleAgentAction(action, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"chain\") {\n\t            return;\n\t        }\n\t        const agentRun = run;\n\t        agentRun.actions = agentRun.actions || [];\n\t        agentRun.actions.push(action);\n\t        agentRun.events.push({\n\t            name: \"agent_action\",\n\t            time: new Date().toISOString(),\n\t            kwargs: { action },\n\t        });\n\t        await this.onAgentAction?.(run);\n\t    }\n\t    async handleAgentEnd(action, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"chain\") {\n\t            return;\n\t        }\n\t        run.events.push({\n\t            name: \"agent_end\",\n\t            time: new Date().toISOString(),\n\t            kwargs: { action },\n\t        });\n\t        await this.onAgentEnd?.(run);\n\t    }\n\t    /**\n\t     * Create and add a run to the run map for retriever start events.\n\t     * This must sometimes be done synchronously to avoid race conditions\n\t     * when callbacks are backgrounded, so we expose it as a separate method here.\n\t     */\n\t    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n\t        const execution_order = this._getExecutionOrder(parentRunId);\n\t        const start_time = Date.now();\n\t        const run = {\n\t            id: runId,\n\t            name: name ?? retriever.id[retriever.id.length - 1],\n\t            parent_run_id: parentRunId,\n\t            start_time,\n\t            serialized: retriever,\n\t            events: [\n\t                {\n\t                    name: \"start\",\n\t                    time: new Date(start_time).toISOString(),\n\t                },\n\t            ],\n\t            inputs: { query },\n\t            execution_order,\n\t            child_execution_order: execution_order,\n\t            run_type: \"retriever\",\n\t            child_runs: [],\n\t            extra: metadata ? { metadata } : {},\n\t            tags: tags || [],\n\t        };\n\t        return this._addRunToRunMap(run);\n\t    }\n\t    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n\t        const run = this.runMap.get(runId) ??\n\t            this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n\t        await this.onRunCreate?.(run);\n\t        await this.onRetrieverStart?.(run);\n\t        return run;\n\t    }\n\t    async handleRetrieverEnd(documents, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"retriever\") {\n\t            throw new Error(\"No retriever run to end\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.outputs = { documents };\n\t        run.events.push({\n\t            name: \"end\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        await this.onRetrieverEnd?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    async handleRetrieverError(error, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"retriever\") {\n\t            throw new Error(\"No retriever run to end\");\n\t        }\n\t        run.end_time = Date.now();\n\t        run.error = this.stringifyError(error);\n\t        run.events.push({\n\t            name: \"error\",\n\t            time: new Date(run.end_time).toISOString(),\n\t        });\n\t        await this.onRetrieverError?.(run);\n\t        await this._endTrace(run);\n\t        return run;\n\t    }\n\t    async handleText(text, runId) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"chain\") {\n\t            return;\n\t        }\n\t        run.events.push({\n\t            name: \"text\",\n\t            time: new Date().toISOString(),\n\t            kwargs: { text },\n\t        });\n\t        await this.onText?.(run);\n\t    }\n\t    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n\t        const run = this.runMap.get(runId);\n\t        if (!run || run?.run_type !== \"llm\") {\n\t            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n\t        }\n\t        run.events.push({\n\t            name: \"new_token\",\n\t            time: new Date().toISOString(),\n\t            kwargs: { token, idx, chunk: fields?.chunk },\n\t        });\n\t        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n\t        return run;\n\t    }\n\t}\n\tbase$1.BaseTracer = BaseTracer;\n\n\tvar stream = {};\n\n\tvar singletons = {};\n\n\tvar dist$1 = {};\n\n\tvar client = {};\n\n\tvar async_caller$1 = {};\n\n\tvar dist = {};\n\n\tvar eventemitter3 = {exports: {}};\n\n\t(function (module) {\n\n\t\tvar has = Object.prototype.hasOwnProperty\n\t\t  , prefix = '~';\n\n\t\t/**\n\t\t * Constructor to create a storage for our `EE` objects.\n\t\t * An `Events` instance is a plain object whose properties are event names.\n\t\t *\n\t\t * @constructor\n\t\t * @private\n\t\t */\n\t\tfunction Events() {}\n\n\t\t//\n\t\t// We try to not inherit from `Object.prototype`. In some engines creating an\n\t\t// instance in this way is faster than calling `Object.create(null)` directly.\n\t\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t\t// character to make sure that the built-in object properties are not\n\t\t// overridden or used as an attack vector.\n\t\t//\n\t\tif (Object.create) {\n\t\t  Events.prototype = Object.create(null);\n\n\t\t  //\n\t\t  // This hack is needed because the `__proto__` property is still inherited in\n\t\t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n\t\t  //\n\t\t  if (!new Events().__proto__) prefix = false;\n\t\t}\n\n\t\t/**\n\t\t * Representation of a single event listener.\n\t\t *\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} context The context to invoke the listener with.\n\t\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t\t * @constructor\n\t\t * @private\n\t\t */\n\t\tfunction EE(fn, context, once) {\n\t\t  this.fn = fn;\n\t\t  this.context = context;\n\t\t  this.once = once || false;\n\t\t}\n\n\t\t/**\n\t\t * Add a listener for a given event.\n\t\t *\n\t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} context The context to invoke the listener with.\n\t\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t\t * @returns {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tfunction addListener(emitter, event, fn, context, once) {\n\t\t  if (typeof fn !== 'function') {\n\t\t    throw new TypeError('The listener must be a function');\n\t\t  }\n\n\t\t  var listener = new EE(fn, context || emitter, once)\n\t\t    , evt = prefix ? prefix + event : event;\n\n\t\t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n\t\t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n\t\t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n\t\t  return emitter;\n\t\t}\n\n\t\t/**\n\t\t * Clear event by name.\n\t\t *\n\t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t\t * @param {(String|Symbol)} evt The Event name.\n\t\t * @private\n\t\t */\n\t\tfunction clearEvent(emitter, evt) {\n\t\t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n\t\t  else delete emitter._events[evt];\n\t\t}\n\n\t\t/**\n\t\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t\t * `EventEmitter` interface.\n\t\t *\n\t\t * @constructor\n\t\t * @public\n\t\t */\n\t\tfunction EventEmitter() {\n\t\t  this._events = new Events();\n\t\t  this._eventsCount = 0;\n\t\t}\n\n\t\t/**\n\t\t * Return an array listing the events for which the emitter has registered\n\t\t * listeners.\n\t\t *\n\t\t * @returns {Array}\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.eventNames = function eventNames() {\n\t\t  var names = []\n\t\t    , events\n\t\t    , name;\n\n\t\t  if (this._eventsCount === 0) return names;\n\n\t\t  for (name in (events = this._events)) {\n\t\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t\t  }\n\n\t\t  if (Object.getOwnPropertySymbols) {\n\t\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t\t  }\n\n\t\t  return names;\n\t\t};\n\n\t\t/**\n\t\t * Return the listeners registered for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Array} The registered listeners.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.listeners = function listeners(event) {\n\t\t  var evt = prefix ? prefix + event : event\n\t\t    , handlers = this._events[evt];\n\n\t\t  if (!handlers) return [];\n\t\t  if (handlers.fn) return [handlers.fn];\n\n\t\t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n\t\t    ee[i] = handlers[i].fn;\n\t\t  }\n\n\t\t  return ee;\n\t\t};\n\n\t\t/**\n\t\t * Return the number of listeners listening to a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Number} The number of listeners.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n\t\t  var evt = prefix ? prefix + event : event\n\t\t    , listeners = this._events[evt];\n\n\t\t  if (!listeners) return 0;\n\t\t  if (listeners.fn) return 1;\n\t\t  return listeners.length;\n\t\t};\n\n\t\t/**\n\t\t * Calls each of the listeners registered for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t\t  var evt = prefix ? prefix + event : event;\n\n\t\t  if (!this._events[evt]) return false;\n\n\t\t  var listeners = this._events[evt]\n\t\t    , len = arguments.length\n\t\t    , args\n\t\t    , i;\n\n\t\t  if (listeners.fn) {\n\t\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n\t\t    switch (len) {\n\t\t      case 1: return listeners.fn.call(listeners.context), true;\n\t\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t\t    }\n\n\t\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t\t      args[i - 1] = arguments[i];\n\t\t    }\n\n\t\t    listeners.fn.apply(listeners.context, args);\n\t\t  } else {\n\t\t    var length = listeners.length\n\t\t      , j;\n\n\t\t    for (i = 0; i < length; i++) {\n\t\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n\t\t      switch (len) {\n\t\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t\t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n\t\t        default:\n\t\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t\t            args[j - 1] = arguments[j];\n\t\t          }\n\n\t\t          listeners[i].fn.apply(listeners[i].context, args);\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return true;\n\t\t};\n\n\t\t/**\n\t\t * Add a listener for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} [context=this] The context to invoke the listener with.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t\t  return addListener(this, event, fn, context, false);\n\t\t};\n\n\t\t/**\n\t\t * Add a one-time listener for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} [context=this] The context to invoke the listener with.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t\t  return addListener(this, event, fn, context, true);\n\t\t};\n\n\t\t/**\n\t\t * Remove the listeners of a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn Only remove the listeners that match this function.\n\t\t * @param {*} context Only remove the listeners that have this context.\n\t\t * @param {Boolean} once Only remove one-time listeners.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t\t  var evt = prefix ? prefix + event : event;\n\n\t\t  if (!this._events[evt]) return this;\n\t\t  if (!fn) {\n\t\t    clearEvent(this, evt);\n\t\t    return this;\n\t\t  }\n\n\t\t  var listeners = this._events[evt];\n\n\t\t  if (listeners.fn) {\n\t\t    if (\n\t\t      listeners.fn === fn &&\n\t\t      (!once || listeners.once) &&\n\t\t      (!context || listeners.context === context)\n\t\t    ) {\n\t\t      clearEvent(this, evt);\n\t\t    }\n\t\t  } else {\n\t\t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n\t\t      if (\n\t\t        listeners[i].fn !== fn ||\n\t\t        (once && !listeners[i].once) ||\n\t\t        (context && listeners[i].context !== context)\n\t\t      ) {\n\t\t        events.push(listeners[i]);\n\t\t      }\n\t\t    }\n\n\t\t    //\n\t\t    // Reset the array, or remove it completely if we have no more listeners.\n\t\t    //\n\t\t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n\t\t    else clearEvent(this, evt);\n\t\t  }\n\n\t\t  return this;\n\t\t};\n\n\t\t/**\n\t\t * Remove all listeners, or those of the specified event.\n\t\t *\n\t\t * @param {(String|Symbol)} [event] The event name.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t\t  var evt;\n\n\t\t  if (event) {\n\t\t    evt = prefix ? prefix + event : event;\n\t\t    if (this._events[evt]) clearEvent(this, evt);\n\t\t  } else {\n\t\t    this._events = new Events();\n\t\t    this._eventsCount = 0;\n\t\t  }\n\n\t\t  return this;\n\t\t};\n\n\t\t//\n\t\t// Alias methods names because people roll like that.\n\t\t//\n\t\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\t\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n\t\t//\n\t\t// Expose the prefix.\n\t\t//\n\t\tEventEmitter.prefixed = prefix;\n\n\t\t//\n\t\t// Allow `EventEmitter` to be imported as module namespace.\n\t\t//\n\t\tEventEmitter.EventEmitter = EventEmitter;\n\n\t\t//\n\t\t// Expose the module.\n\t\t//\n\t\t{\n\t\t  module.exports = EventEmitter;\n\t\t} \n\t} (eventemitter3));\n\n\tvar eventemitter3Exports = eventemitter3.exports;\n\n\tvar pTimeout$1 = {exports: {}};\n\n\tvar pFinally$1 = (promise, onFinally) => {\n\t\tonFinally = onFinally || (() => {});\n\n\t\treturn promise.then(\n\t\t\tval => new Promise(resolve => {\n\t\t\t\tresolve(onFinally());\n\t\t\t}).then(() => val),\n\t\t\terr => new Promise(resolve => {\n\t\t\t\tresolve(onFinally());\n\t\t\t}).then(() => {\n\t\t\t\tthrow err;\n\t\t\t})\n\t\t);\n\t};\n\n\tconst pFinally = pFinally$1;\n\n\tclass TimeoutError extends Error {\n\t\tconstructor(message) {\n\t\t\tsuper(message);\n\t\t\tthis.name = 'TimeoutError';\n\t\t}\n\t}\n\n\tconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t\t}\n\n\t\tif (milliseconds === Infinity) {\n\t\t\tresolve(promise);\n\t\t\treturn;\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tif (typeof fallback === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\treject(timeoutError);\n\t\t}, milliseconds);\n\n\t\t// TODO: Use native `finally` keyword when targeting Node.js 10\n\t\tpFinally(\n\t\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\t\tpromise.then(resolve, reject),\n\t\t\t() => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t}\n\t\t);\n\t});\n\n\tpTimeout$1.exports = pTimeout;\n\t// TODO: Remove this for the next major release\n\tpTimeout$1.exports.default = pTimeout;\n\n\tpTimeout$1.exports.TimeoutError = TimeoutError;\n\n\tvar pTimeoutExports = pTimeout$1.exports;\n\n\tvar priorityQueue = {};\n\n\tvar lowerBound$1 = {};\n\n\tObject.defineProperty(lowerBound$1, \"__esModule\", { value: true });\n\t// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n\t// Used to compute insertion index to keep queue sorted after insertion\n\tfunction lowerBound(array, value, comparator) {\n\t    let first = 0;\n\t    let count = array.length;\n\t    while (count > 0) {\n\t        const step = (count / 2) | 0;\n\t        let it = first + step;\n\t        if (comparator(array[it], value) <= 0) {\n\t            first = ++it;\n\t            count -= step + 1;\n\t        }\n\t        else {\n\t            count = step;\n\t        }\n\t    }\n\t    return first;\n\t}\n\tlowerBound$1.default = lowerBound;\n\n\tObject.defineProperty(priorityQueue, \"__esModule\", { value: true });\n\tconst lower_bound_1 = lowerBound$1;\n\tclass PriorityQueue {\n\t    constructor() {\n\t        this._queue = [];\n\t    }\n\t    enqueue(run, options) {\n\t        options = Object.assign({ priority: 0 }, options);\n\t        const element = {\n\t            priority: options.priority,\n\t            run\n\t        };\n\t        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n\t            this._queue.push(element);\n\t            return;\n\t        }\n\t        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);\n\t        this._queue.splice(index, 0, element);\n\t    }\n\t    dequeue() {\n\t        const item = this._queue.shift();\n\t        return item === null || item === void 0 ? void 0 : item.run;\n\t    }\n\t    filter(options) {\n\t        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n\t    }\n\t    get size() {\n\t        return this._queue.length;\n\t    }\n\t}\n\tpriorityQueue.default = PriorityQueue;\n\n\tObject.defineProperty(dist, \"__esModule\", { value: true });\n\tconst EventEmitter = eventemitter3Exports;\n\tconst p_timeout_1 = pTimeoutExports;\n\tconst priority_queue_1 = priorityQueue;\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tconst empty = () => { };\n\tconst timeoutError = new p_timeout_1.TimeoutError();\n\t/**\n\tPromise queue with concurrency control.\n\t*/\n\tclass PQueue extends EventEmitter {\n\t    constructor(options) {\n\t        var _a, _b, _c, _d;\n\t        super();\n\t        this._intervalCount = 0;\n\t        this._intervalEnd = 0;\n\t        this._pendingCount = 0;\n\t        this._resolveEmpty = empty;\n\t        this._resolveIdle = empty;\n\t        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\t        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);\n\t        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n\t            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n\t        }\n\t        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n\t            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n\t        }\n\t        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n\t        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n\t        this._intervalCap = options.intervalCap;\n\t        this._interval = options.interval;\n\t        this._queue = new options.queueClass();\n\t        this._queueClass = options.queueClass;\n\t        this.concurrency = options.concurrency;\n\t        this._timeout = options.timeout;\n\t        this._throwOnTimeout = options.throwOnTimeout === true;\n\t        this._isPaused = options.autoStart === false;\n\t    }\n\t    get _doesIntervalAllowAnother() {\n\t        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n\t    }\n\t    get _doesConcurrentAllowAnother() {\n\t        return this._pendingCount < this._concurrency;\n\t    }\n\t    _next() {\n\t        this._pendingCount--;\n\t        this._tryToStartAnother();\n\t        this.emit('next');\n\t    }\n\t    _resolvePromises() {\n\t        this._resolveEmpty();\n\t        this._resolveEmpty = empty;\n\t        if (this._pendingCount === 0) {\n\t            this._resolveIdle();\n\t            this._resolveIdle = empty;\n\t            this.emit('idle');\n\t        }\n\t    }\n\t    _onResumeInterval() {\n\t        this._onInterval();\n\t        this._initializeIntervalIfNeeded();\n\t        this._timeoutId = undefined;\n\t    }\n\t    _isIntervalPaused() {\n\t        const now = Date.now();\n\t        if (this._intervalId === undefined) {\n\t            const delay = this._intervalEnd - now;\n\t            if (delay < 0) {\n\t                // Act as the interval was done\n\t                // We don't need to resume it here because it will be resumed on line 160\n\t                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n\t            }\n\t            else {\n\t                // Act as the interval is pending\n\t                if (this._timeoutId === undefined) {\n\t                    this._timeoutId = setTimeout(() => {\n\t                        this._onResumeInterval();\n\t                    }, delay);\n\t                }\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    _tryToStartAnother() {\n\t        if (this._queue.size === 0) {\n\t            // We can clear the interval (\"pause\")\n\t            // Because we can redo it later (\"resume\")\n\t            if (this._intervalId) {\n\t                clearInterval(this._intervalId);\n\t            }\n\t            this._intervalId = undefined;\n\t            this._resolvePromises();\n\t            return false;\n\t        }\n\t        if (!this._isPaused) {\n\t            const canInitializeInterval = !this._isIntervalPaused();\n\t            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n\t                const job = this._queue.dequeue();\n\t                if (!job) {\n\t                    return false;\n\t                }\n\t                this.emit('active');\n\t                job();\n\t                if (canInitializeInterval) {\n\t                    this._initializeIntervalIfNeeded();\n\t                }\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    _initializeIntervalIfNeeded() {\n\t        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n\t            return;\n\t        }\n\t        this._intervalId = setInterval(() => {\n\t            this._onInterval();\n\t        }, this._interval);\n\t        this._intervalEnd = Date.now() + this._interval;\n\t    }\n\t    _onInterval() {\n\t        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n\t            clearInterval(this._intervalId);\n\t            this._intervalId = undefined;\n\t        }\n\t        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\t        this._processQueue();\n\t    }\n\t    /**\n\t    Executes all queued functions until it reaches the limit.\n\t    */\n\t    _processQueue() {\n\t        // eslint-disable-next-line no-empty\n\t        while (this._tryToStartAnother()) { }\n\t    }\n\t    get concurrency() {\n\t        return this._concurrency;\n\t    }\n\t    set concurrency(newConcurrency) {\n\t        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n\t            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n\t        }\n\t        this._concurrency = newConcurrency;\n\t        this._processQueue();\n\t    }\n\t    /**\n\t    Adds a sync or async task to the queue. Always returns a promise.\n\t    */\n\t    async add(fn, options = {}) {\n\t        return new Promise((resolve, reject) => {\n\t            const run = async () => {\n\t                this._pendingCount++;\n\t                this._intervalCount++;\n\t                try {\n\t                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n\t                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n\t                            reject(timeoutError);\n\t                        }\n\t                        return undefined;\n\t                    });\n\t                    resolve(await operation);\n\t                }\n\t                catch (error) {\n\t                    reject(error);\n\t                }\n\t                this._next();\n\t            };\n\t            this._queue.enqueue(run, options);\n\t            this._tryToStartAnother();\n\t            this.emit('add');\n\t        });\n\t    }\n\t    /**\n\t    Same as `.add()`, but accepts an array of sync or async functions.\n\n\t    @returns A promise that resolves when all functions are resolved.\n\t    */\n\t    async addAll(functions, options) {\n\t        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n\t    }\n\t    /**\n\t    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n\t    */\n\t    start() {\n\t        if (!this._isPaused) {\n\t            return this;\n\t        }\n\t        this._isPaused = false;\n\t        this._processQueue();\n\t        return this;\n\t    }\n\t    /**\n\t    Put queue execution on hold.\n\t    */\n\t    pause() {\n\t        this._isPaused = true;\n\t    }\n\t    /**\n\t    Clear the queue.\n\t    */\n\t    clear() {\n\t        this._queue = new this._queueClass();\n\t    }\n\t    /**\n\t    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n\t    @returns A promise that settles when the queue becomes empty.\n\t    */\n\t    async onEmpty() {\n\t        // Instantly resolve if the queue is empty\n\t        if (this._queue.size === 0) {\n\t            return;\n\t        }\n\t        return new Promise(resolve => {\n\t            const existingResolve = this._resolveEmpty;\n\t            this._resolveEmpty = () => {\n\t                existingResolve();\n\t                resolve();\n\t            };\n\t        });\n\t    }\n\t    /**\n\t    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n\t    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n\t    */\n\t    async onIdle() {\n\t        // Instantly resolve if none pending and if nothing else is queued\n\t        if (this._pendingCount === 0 && this._queue.size === 0) {\n\t            return;\n\t        }\n\t        return new Promise(resolve => {\n\t            const existingResolve = this._resolveIdle;\n\t            this._resolveIdle = () => {\n\t                existingResolve();\n\t                resolve();\n\t            };\n\t        });\n\t    }\n\t    /**\n\t    Size of the queue.\n\t    */\n\t    get size() {\n\t        return this._queue.size;\n\t    }\n\t    /**\n\t    Size of the queue, filtered by the given options.\n\n\t    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n\t    */\n\t    sizeBy(options) {\n\t        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n\t        return this._queue.filter(options).length;\n\t    }\n\t    /**\n\t    Number of pending promises.\n\t    */\n\t    get pending() {\n\t        return this._pendingCount;\n\t    }\n\t    /**\n\t    Whether the queue is currently paused.\n\t    */\n\t    get isPaused() {\n\t        return this._isPaused;\n\t    }\n\t    get timeout() {\n\t        return this._timeout;\n\t    }\n\t    /**\n\t    Set the timeout for future operations.\n\t    */\n\t    set timeout(milliseconds) {\n\t        this._timeout = milliseconds;\n\t    }\n\t}\n\tdist.default = PQueue;\n\n\tvar fetch$1 = {};\n\n\tObject.defineProperty(fetch$1, \"__esModule\", { value: true });\n\tfetch$1._getFetchImplementation = fetch$1.overrideFetchImplementation = void 0;\n\t// Wrap the default fetch call due to issues with illegal invocations\n\t// in some environments:\n\t// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n\t// @ts-expect-error Broad typing to support a range of fetch implementations\n\tconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\n\tconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n\t/**\n\t * Overrides the fetch implementation used for LangSmith calls.\n\t * You should use this if you need to use an implementation of fetch\n\t * other than the default global (e.g. for dealing with proxies).\n\t * @param fetch The new fetch functino to use.\n\t */\n\tconst overrideFetchImplementation = (fetch) => {\n\t    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n\t};\n\tfetch$1.overrideFetchImplementation = overrideFetchImplementation;\n\t/**\n\t * @internal\n\t */\n\tconst _getFetchImplementation = () => {\n\t    return (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n\t        DEFAULT_FETCH_IMPLEMENTATION);\n\t};\n\tfetch$1._getFetchImplementation = _getFetchImplementation;\n\n\tvar __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(async_caller$1, \"__esModule\", { value: true });\n\tasync_caller$1.AsyncCaller = void 0;\n\tconst p_retry_1$2 = __importDefault$4(pRetryExports);\n\tconst p_queue_1$2 = __importDefault$4(dist);\n\tconst fetch_js_1 = fetch$1;\n\tconst STATUS_NO_RETRY$1 = [\n\t    400, // Bad Request\n\t    401, // Unauthorized\n\t    403, // Forbidden\n\t    404, // Not Found\n\t    405, // Method Not Allowed\n\t    406, // Not Acceptable\n\t    407, // Proxy Authentication Required\n\t    408, // Request Timeout\n\t];\n\tconst STATUS_IGNORE = [\n\t    409, // Conflict\n\t];\n\t/**\n\t * A class that can be used to make async calls with concurrency and retry logic.\n\t *\n\t * This is useful for making calls to any kind of \"expensive\" external resource,\n\t * be it because it's rate-limited, subject to network issues, etc.\n\t *\n\t * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n\t * to `Infinity`. This means that by default, all calls will be made in parallel.\n\t *\n\t * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n\t * means that by default, each call will be retried up to 6 times, with an\n\t * exponential backoff between each attempt.\n\t */\n\tlet AsyncCaller$1 = class AsyncCaller {\n\t    constructor(params) {\n\t        Object.defineProperty(this, \"maxConcurrency\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"maxRetries\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"queue\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"onFailedResponseHook\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n\t        this.maxRetries = params.maxRetries ?? 6;\n\t        if (\"default\" in p_queue_1$2.default) {\n\t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t            this.queue = new p_queue_1$2.default.default({\n\t                concurrency: this.maxConcurrency,\n\t            });\n\t        }\n\t        else {\n\t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t            this.queue = new p_queue_1$2.default({ concurrency: this.maxConcurrency });\n\t        }\n\t        this.onFailedResponseHook = params?.onFailedResponseHook;\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    call(callable, ...args) {\n\t        const onFailedResponseHook = this.onFailedResponseHook;\n\t        return this.queue.add(() => (0, p_retry_1$2.default)(() => callable(...args).catch((error) => {\n\t            // eslint-disable-next-line no-instanceof/no-instanceof\n\t            if (error instanceof Error) {\n\t                throw error;\n\t            }\n\t            else {\n\t                throw new Error(error);\n\t            }\n\t        }), {\n\t            async onFailedAttempt(error) {\n\t                if (error.message.startsWith(\"Cancel\") ||\n\t                    error.message.startsWith(\"TimeoutError\") ||\n\t                    error.message.startsWith(\"AbortError\")) {\n\t                    throw error;\n\t                }\n\t                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t                if (error?.code === \"ECONNABORTED\") {\n\t                    throw error;\n\t                }\n\t                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t                const response = error?.response;\n\t                const status = response?.status;\n\t                if (status) {\n\t                    if (STATUS_NO_RETRY$1.includes(+status)) {\n\t                        throw error;\n\t                    }\n\t                    else if (STATUS_IGNORE.includes(+status)) {\n\t                        return;\n\t                    }\n\t                    if (onFailedResponseHook) {\n\t                        await onFailedResponseHook(response);\n\t                    }\n\t                }\n\t            },\n\t            // If needed we can change some of the defaults here,\n\t            // but they're quite sensible.\n\t            retries: this.maxRetries,\n\t            randomize: true,\n\t        }), { throwOnTimeout: true });\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    callWithOptions(options, callable, ...args) {\n\t        // Note this doesn't cancel the underlying request,\n\t        // when available prefer to use the signal option of the underlying call\n\t        if (options.signal) {\n\t            return Promise.race([\n\t                this.call(callable, ...args),\n\t                new Promise((_, reject) => {\n\t                    options.signal?.addEventListener(\"abort\", () => {\n\t                        reject(new Error(\"AbortError\"));\n\t                    });\n\t                }),\n\t            ]);\n\t        }\n\t        return this.call(callable, ...args);\n\t    }\n\t    fetch(...args) {\n\t        return this.call(() => (0, fetch_js_1._getFetchImplementation)()(...args).then((res) => res.ok ? res : Promise.reject(res)));\n\t    }\n\t};\n\tasync_caller$1.AsyncCaller = AsyncCaller$1;\n\n\tvar messages$1 = {};\n\n\tObject.defineProperty(messages$1, \"__esModule\", { value: true });\n\tmessages$1.convertLangChainMessageToExample = messages$1.isLangChainMessage = void 0;\n\tfunction isLangChainMessage(\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tmessage) {\n\t    return typeof message?._getType === \"function\";\n\t}\n\tmessages$1.isLangChainMessage = isLangChainMessage;\n\tfunction convertLangChainMessageToExample(message) {\n\t    const converted = {\n\t        type: message._getType(),\n\t        data: { content: message.content },\n\t    };\n\t    // Check for presence of keys in additional_kwargs\n\t    if (message?.additional_kwargs &&\n\t        Object.keys(message.additional_kwargs).length > 0) {\n\t        converted.data.additional_kwargs = { ...message.additional_kwargs };\n\t    }\n\t    return converted;\n\t}\n\tmessages$1.convertLangChainMessageToExample = convertLangChainMessageToExample;\n\n\tvar env$1 = {};\n\n\tvar hasRequiredEnv$1;\n\n\tfunction requireEnv$1 () {\n\t\tif (hasRequiredEnv$1) return env$1;\n\t\thasRequiredEnv$1 = 1;\n\t\t(function (exports) {\n\t\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\t\texports.getShas = exports.setEnvironmentVariable = exports.getLangSmithEnvironmentVariable = exports.getEnvironmentVariable = exports.getEnvironmentVariables = exports.getLangChainEnvVarsMetadata = exports.getLangChainEnvVars = exports.getRuntimeEnvironment = exports.getEnv = exports.isNode = exports.isDeno = exports.isJsDom = exports.isWebWorker = exports.isBrowser = void 0;\n\t\t\t// Inlined from https://github.com/flexdinesh/browser-or-node\n\t\t\tconst index_js_1 = requireDist();\n\t\t\tlet globalEnv;\n\t\t\tconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\t\t\texports.isBrowser = isBrowser;\n\t\t\tconst isWebWorker = () => typeof globalThis === \"object\" &&\n\t\t\t    globalThis.constructor &&\n\t\t\t    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\n\t\t\texports.isWebWorker = isWebWorker;\n\t\t\tconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n\t\t\t    (typeof navigator !== \"undefined\" &&\n\t\t\t        (navigator.userAgent.includes(\"Node.js\") ||\n\t\t\t            navigator.userAgent.includes(\"jsdom\")));\n\t\t\texports.isJsDom = isJsDom;\n\t\t\t// Supabase Edge Function provides a `Deno` global object\n\t\t\t// without `version` property\n\t\t\tconst isDeno = () => typeof Deno !== \"undefined\";\n\t\t\texports.isDeno = isDeno;\n\t\t\t// Mark not-as-node if in Supabase Edge Function\n\t\t\tconst isNode = () => typeof browser$1 !== \"undefined\" &&\n\t\t\t    typeof browser$1.versions !== \"undefined\" &&\n\t\t\t    typeof \"18.15.0\" !== \"undefined\" &&\n\t\t\t    !(0, exports.isDeno)();\n\t\t\texports.isNode = isNode;\n\t\t\tconst getEnv = () => {\n\t\t\t    if (globalEnv) {\n\t\t\t        return globalEnv;\n\t\t\t    }\n\t\t\t    if ((0, exports.isBrowser)()) {\n\t\t\t        globalEnv = \"browser\";\n\t\t\t    }\n\t\t\t    else if ((0, exports.isNode)()) {\n\t\t\t        globalEnv = \"node\";\n\t\t\t    }\n\t\t\t    else if ((0, exports.isWebWorker)()) {\n\t\t\t        globalEnv = \"webworker\";\n\t\t\t    }\n\t\t\t    else if ((0, exports.isJsDom)()) {\n\t\t\t        globalEnv = \"jsdom\";\n\t\t\t    }\n\t\t\t    else if ((0, exports.isDeno)()) {\n\t\t\t        globalEnv = \"deno\";\n\t\t\t    }\n\t\t\t    else {\n\t\t\t        globalEnv = \"other\";\n\t\t\t    }\n\t\t\t    return globalEnv;\n\t\t\t};\n\t\t\texports.getEnv = getEnv;\n\t\t\tlet runtimeEnvironment;\n\t\t\tasync function getRuntimeEnvironment() {\n\t\t\t    if (runtimeEnvironment === undefined) {\n\t\t\t        const env = (0, exports.getEnv)();\n\t\t\t        const releaseEnv = getShas();\n\t\t\t        runtimeEnvironment = {\n\t\t\t            library: \"langsmith\",\n\t\t\t            runtime: env,\n\t\t\t            sdk: \"langsmith-js\",\n\t\t\t            sdk_version: index_js_1.__version__,\n\t\t\t            ...releaseEnv,\n\t\t\t        };\n\t\t\t    }\n\t\t\t    return runtimeEnvironment;\n\t\t\t}\n\t\t\texports.getRuntimeEnvironment = getRuntimeEnvironment;\n\t\t\t/**\n\t\t\t * Retrieves the LangChain-specific environment variables from the current runtime environment.\n\t\t\t * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n\t\t\t *\n\t\t\t * @returns {Record<string, string>}\n\t\t\t *  - A record of LangChain-specific environment variables.\n\t\t\t */\n\t\t\tfunction getLangChainEnvVars() {\n\t\t\t    const allEnvVars = getEnvironmentVariables() || {};\n\t\t\t    const envVars = {};\n\t\t\t    for (const [key, value] of Object.entries(allEnvVars)) {\n\t\t\t        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n\t\t\t            envVars[key] = value;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    for (const key in envVars) {\n\t\t\t        if ((key.toLowerCase().includes(\"key\") ||\n\t\t\t            key.toLowerCase().includes(\"secret\") ||\n\t\t\t            key.toLowerCase().includes(\"token\")) &&\n\t\t\t            typeof envVars[key] === \"string\") {\n\t\t\t            const value = envVars[key];\n\t\t\t            envVars[key] =\n\t\t\t                value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n\t\t\t        }\n\t\t\t    }\n\t\t\t    return envVars;\n\t\t\t}\n\t\t\texports.getLangChainEnvVars = getLangChainEnvVars;\n\t\t\t/**\n\t\t\t * Retrieves the LangChain-specific metadata from the current runtime environment.\n\t\t\t *\n\t\t\t * @returns {Record<string, string>}\n\t\t\t *  - A record of LangChain-specific metadata environment variables.\n\t\t\t */\n\t\t\tfunction getLangChainEnvVarsMetadata() {\n\t\t\t    const allEnvVars = getEnvironmentVariables() || {};\n\t\t\t    const envVars = {};\n\t\t\t    const excluded = [\n\t\t\t        \"LANGCHAIN_API_KEY\",\n\t\t\t        \"LANGCHAIN_ENDPOINT\",\n\t\t\t        \"LANGCHAIN_TRACING_V2\",\n\t\t\t        \"LANGCHAIN_PROJECT\",\n\t\t\t        \"LANGCHAIN_SESSION\",\n\t\t\t    ];\n\t\t\t    for (const [key, value] of Object.entries(allEnvVars)) {\n\t\t\t        if (key.startsWith(\"LANGCHAIN_\") &&\n\t\t\t            typeof value === \"string\" &&\n\t\t\t            !excluded.includes(key) &&\n\t\t\t            !key.toLowerCase().includes(\"key\") &&\n\t\t\t            !key.toLowerCase().includes(\"secret\") &&\n\t\t\t            !key.toLowerCase().includes(\"token\")) {\n\t\t\t            if (key === \"LANGCHAIN_REVISION_ID\") {\n\t\t\t                envVars[\"revision_id\"] = value;\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                envVars[key] = value;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    return envVars;\n\t\t\t}\n\t\t\texports.getLangChainEnvVarsMetadata = getLangChainEnvVarsMetadata;\n\t\t\t/**\n\t\t\t * Retrieves the environment variables from the current runtime environment.\n\t\t\t *\n\t\t\t * This function is designed to operate in a variety of JS environments,\n\t\t\t * including Node.js, Deno, browsers, etc.\n\t\t\t *\n\t\t\t * @returns {Record<string, string> | undefined}\n\t\t\t *  - A record of environment variables if available.\n\t\t\t *  - `undefined` if the environment does not support or allows access to environment variables.\n\t\t\t */\n\t\t\tfunction getEnvironmentVariables() {\n\t\t\t    try {\n\t\t\t        // Check for Node.js environment\n\t\t\t        // eslint-disable-next-line no-process-env\n\t\t\t        if (typeof browser$1 !== \"undefined\" && browser$1.env) {\n\t\t\t            // eslint-disable-next-line no-process-env\n\t\t\t            return Object.entries(browser$1.env).reduce((acc, [key, value]) => {\n\t\t\t                acc[key] = String(value);\n\t\t\t                return acc;\n\t\t\t            }, {});\n\t\t\t        }\n\t\t\t        // For browsers and other environments, we may not have direct access to env variables\n\t\t\t        // Return undefined or any other fallback as required.\n\t\t\t        return undefined;\n\t\t\t    }\n\t\t\t    catch (e) {\n\t\t\t        // Catch any errors that might occur while trying to access environment variables\n\t\t\t        return undefined;\n\t\t\t    }\n\t\t\t}\n\t\t\texports.getEnvironmentVariables = getEnvironmentVariables;\n\t\t\tfunction getEnvironmentVariable(name) {\n\t\t\t    // Certain Deno setups will throw an error if you try to access environment variables\n\t\t\t    // https://github.com/hwchase17/langchainjs/issues/1412\n\t\t\t    try {\n\t\t\t        return typeof browser$1 !== \"undefined\"\n\t\t\t            ? // eslint-disable-next-line no-process-env\n\t\t\t                browser$1.env?.[name]\n\t\t\t            : undefined;\n\t\t\t    }\n\t\t\t    catch (e) {\n\t\t\t        return undefined;\n\t\t\t    }\n\t\t\t}\n\t\t\texports.getEnvironmentVariable = getEnvironmentVariable;\n\t\t\tfunction getLangSmithEnvironmentVariable(name) {\n\t\t\t    return (getEnvironmentVariable(`LANGSMITH_${name}`) ||\n\t\t\t        getEnvironmentVariable(`LANGCHAIN_${name}`));\n\t\t\t}\n\t\t\texports.getLangSmithEnvironmentVariable = getLangSmithEnvironmentVariable;\n\t\t\tfunction setEnvironmentVariable(name, value) {\n\t\t\t    if (typeof browser$1 !== \"undefined\") {\n\t\t\t        // eslint-disable-next-line no-process-env\n\t\t\t        browser$1.env[name] = value;\n\t\t\t    }\n\t\t\t}\n\t\t\texports.setEnvironmentVariable = setEnvironmentVariable;\n\t\t\tlet cachedCommitSHAs;\n\t\t\t/**\n\t\t\t * Get the Git commit SHA from common environment variables\n\t\t\t * used by different CI/CD platforms.\n\t\t\t * @returns {string | undefined} The Git commit SHA or undefined if not found.\n\t\t\t */\n\t\t\tfunction getShas() {\n\t\t\t    if (cachedCommitSHAs !== undefined) {\n\t\t\t        return cachedCommitSHAs;\n\t\t\t    }\n\t\t\t    const common_release_envs = [\n\t\t\t        \"VERCEL_GIT_COMMIT_SHA\",\n\t\t\t        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n\t\t\t        \"COMMIT_REF\",\n\t\t\t        \"RENDER_GIT_COMMIT\",\n\t\t\t        \"CI_COMMIT_SHA\",\n\t\t\t        \"CIRCLE_SHA1\",\n\t\t\t        \"CF_PAGES_COMMIT_SHA\",\n\t\t\t        \"REACT_APP_GIT_SHA\",\n\t\t\t        \"SOURCE_VERSION\",\n\t\t\t        \"GITHUB_SHA\",\n\t\t\t        \"TRAVIS_COMMIT\",\n\t\t\t        \"GIT_COMMIT\",\n\t\t\t        \"BUILD_VCS_NUMBER\",\n\t\t\t        \"bamboo_planRepository_revision\",\n\t\t\t        \"Build.SourceVersion\",\n\t\t\t        \"BITBUCKET_COMMIT\",\n\t\t\t        \"DRONE_COMMIT_SHA\",\n\t\t\t        \"SEMAPHORE_GIT_SHA\",\n\t\t\t        \"BUILDKITE_COMMIT\",\n\t\t\t    ];\n\t\t\t    const shas = {};\n\t\t\t    for (const env of common_release_envs) {\n\t\t\t        const envVar = getEnvironmentVariable(env);\n\t\t\t        if (envVar !== undefined) {\n\t\t\t            shas[env] = envVar;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    cachedCommitSHAs = shas;\n\t\t\t    return shas;\n\t\t\t}\n\t\t\texports.getShas = getShas; \n\t\t} (env$1));\n\t\treturn env$1;\n\t}\n\n\tvar _uuid = {};\n\n\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t    }\n\t    Object.defineProperty(o, k2, desc);\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t    __setModuleDefault(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(_uuid, \"__esModule\", { value: true });\n\t_uuid.assertUuid = void 0;\n\tconst uuid = __importStar(require$$2);\n\tfunction assertUuid(str, which) {\n\t    if (!uuid.validate(str)) {\n\t        const msg = which !== undefined\n\t            ? `Invalid UUID for ${which}: ${str}`\n\t            : `Invalid UUID: ${str}`;\n\t        throw new Error(msg);\n\t    }\n\t    return str;\n\t}\n\t_uuid.assertUuid = assertUuid;\n\n\tvar warn = {};\n\n\tObject.defineProperty(warn, \"__esModule\", { value: true });\n\twarn.warnOnce = void 0;\n\tconst warnedMessages = {};\n\tfunction warnOnce(message) {\n\t    if (!warnedMessages[message]) {\n\t        console.warn(message);\n\t        warnedMessages[message] = true;\n\t    }\n\t}\n\twarn.warnOnce = warnOnce;\n\n\tvar prompts = {};\n\n\tvar re$2 = {exports: {}};\n\n\t// Note: this is the semver.org version of the spec that it implements\n\t// Not necessarily the package version of this code.\n\tconst SEMVER_SPEC_VERSION = '2.0.0';\n\n\tconst MAX_LENGTH$1 = 256;\n\tconst MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER ||\n\t/* istanbul ignore next */ 9007199254740991;\n\n\t// Max safe segment length for coercion.\n\tconst MAX_SAFE_COMPONENT_LENGTH = 16;\n\n\t// Max safe length for a build identifier. The max length minus 6 characters for\n\t// the shortest version with a build 0.0.0+BUILD.\n\tconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;\n\n\tconst RELEASE_TYPES = [\n\t  'major',\n\t  'premajor',\n\t  'minor',\n\t  'preminor',\n\t  'patch',\n\t  'prepatch',\n\t  'prerelease',\n\t];\n\n\tvar constants$1 = {\n\t  MAX_LENGTH: MAX_LENGTH$1,\n\t  MAX_SAFE_COMPONENT_LENGTH,\n\t  MAX_SAFE_BUILD_LENGTH,\n\t  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,\n\t  RELEASE_TYPES,\n\t  SEMVER_SPEC_VERSION,\n\t  FLAG_INCLUDE_PRERELEASE: 0b001,\n\t  FLAG_LOOSE: 0b010,\n\t};\n\n\tconst debug$1 = (\n\t  typeof browser$1 === 'object' &&\n\t  browser$1.env &&\n\t  browser$1.env.NODE_DEBUG &&\n\t  /\\bsemver\\b/i.test(browser$1.env.NODE_DEBUG)\n\t) ? (...args) => console.error('SEMVER', ...args)\n\t  : () => {};\n\n\tvar debug_1 = debug$1;\n\n\t(function (module, exports) {\n\t\tconst {\n\t\t  MAX_SAFE_COMPONENT_LENGTH,\n\t\t  MAX_SAFE_BUILD_LENGTH,\n\t\t  MAX_LENGTH,\n\t\t} = constants$1;\n\t\tconst debug = debug_1;\n\t\texports = module.exports = {};\n\n\t\t// The actual regexps go on exports.re\n\t\tconst re = exports.re = [];\n\t\tconst safeRe = exports.safeRe = [];\n\t\tconst src = exports.src = [];\n\t\tconst t = exports.t = {};\n\t\tlet R = 0;\n\n\t\tconst LETTERDASHNUMBER = '[a-zA-Z0-9-]';\n\n\t\t// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n\t\t// used internally via the safeRe object since all inputs in this library get\n\t\t// normalized first to trim and collapse all extra whitespace. The original\n\t\t// regexes are exported for userland consumption and lower level usage. A\n\t\t// future breaking change could export the safer regex only with a note that\n\t\t// all input should have extra whitespace removed.\n\t\tconst safeRegexReplacements = [\n\t\t  ['\\\\s', 1],\n\t\t  ['\\\\d', MAX_LENGTH],\n\t\t  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n\t\t];\n\n\t\tconst makeSafeRegex = (value) => {\n\t\t  for (const [token, max] of safeRegexReplacements) {\n\t\t    value = value\n\t\t      .split(`${token}*`).join(`${token}{0,${max}}`)\n\t\t      .split(`${token}+`).join(`${token}{1,${max}}`);\n\t\t  }\n\t\t  return value\n\t\t};\n\n\t\tconst createToken = (name, value, isGlobal) => {\n\t\t  const safe = makeSafeRegex(value);\n\t\t  const index = R++;\n\t\t  debug(name, index, value);\n\t\t  t[name] = index;\n\t\t  src[index] = value;\n\t\t  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);\n\t\t  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);\n\t\t};\n\n\t\t// The following Regular Expressions can be used for tokenizing,\n\t\t// validating, and parsing SemVer version strings.\n\n\t\t// ## Numeric Identifier\n\t\t// A single `0`, or a non-zero digit followed by zero or more digits.\n\n\t\tcreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*');\n\t\tcreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+');\n\n\t\t// ## Non-numeric Identifier\n\t\t// Zero or more digits, followed by a letter or hyphen, and then zero or\n\t\t// more letters, digits, or hyphens.\n\n\t\tcreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);\n\n\t\t// ## Main Version\n\t\t// Three dot-separated numeric identifiers.\n\n\t\tcreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n\t\t                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n\t\t                   `(${src[t.NUMERICIDENTIFIER]})`);\n\n\t\tcreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n\t\t                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n\t\t                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n\n\t\t// ## Pre-release Version Identifier\n\t\t// A numeric identifier, or a non-numeric identifier.\n\n\t\tcreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n\t}|${src[t.NONNUMERICIDENTIFIER]})`);\n\n\t\tcreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n\t}|${src[t.NONNUMERICIDENTIFIER]})`);\n\n\t\t// ## Pre-release Version\n\t\t// Hyphen, followed by one or more dot-separated pre-release version\n\t\t// identifiers.\n\n\t\tcreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n\t}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n\n\t\tcreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n\t}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n\n\t\t// ## Build Metadata Identifier\n\t\t// Any combination of digits, letters, or hyphens.\n\n\t\tcreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);\n\n\t\t// ## Build Metadata\n\t\t// Plus sign, followed by one or more period-separated build metadata\n\t\t// identifiers.\n\n\t\tcreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n\t}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n\n\t\t// ## Full Version String\n\t\t// A main version, followed optionally by a pre-release version and\n\t\t// build metadata.\n\n\t\t// Note that the only major, minor, patch, and pre-release sections of\n\t\t// the version string are capturing groups.  The build metadata is not a\n\t\t// capturing group, because it should not ever be used in version\n\t\t// comparison.\n\n\t\tcreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n\t}${src[t.PRERELEASE]}?${\n\t  src[t.BUILD]}?`);\n\n\t\tcreateToken('FULL', `^${src[t.FULLPLAIN]}$`);\n\n\t\t// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n\t\t// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n\t\t// common in the npm registry.\n\t\tcreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n\t}${src[t.PRERELEASELOOSE]}?${\n\t  src[t.BUILD]}?`);\n\n\t\tcreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);\n\n\t\tcreateToken('GTLT', '((?:<|>)?=?)');\n\n\t\t// Something like \"2.*\" or \"1.2.x\".\n\t\t// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n\t\t// Only the first item is strictly required.\n\t\tcreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n\t\tcreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n\n\t\tcreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n\t\t                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n\t\t                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n\t\t                   `(?:${src[t.PRERELEASE]})?${\n\t                     src[t.BUILD]}?` +\n\t\t                   `)?)?`);\n\n\t\tcreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t\t                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t\t                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t\t                        `(?:${src[t.PRERELEASELOOSE]})?${\n\t                          src[t.BUILD]}?` +\n\t\t                        `)?)?`);\n\n\t\tcreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n\t\tcreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n\n\t\t// Coercion.\n\t\t// Extract anything that could conceivably be a part of a valid semver\n\t\tcreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n\t              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n\t\t              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n\t\t              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);\n\t\tcreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`);\n\t\tcreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n\t\t              `(?:${src[t.PRERELEASE]})?` +\n\t\t              `(?:${src[t.BUILD]})?` +\n\t\t              `(?:$|[^\\\\d])`);\n\t\tcreateToken('COERCERTL', src[t.COERCE], true);\n\t\tcreateToken('COERCERTLFULL', src[t.COERCEFULL], true);\n\n\t\t// Tilde ranges.\n\t\t// Meaning is \"reasonably at or greater than\"\n\t\tcreateToken('LONETILDE', '(?:~>?)');\n\n\t\tcreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n\t\texports.tildeTrimReplace = '$1~';\n\n\t\tcreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n\t\tcreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n\n\t\t// Caret ranges.\n\t\t// Meaning is \"at least and backwards compatible with\"\n\t\tcreateToken('LONECARET', '(?:\\\\^)');\n\n\t\tcreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n\t\texports.caretTrimReplace = '$1^';\n\n\t\tcreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n\t\tcreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n\n\t\t// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\n\t\tcreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n\t\tcreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n\n\t\t// An expression to strip any whitespace between the gtlt and the thing\n\t\t// it modifies, so that `> 1.2.3` ==> `>1.2.3`\n\t\tcreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n\t}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n\t\texports.comparatorTrimReplace = '$1$2$3';\n\n\t\t// Something like `1.2.3 - 1.2.4`\n\t\t// Note that these all use the loose form, because they'll be\n\t\t// checked against either the strict or loose comparator form\n\t\t// later.\n\t\tcreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n\t\t                   `\\\\s+-\\\\s+` +\n\t\t                   `(${src[t.XRANGEPLAIN]})` +\n\t\t                   `\\\\s*$`);\n\n\t\tcreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n\t\t                        `\\\\s+-\\\\s+` +\n\t\t                        `(${src[t.XRANGEPLAINLOOSE]})` +\n\t\t                        `\\\\s*$`);\n\n\t\t// Star ranges basically just allow anything at all.\n\t\tcreateToken('STAR', '(<|>)?=?\\\\s*\\\\*');\n\t\t// >=0.0.0 is like a star\n\t\tcreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$');\n\t\tcreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$'); \n\t} (re$2, re$2.exports));\n\n\tvar reExports = re$2.exports;\n\n\t// parse out just the options we care about\n\tconst looseOption = Object.freeze({ loose: true });\n\tconst emptyOpts = Object.freeze({ });\n\tconst parseOptions$1 = options => {\n\t  if (!options) {\n\t    return emptyOpts\n\t  }\n\n\t  if (typeof options !== 'object') {\n\t    return looseOption\n\t  }\n\n\t  return options\n\t};\n\tvar parseOptions_1 = parseOptions$1;\n\n\tconst numeric = /^[0-9]+$/;\n\tconst compareIdentifiers$1 = (a, b) => {\n\t  const anum = numeric.test(a);\n\t  const bnum = numeric.test(b);\n\n\t  if (anum && bnum) {\n\t    a = +a;\n\t    b = +b;\n\t  }\n\n\t  return a === b ? 0\n\t    : (anum && !bnum) ? -1\n\t    : (bnum && !anum) ? 1\n\t    : a < b ? -1\n\t    : 1\n\t};\n\n\tconst rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);\n\n\tvar identifiers$1 = {\n\t  compareIdentifiers: compareIdentifiers$1,\n\t  rcompareIdentifiers,\n\t};\n\n\tconst debug = debug_1;\n\tconst { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;\n\tconst { safeRe: re$1, t: t$1 } = reExports;\n\n\tconst parseOptions = parseOptions_1;\n\tconst { compareIdentifiers } = identifiers$1;\n\tlet SemVer$d = class SemVer {\n\t  constructor (version, options) {\n\t    options = parseOptions(options);\n\n\t    if (version instanceof SemVer) {\n\t      if (version.loose === !!options.loose &&\n\t          version.includePrerelease === !!options.includePrerelease) {\n\t        return version\n\t      } else {\n\t        version = version.version;\n\t      }\n\t    } else if (typeof version !== 'string') {\n\t      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n\t    }\n\n\t    if (version.length > MAX_LENGTH) {\n\t      throw new TypeError(\n\t        `version is longer than ${MAX_LENGTH} characters`\n\t      )\n\t    }\n\n\t    debug('SemVer', version, options);\n\t    this.options = options;\n\t    this.loose = !!options.loose;\n\t    // this isn't actually relevant for versions, but keep it so that we\n\t    // don't run into trouble passing this.options around.\n\t    this.includePrerelease = !!options.includePrerelease;\n\n\t    const m = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);\n\n\t    if (!m) {\n\t      throw new TypeError(`Invalid Version: ${version}`)\n\t    }\n\n\t    this.raw = version;\n\n\t    // these are actually numbers\n\t    this.major = +m[1];\n\t    this.minor = +m[2];\n\t    this.patch = +m[3];\n\n\t    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n\t      throw new TypeError('Invalid major version')\n\t    }\n\n\t    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n\t      throw new TypeError('Invalid minor version')\n\t    }\n\n\t    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n\t      throw new TypeError('Invalid patch version')\n\t    }\n\n\t    // numberify any prerelease numeric ids\n\t    if (!m[4]) {\n\t      this.prerelease = [];\n\t    } else {\n\t      this.prerelease = m[4].split('.').map((id) => {\n\t        if (/^[0-9]+$/.test(id)) {\n\t          const num = +id;\n\t          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n\t            return num\n\t          }\n\t        }\n\t        return id\n\t      });\n\t    }\n\n\t    this.build = m[5] ? m[5].split('.') : [];\n\t    this.format();\n\t  }\n\n\t  format () {\n\t    this.version = `${this.major}.${this.minor}.${this.patch}`;\n\t    if (this.prerelease.length) {\n\t      this.version += `-${this.prerelease.join('.')}`;\n\t    }\n\t    return this.version\n\t  }\n\n\t  toString () {\n\t    return this.version\n\t  }\n\n\t  compare (other) {\n\t    debug('SemVer.compare', this.version, this.options, other);\n\t    if (!(other instanceof SemVer)) {\n\t      if (typeof other === 'string' && other === this.version) {\n\t        return 0\n\t      }\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    if (other.version === this.version) {\n\t      return 0\n\t    }\n\n\t    return this.compareMain(other) || this.comparePre(other)\n\t  }\n\n\t  compareMain (other) {\n\t    if (!(other instanceof SemVer)) {\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    return (\n\t      compareIdentifiers(this.major, other.major) ||\n\t      compareIdentifiers(this.minor, other.minor) ||\n\t      compareIdentifiers(this.patch, other.patch)\n\t    )\n\t  }\n\n\t  comparePre (other) {\n\t    if (!(other instanceof SemVer)) {\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    // NOT having a prerelease is > having one\n\t    if (this.prerelease.length && !other.prerelease.length) {\n\t      return -1\n\t    } else if (!this.prerelease.length && other.prerelease.length) {\n\t      return 1\n\t    } else if (!this.prerelease.length && !other.prerelease.length) {\n\t      return 0\n\t    }\n\n\t    let i = 0;\n\t    do {\n\t      const a = this.prerelease[i];\n\t      const b = other.prerelease[i];\n\t      debug('prerelease compare', i, a, b);\n\t      if (a === undefined && b === undefined) {\n\t        return 0\n\t      } else if (b === undefined) {\n\t        return 1\n\t      } else if (a === undefined) {\n\t        return -1\n\t      } else if (a === b) {\n\t        continue\n\t      } else {\n\t        return compareIdentifiers(a, b)\n\t      }\n\t    } while (++i)\n\t  }\n\n\t  compareBuild (other) {\n\t    if (!(other instanceof SemVer)) {\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    let i = 0;\n\t    do {\n\t      const a = this.build[i];\n\t      const b = other.build[i];\n\t      debug('build compare', i, a, b);\n\t      if (a === undefined && b === undefined) {\n\t        return 0\n\t      } else if (b === undefined) {\n\t        return 1\n\t      } else if (a === undefined) {\n\t        return -1\n\t      } else if (a === b) {\n\t        continue\n\t      } else {\n\t        return compareIdentifiers(a, b)\n\t      }\n\t    } while (++i)\n\t  }\n\n\t  // preminor will bump the version up to the next minor release, and immediately\n\t  // down to pre-release. premajor and prepatch work the same way.\n\t  inc (release, identifier, identifierBase) {\n\t    switch (release) {\n\t      case 'premajor':\n\t        this.prerelease.length = 0;\n\t        this.patch = 0;\n\t        this.minor = 0;\n\t        this.major++;\n\t        this.inc('pre', identifier, identifierBase);\n\t        break\n\t      case 'preminor':\n\t        this.prerelease.length = 0;\n\t        this.patch = 0;\n\t        this.minor++;\n\t        this.inc('pre', identifier, identifierBase);\n\t        break\n\t      case 'prepatch':\n\t        // If this is already a prerelease, it will bump to the next version\n\t        // drop any prereleases that might already exist, since they are not\n\t        // relevant at this point.\n\t        this.prerelease.length = 0;\n\t        this.inc('patch', identifier, identifierBase);\n\t        this.inc('pre', identifier, identifierBase);\n\t        break\n\t      // If the input is a non-prerelease version, this acts the same as\n\t      // prepatch.\n\t      case 'prerelease':\n\t        if (this.prerelease.length === 0) {\n\t          this.inc('patch', identifier, identifierBase);\n\t        }\n\t        this.inc('pre', identifier, identifierBase);\n\t        break\n\n\t      case 'major':\n\t        // If this is a pre-major version, bump up to the same major version.\n\t        // Otherwise increment major.\n\t        // 1.0.0-5 bumps to 1.0.0\n\t        // 1.1.0 bumps to 2.0.0\n\t        if (\n\t          this.minor !== 0 ||\n\t          this.patch !== 0 ||\n\t          this.prerelease.length === 0\n\t        ) {\n\t          this.major++;\n\t        }\n\t        this.minor = 0;\n\t        this.patch = 0;\n\t        this.prerelease = [];\n\t        break\n\t      case 'minor':\n\t        // If this is a pre-minor version, bump up to the same minor version.\n\t        // Otherwise increment minor.\n\t        // 1.2.0-5 bumps to 1.2.0\n\t        // 1.2.1 bumps to 1.3.0\n\t        if (this.patch !== 0 || this.prerelease.length === 0) {\n\t          this.minor++;\n\t        }\n\t        this.patch = 0;\n\t        this.prerelease = [];\n\t        break\n\t      case 'patch':\n\t        // If this is not a pre-release version, it will increment the patch.\n\t        // If it is a pre-release it will bump up to the same patch version.\n\t        // 1.2.0-5 patches to 1.2.0\n\t        // 1.2.0 patches to 1.2.1\n\t        if (this.prerelease.length === 0) {\n\t          this.patch++;\n\t        }\n\t        this.prerelease = [];\n\t        break\n\t      // This probably shouldn't be used publicly.\n\t      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n\t      case 'pre': {\n\t        const base = Number(identifierBase) ? 1 : 0;\n\n\t        if (!identifier && identifierBase === false) {\n\t          throw new Error('invalid increment argument: identifier is empty')\n\t        }\n\n\t        if (this.prerelease.length === 0) {\n\t          this.prerelease = [base];\n\t        } else {\n\t          let i = this.prerelease.length;\n\t          while (--i >= 0) {\n\t            if (typeof this.prerelease[i] === 'number') {\n\t              this.prerelease[i]++;\n\t              i = -2;\n\t            }\n\t          }\n\t          if (i === -1) {\n\t            // didn't increment anything\n\t            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n\t              throw new Error('invalid increment argument: identifier already exists')\n\t            }\n\t            this.prerelease.push(base);\n\t          }\n\t        }\n\t        if (identifier) {\n\t          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n\t          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n\t          let prerelease = [identifier, base];\n\t          if (identifierBase === false) {\n\t            prerelease = [identifier];\n\t          }\n\t          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n\t            if (isNaN(this.prerelease[1])) {\n\t              this.prerelease = prerelease;\n\t            }\n\t          } else {\n\t            this.prerelease = prerelease;\n\t          }\n\t        }\n\t        break\n\t      }\n\t      default:\n\t        throw new Error(`invalid increment argument: ${release}`)\n\t    }\n\t    this.raw = this.format();\n\t    if (this.build.length) {\n\t      this.raw += `+${this.build.join('.')}`;\n\t    }\n\t    return this\n\t  }\n\t};\n\n\tvar semver$1 = SemVer$d;\n\n\tconst SemVer$c = semver$1;\n\tconst parse$6 = (version, options, throwErrors = false) => {\n\t  if (version instanceof SemVer$c) {\n\t    return version\n\t  }\n\t  try {\n\t    return new SemVer$c(version, options)\n\t  } catch (er) {\n\t    if (!throwErrors) {\n\t      return null\n\t    }\n\t    throw er\n\t  }\n\t};\n\n\tvar parse_1 = parse$6;\n\n\tconst parse$5 = parse_1;\n\tconst valid$2 = (version, options) => {\n\t  const v = parse$5(version, options);\n\t  return v ? v.version : null\n\t};\n\tvar valid_1 = valid$2;\n\n\tconst parse$4 = parse_1;\n\tconst clean$1 = (version, options) => {\n\t  const s = parse$4(version.trim().replace(/^[=v]+/, ''), options);\n\t  return s ? s.version : null\n\t};\n\tvar clean_1 = clean$1;\n\n\tconst SemVer$b = semver$1;\n\n\tconst inc$1 = (version, release, options, identifier, identifierBase) => {\n\t  if (typeof (options) === 'string') {\n\t    identifierBase = identifier;\n\t    identifier = options;\n\t    options = undefined;\n\t  }\n\n\t  try {\n\t    return new SemVer$b(\n\t      version instanceof SemVer$b ? version.version : version,\n\t      options\n\t    ).inc(release, identifier, identifierBase).version\n\t  } catch (er) {\n\t    return null\n\t  }\n\t};\n\tvar inc_1 = inc$1;\n\n\tconst parse$3 = parse_1;\n\n\tconst diff$1 = (version1, version2) => {\n\t  const v1 = parse$3(version1, null, true);\n\t  const v2 = parse$3(version2, null, true);\n\t  const comparison = v1.compare(v2);\n\n\t  if (comparison === 0) {\n\t    return null\n\t  }\n\n\t  const v1Higher = comparison > 0;\n\t  const highVersion = v1Higher ? v1 : v2;\n\t  const lowVersion = v1Higher ? v2 : v1;\n\t  const highHasPre = !!highVersion.prerelease.length;\n\t  const lowHasPre = !!lowVersion.prerelease.length;\n\n\t  if (lowHasPre && !highHasPre) {\n\t    // Going from prerelease -> no prerelease requires some special casing\n\n\t    // If the low version has only a major, then it will always be a major\n\t    // Some examples:\n\t    // 1.0.0-1 -> 1.0.0\n\t    // 1.0.0-1 -> 1.1.1\n\t    // 1.0.0-1 -> 2.0.0\n\t    if (!lowVersion.patch && !lowVersion.minor) {\n\t      return 'major'\n\t    }\n\n\t    // Otherwise it can be determined by checking the high version\n\n\t    if (highVersion.patch) {\n\t      // anything higher than a patch bump would result in the wrong version\n\t      return 'patch'\n\t    }\n\n\t    if (highVersion.minor) {\n\t      // anything higher than a minor bump would result in the wrong version\n\t      return 'minor'\n\t    }\n\n\t    // bumping major/minor/patch all have same result\n\t    return 'major'\n\t  }\n\n\t  // add the `pre` prefix if we are going to a prerelease version\n\t  const prefix = highHasPre ? 'pre' : '';\n\n\t  if (v1.major !== v2.major) {\n\t    return prefix + 'major'\n\t  }\n\n\t  if (v1.minor !== v2.minor) {\n\t    return prefix + 'minor'\n\t  }\n\n\t  if (v1.patch !== v2.patch) {\n\t    return prefix + 'patch'\n\t  }\n\n\t  // high and low are preleases\n\t  return 'prerelease'\n\t};\n\n\tvar diff_1 = diff$1;\n\n\tconst SemVer$a = semver$1;\n\tconst major$1 = (a, loose) => new SemVer$a(a, loose).major;\n\tvar major_1 = major$1;\n\n\tconst SemVer$9 = semver$1;\n\tconst minor$1 = (a, loose) => new SemVer$9(a, loose).minor;\n\tvar minor_1 = minor$1;\n\n\tconst SemVer$8 = semver$1;\n\tconst patch$1 = (a, loose) => new SemVer$8(a, loose).patch;\n\tvar patch_1 = patch$1;\n\n\tconst parse$2 = parse_1;\n\tconst prerelease$1 = (version, options) => {\n\t  const parsed = parse$2(version, options);\n\t  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n\t};\n\tvar prerelease_1 = prerelease$1;\n\n\tconst SemVer$7 = semver$1;\n\tconst compare$b = (a, b, loose) =>\n\t  new SemVer$7(a, loose).compare(new SemVer$7(b, loose));\n\n\tvar compare_1 = compare$b;\n\n\tconst compare$a = compare_1;\n\tconst rcompare$1 = (a, b, loose) => compare$a(b, a, loose);\n\tvar rcompare_1 = rcompare$1;\n\n\tconst compare$9 = compare_1;\n\tconst compareLoose$1 = (a, b) => compare$9(a, b, true);\n\tvar compareLoose_1 = compareLoose$1;\n\n\tconst SemVer$6 = semver$1;\n\tconst compareBuild$3 = (a, b, loose) => {\n\t  const versionA = new SemVer$6(a, loose);\n\t  const versionB = new SemVer$6(b, loose);\n\t  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n\t};\n\tvar compareBuild_1 = compareBuild$3;\n\n\tconst compareBuild$2 = compareBuild_1;\n\tconst sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));\n\tvar sort_1 = sort$1;\n\n\tconst compareBuild$1 = compareBuild_1;\n\tconst rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));\n\tvar rsort_1 = rsort$1;\n\n\tconst compare$8 = compare_1;\n\tconst gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;\n\tvar gt_1 = gt$4;\n\n\tconst compare$7 = compare_1;\n\tconst lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;\n\tvar lt_1 = lt$3;\n\n\tconst compare$6 = compare_1;\n\tconst eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;\n\tvar eq_1 = eq$2;\n\n\tconst compare$5 = compare_1;\n\tconst neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;\n\tvar neq_1 = neq$2;\n\n\tconst compare$4 = compare_1;\n\tconst gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;\n\tvar gte_1 = gte$3;\n\n\tconst compare$3 = compare_1;\n\tconst lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;\n\tvar lte_1 = lte$3;\n\n\tconst eq$1 = eq_1;\n\tconst neq$1 = neq_1;\n\tconst gt$3 = gt_1;\n\tconst gte$2 = gte_1;\n\tconst lt$2 = lt_1;\n\tconst lte$2 = lte_1;\n\n\tconst cmp$1 = (a, op, b, loose) => {\n\t  switch (op) {\n\t    case '===':\n\t      if (typeof a === 'object') {\n\t        a = a.version;\n\t      }\n\t      if (typeof b === 'object') {\n\t        b = b.version;\n\t      }\n\t      return a === b\n\n\t    case '!==':\n\t      if (typeof a === 'object') {\n\t        a = a.version;\n\t      }\n\t      if (typeof b === 'object') {\n\t        b = b.version;\n\t      }\n\t      return a !== b\n\n\t    case '':\n\t    case '=':\n\t    case '==':\n\t      return eq$1(a, b, loose)\n\n\t    case '!=':\n\t      return neq$1(a, b, loose)\n\n\t    case '>':\n\t      return gt$3(a, b, loose)\n\n\t    case '>=':\n\t      return gte$2(a, b, loose)\n\n\t    case '<':\n\t      return lt$2(a, b, loose)\n\n\t    case '<=':\n\t      return lte$2(a, b, loose)\n\n\t    default:\n\t      throw new TypeError(`Invalid operator: ${op}`)\n\t  }\n\t};\n\tvar cmp_1 = cmp$1;\n\n\tconst SemVer$5 = semver$1;\n\tconst parse$1 = parse_1;\n\tconst { safeRe: re, t } = reExports;\n\n\tconst coerce$1 = (version, options) => {\n\t  if (version instanceof SemVer$5) {\n\t    return version\n\t  }\n\n\t  if (typeof version === 'number') {\n\t    version = String(version);\n\t  }\n\n\t  if (typeof version !== 'string') {\n\t    return null\n\t  }\n\n\t  options = options || {};\n\n\t  let match = null;\n\t  if (!options.rtl) {\n\t    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);\n\t  } else {\n\t    // Find the right-most coercible string that does not share\n\t    // a terminus with a more left-ward coercible string.\n\t    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n\t    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n\t    //\n\t    // Walk through the string checking with a /g regexp\n\t    // Manually set the index so as to pick up overlapping matches.\n\t    // Stop when we get a match that ends at the string end, since no\n\t    // coercible string can be more right-ward without the same terminus.\n\t    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];\n\t    let next;\n\t    while ((next = coerceRtlRegex.exec(version)) &&\n\t        (!match || match.index + match[0].length !== version.length)\n\t    ) {\n\t      if (!match ||\n\t            next.index + next[0].length !== match.index + match[0].length) {\n\t        match = next;\n\t      }\n\t      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;\n\t    }\n\t    // leave it in a clean state\n\t    coerceRtlRegex.lastIndex = -1;\n\t  }\n\n\t  if (match === null) {\n\t    return null\n\t  }\n\n\t  const major = match[2];\n\t  const minor = match[3] || '0';\n\t  const patch = match[4] || '0';\n\t  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';\n\t  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';\n\n\t  return parse$1(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n\t};\n\tvar coerce_1 = coerce$1;\n\n\tclass LRUCache {\n\t  constructor () {\n\t    this.max = 1000;\n\t    this.map = new Map();\n\t  }\n\n\t  get (key) {\n\t    const value = this.map.get(key);\n\t    if (value === undefined) {\n\t      return undefined\n\t    } else {\n\t      // Remove the key from the map and add it to the end\n\t      this.map.delete(key);\n\t      this.map.set(key, value);\n\t      return value\n\t    }\n\t  }\n\n\t  delete (key) {\n\t    return this.map.delete(key)\n\t  }\n\n\t  set (key, value) {\n\t    const deleted = this.delete(key);\n\n\t    if (!deleted && value !== undefined) {\n\t      // If cache is full, delete the least recently used item\n\t      if (this.map.size >= this.max) {\n\t        const firstKey = this.map.keys().next().value;\n\t        this.delete(firstKey);\n\t      }\n\n\t      this.map.set(key, value);\n\t    }\n\n\t    return this\n\t  }\n\t}\n\n\tvar lrucache = LRUCache;\n\n\tvar range;\n\tvar hasRequiredRange;\n\n\tfunction requireRange () {\n\t\tif (hasRequiredRange) return range;\n\t\thasRequiredRange = 1;\n\t\tconst SPACE_CHARACTERS = /\\s+/g;\n\n\t\t// hoisted class for cyclic dependency\n\t\tclass Range {\n\t\t  constructor (range, options) {\n\t\t    options = parseOptions(options);\n\n\t\t    if (range instanceof Range) {\n\t\t      if (\n\t\t        range.loose === !!options.loose &&\n\t\t        range.includePrerelease === !!options.includePrerelease\n\t\t      ) {\n\t\t        return range\n\t\t      } else {\n\t\t        return new Range(range.raw, options)\n\t\t      }\n\t\t    }\n\n\t\t    if (range instanceof Comparator) {\n\t\t      // just put it in the set and return\n\t\t      this.raw = range.value;\n\t\t      this.set = [[range]];\n\t\t      this.formatted = undefined;\n\t\t      return this\n\t\t    }\n\n\t\t    this.options = options;\n\t\t    this.loose = !!options.loose;\n\t\t    this.includePrerelease = !!options.includePrerelease;\n\n\t\t    // First reduce all whitespace as much as possible so we do not have to rely\n\t\t    // on potentially slow regexes like \\s*. This is then stored and used for\n\t\t    // future error messages as well.\n\t\t    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');\n\n\t\t    // First, split on ||\n\t\t    this.set = this.raw\n\t\t      .split('||')\n\t\t      // map the range to a 2d array of comparators\n\t\t      .map(r => this.parseRange(r.trim()))\n\t\t      // throw out any comparator lists that are empty\n\t\t      // this generally means that it was not a valid range, which is allowed\n\t\t      // in loose mode, but will still throw if the WHOLE range is invalid.\n\t\t      .filter(c => c.length);\n\n\t\t    if (!this.set.length) {\n\t\t      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n\t\t    }\n\n\t\t    // if we have any that are not the null set, throw out null sets.\n\t\t    if (this.set.length > 1) {\n\t\t      // keep the first one, in case they're all null sets\n\t\t      const first = this.set[0];\n\t\t      this.set = this.set.filter(c => !isNullSet(c[0]));\n\t\t      if (this.set.length === 0) {\n\t\t        this.set = [first];\n\t\t      } else if (this.set.length > 1) {\n\t\t        // if we have any that are *, then the range is just *\n\t\t        for (const c of this.set) {\n\t\t          if (c.length === 1 && isAny(c[0])) {\n\t\t            this.set = [c];\n\t\t            break\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\n\t\t    this.formatted = undefined;\n\t\t  }\n\n\t\t  get range () {\n\t\t    if (this.formatted === undefined) {\n\t\t      this.formatted = '';\n\t\t      for (let i = 0; i < this.set.length; i++) {\n\t\t        if (i > 0) {\n\t\t          this.formatted += '||';\n\t\t        }\n\t\t        const comps = this.set[i];\n\t\t        for (let k = 0; k < comps.length; k++) {\n\t\t          if (k > 0) {\n\t\t            this.formatted += ' ';\n\t\t          }\n\t\t          this.formatted += comps[k].toString().trim();\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return this.formatted\n\t\t  }\n\n\t\t  format () {\n\t\t    return this.range\n\t\t  }\n\n\t\t  toString () {\n\t\t    return this.range\n\t\t  }\n\n\t\t  parseRange (range) {\n\t\t    // memoize range parsing for performance.\n\t\t    // this is a very hot path, and fully deterministic.\n\t\t    const memoOpts =\n\t\t      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n\t\t      (this.options.loose && FLAG_LOOSE);\n\t\t    const memoKey = memoOpts + ':' + range;\n\t\t    const cached = cache.get(memoKey);\n\t\t    if (cached) {\n\t\t      return cached\n\t\t    }\n\n\t\t    const loose = this.options.loose;\n\t\t    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n\t\t    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n\t\t    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n\t\t    debug('hyphen replace', range);\n\n\t\t    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n\t\t    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n\t\t    debug('comparator trim', range);\n\n\t\t    // `~ 1.2.3` => `~1.2.3`\n\t\t    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);\n\t\t    debug('tilde trim', range);\n\n\t\t    // `^ 1.2.3` => `^1.2.3`\n\t\t    range = range.replace(re[t.CARETTRIM], caretTrimReplace);\n\t\t    debug('caret trim', range);\n\n\t\t    // At this point, the range is completely trimmed and\n\t\t    // ready to be split into comparators.\n\n\t\t    let rangeList = range\n\t\t      .split(' ')\n\t\t      .map(comp => parseComparator(comp, this.options))\n\t\t      .join(' ')\n\t\t      .split(/\\s+/)\n\t\t      // >=0.0.0 is equivalent to *\n\t\t      .map(comp => replaceGTE0(comp, this.options));\n\n\t\t    if (loose) {\n\t\t      // in loose mode, throw out any that are not valid comparators\n\t\t      rangeList = rangeList.filter(comp => {\n\t\t        debug('loose invalid filter', comp, this.options);\n\t\t        return !!comp.match(re[t.COMPARATORLOOSE])\n\t\t      });\n\t\t    }\n\t\t    debug('range list', rangeList);\n\n\t\t    // if any comparators are the null set, then replace with JUST null set\n\t\t    // if more than one comparator, remove any * comparators\n\t\t    // also, don't include the same comparator more than once\n\t\t    const rangeMap = new Map();\n\t\t    const comparators = rangeList.map(comp => new Comparator(comp, this.options));\n\t\t    for (const comp of comparators) {\n\t\t      if (isNullSet(comp)) {\n\t\t        return [comp]\n\t\t      }\n\t\t      rangeMap.set(comp.value, comp);\n\t\t    }\n\t\t    if (rangeMap.size > 1 && rangeMap.has('')) {\n\t\t      rangeMap.delete('');\n\t\t    }\n\n\t\t    const result = [...rangeMap.values()];\n\t\t    cache.set(memoKey, result);\n\t\t    return result\n\t\t  }\n\n\t\t  intersects (range, options) {\n\t\t    if (!(range instanceof Range)) {\n\t\t      throw new TypeError('a Range is required')\n\t\t    }\n\n\t\t    return this.set.some((thisComparators) => {\n\t\t      return (\n\t\t        isSatisfiable(thisComparators, options) &&\n\t\t        range.set.some((rangeComparators) => {\n\t\t          return (\n\t\t            isSatisfiable(rangeComparators, options) &&\n\t\t            thisComparators.every((thisComparator) => {\n\t\t              return rangeComparators.every((rangeComparator) => {\n\t\t                return thisComparator.intersects(rangeComparator, options)\n\t\t              })\n\t\t            })\n\t\t          )\n\t\t        })\n\t\t      )\n\t\t    })\n\t\t  }\n\n\t\t  // if ANY of the sets match ALL of its comparators, then pass\n\t\t  test (version) {\n\t\t    if (!version) {\n\t\t      return false\n\t\t    }\n\n\t\t    if (typeof version === 'string') {\n\t\t      try {\n\t\t        version = new SemVer(version, this.options);\n\t\t      } catch (er) {\n\t\t        return false\n\t\t      }\n\t\t    }\n\n\t\t    for (let i = 0; i < this.set.length; i++) {\n\t\t      if (testSet(this.set[i], version, this.options)) {\n\t\t        return true\n\t\t      }\n\t\t    }\n\t\t    return false\n\t\t  }\n\t\t}\n\n\t\trange = Range;\n\n\t\tconst LRU = lrucache;\n\t\tconst cache = new LRU();\n\n\t\tconst parseOptions = parseOptions_1;\n\t\tconst Comparator = requireComparator();\n\t\tconst debug = debug_1;\n\t\tconst SemVer = semver$1;\n\t\tconst {\n\t\t  safeRe: re,\n\t\t  t,\n\t\t  comparatorTrimReplace,\n\t\t  tildeTrimReplace,\n\t\t  caretTrimReplace,\n\t\t} = reExports;\n\t\tconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;\n\n\t\tconst isNullSet = c => c.value === '<0.0.0-0';\n\t\tconst isAny = c => c.value === '';\n\n\t\t// take a set of comparators and determine whether there\n\t\t// exists a version which can satisfy it\n\t\tconst isSatisfiable = (comparators, options) => {\n\t\t  let result = true;\n\t\t  const remainingComparators = comparators.slice();\n\t\t  let testComparator = remainingComparators.pop();\n\n\t\t  while (result && remainingComparators.length) {\n\t\t    result = remainingComparators.every((otherComparator) => {\n\t\t      return testComparator.intersects(otherComparator, options)\n\t\t    });\n\n\t\t    testComparator = remainingComparators.pop();\n\t\t  }\n\n\t\t  return result\n\t\t};\n\n\t\t// comprised of xranges, tildes, stars, and gtlt's at this point.\n\t\t// already replaced the hyphen ranges\n\t\t// turn into a set of JUST comparators.\n\t\tconst parseComparator = (comp, options) => {\n\t\t  debug('comp', comp, options);\n\t\t  comp = replaceCarets(comp, options);\n\t\t  debug('caret', comp);\n\t\t  comp = replaceTildes(comp, options);\n\t\t  debug('tildes', comp);\n\t\t  comp = replaceXRanges(comp, options);\n\t\t  debug('xrange', comp);\n\t\t  comp = replaceStars(comp, options);\n\t\t  debug('stars', comp);\n\t\t  return comp\n\t\t};\n\n\t\tconst isX = id => !id || id.toLowerCase() === 'x' || id === '*';\n\n\t\t// ~, ~> --> * (any, kinda silly)\n\t\t// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n\t\t// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n\t\t// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n\t\t// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n\t\t// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n\t\t// ~0.0.1 --> >=0.0.1 <0.1.0-0\n\t\tconst replaceTildes = (comp, options) => {\n\t\t  return comp\n\t\t    .trim()\n\t\t    .split(/\\s+/)\n\t\t    .map((c) => replaceTilde(c, options))\n\t\t    .join(' ')\n\t\t};\n\n\t\tconst replaceTilde = (comp, options) => {\n\t\t  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n\t\t  return comp.replace(r, (_, M, m, p, pr) => {\n\t\t    debug('tilde', comp, _, M, m, p, pr);\n\t\t    let ret;\n\n\t\t    if (isX(M)) {\n\t\t      ret = '';\n\t\t    } else if (isX(m)) {\n\t\t      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n\t\t    } else if (isX(p)) {\n\t\t      // ~1.2 == >=1.2.0 <1.3.0-0\n\t\t      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n\t\t    } else if (pr) {\n\t\t      debug('replaceTilde pr', pr);\n\t\t      ret = `>=${M}.${m}.${p}-${pr\n\t      } <${M}.${+m + 1}.0-0`;\n\t\t    } else {\n\t\t      // ~1.2.3 == >=1.2.3 <1.3.0-0\n\t\t      ret = `>=${M}.${m}.${p\n\t      } <${M}.${+m + 1}.0-0`;\n\t\t    }\n\n\t\t    debug('tilde return', ret);\n\t\t    return ret\n\t\t  })\n\t\t};\n\n\t\t// ^ --> * (any, kinda silly)\n\t\t// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n\t\t// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n\t\t// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n\t\t// ^1.2.3 --> >=1.2.3 <2.0.0-0\n\t\t// ^1.2.0 --> >=1.2.0 <2.0.0-0\n\t\t// ^0.0.1 --> >=0.0.1 <0.0.2-0\n\t\t// ^0.1.0 --> >=0.1.0 <0.2.0-0\n\t\tconst replaceCarets = (comp, options) => {\n\t\t  return comp\n\t\t    .trim()\n\t\t    .split(/\\s+/)\n\t\t    .map((c) => replaceCaret(c, options))\n\t\t    .join(' ')\n\t\t};\n\n\t\tconst replaceCaret = (comp, options) => {\n\t\t  debug('caret', comp, options);\n\t\t  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n\t\t  const z = options.includePrerelease ? '-0' : '';\n\t\t  return comp.replace(r, (_, M, m, p, pr) => {\n\t\t    debug('caret', comp, _, M, m, p, pr);\n\t\t    let ret;\n\n\t\t    if (isX(M)) {\n\t\t      ret = '';\n\t\t    } else if (isX(m)) {\n\t\t      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n\t\t    } else if (isX(p)) {\n\t\t      if (M === '0') {\n\t\t        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n\t\t      } else {\n\t\t        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n\t\t      }\n\t\t    } else if (pr) {\n\t\t      debug('replaceCaret pr', pr);\n\t\t      if (M === '0') {\n\t\t        if (m === '0') {\n\t\t          ret = `>=${M}.${m}.${p}-${pr\n\t          } <${M}.${m}.${+p + 1}-0`;\n\t\t        } else {\n\t\t          ret = `>=${M}.${m}.${p}-${pr\n\t          } <${M}.${+m + 1}.0-0`;\n\t\t        }\n\t\t      } else {\n\t\t        ret = `>=${M}.${m}.${p}-${pr\n\t        } <${+M + 1}.0.0-0`;\n\t\t      }\n\t\t    } else {\n\t\t      debug('no pr');\n\t\t      if (M === '0') {\n\t\t        if (m === '0') {\n\t\t          ret = `>=${M}.${m}.${p\n\t          }${z} <${M}.${m}.${+p + 1}-0`;\n\t\t        } else {\n\t\t          ret = `>=${M}.${m}.${p\n\t          }${z} <${M}.${+m + 1}.0-0`;\n\t\t        }\n\t\t      } else {\n\t\t        ret = `>=${M}.${m}.${p\n\t        } <${+M + 1}.0.0-0`;\n\t\t      }\n\t\t    }\n\n\t\t    debug('caret return', ret);\n\t\t    return ret\n\t\t  })\n\t\t};\n\n\t\tconst replaceXRanges = (comp, options) => {\n\t\t  debug('replaceXRanges', comp, options);\n\t\t  return comp\n\t\t    .split(/\\s+/)\n\t\t    .map((c) => replaceXRange(c, options))\n\t\t    .join(' ')\n\t\t};\n\n\t\tconst replaceXRange = (comp, options) => {\n\t\t  comp = comp.trim();\n\t\t  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n\t\t  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n\t\t    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n\t\t    const xM = isX(M);\n\t\t    const xm = xM || isX(m);\n\t\t    const xp = xm || isX(p);\n\t\t    const anyX = xp;\n\n\t\t    if (gtlt === '=' && anyX) {\n\t\t      gtlt = '';\n\t\t    }\n\n\t\t    // if we're including prereleases in the match, then we need\n\t\t    // to fix this to -0, the lowest possible prerelease value\n\t\t    pr = options.includePrerelease ? '-0' : '';\n\n\t\t    if (xM) {\n\t\t      if (gtlt === '>' || gtlt === '<') {\n\t\t        // nothing is allowed\n\t\t        ret = '<0.0.0-0';\n\t\t      } else {\n\t\t        // nothing is forbidden\n\t\t        ret = '*';\n\t\t      }\n\t\t    } else if (gtlt && anyX) {\n\t\t      // we know patch is an x, because we have any x at all.\n\t\t      // replace X with 0\n\t\t      if (xm) {\n\t\t        m = 0;\n\t\t      }\n\t\t      p = 0;\n\n\t\t      if (gtlt === '>') {\n\t\t        // >1 => >=2.0.0\n\t\t        // >1.2 => >=1.3.0\n\t\t        gtlt = '>=';\n\t\t        if (xm) {\n\t\t          M = +M + 1;\n\t\t          m = 0;\n\t\t          p = 0;\n\t\t        } else {\n\t\t          m = +m + 1;\n\t\t          p = 0;\n\t\t        }\n\t\t      } else if (gtlt === '<=') {\n\t\t        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n\t\t        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n\t\t        gtlt = '<';\n\t\t        if (xm) {\n\t\t          M = +M + 1;\n\t\t        } else {\n\t\t          m = +m + 1;\n\t\t        }\n\t\t      }\n\n\t\t      if (gtlt === '<') {\n\t\t        pr = '-0';\n\t\t      }\n\n\t\t      ret = `${gtlt + M}.${m}.${p}${pr}`;\n\t\t    } else if (xm) {\n\t\t      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n\t\t    } else if (xp) {\n\t\t      ret = `>=${M}.${m}.0${pr\n\t      } <${M}.${+m + 1}.0-0`;\n\t\t    }\n\n\t\t    debug('xRange return', ret);\n\n\t\t    return ret\n\t\t  })\n\t\t};\n\n\t\t// Because * is AND-ed with everything else in the comparator,\n\t\t// and '' means \"any version\", just remove the *s entirely.\n\t\tconst replaceStars = (comp, options) => {\n\t\t  debug('replaceStars', comp, options);\n\t\t  // Looseness is ignored here.  star is always as loose as it gets!\n\t\t  return comp\n\t\t    .trim()\n\t\t    .replace(re[t.STAR], '')\n\t\t};\n\n\t\tconst replaceGTE0 = (comp, options) => {\n\t\t  debug('replaceGTE0', comp, options);\n\t\t  return comp\n\t\t    .trim()\n\t\t    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n\t\t};\n\n\t\t// This function is passed to string.replace(re[t.HYPHENRANGE])\n\t\t// M, m, patch, prerelease, build\n\t\t// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n\t\t// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n\t\t// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n\t\t// TODO build?\n\t\tconst hyphenReplace = incPr => ($0,\n\t\t  from, fM, fm, fp, fpr, fb,\n\t\t  to, tM, tm, tp, tpr) => {\n\t\t  if (isX(fM)) {\n\t\t    from = '';\n\t\t  } else if (isX(fm)) {\n\t\t    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;\n\t\t  } else if (isX(fp)) {\n\t\t    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;\n\t\t  } else if (fpr) {\n\t\t    from = `>=${from}`;\n\t\t  } else {\n\t\t    from = `>=${from}${incPr ? '-0' : ''}`;\n\t\t  }\n\n\t\t  if (isX(tM)) {\n\t\t    to = '';\n\t\t  } else if (isX(tm)) {\n\t\t    to = `<${+tM + 1}.0.0-0`;\n\t\t  } else if (isX(tp)) {\n\t\t    to = `<${tM}.${+tm + 1}.0-0`;\n\t\t  } else if (tpr) {\n\t\t    to = `<=${tM}.${tm}.${tp}-${tpr}`;\n\t\t  } else if (incPr) {\n\t\t    to = `<${tM}.${tm}.${+tp + 1}-0`;\n\t\t  } else {\n\t\t    to = `<=${to}`;\n\t\t  }\n\n\t\t  return `${from} ${to}`.trim()\n\t\t};\n\n\t\tconst testSet = (set, version, options) => {\n\t\t  for (let i = 0; i < set.length; i++) {\n\t\t    if (!set[i].test(version)) {\n\t\t      return false\n\t\t    }\n\t\t  }\n\n\t\t  if (version.prerelease.length && !options.includePrerelease) {\n\t\t    // Find the set of versions that are allowed to have prereleases\n\t\t    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n\t\t    // That should allow `1.2.3-pr.2` to pass.\n\t\t    // However, `1.2.4-alpha.notready` should NOT be allowed,\n\t\t    // even though it's within the range set by the comparators.\n\t\t    for (let i = 0; i < set.length; i++) {\n\t\t      debug(set[i].semver);\n\t\t      if (set[i].semver === Comparator.ANY) {\n\t\t        continue\n\t\t      }\n\n\t\t      if (set[i].semver.prerelease.length > 0) {\n\t\t        const allowed = set[i].semver;\n\t\t        if (allowed.major === version.major &&\n\t\t            allowed.minor === version.minor &&\n\t\t            allowed.patch === version.patch) {\n\t\t          return true\n\t\t        }\n\t\t      }\n\t\t    }\n\n\t\t    // Version has a -pre, but it's not one of the ones we like.\n\t\t    return false\n\t\t  }\n\n\t\t  return true\n\t\t};\n\t\treturn range;\n\t}\n\n\tvar comparator;\n\tvar hasRequiredComparator;\n\n\tfunction requireComparator () {\n\t\tif (hasRequiredComparator) return comparator;\n\t\thasRequiredComparator = 1;\n\t\tconst ANY = Symbol('SemVer ANY');\n\t\t// hoisted class for cyclic dependency\n\t\tclass Comparator {\n\t\t  static get ANY () {\n\t\t    return ANY\n\t\t  }\n\n\t\t  constructor (comp, options) {\n\t\t    options = parseOptions(options);\n\n\t\t    if (comp instanceof Comparator) {\n\t\t      if (comp.loose === !!options.loose) {\n\t\t        return comp\n\t\t      } else {\n\t\t        comp = comp.value;\n\t\t      }\n\t\t    }\n\n\t\t    comp = comp.trim().split(/\\s+/).join(' ');\n\t\t    debug('comparator', comp, options);\n\t\t    this.options = options;\n\t\t    this.loose = !!options.loose;\n\t\t    this.parse(comp);\n\n\t\t    if (this.semver === ANY) {\n\t\t      this.value = '';\n\t\t    } else {\n\t\t      this.value = this.operator + this.semver.version;\n\t\t    }\n\n\t\t    debug('comp', this);\n\t\t  }\n\n\t\t  parse (comp) {\n\t\t    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n\t\t    const m = comp.match(r);\n\n\t\t    if (!m) {\n\t\t      throw new TypeError(`Invalid comparator: ${comp}`)\n\t\t    }\n\n\t\t    this.operator = m[1] !== undefined ? m[1] : '';\n\t\t    if (this.operator === '=') {\n\t\t      this.operator = '';\n\t\t    }\n\n\t\t    // if it literally is just '>' or '' then allow anything.\n\t\t    if (!m[2]) {\n\t\t      this.semver = ANY;\n\t\t    } else {\n\t\t      this.semver = new SemVer(m[2], this.options.loose);\n\t\t    }\n\t\t  }\n\n\t\t  toString () {\n\t\t    return this.value\n\t\t  }\n\n\t\t  test (version) {\n\t\t    debug('Comparator.test', version, this.options.loose);\n\n\t\t    if (this.semver === ANY || version === ANY) {\n\t\t      return true\n\t\t    }\n\n\t\t    if (typeof version === 'string') {\n\t\t      try {\n\t\t        version = new SemVer(version, this.options);\n\t\t      } catch (er) {\n\t\t        return false\n\t\t      }\n\t\t    }\n\n\t\t    return cmp(version, this.operator, this.semver, this.options)\n\t\t  }\n\n\t\t  intersects (comp, options) {\n\t\t    if (!(comp instanceof Comparator)) {\n\t\t      throw new TypeError('a Comparator is required')\n\t\t    }\n\n\t\t    if (this.operator === '') {\n\t\t      if (this.value === '') {\n\t\t        return true\n\t\t      }\n\t\t      return new Range(comp.value, options).test(this.value)\n\t\t    } else if (comp.operator === '') {\n\t\t      if (comp.value === '') {\n\t\t        return true\n\t\t      }\n\t\t      return new Range(this.value, options).test(comp.semver)\n\t\t    }\n\n\t\t    options = parseOptions(options);\n\n\t\t    // Special cases where nothing can possibly be lower\n\t\t    if (options.includePrerelease &&\n\t\t      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n\t\t      return false\n\t\t    }\n\t\t    if (!options.includePrerelease &&\n\t\t      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n\t\t      return false\n\t\t    }\n\n\t\t    // Same direction increasing (> or >=)\n\t\t    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n\t\t      return true\n\t\t    }\n\t\t    // Same direction decreasing (< or <=)\n\t\t    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n\t\t      return true\n\t\t    }\n\t\t    // same SemVer and both sides are inclusive (<= or >=)\n\t\t    if (\n\t\t      (this.semver.version === comp.semver.version) &&\n\t\t      this.operator.includes('=') && comp.operator.includes('=')) {\n\t\t      return true\n\t\t    }\n\t\t    // opposite directions less than\n\t\t    if (cmp(this.semver, '<', comp.semver, options) &&\n\t\t      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n\t\t      return true\n\t\t    }\n\t\t    // opposite directions greater than\n\t\t    if (cmp(this.semver, '>', comp.semver, options) &&\n\t\t      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n\t\t      return true\n\t\t    }\n\t\t    return false\n\t\t  }\n\t\t}\n\n\t\tcomparator = Comparator;\n\n\t\tconst parseOptions = parseOptions_1;\n\t\tconst { safeRe: re, t } = reExports;\n\t\tconst cmp = cmp_1;\n\t\tconst debug = debug_1;\n\t\tconst SemVer = semver$1;\n\t\tconst Range = requireRange();\n\t\treturn comparator;\n\t}\n\n\tconst Range$9 = requireRange();\n\tconst satisfies$4 = (version, range, options) => {\n\t  try {\n\t    range = new Range$9(range, options);\n\t  } catch (er) {\n\t    return false\n\t  }\n\t  return range.test(version)\n\t};\n\tvar satisfies_1 = satisfies$4;\n\n\tconst Range$8 = requireRange();\n\n\t// Mostly just for testing and legacy API reasons\n\tconst toComparators$1 = (range, options) =>\n\t  new Range$8(range, options).set\n\t    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));\n\n\tvar toComparators_1 = toComparators$1;\n\n\tconst SemVer$4 = semver$1;\n\tconst Range$7 = requireRange();\n\n\tconst maxSatisfying$1 = (versions, range, options) => {\n\t  let max = null;\n\t  let maxSV = null;\n\t  let rangeObj = null;\n\t  try {\n\t    rangeObj = new Range$7(range, options);\n\t  } catch (er) {\n\t    return null\n\t  }\n\t  versions.forEach((v) => {\n\t    if (rangeObj.test(v)) {\n\t      // satisfies(v, range, options)\n\t      if (!max || maxSV.compare(v) === -1) {\n\t        // compare(max, v, true)\n\t        max = v;\n\t        maxSV = new SemVer$4(max, options);\n\t      }\n\t    }\n\t  });\n\t  return max\n\t};\n\tvar maxSatisfying_1 = maxSatisfying$1;\n\n\tconst SemVer$3 = semver$1;\n\tconst Range$6 = requireRange();\n\tconst minSatisfying$1 = (versions, range, options) => {\n\t  let min = null;\n\t  let minSV = null;\n\t  let rangeObj = null;\n\t  try {\n\t    rangeObj = new Range$6(range, options);\n\t  } catch (er) {\n\t    return null\n\t  }\n\t  versions.forEach((v) => {\n\t    if (rangeObj.test(v)) {\n\t      // satisfies(v, range, options)\n\t      if (!min || minSV.compare(v) === 1) {\n\t        // compare(min, v, true)\n\t        min = v;\n\t        minSV = new SemVer$3(min, options);\n\t      }\n\t    }\n\t  });\n\t  return min\n\t};\n\tvar minSatisfying_1 = minSatisfying$1;\n\n\tconst SemVer$2 = semver$1;\n\tconst Range$5 = requireRange();\n\tconst gt$2 = gt_1;\n\n\tconst minVersion$1 = (range, loose) => {\n\t  range = new Range$5(range, loose);\n\n\t  let minver = new SemVer$2('0.0.0');\n\t  if (range.test(minver)) {\n\t    return minver\n\t  }\n\n\t  minver = new SemVer$2('0.0.0-0');\n\t  if (range.test(minver)) {\n\t    return minver\n\t  }\n\n\t  minver = null;\n\t  for (let i = 0; i < range.set.length; ++i) {\n\t    const comparators = range.set[i];\n\n\t    let setMin = null;\n\t    comparators.forEach((comparator) => {\n\t      // Clone to avoid manipulating the comparator's semver object.\n\t      const compver = new SemVer$2(comparator.semver.version);\n\t      switch (comparator.operator) {\n\t        case '>':\n\t          if (compver.prerelease.length === 0) {\n\t            compver.patch++;\n\t          } else {\n\t            compver.prerelease.push(0);\n\t          }\n\t          compver.raw = compver.format();\n\t          /* fallthrough */\n\t        case '':\n\t        case '>=':\n\t          if (!setMin || gt$2(compver, setMin)) {\n\t            setMin = compver;\n\t          }\n\t          break\n\t        case '<':\n\t        case '<=':\n\t          /* Ignore maximum versions */\n\t          break\n\t        /* istanbul ignore next */\n\t        default:\n\t          throw new Error(`Unexpected operation: ${comparator.operator}`)\n\t      }\n\t    });\n\t    if (setMin && (!minver || gt$2(minver, setMin))) {\n\t      minver = setMin;\n\t    }\n\t  }\n\n\t  if (minver && range.test(minver)) {\n\t    return minver\n\t  }\n\n\t  return null\n\t};\n\tvar minVersion_1 = minVersion$1;\n\n\tconst Range$4 = requireRange();\n\tconst validRange$1 = (range, options) => {\n\t  try {\n\t    // Return '*' instead of '' so that truthiness works.\n\t    // This will throw if it's invalid anyway\n\t    return new Range$4(range, options).range || '*'\n\t  } catch (er) {\n\t    return null\n\t  }\n\t};\n\tvar valid$1 = validRange$1;\n\n\tconst SemVer$1 = semver$1;\n\tconst Comparator$2 = requireComparator();\n\tconst { ANY: ANY$1 } = Comparator$2;\n\tconst Range$3 = requireRange();\n\tconst satisfies$3 = satisfies_1;\n\tconst gt$1 = gt_1;\n\tconst lt$1 = lt_1;\n\tconst lte$1 = lte_1;\n\tconst gte$1 = gte_1;\n\n\tconst outside$3 = (version, range, hilo, options) => {\n\t  version = new SemVer$1(version, options);\n\t  range = new Range$3(range, options);\n\n\t  let gtfn, ltefn, ltfn, comp, ecomp;\n\t  switch (hilo) {\n\t    case '>':\n\t      gtfn = gt$1;\n\t      ltefn = lte$1;\n\t      ltfn = lt$1;\n\t      comp = '>';\n\t      ecomp = '>=';\n\t      break\n\t    case '<':\n\t      gtfn = lt$1;\n\t      ltefn = gte$1;\n\t      ltfn = gt$1;\n\t      comp = '<';\n\t      ecomp = '<=';\n\t      break\n\t    default:\n\t      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n\t  }\n\n\t  // If it satisfies the range it is not outside\n\t  if (satisfies$3(version, range, options)) {\n\t    return false\n\t  }\n\n\t  // From now on, variable terms are as if we're in \"gtr\" mode.\n\t  // but note that everything is flipped for the \"ltr\" function.\n\n\t  for (let i = 0; i < range.set.length; ++i) {\n\t    const comparators = range.set[i];\n\n\t    let high = null;\n\t    let low = null;\n\n\t    comparators.forEach((comparator) => {\n\t      if (comparator.semver === ANY$1) {\n\t        comparator = new Comparator$2('>=0.0.0');\n\t      }\n\t      high = high || comparator;\n\t      low = low || comparator;\n\t      if (gtfn(comparator.semver, high.semver, options)) {\n\t        high = comparator;\n\t      } else if (ltfn(comparator.semver, low.semver, options)) {\n\t        low = comparator;\n\t      }\n\t    });\n\n\t    // If the edge version comparator has a operator then our version\n\t    // isn't outside it\n\t    if (high.operator === comp || high.operator === ecomp) {\n\t      return false\n\t    }\n\n\t    // If the lowest version comparator has an operator and our version\n\t    // is less than it then it isn't higher than the range\n\t    if ((!low.operator || low.operator === comp) &&\n\t        ltefn(version, low.semver)) {\n\t      return false\n\t    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t};\n\n\tvar outside_1 = outside$3;\n\n\t// Determine if version is greater than all the versions possible in the range.\n\tconst outside$2 = outside_1;\n\tconst gtr$1 = (version, range, options) => outside$2(version, range, '>', options);\n\tvar gtr_1 = gtr$1;\n\n\tconst outside$1 = outside_1;\n\t// Determine if version is less than all the versions possible in the range\n\tconst ltr$1 = (version, range, options) => outside$1(version, range, '<', options);\n\tvar ltr_1 = ltr$1;\n\n\tconst Range$2 = requireRange();\n\tconst intersects$1 = (r1, r2, options) => {\n\t  r1 = new Range$2(r1, options);\n\t  r2 = new Range$2(r2, options);\n\t  return r1.intersects(r2, options)\n\t};\n\tvar intersects_1 = intersects$1;\n\n\t// given a set of versions and a range, create a \"simplified\" range\n\t// that includes the same versions that the original range does\n\t// If the original range is shorter than the simplified one, return that.\n\tconst satisfies$2 = satisfies_1;\n\tconst compare$2 = compare_1;\n\tvar simplify = (versions, range, options) => {\n\t  const set = [];\n\t  let first = null;\n\t  let prev = null;\n\t  const v = versions.sort((a, b) => compare$2(a, b, options));\n\t  for (const version of v) {\n\t    const included = satisfies$2(version, range, options);\n\t    if (included) {\n\t      prev = version;\n\t      if (!first) {\n\t        first = version;\n\t      }\n\t    } else {\n\t      if (prev) {\n\t        set.push([first, prev]);\n\t      }\n\t      prev = null;\n\t      first = null;\n\t    }\n\t  }\n\t  if (first) {\n\t    set.push([first, null]);\n\t  }\n\n\t  const ranges = [];\n\t  for (const [min, max] of set) {\n\t    if (min === max) {\n\t      ranges.push(min);\n\t    } else if (!max && min === v[0]) {\n\t      ranges.push('*');\n\t    } else if (!max) {\n\t      ranges.push(`>=${min}`);\n\t    } else if (min === v[0]) {\n\t      ranges.push(`<=${max}`);\n\t    } else {\n\t      ranges.push(`${min} - ${max}`);\n\t    }\n\t  }\n\t  const simplified = ranges.join(' || ');\n\t  const original = typeof range.raw === 'string' ? range.raw : String(range);\n\t  return simplified.length < original.length ? simplified : range\n\t};\n\n\tconst Range$1 = requireRange();\n\tconst Comparator$1 = requireComparator();\n\tconst { ANY } = Comparator$1;\n\tconst satisfies$1 = satisfies_1;\n\tconst compare$1 = compare_1;\n\n\t// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n\t// - Every simple range `r1, r2, ...` is a null set, OR\n\t// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n\t//   some `R1, R2, ...`\n\t//\n\t// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n\t// - If c is only the ANY comparator\n\t//   - If C is only the ANY comparator, return true\n\t//   - Else if in prerelease mode, return false\n\t//   - else replace c with `[>=0.0.0]`\n\t// - If C is only the ANY comparator\n\t//   - if in prerelease mode, return true\n\t//   - else replace C with `[>=0.0.0]`\n\t// - Let EQ be the set of = comparators in c\n\t// - If EQ is more than one, return true (null set)\n\t// - Let GT be the highest > or >= comparator in c\n\t// - Let LT be the lowest < or <= comparator in c\n\t// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n\t// - If any C is a = range, and GT or LT are set, return false\n\t// - If EQ\n\t//   - If GT, and EQ does not satisfy GT, return true (null set)\n\t//   - If LT, and EQ does not satisfy LT, return true (null set)\n\t//   - If EQ satisfies every C, return true\n\t//   - Else return false\n\t// - If GT\n\t//   - If GT.semver is lower than any > or >= comp in C, return false\n\t//   - If GT is >=, and GT.semver does not satisfy every C, return false\n\t//   - If GT.semver has a prerelease, and not in prerelease mode\n\t//     - If no C has a prerelease and the GT.semver tuple, return false\n\t// - If LT\n\t//   - If LT.semver is greater than any < or <= comp in C, return false\n\t//   - If LT is <=, and LT.semver does not satisfy every C, return false\n\t//   - If GT.semver has a prerelease, and not in prerelease mode\n\t//     - If no C has a prerelease and the LT.semver tuple, return false\n\t// - Else return true\n\n\tconst subset$1 = (sub, dom, options = {}) => {\n\t  if (sub === dom) {\n\t    return true\n\t  }\n\n\t  sub = new Range$1(sub, options);\n\t  dom = new Range$1(dom, options);\n\t  let sawNonNull = false;\n\n\t  OUTER: for (const simpleSub of sub.set) {\n\t    for (const simpleDom of dom.set) {\n\t      const isSub = simpleSubset(simpleSub, simpleDom, options);\n\t      sawNonNull = sawNonNull || isSub !== null;\n\t      if (isSub) {\n\t        continue OUTER\n\t      }\n\t    }\n\t    // the null set is a subset of everything, but null simple ranges in\n\t    // a complex range should be ignored.  so if we saw a non-null range,\n\t    // then we know this isn't a subset, but if EVERY simple range was null,\n\t    // then it is a subset.\n\t    if (sawNonNull) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t};\n\n\tconst minimumVersionWithPreRelease = [new Comparator$1('>=0.0.0-0')];\n\tconst minimumVersion = [new Comparator$1('>=0.0.0')];\n\n\tconst simpleSubset = (sub, dom, options) => {\n\t  if (sub === dom) {\n\t    return true\n\t  }\n\n\t  if (sub.length === 1 && sub[0].semver === ANY) {\n\t    if (dom.length === 1 && dom[0].semver === ANY) {\n\t      return true\n\t    } else if (options.includePrerelease) {\n\t      sub = minimumVersionWithPreRelease;\n\t    } else {\n\t      sub = minimumVersion;\n\t    }\n\t  }\n\n\t  if (dom.length === 1 && dom[0].semver === ANY) {\n\t    if (options.includePrerelease) {\n\t      return true\n\t    } else {\n\t      dom = minimumVersion;\n\t    }\n\t  }\n\n\t  const eqSet = new Set();\n\t  let gt, lt;\n\t  for (const c of sub) {\n\t    if (c.operator === '>' || c.operator === '>=') {\n\t      gt = higherGT(gt, c, options);\n\t    } else if (c.operator === '<' || c.operator === '<=') {\n\t      lt = lowerLT(lt, c, options);\n\t    } else {\n\t      eqSet.add(c.semver);\n\t    }\n\t  }\n\n\t  if (eqSet.size > 1) {\n\t    return null\n\t  }\n\n\t  let gtltComp;\n\t  if (gt && lt) {\n\t    gtltComp = compare$1(gt.semver, lt.semver, options);\n\t    if (gtltComp > 0) {\n\t      return null\n\t    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n\t      return null\n\t    }\n\t  }\n\n\t  // will iterate one or zero times\n\t  for (const eq of eqSet) {\n\t    if (gt && !satisfies$1(eq, String(gt), options)) {\n\t      return null\n\t    }\n\n\t    if (lt && !satisfies$1(eq, String(lt), options)) {\n\t      return null\n\t    }\n\n\t    for (const c of dom) {\n\t      if (!satisfies$1(eq, String(c), options)) {\n\t        return false\n\t      }\n\t    }\n\n\t    return true\n\t  }\n\n\t  let higher, lower;\n\t  let hasDomLT, hasDomGT;\n\t  // if the subset has a prerelease, we need a comparator in the superset\n\t  // with the same tuple and a prerelease, or it's not a subset\n\t  let needDomLTPre = lt &&\n\t    !options.includePrerelease &&\n\t    lt.semver.prerelease.length ? lt.semver : false;\n\t  let needDomGTPre = gt &&\n\t    !options.includePrerelease &&\n\t    gt.semver.prerelease.length ? gt.semver : false;\n\t  // exception: <1.2.3-0 is the same as <1.2.3\n\t  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n\t      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n\t    needDomLTPre = false;\n\t  }\n\n\t  for (const c of dom) {\n\t    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';\n\t    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';\n\t    if (gt) {\n\t      if (needDomGTPre) {\n\t        if (c.semver.prerelease && c.semver.prerelease.length &&\n\t            c.semver.major === needDomGTPre.major &&\n\t            c.semver.minor === needDomGTPre.minor &&\n\t            c.semver.patch === needDomGTPre.patch) {\n\t          needDomGTPre = false;\n\t        }\n\t      }\n\t      if (c.operator === '>' || c.operator === '>=') {\n\t        higher = higherGT(gt, c, options);\n\t        if (higher === c && higher !== gt) {\n\t          return false\n\t        }\n\t      } else if (gt.operator === '>=' && !satisfies$1(gt.semver, String(c), options)) {\n\t        return false\n\t      }\n\t    }\n\t    if (lt) {\n\t      if (needDomLTPre) {\n\t        if (c.semver.prerelease && c.semver.prerelease.length &&\n\t            c.semver.major === needDomLTPre.major &&\n\t            c.semver.minor === needDomLTPre.minor &&\n\t            c.semver.patch === needDomLTPre.patch) {\n\t          needDomLTPre = false;\n\t        }\n\t      }\n\t      if (c.operator === '<' || c.operator === '<=') {\n\t        lower = lowerLT(lt, c, options);\n\t        if (lower === c && lower !== lt) {\n\t          return false\n\t        }\n\t      } else if (lt.operator === '<=' && !satisfies$1(lt.semver, String(c), options)) {\n\t        return false\n\t      }\n\t    }\n\t    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n\t      return false\n\t    }\n\t  }\n\n\t  // if there was a < or >, and nothing in the dom, then must be false\n\t  // UNLESS it was limited by another range in the other direction.\n\t  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n\t  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n\t    return false\n\t  }\n\n\t  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n\t    return false\n\t  }\n\n\t  // we needed a prerelease range in a specific tuple, but didn't get one\n\t  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n\t  // because it includes prereleases in the 1.2.3 tuple\n\t  if (needDomGTPre || needDomLTPre) {\n\t    return false\n\t  }\n\n\t  return true\n\t};\n\n\t// >=1.2.3 is lower than >1.2.3\n\tconst higherGT = (a, b, options) => {\n\t  if (!a) {\n\t    return b\n\t  }\n\t  const comp = compare$1(a.semver, b.semver, options);\n\t  return comp > 0 ? a\n\t    : comp < 0 ? b\n\t    : b.operator === '>' && a.operator === '>=' ? b\n\t    : a\n\t};\n\n\t// <=1.2.3 is higher than <1.2.3\n\tconst lowerLT = (a, b, options) => {\n\t  if (!a) {\n\t    return b\n\t  }\n\t  const comp = compare$1(a.semver, b.semver, options);\n\t  return comp < 0 ? a\n\t    : comp > 0 ? b\n\t    : b.operator === '<' && a.operator === '<=' ? b\n\t    : a\n\t};\n\n\tvar subset_1 = subset$1;\n\n\t// just pre-load all the stuff that index.js lazily exports\n\tconst internalRe = reExports;\n\tconst constants = constants$1;\n\tconst SemVer = semver$1;\n\tconst identifiers = identifiers$1;\n\tconst parse = parse_1;\n\tconst valid = valid_1;\n\tconst clean = clean_1;\n\tconst inc = inc_1;\n\tconst diff = diff_1;\n\tconst major = major_1;\n\tconst minor = minor_1;\n\tconst patch = patch_1;\n\tconst prerelease = prerelease_1;\n\tconst compare = compare_1;\n\tconst rcompare = rcompare_1;\n\tconst compareLoose = compareLoose_1;\n\tconst compareBuild = compareBuild_1;\n\tconst sort = sort_1;\n\tconst rsort = rsort_1;\n\tconst gt = gt_1;\n\tconst lt = lt_1;\n\tconst eq = eq_1;\n\tconst neq = neq_1;\n\tconst gte = gte_1;\n\tconst lte = lte_1;\n\tconst cmp = cmp_1;\n\tconst coerce = coerce_1;\n\tconst Comparator = requireComparator();\n\tconst Range = requireRange();\n\tconst satisfies = satisfies_1;\n\tconst toComparators = toComparators_1;\n\tconst maxSatisfying = maxSatisfying_1;\n\tconst minSatisfying = minSatisfying_1;\n\tconst minVersion = minVersion_1;\n\tconst validRange = valid$1;\n\tconst outside = outside_1;\n\tconst gtr = gtr_1;\n\tconst ltr = ltr_1;\n\tconst intersects = intersects_1;\n\tconst simplifyRange = simplify;\n\tconst subset = subset_1;\n\tvar semver = {\n\t  parse,\n\t  valid,\n\t  clean,\n\t  inc,\n\t  diff,\n\t  major,\n\t  minor,\n\t  patch,\n\t  prerelease,\n\t  compare,\n\t  rcompare,\n\t  compareLoose,\n\t  compareBuild,\n\t  sort,\n\t  rsort,\n\t  gt,\n\t  lt,\n\t  eq,\n\t  neq,\n\t  gte,\n\t  lte,\n\t  cmp,\n\t  coerce,\n\t  Comparator,\n\t  Range,\n\t  satisfies,\n\t  toComparators,\n\t  maxSatisfying,\n\t  minSatisfying,\n\t  minVersion,\n\t  validRange,\n\t  outside,\n\t  gtr,\n\t  ltr,\n\t  intersects,\n\t  simplifyRange,\n\t  subset,\n\t  SemVer,\n\t  re: internalRe.re,\n\t  src: internalRe.src,\n\t  tokens: internalRe.t,\n\t  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n\t  RELEASE_TYPES: constants.RELEASE_TYPES,\n\t  compareIdentifiers: identifiers.compareIdentifiers,\n\t  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n\t};\n\n\tObject.defineProperty(prompts, \"__esModule\", { value: true });\n\tprompts.parsePromptIdentifier = prompts.isVersionGreaterOrEqual = void 0;\n\tconst semver_1 = semver;\n\tfunction isVersionGreaterOrEqual(current_version, target_version) {\n\t    const current = (0, semver_1.parse)(current_version);\n\t    const target = (0, semver_1.parse)(target_version);\n\t    if (!current || !target) {\n\t        throw new Error(\"Invalid version format.\");\n\t    }\n\t    return current.compare(target) >= 0;\n\t}\n\tprompts.isVersionGreaterOrEqual = isVersionGreaterOrEqual;\n\tfunction parsePromptIdentifier(identifier) {\n\t    if (!identifier ||\n\t        identifier.split(\"/\").length > 2 ||\n\t        identifier.startsWith(\"/\") ||\n\t        identifier.endsWith(\"/\") ||\n\t        identifier.split(\":\").length > 2) {\n\t        throw new Error(`Invalid identifier format: ${identifier}`);\n\t    }\n\t    const [ownerNamePart, commitPart] = identifier.split(\":\");\n\t    const commit = commitPart || \"latest\";\n\t    if (ownerNamePart.includes(\"/\")) {\n\t        const [owner, name] = ownerNamePart.split(\"/\", 2);\n\t        if (!owner || !name) {\n\t            throw new Error(`Invalid identifier format: ${identifier}`);\n\t        }\n\t        return [owner, name, commit];\n\t    }\n\t    else {\n\t        if (!ownerNamePart) {\n\t            throw new Error(`Invalid identifier format: ${identifier}`);\n\t        }\n\t        return [\"-\", ownerNamePart, commit];\n\t    }\n\t}\n\tprompts.parsePromptIdentifier = parsePromptIdentifier;\n\n\tvar error = {};\n\n\tObject.defineProperty(error, \"__esModule\", { value: true });\n\terror.raiseForStatus = error.LangSmithConflictError = error.printErrorStackTrace = void 0;\n\tfunction getErrorStackTrace(e) {\n\t    if (typeof e !== \"object\" || e == null)\n\t        return undefined;\n\t    if (!(\"stack\" in e) || typeof e.stack !== \"string\")\n\t        return undefined;\n\t    let stack = e.stack;\n\t    const prevLine = `${e}`;\n\t    if (stack.startsWith(prevLine)) {\n\t        stack = stack.slice(prevLine.length);\n\t    }\n\t    if (stack.startsWith(\"\\n\")) {\n\t        stack = stack.slice(1);\n\t    }\n\t    return stack;\n\t}\n\tfunction printErrorStackTrace(e) {\n\t    const stack = getErrorStackTrace(e);\n\t    if (stack == null)\n\t        return;\n\t    console.error(stack);\n\t}\n\terror.printErrorStackTrace = printErrorStackTrace;\n\t/**\n\t * LangSmithConflictError\n\t *\n\t * Represents an error that occurs when there's a conflict during an operation,\n\t * typically corresponding to HTTP 409 status code responses.\n\t *\n\t * This error is thrown when an attempt to create or modify a resource conflicts\n\t * with the current state of the resource on the server. Common scenarios include:\n\t * - Attempting to create a resource that already exists\n\t * - Trying to update a resource that has been modified by another process\n\t * - Violating a uniqueness constraint in the data\n\t *\n\t * @extends Error\n\t *\n\t * @example\n\t * try {\n\t *   await createProject(\"existingProject\");\n\t * } catch (error) {\n\t *   if (error instanceof ConflictError) {\n\t *     console.log(\"A conflict occurred:\", error.message);\n\t *     // Handle the conflict, e.g., by suggesting a different project name\n\t *   } else {\n\t *     // Handle other types of errors\n\t *   }\n\t * }\n\t *\n\t * @property {string} name - Always set to 'ConflictError' for easy identification\n\t * @property {string} message - Detailed error message including server response\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n\t */\n\tclass LangSmithConflictError extends Error {\n\t    constructor(message) {\n\t        super(message);\n\t        this.name = \"LangSmithConflictError\";\n\t    }\n\t}\n\terror.LangSmithConflictError = LangSmithConflictError;\n\t/**\n\t * Throws an appropriate error based on the response status and body.\n\t *\n\t * @param response - The fetch Response object\n\t * @param context - Additional context to include in the error message (e.g., operation being performed)\n\t * @throws {LangSmithConflictError} When the response status is 409\n\t * @throws {Error} For all other non-ok responses\n\t */\n\tasync function raiseForStatus(response, context, consume) {\n\t    // consume the response body to release the connection\n\t    // https://undici.nodejs.org/#/?id=garbage-collection\n\t    let errorBody;\n\t    if (response.ok) {\n\t        if (consume) {\n\t            errorBody = await response.text();\n\t        }\n\t        return;\n\t    }\n\t    errorBody = await response.text();\n\t    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;\n\t    if (response.status === 409) {\n\t        throw new LangSmithConflictError(fullMessage);\n\t    }\n\t    throw new Error(fullMessage);\n\t}\n\terror.raiseForStatus = raiseForStatus;\n\n\tvar fastSafeStringify = {};\n\n\tObject.defineProperty(fastSafeStringify, \"__esModule\", { value: true });\n\tfastSafeStringify.stringify = void 0;\n\t/* eslint-disable */\n\t// @ts-nocheck\n\tvar LIMIT_REPLACE_NODE = \"[...]\";\n\tvar CIRCULAR_REPLACE_NODE = { result: \"[Circular]\" };\n\tvar arr = [];\n\tvar replacerStack = [];\n\tfunction defaultOptions() {\n\t    return {\n\t        depthLimit: Number.MAX_SAFE_INTEGER,\n\t        edgesLimit: Number.MAX_SAFE_INTEGER,\n\t    };\n\t}\n\t// Regular stringify\n\tfunction stringify(obj, replacer, spacer, options) {\n\t    if (typeof options === \"undefined\") {\n\t        options = defaultOptions();\n\t    }\n\t    decirc(obj, \"\", 0, [], undefined, 0, options);\n\t    var res;\n\t    try {\n\t        if (replacerStack.length === 0) {\n\t            res = JSON.stringify(obj, replacer, spacer);\n\t        }\n\t        else {\n\t            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n\t        }\n\t    }\n\t    catch (_) {\n\t        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n\t    }\n\t    finally {\n\t        while (arr.length !== 0) {\n\t            var part = arr.pop();\n\t            if (part.length === 4) {\n\t                Object.defineProperty(part[0], part[1], part[3]);\n\t            }\n\t            else {\n\t                part[0][part[1]] = part[2];\n\t            }\n\t        }\n\t    }\n\t    return res;\n\t}\n\tfastSafeStringify.stringify = stringify;\n\tfunction setReplace(replace, val, k, parent) {\n\t    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n\t    if (propertyDescriptor.get !== undefined) {\n\t        if (propertyDescriptor.configurable) {\n\t            Object.defineProperty(parent, k, { value: replace });\n\t            arr.push([parent, k, val, propertyDescriptor]);\n\t        }\n\t        else {\n\t            replacerStack.push([val, k, replace]);\n\t        }\n\t    }\n\t    else {\n\t        parent[k] = replace;\n\t        arr.push([parent, k, val]);\n\t    }\n\t}\n\tfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n\t    depth += 1;\n\t    var i;\n\t    if (typeof val === \"object\" && val !== null) {\n\t        for (i = 0; i < stack.length; i++) {\n\t            if (stack[i] === val) {\n\t                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n\t                return;\n\t            }\n\t        }\n\t        if (typeof options.depthLimit !== \"undefined\" &&\n\t            depth > options.depthLimit) {\n\t            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n\t            return;\n\t        }\n\t        if (typeof options.edgesLimit !== \"undefined\" &&\n\t            edgeIndex + 1 > options.edgesLimit) {\n\t            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n\t            return;\n\t        }\n\t        stack.push(val);\n\t        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n\t        if (Array.isArray(val)) {\n\t            for (i = 0; i < val.length; i++) {\n\t                decirc(val[i], i, i, stack, val, depth, options);\n\t            }\n\t        }\n\t        else {\n\t            var keys = Object.keys(val);\n\t            for (i = 0; i < keys.length; i++) {\n\t                var key = keys[i];\n\t                decirc(val[key], key, i, stack, val, depth, options);\n\t            }\n\t        }\n\t        stack.pop();\n\t    }\n\t}\n\t// wraps replacer function to handle values we couldn't replace\n\t// and mark them as replaced value\n\tfunction replaceGetterValues(replacer) {\n\t    replacer =\n\t        typeof replacer !== \"undefined\"\n\t            ? replacer\n\t            : function (k, v) {\n\t                return v;\n\t            };\n\t    return function (key, val) {\n\t        if (replacerStack.length > 0) {\n\t            for (var i = 0; i < replacerStack.length; i++) {\n\t                var part = replacerStack[i];\n\t                if (part[1] === key && part[0] === val) {\n\t                    val = part[2];\n\t                    replacerStack.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return replacer.call(this, key, val);\n\t    };\n\t}\n\n\tvar hasRequiredClient;\n\n\tfunction requireClient () {\n\t\tif (hasRequiredClient) return client;\n\t\thasRequiredClient = 1;\n\t\t(function (exports) {\n\t\t\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t\t    if (k2 === undefined) k2 = k;\n\t\t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t\t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t\t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t\t\t    }\n\t\t\t    Object.defineProperty(o, k2, desc);\n\t\t\t}) : (function(o, m, k, k2) {\n\t\t\t    if (k2 === undefined) k2 = k;\n\t\t\t    o[k2] = m[k];\n\t\t\t}));\n\t\t\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t\t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t\t\t}) : function(o, v) {\n\t\t\t    o[\"default\"] = v;\n\t\t\t});\n\t\t\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t\t\t    if (mod && mod.__esModule) return mod;\n\t\t\t    var result = {};\n\t\t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t\t\t    __setModuleDefault(result, mod);\n\t\t\t    return result;\n\t\t\t};\n\t\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\t\texports.Client = exports.DEFAULT_BATCH_SIZE_LIMIT_BYTES = exports.Queue = void 0;\n\t\t\tconst uuid = __importStar(require$$2);\n\t\t\tconst async_caller_js_1 = async_caller$1;\n\t\t\tconst messages_js_1 = messages$1;\n\t\t\tconst env_js_1 = requireEnv$1();\n\t\t\tconst index_js_1 = requireDist();\n\t\t\tconst _uuid_js_1 = _uuid;\n\t\t\tconst warn_js_1 = warn;\n\t\t\tconst prompts_js_1 = prompts;\n\t\t\tconst error_js_1 = error;\n\t\t\tconst fetch_js_1 = fetch$1;\n\t\t\tconst index_js_2 = fastSafeStringify;\n\t\t\tasync function mergeRuntimeEnvIntoRunCreates(runs) {\n\t\t\t    const runtimeEnv = await (0, env_js_1.getRuntimeEnvironment)();\n\t\t\t    const envVars = (0, env_js_1.getLangChainEnvVarsMetadata)();\n\t\t\t    return runs.map((run) => {\n\t\t\t        const extra = run.extra ?? {};\n\t\t\t        const metadata = extra.metadata;\n\t\t\t        run.extra = {\n\t\t\t            ...extra,\n\t\t\t            runtime: {\n\t\t\t                ...runtimeEnv,\n\t\t\t                ...extra?.runtime,\n\t\t\t            },\n\t\t\t            metadata: {\n\t\t\t                ...envVars,\n\t\t\t                ...(envVars.revision_id || run.revision_id\n\t\t\t                    ? { revision_id: run.revision_id ?? envVars.revision_id }\n\t\t\t                    : {}),\n\t\t\t                ...metadata,\n\t\t\t            },\n\t\t\t        };\n\t\t\t        return run;\n\t\t\t    });\n\t\t\t}\n\t\t\tconst getTracingSamplingRate = () => {\n\t\t\t    const samplingRateStr = (0, env_js_1.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n\t\t\t    if (samplingRateStr === undefined) {\n\t\t\t        return undefined;\n\t\t\t    }\n\t\t\t    const samplingRate = parseFloat(samplingRateStr);\n\t\t\t    if (samplingRate < 0 || samplingRate > 1) {\n\t\t\t        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n\t\t\t    }\n\t\t\t    return samplingRate;\n\t\t\t};\n\t\t\t// utility functions\n\t\t\tconst isLocalhost = (url) => {\n\t\t\t    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n\t\t\t    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n\t\t\t    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n\t\t\t};\n\t\t\tasync function toArray(iterable) {\n\t\t\t    const result = [];\n\t\t\t    for await (const item of iterable) {\n\t\t\t        result.push(item);\n\t\t\t    }\n\t\t\t    return result;\n\t\t\t}\n\t\t\tfunction trimQuotes(str) {\n\t\t\t    if (str === undefined) {\n\t\t\t        return undefined;\n\t\t\t    }\n\t\t\t    return str\n\t\t\t        .trim()\n\t\t\t        .replace(/^\"(.*)\"$/, \"$1\")\n\t\t\t        .replace(/^'(.*)'$/, \"$1\");\n\t\t\t}\n\t\t\tconst handle429 = async (response) => {\n\t\t\t    if (response?.status === 429) {\n\t\t\t        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n\t\t\t        if (retryAfter > 0) {\n\t\t\t            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n\t\t\t            // Return directly after calling this check\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    // Fall back to existing status checks\n\t\t\t    return false;\n\t\t\t};\n\t\t\tclass Queue {\n\t\t\t    constructor() {\n\t\t\t        Object.defineProperty(this, \"items\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: []\n\t\t\t        });\n\t\t\t    }\n\t\t\t    get size() {\n\t\t\t        return this.items.length;\n\t\t\t    }\n\t\t\t    push(item) {\n\t\t\t        // this.items.push is synchronous with promise creation:\n\t\t\t        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n\t\t\t        return new Promise((resolve) => {\n\t\t\t            this.items.push([item, resolve]);\n\t\t\t        });\n\t\t\t    }\n\t\t\t    pop(upToN) {\n\t\t\t        if (upToN < 1) {\n\t\t\t            throw new Error(\"Number of items to pop off may not be less than 1.\");\n\t\t\t        }\n\t\t\t        const popped = [];\n\t\t\t        while (popped.length < upToN && this.items.length) {\n\t\t\t            const item = this.items.shift();\n\t\t\t            if (item) {\n\t\t\t                popped.push(item);\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return [popped.map((it) => it[0]), () => popped.forEach((it) => it[1]())];\n\t\t\t    }\n\t\t\t}\n\t\t\texports.Queue = Queue;\n\t\t\t// 20 MB\n\t\t\texports.DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20_971_520;\n\t\t\tclass Client {\n\t\t\t    constructor(config = {}) {\n\t\t\t        Object.defineProperty(this, \"apiKey\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"apiUrl\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"webUrl\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"caller\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"batchIngestCaller\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"timeout_ms\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"_tenantId\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: null\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"hideInputs\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"hideOutputs\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"tracingSampleRate\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"filteredPostUuids\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: new Set()\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"autoBatchTracing\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: true\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"batchEndpointSupported\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"autoBatchQueue\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: new Queue()\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: 100\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"autoBatchTimeout\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: 250\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: 50\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"serverInfo\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"fetchOptions\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        Object.defineProperty(this, \"settings\", {\n\t\t\t            enumerable: true,\n\t\t\t            configurable: true,\n\t\t\t            writable: true,\n\t\t\t            value: void 0\n\t\t\t        });\n\t\t\t        const defaultConfig = Client.getDefaultClientConfig();\n\t\t\t        this.tracingSampleRate = getTracingSamplingRate();\n\t\t\t        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n\t\t\t        if (this.apiUrl.endsWith(\"/\")) {\n\t\t\t            this.apiUrl = this.apiUrl.slice(0, -1);\n\t\t\t        }\n\t\t\t        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n\t\t\t        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n\t\t\t        if (this.webUrl?.endsWith(\"/\")) {\n\t\t\t            this.webUrl = this.webUrl.slice(0, -1);\n\t\t\t        }\n\t\t\t        this.timeout_ms = config.timeout_ms ?? 12_000;\n\t\t\t        this.caller = new async_caller_js_1.AsyncCaller(config.callerOptions ?? {});\n\t\t\t        this.batchIngestCaller = new async_caller_js_1.AsyncCaller({\n\t\t\t            ...(config.callerOptions ?? {}),\n\t\t\t            onFailedResponseHook: handle429,\n\t\t\t        });\n\t\t\t        this.hideInputs =\n\t\t\t            config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n\t\t\t        this.hideOutputs =\n\t\t\t            config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n\t\t\t        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n\t\t\t        this.pendingAutoBatchedRunLimit =\n\t\t\t            config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n\t\t\t        this.fetchOptions = config.fetchOptions || {};\n\t\t\t    }\n\t\t\t    static getDefaultClientConfig() {\n\t\t\t        const apiKey = (0, env_js_1.getLangSmithEnvironmentVariable)(\"API_KEY\");\n\t\t\t        const apiUrl = (0, env_js_1.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ??\n\t\t\t            \"https://api.smith.langchain.com\";\n\t\t\t        const hideInputs = (0, env_js_1.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n\t\t\t        const hideOutputs = (0, env_js_1.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n\t\t\t        return {\n\t\t\t            apiUrl: apiUrl,\n\t\t\t            apiKey: apiKey,\n\t\t\t            webUrl: undefined,\n\t\t\t            hideInputs: hideInputs,\n\t\t\t            hideOutputs: hideOutputs,\n\t\t\t        };\n\t\t\t    }\n\t\t\t    getHostUrl() {\n\t\t\t        if (this.webUrl) {\n\t\t\t            return this.webUrl;\n\t\t\t        }\n\t\t\t        else if (isLocalhost(this.apiUrl)) {\n\t\t\t            this.webUrl = \"http://localhost:3000\";\n\t\t\t            return this.webUrl;\n\t\t\t        }\n\t\t\t        else if (this.apiUrl.includes(\"/api\") &&\n\t\t\t            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n\t\t\t            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n\t\t\t            return this.webUrl;\n\t\t\t        }\n\t\t\t        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n\t\t\t            this.webUrl = \"https://dev.smith.langchain.com\";\n\t\t\t            return this.webUrl;\n\t\t\t        }\n\t\t\t        else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n\t\t\t            this.webUrl = \"https://eu.smith.langchain.com\";\n\t\t\t            return this.webUrl;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            this.webUrl = \"https://smith.langchain.com\";\n\t\t\t            return this.webUrl;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    get headers() {\n\t\t\t        const headers = {\n\t\t\t            \"User-Agent\": `langsmith-js/${index_js_1.__version__}`,\n\t\t\t        };\n\t\t\t        if (this.apiKey) {\n\t\t\t            headers[\"x-api-key\"] = `${this.apiKey}`;\n\t\t\t        }\n\t\t\t        return headers;\n\t\t\t    }\n\t\t\t    processInputs(inputs) {\n\t\t\t        if (this.hideInputs === false) {\n\t\t\t            return inputs;\n\t\t\t        }\n\t\t\t        if (this.hideInputs === true) {\n\t\t\t            return {};\n\t\t\t        }\n\t\t\t        if (typeof this.hideInputs === \"function\") {\n\t\t\t            return this.hideInputs(inputs);\n\t\t\t        }\n\t\t\t        return inputs;\n\t\t\t    }\n\t\t\t    processOutputs(outputs) {\n\t\t\t        if (this.hideOutputs === false) {\n\t\t\t            return outputs;\n\t\t\t        }\n\t\t\t        if (this.hideOutputs === true) {\n\t\t\t            return {};\n\t\t\t        }\n\t\t\t        if (typeof this.hideOutputs === \"function\") {\n\t\t\t            return this.hideOutputs(outputs);\n\t\t\t        }\n\t\t\t        return outputs;\n\t\t\t    }\n\t\t\t    prepareRunCreateOrUpdateInputs(run) {\n\t\t\t        const runParams = { ...run };\n\t\t\t        if (runParams.inputs !== undefined) {\n\t\t\t            runParams.inputs = this.processInputs(runParams.inputs);\n\t\t\t        }\n\t\t\t        if (runParams.outputs !== undefined) {\n\t\t\t            runParams.outputs = this.processOutputs(runParams.outputs);\n\t\t\t        }\n\t\t\t        return runParams;\n\t\t\t    }\n\t\t\t    async _getResponse(path, queryParams) {\n\t\t\t        const paramsString = queryParams?.toString() ?? \"\";\n\t\t\t        const url = `${this.apiUrl}${path}?${paramsString}`;\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), url, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, `Failed to fetch ${path}`);\n\t\t\t        return response;\n\t\t\t    }\n\t\t\t    async _get(path, queryParams) {\n\t\t\t        const response = await this._getResponse(path, queryParams);\n\t\t\t        return response.json();\n\t\t\t    }\n\t\t\t    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n\t\t\t        let offset = Number(queryParams.get(\"offset\")) || 0;\n\t\t\t        const limit = Number(queryParams.get(\"limit\")) || 100;\n\t\t\t        while (true) {\n\t\t\t            queryParams.set(\"offset\", String(offset));\n\t\t\t            queryParams.set(\"limit\", String(limit));\n\t\t\t            const url = `${this.apiUrl}${path}?${queryParams}`;\n\t\t\t            const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), url, {\n\t\t\t                method: \"GET\",\n\t\t\t                headers: this.headers,\n\t\t\t                signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t                ...this.fetchOptions,\n\t\t\t            });\n\t\t\t            await (0, error_js_1.raiseForStatus)(response, `Failed to fetch ${path}`);\n\t\t\t            const items = transform\n\t\t\t                ? transform(await response.json())\n\t\t\t                : await response.json();\n\t\t\t            if (items.length === 0) {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t            yield items;\n\t\t\t            if (items.length < limit) {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t            offset += items.length;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n\t\t\t        const bodyParams = body ? { ...body } : {};\n\t\t\t        while (true) {\n\t\t\t            const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}${path}`, {\n\t\t\t                method: requestMethod,\n\t\t\t                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t                signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t                ...this.fetchOptions,\n\t\t\t                body: JSON.stringify(bodyParams),\n\t\t\t            });\n\t\t\t            const responseBody = await response.json();\n\t\t\t            if (!responseBody) {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t            if (!responseBody[dataKey]) {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t            yield responseBody[dataKey];\n\t\t\t            const cursors = responseBody.cursors;\n\t\t\t            if (!cursors) {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t            if (!cursors.next) {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t            bodyParams.cursor = cursors.next;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    _filterForSampling(runs, patch = false) {\n\t\t\t        if (this.tracingSampleRate === undefined) {\n\t\t\t            return runs;\n\t\t\t        }\n\t\t\t        if (patch) {\n\t\t\t            const sampled = [];\n\t\t\t            for (const run of runs) {\n\t\t\t                if (!this.filteredPostUuids.has(run.id)) {\n\t\t\t                    sampled.push(run);\n\t\t\t                }\n\t\t\t                else {\n\t\t\t                    this.filteredPostUuids.delete(run.id);\n\t\t\t                }\n\t\t\t            }\n\t\t\t            return sampled;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            const sampled = [];\n\t\t\t            for (const run of runs) {\n\t\t\t                if ((run.id !== run.trace_id &&\n\t\t\t                    !this.filteredPostUuids.has(run.trace_id)) ||\n\t\t\t                    Math.random() < this.tracingSampleRate) {\n\t\t\t                    sampled.push(run);\n\t\t\t                }\n\t\t\t                else {\n\t\t\t                    this.filteredPostUuids.add(run.id);\n\t\t\t                }\n\t\t\t            }\n\t\t\t            return sampled;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async drainAutoBatchQueue() {\n\t\t\t        while (this.autoBatchQueue.size >= 0) {\n\t\t\t            const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n\t\t\t            if (!batch.length) {\n\t\t\t                done();\n\t\t\t                return;\n\t\t\t            }\n\t\t\t            try {\n\t\t\t                await this.batchIngestRuns({\n\t\t\t                    runCreates: batch\n\t\t\t                        .filter((item) => item.action === \"create\")\n\t\t\t                        .map((item) => item.item),\n\t\t\t                    runUpdates: batch\n\t\t\t                        .filter((item) => item.action === \"update\")\n\t\t\t                        .map((item) => item.item),\n\t\t\t                });\n\t\t\t            }\n\t\t\t            finally {\n\t\t\t                done();\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async processRunOperation(item, immediatelyTriggerBatch) {\n\t\t\t        const oldTimeout = this.autoBatchTimeout;\n\t\t\t        clearTimeout(this.autoBatchTimeout);\n\t\t\t        this.autoBatchTimeout = undefined;\n\t\t\t        const itemPromise = this.autoBatchQueue.push(item);\n\t\t\t        if (immediatelyTriggerBatch ||\n\t\t\t            this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n\t\t\t            await this.drainAutoBatchQueue().catch(console.error);\n\t\t\t        }\n\t\t\t        if (this.autoBatchQueue.size > 0) {\n\t\t\t            this.autoBatchTimeout = setTimeout(() => {\n\t\t\t                this.autoBatchTimeout = undefined;\n\t\t\t                // This error would happen in the background and is uncatchable\n\t\t\t                // from the outside. So just log instead.\n\t\t\t                void this.drainAutoBatchQueue().catch(console.error);\n\t\t\t            }, oldTimeout\n\t\t\t                ? this.autoBatchAggregationDelayMs\n\t\t\t                : this.autoBatchInitialDelayMs);\n\t\t\t        }\n\t\t\t        return itemPromise;\n\t\t\t    }\n\t\t\t    async _getServerInfo() {\n\t\t\t        const response = await (0, fetch_js_1._getFetchImplementation)()(`${this.apiUrl}/info`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: { Accept: \"application/json\" },\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"get server info\");\n\t\t\t        return response.json();\n\t\t\t    }\n\t\t\t    async batchEndpointIsSupported() {\n\t\t\t        try {\n\t\t\t            this.serverInfo = await this._getServerInfo();\n\t\t\t        }\n\t\t\t        catch (e) {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t    async _getSettings() {\n\t\t\t        if (!this.settings) {\n\t\t\t            this.settings = this._get(\"/settings\");\n\t\t\t        }\n\t\t\t        return await this.settings;\n\t\t\t    }\n\t\t\t    async createRun(run) {\n\t\t\t        if (!this._filterForSampling([run]).length) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n\t\t\t        const session_name = run.project_name;\n\t\t\t        delete run.project_name;\n\t\t\t        const runCreate = this.prepareRunCreateOrUpdateInputs({\n\t\t\t            session_name,\n\t\t\t            ...run,\n\t\t\t            start_time: run.start_time ?? Date.now(),\n\t\t\t        });\n\t\t\t        if (this.autoBatchTracing &&\n\t\t\t            runCreate.trace_id !== undefined &&\n\t\t\t            runCreate.dotted_order !== undefined) {\n\t\t\t            void this.processRunOperation({\n\t\t\t                action: \"create\",\n\t\t\t                item: runCreate,\n\t\t\t            }).catch(console.error);\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n\t\t\t            runCreate,\n\t\t\t        ]);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/runs`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers,\n\t\t\t            body: (0, index_js_2.stringify)(mergedRunCreateParams[0]),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create run\", true);\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Batch ingest/upsert multiple runs in the Langsmith system.\n\t\t\t     * @param runs\n\t\t\t     */\n\t\t\t    async batchIngestRuns({ runCreates, runUpdates, }) {\n\t\t\t        if (runCreates === undefined && runUpdates === undefined) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n\t\t\t        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n\t\t\t        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n\t\t\t            const createById = preparedCreateParams.reduce((params, run) => {\n\t\t\t                if (!run.id) {\n\t\t\t                    return params;\n\t\t\t                }\n\t\t\t                params[run.id] = run;\n\t\t\t                return params;\n\t\t\t            }, {});\n\t\t\t            const standaloneUpdates = [];\n\t\t\t            for (const updateParam of preparedUpdateParams) {\n\t\t\t                if (updateParam.id !== undefined && createById[updateParam.id]) {\n\t\t\t                    createById[updateParam.id] = {\n\t\t\t                        ...createById[updateParam.id],\n\t\t\t                        ...updateParam,\n\t\t\t                    };\n\t\t\t                }\n\t\t\t                else {\n\t\t\t                    standaloneUpdates.push(updateParam);\n\t\t\t                }\n\t\t\t            }\n\t\t\t            preparedCreateParams = Object.values(createById);\n\t\t\t            preparedUpdateParams = standaloneUpdates;\n\t\t\t        }\n\t\t\t        const rawBatch = {\n\t\t\t            post: this._filterForSampling(preparedCreateParams),\n\t\t\t            patch: this._filterForSampling(preparedUpdateParams, true),\n\t\t\t        };\n\t\t\t        if (!rawBatch.post.length && !rawBatch.patch.length) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n\t\t\t        if (this.batchEndpointSupported === undefined) {\n\t\t\t            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n\t\t\t        }\n\t\t\t        if (!this.batchEndpointSupported) {\n\t\t\t            this.autoBatchTracing = false;\n\t\t\t            for (const preparedCreateParam of rawBatch.post) {\n\t\t\t                await this.createRun(preparedCreateParam);\n\t\t\t            }\n\t\t\t            for (const preparedUpdateParam of rawBatch.patch) {\n\t\t\t                if (preparedUpdateParam.id !== undefined) {\n\t\t\t                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n\t\t\t                }\n\t\t\t            }\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        const sizeLimitBytes = this.serverInfo?.batch_ingest_config?.size_limit_bytes ??\n\t\t\t            exports.DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n\t\t\t        const batchChunks = {\n\t\t\t            post: [],\n\t\t\t            patch: [],\n\t\t\t        };\n\t\t\t        let currentBatchSizeBytes = 0;\n\t\t\t        for (const k of [\"post\", \"patch\"]) {\n\t\t\t            const key = k;\n\t\t\t            const batchItems = rawBatch[key].reverse();\n\t\t\t            let batchItem = batchItems.pop();\n\t\t\t            while (batchItem !== undefined) {\n\t\t\t                const stringifiedBatchItem = (0, index_js_2.stringify)(batchItem);\n\t\t\t                if (currentBatchSizeBytes > 0 &&\n\t\t\t                    currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {\n\t\t\t                    await this._postBatchIngestRuns((0, index_js_2.stringify)(batchChunks));\n\t\t\t                    currentBatchSizeBytes = 0;\n\t\t\t                    batchChunks.post = [];\n\t\t\t                    batchChunks.patch = [];\n\t\t\t                }\n\t\t\t                currentBatchSizeBytes += stringifiedBatchItem.length;\n\t\t\t                batchChunks[key].push(batchItem);\n\t\t\t                batchItem = batchItems.pop();\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n\t\t\t            await this._postBatchIngestRuns((0, index_js_2.stringify)(batchChunks));\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async _postBatchIngestRuns(body) {\n\t\t\t        const headers = {\n\t\t\t            ...this.headers,\n\t\t\t            \"Content-Type\": \"application/json\",\n\t\t\t            Accept: \"application/json\",\n\t\t\t        };\n\t\t\t        const response = await this.batchIngestCaller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/runs/batch`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers,\n\t\t\t            body: body,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"batch create run\", true);\n\t\t\t    }\n\t\t\t    async updateRun(runId, run) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(runId);\n\t\t\t        if (run.inputs) {\n\t\t\t            run.inputs = this.processInputs(run.inputs);\n\t\t\t        }\n\t\t\t        if (run.outputs) {\n\t\t\t            run.outputs = this.processOutputs(run.outputs);\n\t\t\t        }\n\t\t\t        // TODO: Untangle types\n\t\t\t        const data = { ...run, id: runId };\n\t\t\t        if (!this._filterForSampling([data], true).length) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        if (this.autoBatchTracing &&\n\t\t\t            data.trace_id !== undefined &&\n\t\t\t            data.dotted_order !== undefined) {\n\t\t\t            if (run.end_time !== undefined && data.parent_run_id === undefined) {\n\t\t\t                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n\t\t\t                // in serverless environments.\n\t\t\t                await this.processRunOperation({ action: \"update\", item: data }, true);\n\t\t\t                return;\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                void this.processRunOperation({ action: \"update\", item: data }).catch(console.error);\n\t\t\t            }\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}`, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            headers,\n\t\t\t            body: (0, index_js_2.stringify)(run),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update run\", true);\n\t\t\t    }\n\t\t\t    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(runId);\n\t\t\t        let run = await this._get(`/runs/${runId}`);\n\t\t\t        if (loadChildRuns && run.child_run_ids) {\n\t\t\t            run = await this._loadChildRuns(run);\n\t\t\t        }\n\t\t\t        return run;\n\t\t\t    }\n\t\t\t    async getRunUrl({ runId, run, projectOpts, }) {\n\t\t\t        if (run !== undefined) {\n\t\t\t            let sessionId;\n\t\t\t            if (run.session_id) {\n\t\t\t                sessionId = run.session_id;\n\t\t\t            }\n\t\t\t            else if (projectOpts?.projectName) {\n\t\t\t                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n\t\t\t            }\n\t\t\t            else if (projectOpts?.projectId) {\n\t\t\t                sessionId = projectOpts?.projectId;\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                const project = await this.readProject({\n\t\t\t                    projectName: (0, env_js_1.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\",\n\t\t\t                });\n\t\t\t                sessionId = project.id;\n\t\t\t            }\n\t\t\t            const tenantId = await this._getTenantId();\n\t\t\t            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n\t\t\t        }\n\t\t\t        else if (runId !== undefined) {\n\t\t\t            const run_ = await this.readRun(runId);\n\t\t\t            if (!run_.app_path) {\n\t\t\t                throw new Error(`Run ${runId} has no app_path`);\n\t\t\t            }\n\t\t\t            const baseUrl = this.getHostUrl();\n\t\t\t            return `${baseUrl}${run_.app_path}`;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(\"Must provide either runId or run\");\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async _loadChildRuns(run) {\n\t\t\t        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n\t\t\t        const treemap = {};\n\t\t\t        const runs = {};\n\t\t\t        // TODO: make dotted order required when the migration finishes\n\t\t\t        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n\t\t\t        for (const childRun of childRuns) {\n\t\t\t            if (childRun.parent_run_id === null ||\n\t\t\t                childRun.parent_run_id === undefined) {\n\t\t\t                throw new Error(`Child run ${childRun.id} has no parent`);\n\t\t\t            }\n\t\t\t            if (!(childRun.parent_run_id in treemap)) {\n\t\t\t                treemap[childRun.parent_run_id] = [];\n\t\t\t            }\n\t\t\t            treemap[childRun.parent_run_id].push(childRun);\n\t\t\t            runs[childRun.id] = childRun;\n\t\t\t        }\n\t\t\t        run.child_runs = treemap[run.id] || [];\n\t\t\t        for (const runId in treemap) {\n\t\t\t            if (runId !== run.id) {\n\t\t\t                runs[runId].child_runs = treemap[runId];\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return run;\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * List runs from the LangSmith server.\n\t\t\t     * @param projectId - The ID of the project to filter by.\n\t\t\t     * @param projectName - The name of the project to filter by.\n\t\t\t     * @param parentRunId - The ID of the parent run to filter by.\n\t\t\t     * @param traceId - The ID of the trace to filter by.\n\t\t\t     * @param referenceExampleId - The ID of the reference example to filter by.\n\t\t\t     * @param startTime - The start time to filter by.\n\t\t\t     * @param isRoot - Indicates whether to only return root runs.\n\t\t\t     * @param runType - The run type to filter by.\n\t\t\t     * @param error - Indicates whether to filter by error runs.\n\t\t\t     * @param id - The ID of the run to filter by.\n\t\t\t     * @param query - The query string to filter by.\n\t\t\t     * @param filter - The filter string to apply to the run spans.\n\t\t\t     * @param traceFilter - The filter string to apply on the root run of the trace.\n\t\t\t     * @param limit - The maximum number of runs to retrieve.\n\t\t\t     * @returns {AsyncIterable<Run>} - The runs.\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List all runs in a project\n\t\t\t     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List LLM and Chat runs in the last 24 hours\n\t\t\t     * const todaysLLMRuns = client.listRuns({\n\t\t\t     *   projectName: \"<your_project>\",\n\t\t\t     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n\t\t\t     *   run_type: \"llm\",\n\t\t\t     * });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List traces in a project\n\t\t\t     * const rootRuns = client.listRuns({\n\t\t\t     *   projectName: \"<your_project>\",\n\t\t\t     *   execution_order: 1,\n\t\t\t     * });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List runs without errors\n\t\t\t     * const correctRuns = client.listRuns({\n\t\t\t     *   projectName: \"<your_project>\",\n\t\t\t     *   error: false,\n\t\t\t     * });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List runs by run ID\n\t\t\t     * const runIds = [\n\t\t\t     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n\t\t\t     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n\t\t\t     * ];\n\t\t\t     * const selectedRuns = client.listRuns({ run_ids: runIds });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n\t\t\t     * const chainRuns = client.listRuns({\n\t\t\t     *   projectName: \"<your_project>\",\n\t\t\t     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n\t\t\t     * });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n\t\t\t     * const goodExtractorRuns = client.listRuns({\n\t\t\t     *   projectName: \"<your_project>\",\n\t\t\t     *   filter: 'eq(name, \"extractor\")',\n\t\t\t     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n\t\t\t     * });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n\t\t\t     * const complexRuns = client.listRuns({\n\t\t\t     *   projectName: \"<your_project>\",\n\t\t\t     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n\t\t\t     * });\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n\t\t\t     * const taggedRuns = client.listRuns({\n\t\t\t     *   projectName: \"<your_project>\",\n\t\t\t     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n\t\t\t     * });\n\t\t\t     */\n\t\t\t    async *listRuns(props) {\n\t\t\t        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, } = props;\n\t\t\t        let projectIds = [];\n\t\t\t        if (projectId) {\n\t\t\t            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n\t\t\t        }\n\t\t\t        if (projectName) {\n\t\t\t            const projectNames = Array.isArray(projectName)\n\t\t\t                ? projectName\n\t\t\t                : [projectName];\n\t\t\t            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n\t\t\t            projectIds.push(...projectIds_);\n\t\t\t        }\n\t\t\t        const default_select = [\n\t\t\t            \"app_path\",\n\t\t\t            \"child_run_ids\",\n\t\t\t            \"completion_cost\",\n\t\t\t            \"completion_tokens\",\n\t\t\t            \"dotted_order\",\n\t\t\t            \"end_time\",\n\t\t\t            \"error\",\n\t\t\t            \"events\",\n\t\t\t            \"extra\",\n\t\t\t            \"feedback_stats\",\n\t\t\t            \"first_token_time\",\n\t\t\t            \"id\",\n\t\t\t            \"inputs\",\n\t\t\t            \"name\",\n\t\t\t            \"outputs\",\n\t\t\t            \"parent_run_id\",\n\t\t\t            \"parent_run_ids\",\n\t\t\t            \"prompt_cost\",\n\t\t\t            \"prompt_tokens\",\n\t\t\t            \"reference_example_id\",\n\t\t\t            \"run_type\",\n\t\t\t            \"session_id\",\n\t\t\t            \"start_time\",\n\t\t\t            \"status\",\n\t\t\t            \"tags\",\n\t\t\t            \"total_cost\",\n\t\t\t            \"total_tokens\",\n\t\t\t            \"trace_id\",\n\t\t\t        ];\n\t\t\t        const body = {\n\t\t\t            session: projectIds.length ? projectIds : null,\n\t\t\t            run_type: runType,\n\t\t\t            reference_example: referenceExampleId,\n\t\t\t            query,\n\t\t\t            filter,\n\t\t\t            trace_filter: traceFilter,\n\t\t\t            tree_filter: treeFilter,\n\t\t\t            execution_order: executionOrder,\n\t\t\t            parent_run: parentRunId,\n\t\t\t            start_time: startTime ? startTime.toISOString() : null,\n\t\t\t            error,\n\t\t\t            id,\n\t\t\t            limit,\n\t\t\t            trace: traceId,\n\t\t\t            select: select ? select : default_select,\n\t\t\t            is_root: isRoot,\n\t\t\t        };\n\t\t\t        let runsYielded = 0;\n\t\t\t        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n\t\t\t            if (limit) {\n\t\t\t                if (runsYielded >= limit) {\n\t\t\t                    break;\n\t\t\t                }\n\t\t\t                if (runs.length + runsYielded > limit) {\n\t\t\t                    const newRuns = runs.slice(0, limit - runsYielded);\n\t\t\t                    yield* newRuns;\n\t\t\t                    break;\n\t\t\t                }\n\t\t\t                runsYielded += runs.length;\n\t\t\t                yield* runs;\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                yield* runs;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }) {\n\t\t\t        let projectIds_ = projectIds || [];\n\t\t\t        if (projectNames) {\n\t\t\t            projectIds_ = [\n\t\t\t                ...(projectIds || []),\n\t\t\t                ...(await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))),\n\t\t\t            ];\n\t\t\t        }\n\t\t\t        const payload = {\n\t\t\t            id,\n\t\t\t            trace,\n\t\t\t            parent_run: parentRun,\n\t\t\t            run_type: runType,\n\t\t\t            session: projectIds_,\n\t\t\t            reference_example: referenceExampleIds,\n\t\t\t            start_time: startTime,\n\t\t\t            end_time: endTime,\n\t\t\t            error,\n\t\t\t            query,\n\t\t\t            filter,\n\t\t\t            trace_filter: traceFilter,\n\t\t\t            tree_filter: treeFilter,\n\t\t\t            is_root: isRoot,\n\t\t\t            data_source_type: dataSourceType,\n\t\t\t        };\n\t\t\t        // Remove undefined values from the payload\n\t\t\t        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/runs/stats`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: this.headers,\n\t\t\t            body: JSON.stringify(filteredPayload),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async shareRun(runId, { shareId } = {}) {\n\t\t\t        const data = {\n\t\t\t            run_id: runId,\n\t\t\t            share_token: shareId || uuid.v4(),\n\t\t\t        };\n\t\t\t        (0, _uuid_js_1.assertUuid)(runId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n\t\t\t            method: \"PUT\",\n\t\t\t            headers: this.headers,\n\t\t\t            body: JSON.stringify(data),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const result = await response.json();\n\t\t\t        if (result === null || !(\"share_token\" in result)) {\n\t\t\t            throw new Error(\"Invalid response from server\");\n\t\t\t        }\n\t\t\t        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n\t\t\t    }\n\t\t\t    async unshareRun(runId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(runId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"unshare run\", true);\n\t\t\t    }\n\t\t\t    async readRunSharedLink(runId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(runId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const result = await response.json();\n\t\t\t        if (result === null || !(\"share_token\" in result)) {\n\t\t\t            return undefined;\n\t\t\t        }\n\t\t\t        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n\t\t\t    }\n\t\t\t    async listSharedRuns(shareToken, { runIds, } = {}) {\n\t\t\t        const queryParams = new URLSearchParams({\n\t\t\t            share_token: shareToken,\n\t\t\t        });\n\t\t\t        if (runIds !== undefined) {\n\t\t\t            for (const runId of runIds) {\n\t\t\t                queryParams.append(\"id\", runId);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(shareToken);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const runs = await response.json();\n\t\t\t        return runs;\n\t\t\t    }\n\t\t\t    async readDatasetSharedSchema(datasetId, datasetName) {\n\t\t\t        if (!datasetId && !datasetName) {\n\t\t\t            throw new Error(\"Either datasetId or datasetName must be given\");\n\t\t\t        }\n\t\t\t        if (!datasetId) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId = dataset.id;\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(datasetId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const shareSchema = await response.json();\n\t\t\t        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n\t\t\t        return shareSchema;\n\t\t\t    }\n\t\t\t    async shareDataset(datasetId, datasetName) {\n\t\t\t        if (!datasetId && !datasetName) {\n\t\t\t            throw new Error(\"Either datasetId or datasetName must be given\");\n\t\t\t        }\n\t\t\t        if (!datasetId) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId = dataset.id;\n\t\t\t        }\n\t\t\t        const data = {\n\t\t\t            dataset_id: datasetId,\n\t\t\t        };\n\t\t\t        (0, _uuid_js_1.assertUuid)(datasetId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n\t\t\t            method: \"PUT\",\n\t\t\t            headers: this.headers,\n\t\t\t            body: JSON.stringify(data),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const shareSchema = await response.json();\n\t\t\t        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n\t\t\t        return shareSchema;\n\t\t\t    }\n\t\t\t    async unshareDataset(datasetId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(datasetId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"unshare dataset\", true);\n\t\t\t    }\n\t\t\t    async readSharedDataset(shareToken) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(shareToken);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/datasets`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const dataset = await response.json();\n\t\t\t        return dataset;\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Get shared examples.\n\t\t\t     *\n\t\t\t     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n\t\t\t     * @param {Object} [options] Additional options for listing the examples.\n\t\t\t     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n\t\t\t     * @returns {Promise<Example[]>} The shared examples.\n\t\t\t     */\n\t\t\t    async listSharedExamples(shareToken, options) {\n\t\t\t        const params = {};\n\t\t\t        if (options?.exampleIds) {\n\t\t\t            params.id = options.exampleIds;\n\t\t\t        }\n\t\t\t        const urlParams = new URLSearchParams();\n\t\t\t        Object.entries(params).forEach(([key, value]) => {\n\t\t\t            if (Array.isArray(value)) {\n\t\t\t                value.forEach((v) => urlParams.append(key, v));\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                urlParams.append(key, value);\n\t\t\t            }\n\t\t\t        });\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const result = await response.json();\n\t\t\t        if (!response.ok) {\n\t\t\t            if (\"detail\" in result) {\n\t\t\t                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${result.detail.join(\"\\n\")}`);\n\t\t\t            }\n\t\t\t            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n\t\t\t        }\n\t\t\t        return result.map((example) => ({\n\t\t\t            ...example,\n\t\t\t            _hostUrl: this.getHostUrl(),\n\t\t\t        }));\n\t\t\t    }\n\t\t\t    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n\t\t\t        const upsert_ = upsert ? `?upsert=true` : \"\";\n\t\t\t        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n\t\t\t        const extra = projectExtra || {};\n\t\t\t        if (metadata) {\n\t\t\t            extra[\"metadata\"] = metadata;\n\t\t\t        }\n\t\t\t        const body = {\n\t\t\t            name: projectName,\n\t\t\t            extra,\n\t\t\t            description,\n\t\t\t        };\n\t\t\t        if (referenceDatasetId !== null) {\n\t\t\t            body[\"reference_dataset_id\"] = referenceDatasetId;\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), endpoint, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(body),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create project\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n\t\t\t        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n\t\t\t        let extra = projectExtra;\n\t\t\t        if (metadata) {\n\t\t\t            extra = { ...(extra || {}), metadata };\n\t\t\t        }\n\t\t\t        const body = {\n\t\t\t            name,\n\t\t\t            extra,\n\t\t\t            description,\n\t\t\t            end_time: endTime ? new Date(endTime).toISOString() : null,\n\t\t\t        };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), endpoint, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(body),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update project\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async hasProject({ projectId, projectName, }) {\n\t\t\t        // TODO: Add a head request\n\t\t\t        let path = \"/sessions\";\n\t\t\t        const params = new URLSearchParams();\n\t\t\t        if (projectId !== undefined && projectName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either projectName or projectId, not both\");\n\t\t\t        }\n\t\t\t        else if (projectId !== undefined) {\n\t\t\t            (0, _uuid_js_1.assertUuid)(projectId);\n\t\t\t            path += `/${projectId}`;\n\t\t\t        }\n\t\t\t        else if (projectName !== undefined) {\n\t\t\t            params.append(\"name\", projectName);\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(\"Must provide projectName or projectId\");\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}${path}?${params}`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        // consume the response body to release the connection\n\t\t\t        // https://undici.nodejs.org/#/?id=garbage-collection\n\t\t\t        try {\n\t\t\t            const result = await response.json();\n\t\t\t            if (!response.ok) {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t            // If it's OK and we're querying by name, need to check the list is not empty\n\t\t\t            if (Array.isArray(result)) {\n\t\t\t                return result.length > 0;\n\t\t\t            }\n\t\t\t            // projectId querying\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        catch (e) {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async readProject({ projectId, projectName, includeStats, }) {\n\t\t\t        let path = \"/sessions\";\n\t\t\t        const params = new URLSearchParams();\n\t\t\t        if (projectId !== undefined && projectName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either projectName or projectId, not both\");\n\t\t\t        }\n\t\t\t        else if (projectId !== undefined) {\n\t\t\t            (0, _uuid_js_1.assertUuid)(projectId);\n\t\t\t            path += `/${projectId}`;\n\t\t\t        }\n\t\t\t        else if (projectName !== undefined) {\n\t\t\t            params.append(\"name\", projectName);\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(\"Must provide projectName or projectId\");\n\t\t\t        }\n\t\t\t        if (includeStats !== undefined) {\n\t\t\t            params.append(\"include_stats\", includeStats.toString());\n\t\t\t        }\n\t\t\t        const response = await this._get(path, params);\n\t\t\t        let result;\n\t\t\t        if (Array.isArray(response)) {\n\t\t\t            if (response.length === 0) {\n\t\t\t                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n\t\t\t            }\n\t\t\t            result = response[0];\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            result = response;\n\t\t\t        }\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async getProjectUrl({ projectId, projectName, }) {\n\t\t\t        if (projectId === undefined && projectName === undefined) {\n\t\t\t            throw new Error(\"Must provide either projectName or projectId\");\n\t\t\t        }\n\t\t\t        const project = await this.readProject({ projectId, projectName });\n\t\t\t        const tenantId = await this._getTenantId();\n\t\t\t        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n\t\t\t    }\n\t\t\t    async getDatasetUrl({ datasetId, datasetName, }) {\n\t\t\t        if (datasetId === undefined && datasetName === undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        const dataset = await this.readDataset({ datasetId, datasetName });\n\t\t\t        const tenantId = await this._getTenantId();\n\t\t\t        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n\t\t\t    }\n\t\t\t    async _getTenantId() {\n\t\t\t        if (this._tenantId !== null) {\n\t\t\t            return this._tenantId;\n\t\t\t        }\n\t\t\t        const queryParams = new URLSearchParams({ limit: \"1\" });\n\t\t\t        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n\t\t\t            this._tenantId = projects[0].tenant_id;\n\t\t\t            return projects[0].tenant_id;\n\t\t\t        }\n\t\t\t        throw new Error(\"No projects found to resolve tenant.\");\n\t\t\t    }\n\t\t\t    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata, } = {}) {\n\t\t\t        const params = new URLSearchParams();\n\t\t\t        if (projectIds !== undefined) {\n\t\t\t            for (const projectId of projectIds) {\n\t\t\t                params.append(\"id\", projectId);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (name !== undefined) {\n\t\t\t            params.append(\"name\", name);\n\t\t\t        }\n\t\t\t        if (nameContains !== undefined) {\n\t\t\t            params.append(\"name_contains\", nameContains);\n\t\t\t        }\n\t\t\t        if (referenceDatasetId !== undefined) {\n\t\t\t            params.append(\"reference_dataset\", referenceDatasetId);\n\t\t\t        }\n\t\t\t        else if (referenceDatasetName !== undefined) {\n\t\t\t            const dataset = await this.readDataset({\n\t\t\t                datasetName: referenceDatasetName,\n\t\t\t            });\n\t\t\t            params.append(\"reference_dataset\", dataset.id);\n\t\t\t        }\n\t\t\t        if (referenceFree !== undefined) {\n\t\t\t            params.append(\"reference_free\", referenceFree.toString());\n\t\t\t        }\n\t\t\t        if (metadata !== undefined) {\n\t\t\t            params.append(\"metadata\", JSON.stringify(metadata));\n\t\t\t        }\n\t\t\t        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n\t\t\t            yield* projects;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async deleteProject({ projectId, projectName, }) {\n\t\t\t        let projectId_;\n\t\t\t        if (projectId === undefined && projectName === undefined) {\n\t\t\t            throw new Error(\"Must provide projectName or projectId\");\n\t\t\t        }\n\t\t\t        else if (projectId !== undefined && projectName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either projectName or projectId, not both\");\n\t\t\t        }\n\t\t\t        else if (projectId === undefined) {\n\t\t\t            projectId_ = (await this.readProject({ projectName })).id;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            projectId_ = projectId;\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(projectId_);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/sessions/${projectId_}`, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, `delete session ${projectId_} (${projectName})`, true);\n\t\t\t    }\n\t\t\t    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n\t\t\t        const url = `${this.apiUrl}/datasets/upload`;\n\t\t\t        const formData = new FormData();\n\t\t\t        formData.append(\"file\", csvFile, fileName);\n\t\t\t        inputKeys.forEach((key) => {\n\t\t\t            formData.append(\"input_keys\", key);\n\t\t\t        });\n\t\t\t        outputKeys.forEach((key) => {\n\t\t\t            formData.append(\"output_keys\", key);\n\t\t\t        });\n\t\t\t        if (description) {\n\t\t\t            formData.append(\"description\", description);\n\t\t\t        }\n\t\t\t        if (dataType) {\n\t\t\t            formData.append(\"data_type\", dataType);\n\t\t\t        }\n\t\t\t        if (name) {\n\t\t\t            formData.append(\"name\", name);\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), url, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: this.headers,\n\t\t\t            body: formData,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"upload CSV\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata, } = {}) {\n\t\t\t        const body = {\n\t\t\t            name,\n\t\t\t            description,\n\t\t\t            extra: metadata ? { metadata } : undefined,\n\t\t\t        };\n\t\t\t        if (dataType) {\n\t\t\t            body.data_type = dataType;\n\t\t\t        }\n\t\t\t        if (inputsSchema) {\n\t\t\t            body.inputs_schema_definition = inputsSchema;\n\t\t\t        }\n\t\t\t        if (outputsSchema) {\n\t\t\t            body.outputs_schema_definition = outputsSchema;\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(body),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create dataset\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async readDataset({ datasetId, datasetName, }) {\n\t\t\t        let path = \"/datasets\";\n\t\t\t        // limit to 1 result\n\t\t\t        const params = new URLSearchParams({ limit: \"1\" });\n\t\t\t        if (datasetId !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetId !== undefined) {\n\t\t\t            (0, _uuid_js_1.assertUuid)(datasetId);\n\t\t\t            path += `/${datasetId}`;\n\t\t\t        }\n\t\t\t        else if (datasetName !== undefined) {\n\t\t\t            params.append(\"name\", datasetName);\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(\"Must provide datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        const response = await this._get(path, params);\n\t\t\t        let result;\n\t\t\t        if (Array.isArray(response)) {\n\t\t\t            if (response.length === 0) {\n\t\t\t                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n\t\t\t            }\n\t\t\t            result = response[0];\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            result = response;\n\t\t\t        }\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async hasDataset({ datasetId, datasetName, }) {\n\t\t\t        try {\n\t\t\t            await this.readDataset({ datasetId, datasetName });\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        catch (e) {\n\t\t\t            if (\n\t\t\t            // eslint-disable-next-line no-instanceof/no-instanceof\n\t\t\t            e instanceof Error &&\n\t\t\t                e.message.toLocaleLowerCase().includes(\"not found\")) {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t            throw e;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n\t\t\t        let datasetId_ = datasetId;\n\t\t\t        if (datasetId_ === undefined && datasetName === undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        else if (datasetId_ !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetId_ === undefined) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        const urlParams = new URLSearchParams({\n\t\t\t            from_version: typeof fromVersion === \"string\"\n\t\t\t                ? fromVersion\n\t\t\t                : fromVersion.toISOString(),\n\t\t\t            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n\t\t\t        });\n\t\t\t        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n\t\t\t        return response;\n\t\t\t    }\n\t\t\t    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n\t\t\t        const path = \"/datasets\";\n\t\t\t        if (datasetId !== undefined) ;\n\t\t\t        else if (datasetName !== undefined) {\n\t\t\t            datasetId = (await this.readDataset({ datasetName })).id;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(\"Must provide datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n\t\t\t        const datasetText = await response.text();\n\t\t\t        const dataset = datasetText\n\t\t\t            .trim()\n\t\t\t            .split(\"\\n\")\n\t\t\t            .map((line) => JSON.parse(line));\n\t\t\t        return dataset;\n\t\t\t    }\n\t\t\t    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata, } = {}) {\n\t\t\t        const path = \"/datasets\";\n\t\t\t        const params = new URLSearchParams({\n\t\t\t            limit: limit.toString(),\n\t\t\t            offset: offset.toString(),\n\t\t\t        });\n\t\t\t        if (datasetIds !== undefined) {\n\t\t\t            for (const id_ of datasetIds) {\n\t\t\t                params.append(\"id\", id_);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (datasetName !== undefined) {\n\t\t\t            params.append(\"name\", datasetName);\n\t\t\t        }\n\t\t\t        if (datasetNameContains !== undefined) {\n\t\t\t            params.append(\"name_contains\", datasetNameContains);\n\t\t\t        }\n\t\t\t        if (metadata !== undefined) {\n\t\t\t            params.append(\"metadata\", JSON.stringify(metadata));\n\t\t\t        }\n\t\t\t        for await (const datasets of this._getPaginated(path, params)) {\n\t\t\t            yield* datasets;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Update a dataset\n\t\t\t     * @param props The dataset details to update\n\t\t\t     * @returns The updated dataset\n\t\t\t     */\n\t\t\t    async updateDataset(props) {\n\t\t\t        const { datasetId, datasetName, ...update } = props;\n\t\t\t        if (!datasetId && !datasetName) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n\t\t\t        (0, _uuid_js_1.assertUuid)(_datasetId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/${_datasetId}`, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(update),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update dataset\");\n\t\t\t        return (await response.json());\n\t\t\t    }\n\t\t\t    async deleteDataset({ datasetId, datasetName, }) {\n\t\t\t        let path = \"/datasets\";\n\t\t\t        let datasetId_ = datasetId;\n\t\t\t        if (datasetId !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetName !== undefined) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        if (datasetId_ !== undefined) {\n\t\t\t            (0, _uuid_js_1.assertUuid)(datasetId_);\n\t\t\t            path += `/${datasetId_}`;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(\"Must provide datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), this.apiUrl + path, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, `delete ${path}`);\n\t\t\t        await response.json();\n\t\t\t    }\n\t\t\t    async indexDataset({ datasetId, datasetName, tag, }) {\n\t\t\t        let datasetId_ = datasetId;\n\t\t\t        if (!datasetId_ && !datasetName) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        else if (datasetId_ && datasetName) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (!datasetId_) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(datasetId_);\n\t\t\t        const data = {\n\t\t\t            tag: tag,\n\t\t\t        };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/index`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(data),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"index dataset\");\n\t\t\t        await response.json();\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Lets you run a similarity search query on a dataset.\n\t\t\t     *\n\t\t\t     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n\t\t\t     *\n\t\t\t     * @param inputs      The input on which to run the similarity search. Must have the\n\t\t\t     *                    same schema as the dataset.\n\t\t\t     *\n\t\t\t     * @param datasetId   The dataset to search for similar examples.\n\t\t\t     *\n\t\t\t     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n\t\t\t     *                    similar examples in order of most similar to least similar. If no similar\n\t\t\t     *                    examples are found, random examples will be returned.\n\t\t\t     *\n\t\t\t     * @param filter      A filter string to apply to the search. Only examples will be returned that\n\t\t\t     *                    match the filter string. Some examples of filters\n\t\t\t     *\n\t\t\t     *                    - eq(metadata.mykey, \"value\")\n\t\t\t     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n\t\t\t     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n\t\t\t     *\n\t\t\t     * @returns           A list of similar examples.\n\t\t\t     *\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n\t\t\t     * inputs = {\"text\": \"How many people live in Berlin?\"}\n\t\t\t     * limit = 5\n\t\t\t     * examples = await client.similarExamples(inputs, dataset_id, limit)\n\t\t\t     */\n\t\t\t    async similarExamples(inputs, datasetId, limit, { filter, } = {}) {\n\t\t\t        const data = {\n\t\t\t            limit: limit,\n\t\t\t            inputs: inputs,\n\t\t\t        };\n\t\t\t        if (filter !== undefined) {\n\t\t\t            data[\"filter\"] = filter;\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(datasetId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/search`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(data),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"fetch similar examples\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result[\"examples\"];\n\t\t\t    }\n\t\t\t    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId, metadata, split, sourceRunId, }) {\n\t\t\t        let datasetId_ = datasetId;\n\t\t\t        if (datasetId_ === undefined && datasetName === undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        else if (datasetId_ !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetId_ === undefined) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        const createdAt_ = createdAt || new Date();\n\t\t\t        const data = {\n\t\t\t            dataset_id: datasetId_,\n\t\t\t            inputs,\n\t\t\t            outputs,\n\t\t\t            created_at: createdAt_?.toISOString(),\n\t\t\t            id: exampleId,\n\t\t\t            metadata,\n\t\t\t            split,\n\t\t\t            source_run_id: sourceRunId,\n\t\t\t        };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/examples`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(data),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create example\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async createExamples(props) {\n\t\t\t        const { inputs, outputs, metadata, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n\t\t\t        let datasetId_ = datasetId;\n\t\t\t        if (datasetId_ === undefined && datasetName === undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        else if (datasetId_ !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetId_ === undefined) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        const formattedExamples = inputs.map((input, idx) => {\n\t\t\t            return {\n\t\t\t                dataset_id: datasetId_,\n\t\t\t                inputs: input,\n\t\t\t                outputs: outputs ? outputs[idx] : undefined,\n\t\t\t                metadata: metadata ? metadata[idx] : undefined,\n\t\t\t                split: props.splits ? props.splits[idx] : undefined,\n\t\t\t                id: exampleIds ? exampleIds[idx] : undefined,\n\t\t\t                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n\t\t\t            };\n\t\t\t        });\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/examples/bulk`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(formattedExamples),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create examples\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async createLLMExample(input, generation, options) {\n\t\t\t        return this.createExample({ input }, { output: generation }, options);\n\t\t\t    }\n\t\t\t    async createChatExample(input, generations, options) {\n\t\t\t        const finalInput = input.map((message) => {\n\t\t\t            if ((0, messages_js_1.isLangChainMessage)(message)) {\n\t\t\t                return (0, messages_js_1.convertLangChainMessageToExample)(message);\n\t\t\t            }\n\t\t\t            return message;\n\t\t\t        });\n\t\t\t        const finalOutput = (0, messages_js_1.isLangChainMessage)(generations)\n\t\t\t            ? (0, messages_js_1.convertLangChainMessageToExample)(generations)\n\t\t\t            : generations;\n\t\t\t        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n\t\t\t    }\n\t\t\t    async readExample(exampleId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(exampleId);\n\t\t\t        const path = `/examples/${exampleId}`;\n\t\t\t        return await this._get(path);\n\t\t\t    }\n\t\t\t    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, } = {}) {\n\t\t\t        let datasetId_;\n\t\t\t        if (datasetId !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetId !== undefined) {\n\t\t\t            datasetId_ = datasetId;\n\t\t\t        }\n\t\t\t        else if (datasetName !== undefined) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(\"Must provide a datasetName or datasetId\");\n\t\t\t        }\n\t\t\t        const params = new URLSearchParams({ dataset: datasetId_ });\n\t\t\t        const dataset_version = asOf\n\t\t\t            ? typeof asOf === \"string\"\n\t\t\t                ? asOf\n\t\t\t                : asOf?.toISOString()\n\t\t\t            : undefined;\n\t\t\t        if (dataset_version) {\n\t\t\t            params.append(\"as_of\", dataset_version);\n\t\t\t        }\n\t\t\t        const inlineS3Urls_ = inlineS3Urls ?? true;\n\t\t\t        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n\t\t\t        if (exampleIds !== undefined) {\n\t\t\t            for (const id_ of exampleIds) {\n\t\t\t                params.append(\"id\", id_);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (splits !== undefined) {\n\t\t\t            for (const split of splits) {\n\t\t\t                params.append(\"splits\", split);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (metadata !== undefined) {\n\t\t\t            const serializedMetadata = JSON.stringify(metadata);\n\t\t\t            params.append(\"metadata\", serializedMetadata);\n\t\t\t        }\n\t\t\t        if (limit !== undefined) {\n\t\t\t            params.append(\"limit\", limit.toString());\n\t\t\t        }\n\t\t\t        if (offset !== undefined) {\n\t\t\t            params.append(\"offset\", offset.toString());\n\t\t\t        }\n\t\t\t        if (filter !== undefined) {\n\t\t\t            params.append(\"filter\", filter);\n\t\t\t        }\n\t\t\t        let i = 0;\n\t\t\t        for await (const examples of this._getPaginated(\"/examples\", params)) {\n\t\t\t            for (const example of examples) {\n\t\t\t                yield example;\n\t\t\t                i++;\n\t\t\t            }\n\t\t\t            if (limit !== undefined && i >= limit) {\n\t\t\t                break;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async deleteExample(exampleId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(exampleId);\n\t\t\t        const path = `/examples/${exampleId}`;\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), this.apiUrl + path, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, `delete ${path}`);\n\t\t\t        await response.json();\n\t\t\t    }\n\t\t\t    async updateExample(exampleId, update) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(exampleId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/examples/${exampleId}`, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(update),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update example\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async updateExamples(update) {\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/examples/bulk`, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(update),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update examples\");\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async listDatasetSplits({ datasetId, datasetName, asOf, }) {\n\t\t\t        let datasetId_;\n\t\t\t        if (datasetId === undefined && datasetName === undefined) {\n\t\t\t            throw new Error(\"Must provide dataset name or ID\");\n\t\t\t        }\n\t\t\t        else if (datasetId !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetId === undefined) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            datasetId_ = datasetId;\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(datasetId_);\n\t\t\t        const params = new URLSearchParams();\n\t\t\t        const dataset_version = asOf\n\t\t\t            ? typeof asOf === \"string\"\n\t\t\t                ? asOf\n\t\t\t                : asOf?.toISOString()\n\t\t\t            : undefined;\n\t\t\t        if (dataset_version) {\n\t\t\t            params.append(\"as_of\", dataset_version);\n\t\t\t        }\n\t\t\t        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n\t\t\t        return response;\n\t\t\t    }\n\t\t\t    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false, }) {\n\t\t\t        let datasetId_;\n\t\t\t        if (datasetId === undefined && datasetName === undefined) {\n\t\t\t            throw new Error(\"Must provide dataset name or ID\");\n\t\t\t        }\n\t\t\t        else if (datasetId !== undefined && datasetName !== undefined) {\n\t\t\t            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n\t\t\t        }\n\t\t\t        else if (datasetId === undefined) {\n\t\t\t            const dataset = await this.readDataset({ datasetName });\n\t\t\t            datasetId_ = dataset.id;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            datasetId_ = datasetId;\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(datasetId_);\n\t\t\t        const data = {\n\t\t\t            split_name: splitName,\n\t\t\t            examples: exampleIds.map((id) => {\n\t\t\t                (0, _uuid_js_1.assertUuid)(id);\n\t\t\t                return id;\n\t\t\t            }),\n\t\t\t            remove,\n\t\t\t        };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/splits`, {\n\t\t\t            method: \"PUT\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(data),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update dataset splits\", true);\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n\t\t\t     */\n\t\t\t    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n\t\t\t        (0, warn_js_1.warnOnce)(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n\t\t\t        let run_;\n\t\t\t        if (typeof run === \"string\") {\n\t\t\t            run_ = await this.readRun(run, { loadChildRuns });\n\t\t\t        }\n\t\t\t        else if (typeof run === \"object\" && \"id\" in run) {\n\t\t\t            run_ = run;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            throw new Error(`Invalid run type: ${typeof run}`);\n\t\t\t        }\n\t\t\t        if (run_.reference_example_id !== null &&\n\t\t\t            run_.reference_example_id !== undefined) {\n\t\t\t            referenceExample = await this.readExample(run_.reference_example_id);\n\t\t\t        }\n\t\t\t        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n\t\t\t        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n\t\t\t        return feedbacks[0];\n\t\t\t    }\n\t\t\t    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n\t\t\t        if (!runId && !projectId) {\n\t\t\t            throw new Error(\"One of runId or projectId must be provided\");\n\t\t\t        }\n\t\t\t        if (runId && projectId) {\n\t\t\t            throw new Error(\"Only one of runId or projectId can be provided\");\n\t\t\t        }\n\t\t\t        const feedback_source = {\n\t\t\t            type: feedbackSourceType ?? \"api\",\n\t\t\t            metadata: sourceInfo ?? {},\n\t\t\t        };\n\t\t\t        if (sourceRunId !== undefined &&\n\t\t\t            feedback_source?.metadata !== undefined &&\n\t\t\t            !feedback_source.metadata[\"__run\"]) {\n\t\t\t            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n\t\t\t        }\n\t\t\t        if (feedback_source?.metadata !== undefined &&\n\t\t\t            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n\t\t\t            (0, _uuid_js_1.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n\t\t\t        }\n\t\t\t        const feedback = {\n\t\t\t            id: feedbackId ?? uuid.v4(),\n\t\t\t            run_id: runId,\n\t\t\t            key,\n\t\t\t            score,\n\t\t\t            value,\n\t\t\t            correction,\n\t\t\t            comment,\n\t\t\t            feedback_source: feedback_source,\n\t\t\t            comparative_experiment_id: comparativeExperimentId,\n\t\t\t            feedbackConfig,\n\t\t\t            session_id: projectId,\n\t\t\t        };\n\t\t\t        const url = `${this.apiUrl}/feedback`;\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), url, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(feedback),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create feedback\", true);\n\t\t\t        return feedback;\n\t\t\t    }\n\t\t\t    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n\t\t\t        const feedbackUpdate = {};\n\t\t\t        if (score !== undefined && score !== null) {\n\t\t\t            feedbackUpdate[\"score\"] = score;\n\t\t\t        }\n\t\t\t        if (value !== undefined && value !== null) {\n\t\t\t            feedbackUpdate[\"value\"] = value;\n\t\t\t        }\n\t\t\t        if (correction !== undefined && correction !== null) {\n\t\t\t            feedbackUpdate[\"correction\"] = correction;\n\t\t\t        }\n\t\t\t        if (comment !== undefined && comment !== null) {\n\t\t\t            feedbackUpdate[\"comment\"] = comment;\n\t\t\t        }\n\t\t\t        (0, _uuid_js_1.assertUuid)(feedbackId);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/feedback/${feedbackId}`, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(feedbackUpdate),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update feedback\", true);\n\t\t\t    }\n\t\t\t    async readFeedback(feedbackId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(feedbackId);\n\t\t\t        const path = `/feedback/${feedbackId}`;\n\t\t\t        const response = await this._get(path);\n\t\t\t        return response;\n\t\t\t    }\n\t\t\t    async deleteFeedback(feedbackId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(feedbackId);\n\t\t\t        const path = `/feedback/${feedbackId}`;\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), this.apiUrl + path, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, `delete ${path}`);\n\t\t\t        await response.json();\n\t\t\t    }\n\t\t\t    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n\t\t\t        const queryParams = new URLSearchParams();\n\t\t\t        if (runIds) {\n\t\t\t            queryParams.append(\"run\", runIds.join(\",\"));\n\t\t\t        }\n\t\t\t        if (feedbackKeys) {\n\t\t\t            for (const key of feedbackKeys) {\n\t\t\t                queryParams.append(\"key\", key);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (feedbackSourceTypes) {\n\t\t\t            for (const type of feedbackSourceTypes) {\n\t\t\t                queryParams.append(\"source\", type);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n\t\t\t            yield* feedbacks;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Creates a presigned feedback token and URL.\n\t\t\t     *\n\t\t\t     * The token can be used to authorize feedback metrics without\n\t\t\t     * needing an API key. This is useful for giving browser-based\n\t\t\t     * applications the ability to submit feedback without needing\n\t\t\t     * to expose an API key.\n\t\t\t     *\n\t\t\t     * @param runId - The ID of the run.\n\t\t\t     * @param feedbackKey - The feedback key.\n\t\t\t     * @param options - Additional options for the token.\n\t\t\t     * @param options.expiration - The expiration time for the token.\n\t\t\t     *\n\t\t\t     * @returns A promise that resolves to a FeedbackIngestToken.\n\t\t\t     */\n\t\t\t    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n\t\t\t        const body = {\n\t\t\t            run_id: runId,\n\t\t\t            feedback_key: feedbackKey,\n\t\t\t            feedback_config: feedbackConfig,\n\t\t\t        };\n\t\t\t        if (expiration) {\n\t\t\t            if (typeof expiration === \"string\") {\n\t\t\t                body[\"expires_at\"] = expiration;\n\t\t\t            }\n\t\t\t            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n\t\t\t                body[\"expires_in\"] = expiration;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            body[\"expires_in\"] = {\n\t\t\t                hours: 3,\n\t\t\t            };\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/feedback/tokens`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(body),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const result = await response.json();\n\t\t\t        return result;\n\t\t\t    }\n\t\t\t    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n\t\t\t        if (experimentIds.length === 0) {\n\t\t\t            throw new Error(\"At least one experiment is required\");\n\t\t\t        }\n\t\t\t        if (!referenceDatasetId) {\n\t\t\t            referenceDatasetId = (await this.readProject({\n\t\t\t                projectId: experimentIds[0],\n\t\t\t            })).reference_dataset_id;\n\t\t\t        }\n\t\t\t        if (!referenceDatasetId == null) {\n\t\t\t            throw new Error(\"A reference dataset is required\");\n\t\t\t        }\n\t\t\t        const body = {\n\t\t\t            id,\n\t\t\t            name,\n\t\t\t            experiment_ids: experimentIds,\n\t\t\t            reference_dataset_id: referenceDatasetId,\n\t\t\t            description,\n\t\t\t            created_at: (createdAt ?? new Date())?.toISOString(),\n\t\t\t            extra: {},\n\t\t\t        };\n\t\t\t        if (metadata)\n\t\t\t            body.extra[\"metadata\"] = metadata;\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/datasets/comparative`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(body),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        return await response.json();\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Retrieves a list of presigned feedback tokens for a given run ID.\n\t\t\t     * @param runId The ID of the run.\n\t\t\t     * @returns An async iterable of FeedbackIngestToken objects.\n\t\t\t     */\n\t\t\t    async *listPresignedFeedbackTokens(runId) {\n\t\t\t        (0, _uuid_js_1.assertUuid)(runId);\n\t\t\t        const params = new URLSearchParams({ run_id: runId });\n\t\t\t        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n\t\t\t            yield* tokens;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    _selectEvalResults(results) {\n\t\t\t        let results_;\n\t\t\t        if (\"results\" in results) {\n\t\t\t            results_ = results.results;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            results_ = [results];\n\t\t\t        }\n\t\t\t        return results_;\n\t\t\t    }\n\t\t\t    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n\t\t\t        const evalResults = this._selectEvalResults(evaluatorResponse);\n\t\t\t        const feedbacks = [];\n\t\t\t        for (const res of evalResults) {\n\t\t\t            let sourceInfo_ = sourceInfo || {};\n\t\t\t            if (res.evaluatorInfo) {\n\t\t\t                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n\t\t\t            }\n\t\t\t            let runId_ = null;\n\t\t\t            if (res.targetRunId) {\n\t\t\t                runId_ = res.targetRunId;\n\t\t\t            }\n\t\t\t            else if (run) {\n\t\t\t                runId_ = run.id;\n\t\t\t            }\n\t\t\t            feedbacks.push(await this.createFeedback(runId_, res.key, {\n\t\t\t                score: res.score,\n\t\t\t                value: res.value,\n\t\t\t                comment: res.comment,\n\t\t\t                correction: res.correction,\n\t\t\t                sourceInfo: sourceInfo_,\n\t\t\t                sourceRunId: res.sourceRunId,\n\t\t\t                feedbackConfig: res.feedbackConfig,\n\t\t\t                feedbackSourceType: \"model\",\n\t\t\t            }));\n\t\t\t        }\n\t\t\t        return [evalResults, feedbacks];\n\t\t\t    }\n\t\t\t    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n\t\t\t        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n\t\t\t        return results;\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * API for managing annotation queues\n\t\t\t     */\n\t\t\t    /**\n\t\t\t     * List the annotation queues on the LangSmith API.\n\t\t\t     * @param options - The options for listing annotation queues\n\t\t\t     * @param options.queueIds - The IDs of the queues to filter by\n\t\t\t     * @param options.name - The name of the queue to filter by\n\t\t\t     * @param options.nameContains - The substring that the queue name should contain\n\t\t\t     * @param options.limit - The maximum number of queues to return\n\t\t\t     * @returns An iterator of AnnotationQueue objects\n\t\t\t     */\n\t\t\t    async *listAnnotationQueues(options = {}) {\n\t\t\t        const { queueIds, name, nameContains, limit } = options;\n\t\t\t        const params = new URLSearchParams();\n\t\t\t        if (queueIds) {\n\t\t\t            queueIds.forEach((id, i) => {\n\t\t\t                (0, _uuid_js_1.assertUuid)(id, `queueIds[${i}]`);\n\t\t\t                params.append(\"ids\", id);\n\t\t\t            });\n\t\t\t        }\n\t\t\t        if (name)\n\t\t\t            params.append(\"name\", name);\n\t\t\t        if (nameContains)\n\t\t\t            params.append(\"name_contains\", nameContains);\n\t\t\t        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n\t\t\t        let count = 0;\n\t\t\t        for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n\t\t\t            yield* queues;\n\t\t\t            count++;\n\t\t\t            if (limit !== undefined && count >= limit)\n\t\t\t                break;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Create an annotation queue on the LangSmith API.\n\t\t\t     * @param options - The options for creating an annotation queue\n\t\t\t     * @param options.name - The name of the annotation queue\n\t\t\t     * @param options.description - The description of the annotation queue\n\t\t\t     * @param options.queueId - The ID of the annotation queue\n\t\t\t     * @returns The created AnnotationQueue object\n\t\t\t     */\n\t\t\t    async createAnnotationQueue(options) {\n\t\t\t        const { name, description, queueId } = options;\n\t\t\t        const body = {\n\t\t\t            name,\n\t\t\t            description,\n\t\t\t            id: queueId || uuid.v4(),\n\t\t\t        };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/annotation-queues`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined))),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create annotation queue\");\n\t\t\t        const data = await response.json();\n\t\t\t        return data;\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Read an annotation queue with the specified queue ID.\n\t\t\t     * @param queueId - The ID of the annotation queue to read\n\t\t\t     * @returns The AnnotationQueue object\n\t\t\t     */\n\t\t\t    async readAnnotationQueue(queueId) {\n\t\t\t        // TODO: Replace when actual endpoint is added\n\t\t\t        const queueIteratorResult = await this.listAnnotationQueues({\n\t\t\t            queueIds: [queueId],\n\t\t\t        }).next();\n\t\t\t        if (queueIteratorResult.done) {\n\t\t\t            throw new Error(`Annotation queue with ID ${queueId} not found`);\n\t\t\t        }\n\t\t\t        return queueIteratorResult.value;\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Update an annotation queue with the specified queue ID.\n\t\t\t     * @param queueId - The ID of the annotation queue to update\n\t\t\t     * @param options - The options for updating the annotation queue\n\t\t\t     * @param options.name - The new name for the annotation queue\n\t\t\t     * @param options.description - The new description for the annotation queue\n\t\t\t     */\n\t\t\t    async updateAnnotationQueue(queueId, options) {\n\t\t\t        const { name, description } = options;\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, \"queueId\")}`, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify({ name, description }),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update annotation queue\");\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Delete an annotation queue with the specified queue ID.\n\t\t\t     * @param queueId - The ID of the annotation queue to delete\n\t\t\t     */\n\t\t\t    async deleteAnnotationQueue(queueId) {\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, \"queueId\")}`, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: { ...this.headers, Accept: \"application/json\" },\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"delete annotation queue\");\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Add runs to an annotation queue with the specified queue ID.\n\t\t\t     * @param queueId - The ID of the annotation queue\n\t\t\t     * @param runIds - The IDs of the runs to be added to the annotation queue\n\t\t\t     */\n\t\t\t    async addRunsToAnnotationQueue(queueId, runIds) {\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, \"queueId\")}/runs`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(runIds.map((id, i) => (0, _uuid_js_1.assertUuid)(id, `runIds[${i}]`).toString())),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"add runs to annotation queue\");\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Get a run from an annotation queue at the specified index.\n\t\t\t     * @param queueId - The ID of the annotation queue\n\t\t\t     * @param index - The index of the run to retrieve\n\t\t\t     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n\t\t\t     * @throws {Error} If the run is not found at the given index or for other API-related errors\n\t\t\t     */\n\t\t\t    async getRunFromAnnotationQueue(queueId, index) {\n\t\t\t        const baseUrl = `/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, \"queueId\")}/run`;\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}${baseUrl}/${index}`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"get run from annotation queue\");\n\t\t\t        return await response.json();\n\t\t\t    }\n\t\t\t    async _currentTenantIsOwner(owner) {\n\t\t\t        const settings = await this._getSettings();\n\t\t\t        return owner == \"-\" || settings.tenant_handle === owner;\n\t\t\t    }\n\t\t\t    async _ownerConflictError(action, owner) {\n\t\t\t        const settings = await this._getSettings();\n\t\t\t        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n\t\t\t    }\n\t\t\t    async _getLatestCommitHash(promptOwnerAndName) {\n\t\t\t        const res = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        const json = await res.json();\n\t\t\t        if (!res.ok) {\n\t\t\t            const detail = typeof json.detail === \"string\"\n\t\t\t                ? json.detail\n\t\t\t                : JSON.stringify(json.detail);\n\t\t\t            const error = new Error(`Error ${res.status}: ${res.statusText}\\n${detail}`);\n\t\t\t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t            error.statusCode = res.status;\n\t\t\t            throw error;\n\t\t\t        }\n\t\t\t        if (json.commits.length === 0) {\n\t\t\t            return undefined;\n\t\t\t        }\n\t\t\t        return json.commits[0].commit_hash;\n\t\t\t    }\n\t\t\t    async _likeOrUnlikePrompt(promptIdentifier, like) {\n\t\t\t        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/likes/${owner}/${promptName}`, {\n\t\t\t            method: \"POST\",\n\t\t\t            body: JSON.stringify({ like: like }),\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, `${like ? \"like\" : \"unlike\"} prompt`);\n\t\t\t        return await response.json();\n\t\t\t    }\n\t\t\t    async _getPromptUrl(promptIdentifier) {\n\t\t\t        const [owner, promptName, commitHash] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        if (!(await this._currentTenantIsOwner(owner))) {\n\t\t\t            if (commitHash !== \"latest\") {\n\t\t\t                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            const settings = await this._getSettings();\n\t\t\t            if (commitHash !== \"latest\") {\n\t\t\t                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async promptExists(promptIdentifier) {\n\t\t\t        const prompt = await this.getPrompt(promptIdentifier);\n\t\t\t        return !!prompt;\n\t\t\t    }\n\t\t\t    async likePrompt(promptIdentifier) {\n\t\t\t        return this._likeOrUnlikePrompt(promptIdentifier, true);\n\t\t\t    }\n\t\t\t    async unlikePrompt(promptIdentifier) {\n\t\t\t        return this._likeOrUnlikePrompt(promptIdentifier, false);\n\t\t\t    }\n\t\t\t    async *listCommits(promptOwnerAndName) {\n\t\t\t        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {\n\t\t\t            yield* commits;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async *listPrompts(options) {\n\t\t\t        const params = new URLSearchParams();\n\t\t\t        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n\t\t\t        params.append(\"sort_direction\", \"desc\");\n\t\t\t        params.append(\"is_archived\", (!!options?.isArchived).toString());\n\t\t\t        if (options?.isPublic !== undefined) {\n\t\t\t            params.append(\"is_public\", options.isPublic.toString());\n\t\t\t        }\n\t\t\t        if (options?.query) {\n\t\t\t            params.append(\"query\", options.query);\n\t\t\t        }\n\t\t\t        for await (const prompts of this._getPaginated(\"/repos\", params, (res) => res.repos)) {\n\t\t\t            yield* prompts;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async getPrompt(promptIdentifier) {\n\t\t\t        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        if (response.status === 404) {\n\t\t\t            return null;\n\t\t\t        }\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"get prompt\");\n\t\t\t        const result = await response.json();\n\t\t\t        if (result.repo) {\n\t\t\t            return result.repo;\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            return null;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    async createPrompt(promptIdentifier, options) {\n\t\t\t        const settings = await this._getSettings();\n\t\t\t        if (options?.isPublic && !settings.tenant_handle) {\n\t\t\t            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle. \n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n\t\t\t        }\n\t\t\t        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        if (!(await this._currentTenantIsOwner(owner))) {\n\t\t\t            throw await this._ownerConflictError(\"create a prompt\", owner);\n\t\t\t        }\n\t\t\t        const data = {\n\t\t\t            repo_handle: promptName,\n\t\t\t            ...(options?.description && { description: options.description }),\n\t\t\t            ...(options?.readme && { readme: options.readme }),\n\t\t\t            ...(options?.tags && { tags: options.tags }),\n\t\t\t            is_public: !!options?.isPublic,\n\t\t\t        };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/repos/`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(data),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create prompt\");\n\t\t\t        const { repo } = await response.json();\n\t\t\t        return repo;\n\t\t\t    }\n\t\t\t    async createCommit(promptIdentifier, object, options) {\n\t\t\t        if (!(await this.promptExists(promptIdentifier))) {\n\t\t\t            throw new Error(\"Prompt does not exist, you must create it first.\");\n\t\t\t        }\n\t\t\t        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash\n\t\t\t            ? await this._getLatestCommitHash(`${owner}/${promptName}`)\n\t\t\t            : options?.parentCommitHash;\n\t\t\t        const payload = {\n\t\t\t            manifest: JSON.parse(JSON.stringify(object)),\n\t\t\t            parent_commit: resolvedParentCommitHash,\n\t\t\t        };\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}`, {\n\t\t\t            method: \"POST\",\n\t\t\t            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n\t\t\t            body: JSON.stringify(payload),\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"create commit\");\n\t\t\t        const result = await response.json();\n\t\t\t        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n\t\t\t    }\n\t\t\t    async updatePrompt(promptIdentifier, options) {\n\t\t\t        if (!(await this.promptExists(promptIdentifier))) {\n\t\t\t            throw new Error(\"Prompt does not exist, you must create it first.\");\n\t\t\t        }\n\t\t\t        const [owner, promptName] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        if (!(await this._currentTenantIsOwner(owner))) {\n\t\t\t            throw await this._ownerConflictError(\"update a prompt\", owner);\n\t\t\t        }\n\t\t\t        const payload = {};\n\t\t\t        if (options?.description !== undefined)\n\t\t\t            payload.description = options.description;\n\t\t\t        if (options?.readme !== undefined)\n\t\t\t            payload.readme = options.readme;\n\t\t\t        if (options?.tags !== undefined)\n\t\t\t            payload.tags = options.tags;\n\t\t\t        if (options?.isPublic !== undefined)\n\t\t\t            payload.is_public = options.isPublic;\n\t\t\t        if (options?.isArchived !== undefined)\n\t\t\t            payload.is_archived = options.isArchived;\n\t\t\t        // Check if payload is empty\n\t\t\t        if (Object.keys(payload).length === 0) {\n\t\t\t            throw new Error(\"No valid update options provided\");\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n\t\t\t            method: \"PATCH\",\n\t\t\t            body: JSON.stringify(payload),\n\t\t\t            headers: {\n\t\t\t                ...this.headers,\n\t\t\t                \"Content-Type\": \"application/json\",\n\t\t\t            },\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"update prompt\");\n\t\t\t        return response.json();\n\t\t\t    }\n\t\t\t    async deletePrompt(promptIdentifier) {\n\t\t\t        if (!(await this.promptExists(promptIdentifier))) {\n\t\t\t            throw new Error(\"Prompt does not exist, you must create it first.\");\n\t\t\t        }\n\t\t\t        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        if (!(await this._currentTenantIsOwner(owner))) {\n\t\t\t            throw await this._ownerConflictError(\"delete a prompt\", owner);\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n\t\t\t            method: \"DELETE\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        return await response.json();\n\t\t\t    }\n\t\t\t    async pullPromptCommit(promptIdentifier, options) {\n\t\t\t        const [owner, promptName, commitHash] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);\n\t\t\t        const serverInfo = await this._getServerInfo();\n\t\t\t        const useOptimization = (0, prompts_js_1.isVersionGreaterOrEqual)(serverInfo.version, \"0.5.23\");\n\t\t\t        let passedCommitHash = commitHash;\n\t\t\t        if (!useOptimization && commitHash === \"latest\") {\n\t\t\t            const latestCommitHash = await this._getLatestCommitHash(`${owner}/${promptName}`);\n\t\t\t            if (!latestCommitHash) {\n\t\t\t                throw new Error(\"No commits found\");\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                passedCommitHash = latestCommitHash;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        const response = await this.caller.call((0, fetch_js_1._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}/${passedCommitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n\t\t\t            method: \"GET\",\n\t\t\t            headers: this.headers,\n\t\t\t            signal: AbortSignal.timeout(this.timeout_ms),\n\t\t\t            ...this.fetchOptions,\n\t\t\t        });\n\t\t\t        await (0, error_js_1.raiseForStatus)(response, \"pull prompt commit\");\n\t\t\t        const result = await response.json();\n\t\t\t        return {\n\t\t\t            owner,\n\t\t\t            repo: promptName,\n\t\t\t            commit_hash: result.commit_hash,\n\t\t\t            manifest: result.manifest,\n\t\t\t            examples: result.examples,\n\t\t\t        };\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n\t\t\t     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n\t\t\t     * @private\n\t\t\t     */\n\t\t\t    async _pullPrompt(promptIdentifier, options) {\n\t\t\t        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n\t\t\t            includeModel: options?.includeModel,\n\t\t\t        });\n\t\t\t        const prompt = JSON.stringify(promptObject.manifest);\n\t\t\t        return prompt;\n\t\t\t    }\n\t\t\t    async pushPrompt(promptIdentifier, options) {\n\t\t\t        // Create or update prompt metadata\n\t\t\t        if (await this.promptExists(promptIdentifier)) {\n\t\t\t            if (options && Object.keys(options).some((key) => key !== \"object\")) {\n\t\t\t                await this.updatePrompt(promptIdentifier, {\n\t\t\t                    description: options?.description,\n\t\t\t                    readme: options?.readme,\n\t\t\t                    tags: options?.tags,\n\t\t\t                    isPublic: options?.isPublic,\n\t\t\t                });\n\t\t\t            }\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            await this.createPrompt(promptIdentifier, {\n\t\t\t                description: options?.description,\n\t\t\t                readme: options?.readme,\n\t\t\t                tags: options?.tags,\n\t\t\t                isPublic: options?.isPublic,\n\t\t\t            });\n\t\t\t        }\n\t\t\t        if (!options?.object) {\n\t\t\t            return await this._getPromptUrl(promptIdentifier);\n\t\t\t        }\n\t\t\t        // Create a commit with the new manifest\n\t\t\t        const url = await this.createCommit(promptIdentifier, options?.object, {\n\t\t\t            parentCommitHash: options?.parentCommitHash,\n\t\t\t        });\n\t\t\t        return url;\n\t\t\t    }\n\t\t\t    /**\n\t\t\t     * Clone a public dataset to your own langsmith tenant.\n\t\t\t     * This operation is idempotent. If you already have a dataset with the given name,\n\t\t\t     * this function will do nothing.\n\t\t\t  \n\t\t\t     * @param {string} tokenOrUrl The token of the public dataset to clone.\n\t\t\t     * @param {Object} [options] Additional options for cloning the dataset.\n\t\t\t     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n\t\t\t     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n\t\t\t     * @returns {Promise<void>}\n\t\t\t     */\n\t\t\t    async clonePublicDataset(tokenOrUrl, options = {}) {\n\t\t\t        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n\t\t\t        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n\t\t\t        const sourceClient = new Client({\n\t\t\t            apiUrl: parsedApiUrl,\n\t\t\t            // Placeholder API key not needed anymore in most cases, but\n\t\t\t            // some private deployments may have API key-based rate limiting\n\t\t\t            // that would cause this to fail if we provide no value.\n\t\t\t            apiKey: \"placeholder\",\n\t\t\t        });\n\t\t\t        const ds = await sourceClient.readSharedDataset(tokenUuid);\n\t\t\t        const finalDatasetName = datasetName || ds.name;\n\t\t\t        try {\n\t\t\t            if (await this.hasDataset({ datasetId: finalDatasetName })) {\n\t\t\t                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n\t\t\t                return;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        catch (_) {\n\t\t\t            // `.hasDataset` will throw an error if the dataset does not exist.\n\t\t\t            // no-op in that case\n\t\t\t        }\n\t\t\t        // Fetch examples first, then create the dataset\n\t\t\t        const examples = await sourceClient.listSharedExamples(tokenUuid);\n\t\t\t        const dataset = await this.createDataset(finalDatasetName, {\n\t\t\t            description: ds.description,\n\t\t\t            dataType: ds.data_type || \"kv\",\n\t\t\t            inputsSchema: ds.inputs_schema_definition ?? undefined,\n\t\t\t            outputsSchema: ds.outputs_schema_definition ?? undefined,\n\t\t\t        });\n\t\t\t        try {\n\t\t\t            await this.createExamples({\n\t\t\t                inputs: examples.map((e) => e.inputs),\n\t\t\t                outputs: examples.flatMap((e) => (e.outputs ? [e.outputs] : [])),\n\t\t\t                datasetId: dataset.id,\n\t\t\t            });\n\t\t\t        }\n\t\t\t        catch (e) {\n\t\t\t            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` +\n\t\t\t                \"You should delete it manually.\");\n\t\t\t            throw e;\n\t\t\t        }\n\t\t\t    }\n\t\t\t    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n\t\t\t        // Try parsing as UUID\n\t\t\t        try {\n\t\t\t            (0, _uuid_js_1.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n\t\t\t            return [apiUrl, urlOrToken];\n\t\t\t        }\n\t\t\t        catch (_) {\n\t\t\t            // no-op if it's not a uuid\n\t\t\t        }\n\t\t\t        // Parse as URL\n\t\t\t        try {\n\t\t\t            const parsedUrl = new URL(urlOrToken);\n\t\t\t            const pathParts = parsedUrl.pathname\n\t\t\t                .split(\"/\")\n\t\t\t                .filter((part) => part !== \"\");\n\t\t\t            if (pathParts.length >= numParts) {\n\t\t\t                const tokenUuid = pathParts[pathParts.length - numParts];\n\t\t\t                return [apiUrl, tokenUuid];\n\t\t\t            }\n\t\t\t            else {\n\t\t\t                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        catch (error) {\n\t\t\t            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t\texports.Client = Client; \n\t\t} (client));\n\t\treturn client;\n\t}\n\n\tvar run_trees$1 = {};\n\n\tvar env = {};\n\n\tvar hasRequiredEnv;\n\n\tfunction requireEnv () {\n\t\tif (hasRequiredEnv) return env;\n\t\thasRequiredEnv = 1;\n\t\tObject.defineProperty(env, \"__esModule\", { value: true });\n\t\tenv.isTracingEnabled = void 0;\n\t\tconst env_js_1 = requireEnv$1();\n\t\tconst isTracingEnabled = (tracingEnabled) => {\n\t\t    if (tracingEnabled !== undefined) {\n\t\t        return tracingEnabled;\n\t\t    }\n\t\t    const envVars = [\"TRACING_V2\", \"TRACING\"];\n\t\t    return !!envVars.find((envVar) => (0, env_js_1.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n\t\t};\n\t\tenv.isTracingEnabled = isTracingEnabled;\n\t\treturn env;\n\t}\n\n\tvar hasRequiredRun_trees;\n\n\tfunction requireRun_trees () {\n\t\tif (hasRequiredRun_trees) return run_trees$1;\n\t\thasRequiredRun_trees = 1;\n\t\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t\t    }\n\t\t    Object.defineProperty(o, k2, desc);\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t\t}) : function(o, v) {\n\t\t    o[\"default\"] = v;\n\t\t});\n\t\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t\t    if (mod && mod.__esModule) return mod;\n\t\t    var result = {};\n\t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t\t    __setModuleDefault(result, mod);\n\t\t    return result;\n\t\t};\n\t\tObject.defineProperty(run_trees$1, \"__esModule\", { value: true });\n\t\trun_trees$1.isRunnableConfigLike = run_trees$1.isRunTree = run_trees$1.RunTree = run_trees$1.convertToDottedOrderFormat = void 0;\n\t\tconst uuid = __importStar(require$$2);\n\t\tconst env_js_1 = requireEnv$1();\n\t\tconst client_js_1 = requireClient();\n\t\tconst env_js_2 = requireEnv();\n\t\tconst warn_js_1 = warn;\n\t\tfunction stripNonAlphanumeric(input) {\n\t\t    return input.replace(/[-:.]/g, \"\");\n\t\t}\n\t\tfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n\t\t    // Date only has millisecond precision, so we use the microseconds to break\n\t\t    // possible ties, avoiding incorrect run order\n\t\t    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n\t\t    return (stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId);\n\t\t}\n\t\trun_trees$1.convertToDottedOrderFormat = convertToDottedOrderFormat;\n\t\t/**\n\t\t * Baggage header information\n\t\t */\n\t\tclass Baggage {\n\t\t    constructor(metadata, tags) {\n\t\t        Object.defineProperty(this, \"metadata\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"tags\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        this.metadata = metadata;\n\t\t        this.tags = tags;\n\t\t    }\n\t\t    static fromHeader(value) {\n\t\t        const items = value.split(\",\");\n\t\t        let metadata = {};\n\t\t        let tags = [];\n\t\t        for (const item of items) {\n\t\t            const [key, uriValue] = item.split(\"=\");\n\t\t            const value = decodeURIComponent(uriValue);\n\t\t            if (key === \"langsmith-metadata\") {\n\t\t                metadata = JSON.parse(value);\n\t\t            }\n\t\t            else if (key === \"langsmith-tags\") {\n\t\t                tags = value.split(\",\");\n\t\t            }\n\t\t        }\n\t\t        return new Baggage(metadata, tags);\n\t\t    }\n\t\t    toHeader() {\n\t\t        const items = [];\n\t\t        if (this.metadata && Object.keys(this.metadata).length > 0) {\n\t\t            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n\t\t        }\n\t\t        if (this.tags && this.tags.length > 0) {\n\t\t            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n\t\t        }\n\t\t        return items.join(\",\");\n\t\t    }\n\t\t}\n\t\tclass RunTree {\n\t\t    constructor(originalConfig) {\n\t\t        Object.defineProperty(this, \"id\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"name\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"run_type\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"project_name\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"parent_run\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"child_runs\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"start_time\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"end_time\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"extra\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"tags\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"error\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"serialized\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"inputs\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"outputs\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"reference_example_id\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"client\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"events\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"trace_id\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"dotted_order\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"tracingEnabled\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"execution_order\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        Object.defineProperty(this, \"child_execution_order\", {\n\t\t            enumerable: true,\n\t\t            configurable: true,\n\t\t            writable: true,\n\t\t            value: void 0\n\t\t        });\n\t\t        const defaultConfig = RunTree.getDefaultConfig();\n\t\t        const { metadata, ...config } = originalConfig;\n\t\t        const client = config.client ?? RunTree.getSharedClient();\n\t\t        const dedupedMetadata = {\n\t\t            ...metadata,\n\t\t            ...config?.extra?.metadata,\n\t\t        };\n\t\t        config.extra = { ...config.extra, metadata: dedupedMetadata };\n\t\t        Object.assign(this, { ...defaultConfig, ...config, client });\n\t\t        if (!this.trace_id) {\n\t\t            if (this.parent_run) {\n\t\t                this.trace_id = this.parent_run.trace_id ?? this.id;\n\t\t            }\n\t\t            else {\n\t\t                this.trace_id = this.id;\n\t\t            }\n\t\t        }\n\t\t        this.execution_order ??= 1;\n\t\t        this.child_execution_order ??= 1;\n\t\t        if (!this.dotted_order) {\n\t\t            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n\t\t            if (this.parent_run) {\n\t\t                this.dotted_order =\n\t\t                    this.parent_run.dotted_order + \".\" + currentDottedOrder;\n\t\t            }\n\t\t            else {\n\t\t                this.dotted_order = currentDottedOrder;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    static getDefaultConfig() {\n\t\t        return {\n\t\t            id: uuid.v4(),\n\t\t            run_type: \"chain\",\n\t\t            project_name: (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ??\n\t\t                (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n\t\t                \"default\",\n\t\t            child_runs: [],\n\t\t            api_url: (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n\t\t            api_key: (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n\t\t            caller_options: {},\n\t\t            start_time: Date.now(),\n\t\t            serialized: {},\n\t\t            inputs: {},\n\t\t            extra: {},\n\t\t        };\n\t\t    }\n\t\t    static getSharedClient() {\n\t\t        if (!RunTree.sharedClient) {\n\t\t            RunTree.sharedClient = new client_js_1.Client();\n\t\t        }\n\t\t        return RunTree.sharedClient;\n\t\t    }\n\t\t    createChild(config) {\n\t\t        const child_execution_order = this.child_execution_order + 1;\n\t\t        const child = new RunTree({\n\t\t            ...config,\n\t\t            parent_run: this,\n\t\t            project_name: this.project_name,\n\t\t            client: this.client,\n\t\t            tracingEnabled: this.tracingEnabled,\n\t\t            execution_order: child_execution_order,\n\t\t            child_execution_order: child_execution_order,\n\t\t        });\n\t\t        const LC_CHILD = Symbol.for(\"lc:child_config\");\n\t\t        const presentConfig = config.extra?.[LC_CHILD] ??\n\t\t            this.extra[LC_CHILD];\n\t\t        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n\t\t        if (isRunnableConfigLike(presentConfig)) {\n\t\t            const newConfig = { ...presentConfig };\n\t\t            const callbacks = isCallbackManagerLike(newConfig.callbacks)\n\t\t                ? newConfig.callbacks.copy?.()\n\t\t                : undefined;\n\t\t            if (callbacks) {\n\t\t                // update the parent run id\n\t\t                Object.assign(callbacks, { _parentRunId: child.id });\n\t\t                // only populate if we're in a newer LC.JS version\n\t\t                callbacks.handlers\n\t\t                    ?.find(isLangChainTracerLike)\n\t\t                    ?.updateFromRunTree?.(child);\n\t\t                newConfig.callbacks = callbacks;\n\t\t            }\n\t\t            child.extra[LC_CHILD] = newConfig;\n\t\t        }\n\t\t        // propagate child_execution_order upwards\n\t\t        const visited = new Set();\n\t\t        let current = this;\n\t\t        while (current != null && !visited.has(current.id)) {\n\t\t            visited.add(current.id);\n\t\t            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n\t\t            current = current.parent_run;\n\t\t        }\n\t\t        this.child_runs.push(child);\n\t\t        return child;\n\t\t    }\n\t\t    async end(outputs, error, endTime = Date.now()) {\n\t\t        this.outputs = this.outputs ?? outputs;\n\t\t        this.error = this.error ?? error;\n\t\t        this.end_time = this.end_time ?? endTime;\n\t\t    }\n\t\t    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n\t\t        const runExtra = run.extra ?? {};\n\t\t        if (!runExtra.runtime) {\n\t\t            runExtra.runtime = {};\n\t\t        }\n\t\t        if (runtimeEnv) {\n\t\t            for (const [k, v] of Object.entries(runtimeEnv)) {\n\t\t                if (!runExtra.runtime[k]) {\n\t\t                    runExtra.runtime[k] = v;\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        let child_runs;\n\t\t        let parent_run_id;\n\t\t        if (!excludeChildRuns) {\n\t\t            child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n\t\t            parent_run_id = undefined;\n\t\t        }\n\t\t        else {\n\t\t            parent_run_id = run.parent_run?.id;\n\t\t            child_runs = [];\n\t\t        }\n\t\t        const persistedRun = {\n\t\t            id: run.id,\n\t\t            name: run.name,\n\t\t            start_time: run.start_time,\n\t\t            end_time: run.end_time,\n\t\t            run_type: run.run_type,\n\t\t            reference_example_id: run.reference_example_id,\n\t\t            extra: runExtra,\n\t\t            serialized: run.serialized,\n\t\t            error: run.error,\n\t\t            inputs: run.inputs,\n\t\t            outputs: run.outputs,\n\t\t            session_name: run.project_name,\n\t\t            child_runs: child_runs,\n\t\t            parent_run_id: parent_run_id,\n\t\t            trace_id: run.trace_id,\n\t\t            dotted_order: run.dotted_order,\n\t\t            tags: run.tags,\n\t\t        };\n\t\t        return persistedRun;\n\t\t    }\n\t\t    async postRun(excludeChildRuns = true) {\n\t\t        try {\n\t\t            const runtimeEnv = await (0, env_js_1.getRuntimeEnvironment)();\n\t\t            const runCreate = await this._convertToCreate(this, runtimeEnv, true);\n\t\t            await this.client.createRun(runCreate);\n\t\t            if (!excludeChildRuns) {\n\t\t                (0, warn_js_1.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n\t\t                for (const childRun of this.child_runs) {\n\t\t                    await childRun.postRun(false);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        catch (error) {\n\t\t            console.error(`Error in postRun for run ${this.id}:`, error);\n\t\t        }\n\t\t    }\n\t\t    async patchRun() {\n\t\t        try {\n\t\t            const runUpdate = {\n\t\t                end_time: this.end_time,\n\t\t                error: this.error,\n\t\t                inputs: this.inputs,\n\t\t                outputs: this.outputs,\n\t\t                parent_run_id: this.parent_run?.id,\n\t\t                reference_example_id: this.reference_example_id,\n\t\t                extra: this.extra,\n\t\t                events: this.events,\n\t\t                dotted_order: this.dotted_order,\n\t\t                trace_id: this.trace_id,\n\t\t                tags: this.tags,\n\t\t            };\n\t\t            await this.client.updateRun(this.id, runUpdate);\n\t\t        }\n\t\t        catch (error) {\n\t\t            console.error(`Error in patchRun for run ${this.id}`, error);\n\t\t        }\n\t\t    }\n\t\t    toJSON() {\n\t\t        return this._convertToCreate(this, undefined, false);\n\t\t    }\n\t\t    static fromRunnableConfig(parentConfig, props) {\n\t\t        // We only handle the callback manager case for now\n\t\t        const callbackManager = parentConfig?.callbacks;\n\t\t        let parentRun;\n\t\t        let projectName;\n\t\t        let client;\n\t\t        let tracingEnabled = (0, env_js_2.isTracingEnabled)();\n\t\t        if (callbackManager) {\n\t\t            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n\t\t            const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == \"langchain_tracer\");\n\t\t            parentRun = langChainTracer?.getRun?.(parentRunId);\n\t\t            projectName = langChainTracer?.projectName;\n\t\t            client = langChainTracer?.client;\n\t\t            tracingEnabled = tracingEnabled || !!langChainTracer;\n\t\t        }\n\t\t        if (!parentRun) {\n\t\t            return new RunTree({\n\t\t                ...props,\n\t\t                client,\n\t\t                tracingEnabled,\n\t\t                project_name: projectName,\n\t\t            });\n\t\t        }\n\t\t        const parentRunTree = new RunTree({\n\t\t            name: parentRun.name,\n\t\t            id: parentRun.id,\n\t\t            trace_id: parentRun.trace_id,\n\t\t            dotted_order: parentRun.dotted_order,\n\t\t            client,\n\t\t            tracingEnabled,\n\t\t            project_name: projectName,\n\t\t            tags: [\n\t\t                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? [])),\n\t\t            ],\n\t\t            extra: {\n\t\t                metadata: {\n\t\t                    ...parentRun?.extra?.metadata,\n\t\t                    ...parentConfig?.metadata,\n\t\t                },\n\t\t            },\n\t\t        });\n\t\t        return parentRunTree.createChild(props);\n\t\t    }\n\t\t    static fromDottedOrder(dottedOrder) {\n\t\t        return this.fromHeaders({ \"langsmith-trace\": dottedOrder });\n\t\t    }\n\t\t    static fromHeaders(headers, inheritArgs) {\n\t\t        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\"\n\t\t            ? {\n\t\t                \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n\t\t                baggage: headers.get(\"baggage\"),\n\t\t            }\n\t\t            : headers;\n\t\t        const headerTrace = rawHeaders[\"langsmith-trace\"];\n\t\t        if (!headerTrace || typeof headerTrace !== \"string\")\n\t\t            return undefined;\n\t\t        const parentDottedOrder = headerTrace.trim();\n\t\t        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part) => {\n\t\t            const [strTime, uuid] = part.split(\"Z\");\n\t\t            return { strTime, time: Date.parse(strTime + \"Z\"), uuid };\n\t\t        });\n\t\t        const traceId = parsedDottedOrder[0].uuid;\n\t\t        const config = {\n\t\t            ...inheritArgs,\n\t\t            name: inheritArgs?.[\"name\"] ?? \"parent\",\n\t\t            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n\t\t            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n\t\t            id: parsedDottedOrder.at(-1)?.uuid,\n\t\t            trace_id: traceId,\n\t\t            dotted_order: parentDottedOrder,\n\t\t        };\n\t\t        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n\t\t            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n\t\t            config.metadata = baggage.metadata;\n\t\t            config.tags = baggage.tags;\n\t\t        }\n\t\t        return new RunTree(config);\n\t\t    }\n\t\t    toHeaders(headers) {\n\t\t        const result = {\n\t\t            \"langsmith-trace\": this.dotted_order,\n\t\t            baggage: new Baggage(this.extra?.metadata, this.tags).toHeader(),\n\t\t        };\n\t\t        if (headers) {\n\t\t            for (const [key, value] of Object.entries(result)) {\n\t\t                headers.set(key, value);\n\t\t            }\n\t\t        }\n\t\t        return result;\n\t\t    }\n\t\t}\n\t\trun_trees$1.RunTree = RunTree;\n\t\tObject.defineProperty(RunTree, \"sharedClient\", {\n\t\t    enumerable: true,\n\t\t    configurable: true,\n\t\t    writable: true,\n\t\t    value: null\n\t\t});\n\t\tfunction isRunTree(x) {\n\t\t    return (x !== undefined &&\n\t\t        typeof x.createChild === \"function\" &&\n\t\t        typeof x.postRun === \"function\");\n\t\t}\n\t\trun_trees$1.isRunTree = isRunTree;\n\t\tfunction isLangChainTracerLike(x) {\n\t\t    return (typeof x === \"object\" &&\n\t\t        x != null &&\n\t\t        typeof x.name === \"string\" &&\n\t\t        x.name === \"langchain_tracer\");\n\t\t}\n\t\tfunction containsLangChainTracerLike(x) {\n\t\t    return (Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback)));\n\t\t}\n\t\tfunction isCallbackManagerLike(x) {\n\t\t    return (typeof x === \"object\" &&\n\t\t        x != null &&\n\t\t        Array.isArray(x.handlers));\n\t\t}\n\t\tfunction isRunnableConfigLike(x) {\n\t\t    // Check that it's an object with a callbacks arg\n\t\t    // that has either a CallbackManagerLike object with a langchain tracer within it\n\t\t    // or an array with a LangChainTracerLike object within it\n\t\t    return (x !== undefined &&\n\t\t        typeof x.callbacks === \"object\" &&\n\t\t        // Callback manager with a langchain tracer\n\t\t        (containsLangChainTracerLike(x.callbacks?.handlers) ||\n\t\t            // Or it's an array with a LangChainTracerLike object within it\n\t\t            containsLangChainTracerLike(x.callbacks)));\n\t\t}\n\t\trun_trees$1.isRunnableConfigLike = isRunnableConfigLike;\n\t\treturn run_trees$1;\n\t}\n\n\tvar hasRequiredDist;\n\n\tfunction requireDist () {\n\t\tif (hasRequiredDist) return dist$1;\n\t\thasRequiredDist = 1;\n\t\t(function (exports) {\n\t\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\t\texports.__version__ = exports.overrideFetchImplementation = exports.RunTree = exports.Client = void 0;\n\t\t\tvar client_js_1 = requireClient();\n\t\t\tObject.defineProperty(exports, \"Client\", { enumerable: true, get: function () { return client_js_1.Client; } });\n\t\t\tvar run_trees_js_1 = requireRun_trees();\n\t\t\tObject.defineProperty(exports, \"RunTree\", { enumerable: true, get: function () { return run_trees_js_1.RunTree; } });\n\t\t\tvar fetch_js_1 = fetch$1;\n\t\t\tObject.defineProperty(exports, \"overrideFetchImplementation\", { enumerable: true, get: function () { return fetch_js_1.overrideFetchImplementation; } });\n\t\t\t// Update using yarn bump-version\n\t\t\texports.__version__ = \"0.1.61\"; \n\t\t} (dist$1));\n\t\treturn dist$1;\n\t}\n\n\tvar langsmith = requireDist();\n\n\tvar manager = {};\n\n\tvar console$1 = {};\n\n\tvar ansiStyles = {exports: {}};\n\n\tvar colorName;\n\tvar hasRequiredColorName;\n\n\tfunction requireColorName () {\n\t\tif (hasRequiredColorName) return colorName;\n\t\thasRequiredColorName = 1;\n\r\n\t\tcolorName = {\r\n\t\t\t\"aliceblue\": [240, 248, 255],\r\n\t\t\t\"antiquewhite\": [250, 235, 215],\r\n\t\t\t\"aqua\": [0, 255, 255],\r\n\t\t\t\"aquamarine\": [127, 255, 212],\r\n\t\t\t\"azure\": [240, 255, 255],\r\n\t\t\t\"beige\": [245, 245, 220],\r\n\t\t\t\"bisque\": [255, 228, 196],\r\n\t\t\t\"black\": [0, 0, 0],\r\n\t\t\t\"blanchedalmond\": [255, 235, 205],\r\n\t\t\t\"blue\": [0, 0, 255],\r\n\t\t\t\"blueviolet\": [138, 43, 226],\r\n\t\t\t\"brown\": [165, 42, 42],\r\n\t\t\t\"burlywood\": [222, 184, 135],\r\n\t\t\t\"cadetblue\": [95, 158, 160],\r\n\t\t\t\"chartreuse\": [127, 255, 0],\r\n\t\t\t\"chocolate\": [210, 105, 30],\r\n\t\t\t\"coral\": [255, 127, 80],\r\n\t\t\t\"cornflowerblue\": [100, 149, 237],\r\n\t\t\t\"cornsilk\": [255, 248, 220],\r\n\t\t\t\"crimson\": [220, 20, 60],\r\n\t\t\t\"cyan\": [0, 255, 255],\r\n\t\t\t\"darkblue\": [0, 0, 139],\r\n\t\t\t\"darkcyan\": [0, 139, 139],\r\n\t\t\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\t\t\"darkgray\": [169, 169, 169],\r\n\t\t\t\"darkgreen\": [0, 100, 0],\r\n\t\t\t\"darkgrey\": [169, 169, 169],\r\n\t\t\t\"darkkhaki\": [189, 183, 107],\r\n\t\t\t\"darkmagenta\": [139, 0, 139],\r\n\t\t\t\"darkolivegreen\": [85, 107, 47],\r\n\t\t\t\"darkorange\": [255, 140, 0],\r\n\t\t\t\"darkorchid\": [153, 50, 204],\r\n\t\t\t\"darkred\": [139, 0, 0],\r\n\t\t\t\"darksalmon\": [233, 150, 122],\r\n\t\t\t\"darkseagreen\": [143, 188, 143],\r\n\t\t\t\"darkslateblue\": [72, 61, 139],\r\n\t\t\t\"darkslategray\": [47, 79, 79],\r\n\t\t\t\"darkslategrey\": [47, 79, 79],\r\n\t\t\t\"darkturquoise\": [0, 206, 209],\r\n\t\t\t\"darkviolet\": [148, 0, 211],\r\n\t\t\t\"deeppink\": [255, 20, 147],\r\n\t\t\t\"deepskyblue\": [0, 191, 255],\r\n\t\t\t\"dimgray\": [105, 105, 105],\r\n\t\t\t\"dimgrey\": [105, 105, 105],\r\n\t\t\t\"dodgerblue\": [30, 144, 255],\r\n\t\t\t\"firebrick\": [178, 34, 34],\r\n\t\t\t\"floralwhite\": [255, 250, 240],\r\n\t\t\t\"forestgreen\": [34, 139, 34],\r\n\t\t\t\"fuchsia\": [255, 0, 255],\r\n\t\t\t\"gainsboro\": [220, 220, 220],\r\n\t\t\t\"ghostwhite\": [248, 248, 255],\r\n\t\t\t\"gold\": [255, 215, 0],\r\n\t\t\t\"goldenrod\": [218, 165, 32],\r\n\t\t\t\"gray\": [128, 128, 128],\r\n\t\t\t\"green\": [0, 128, 0],\r\n\t\t\t\"greenyellow\": [173, 255, 47],\r\n\t\t\t\"grey\": [128, 128, 128],\r\n\t\t\t\"honeydew\": [240, 255, 240],\r\n\t\t\t\"hotpink\": [255, 105, 180],\r\n\t\t\t\"indianred\": [205, 92, 92],\r\n\t\t\t\"indigo\": [75, 0, 130],\r\n\t\t\t\"ivory\": [255, 255, 240],\r\n\t\t\t\"khaki\": [240, 230, 140],\r\n\t\t\t\"lavender\": [230, 230, 250],\r\n\t\t\t\"lavenderblush\": [255, 240, 245],\r\n\t\t\t\"lawngreen\": [124, 252, 0],\r\n\t\t\t\"lemonchiffon\": [255, 250, 205],\r\n\t\t\t\"lightblue\": [173, 216, 230],\r\n\t\t\t\"lightcoral\": [240, 128, 128],\r\n\t\t\t\"lightcyan\": [224, 255, 255],\r\n\t\t\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\t\t\"lightgray\": [211, 211, 211],\r\n\t\t\t\"lightgreen\": [144, 238, 144],\r\n\t\t\t\"lightgrey\": [211, 211, 211],\r\n\t\t\t\"lightpink\": [255, 182, 193],\r\n\t\t\t\"lightsalmon\": [255, 160, 122],\r\n\t\t\t\"lightseagreen\": [32, 178, 170],\r\n\t\t\t\"lightskyblue\": [135, 206, 250],\r\n\t\t\t\"lightslategray\": [119, 136, 153],\r\n\t\t\t\"lightslategrey\": [119, 136, 153],\r\n\t\t\t\"lightsteelblue\": [176, 196, 222],\r\n\t\t\t\"lightyellow\": [255, 255, 224],\r\n\t\t\t\"lime\": [0, 255, 0],\r\n\t\t\t\"limegreen\": [50, 205, 50],\r\n\t\t\t\"linen\": [250, 240, 230],\r\n\t\t\t\"magenta\": [255, 0, 255],\r\n\t\t\t\"maroon\": [128, 0, 0],\r\n\t\t\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\t\t\"mediumblue\": [0, 0, 205],\r\n\t\t\t\"mediumorchid\": [186, 85, 211],\r\n\t\t\t\"mediumpurple\": [147, 112, 219],\r\n\t\t\t\"mediumseagreen\": [60, 179, 113],\r\n\t\t\t\"mediumslateblue\": [123, 104, 238],\r\n\t\t\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\t\t\"mediumturquoise\": [72, 209, 204],\r\n\t\t\t\"mediumvioletred\": [199, 21, 133],\r\n\t\t\t\"midnightblue\": [25, 25, 112],\r\n\t\t\t\"mintcream\": [245, 255, 250],\r\n\t\t\t\"mistyrose\": [255, 228, 225],\r\n\t\t\t\"moccasin\": [255, 228, 181],\r\n\t\t\t\"navajowhite\": [255, 222, 173],\r\n\t\t\t\"navy\": [0, 0, 128],\r\n\t\t\t\"oldlace\": [253, 245, 230],\r\n\t\t\t\"olive\": [128, 128, 0],\r\n\t\t\t\"olivedrab\": [107, 142, 35],\r\n\t\t\t\"orange\": [255, 165, 0],\r\n\t\t\t\"orangered\": [255, 69, 0],\r\n\t\t\t\"orchid\": [218, 112, 214],\r\n\t\t\t\"palegoldenrod\": [238, 232, 170],\r\n\t\t\t\"palegreen\": [152, 251, 152],\r\n\t\t\t\"paleturquoise\": [175, 238, 238],\r\n\t\t\t\"palevioletred\": [219, 112, 147],\r\n\t\t\t\"papayawhip\": [255, 239, 213],\r\n\t\t\t\"peachpuff\": [255, 218, 185],\r\n\t\t\t\"peru\": [205, 133, 63],\r\n\t\t\t\"pink\": [255, 192, 203],\r\n\t\t\t\"plum\": [221, 160, 221],\r\n\t\t\t\"powderblue\": [176, 224, 230],\r\n\t\t\t\"purple\": [128, 0, 128],\r\n\t\t\t\"rebeccapurple\": [102, 51, 153],\r\n\t\t\t\"red\": [255, 0, 0],\r\n\t\t\t\"rosybrown\": [188, 143, 143],\r\n\t\t\t\"royalblue\": [65, 105, 225],\r\n\t\t\t\"saddlebrown\": [139, 69, 19],\r\n\t\t\t\"salmon\": [250, 128, 114],\r\n\t\t\t\"sandybrown\": [244, 164, 96],\r\n\t\t\t\"seagreen\": [46, 139, 87],\r\n\t\t\t\"seashell\": [255, 245, 238],\r\n\t\t\t\"sienna\": [160, 82, 45],\r\n\t\t\t\"silver\": [192, 192, 192],\r\n\t\t\t\"skyblue\": [135, 206, 235],\r\n\t\t\t\"slateblue\": [106, 90, 205],\r\n\t\t\t\"slategray\": [112, 128, 144],\r\n\t\t\t\"slategrey\": [112, 128, 144],\r\n\t\t\t\"snow\": [255, 250, 250],\r\n\t\t\t\"springgreen\": [0, 255, 127],\r\n\t\t\t\"steelblue\": [70, 130, 180],\r\n\t\t\t\"tan\": [210, 180, 140],\r\n\t\t\t\"teal\": [0, 128, 128],\r\n\t\t\t\"thistle\": [216, 191, 216],\r\n\t\t\t\"tomato\": [255, 99, 71],\r\n\t\t\t\"turquoise\": [64, 224, 208],\r\n\t\t\t\"violet\": [238, 130, 238],\r\n\t\t\t\"wheat\": [245, 222, 179],\r\n\t\t\t\"white\": [255, 255, 255],\r\n\t\t\t\"whitesmoke\": [245, 245, 245],\r\n\t\t\t\"yellow\": [255, 255, 0],\r\n\t\t\t\"yellowgreen\": [154, 205, 50]\r\n\t\t};\n\t\treturn colorName;\n\t}\n\n\t/* MIT license */\n\n\tvar conversions;\n\tvar hasRequiredConversions;\n\n\tfunction requireConversions () {\n\t\tif (hasRequiredConversions) return conversions;\n\t\thasRequiredConversions = 1;\n\t\t/* eslint-disable no-mixed-operators */\n\t\tconst cssKeywords = requireColorName();\n\n\t\t// NOTE: conversions should only return primitive values (i.e. arrays, or\n\t\t//       values that give correct `typeof` results).\n\t\t//       do not use box values types (i.e. Number(), String(), etc.)\n\n\t\tconst reverseKeywords = {};\n\t\tfor (const key of Object.keys(cssKeywords)) {\n\t\t\treverseKeywords[cssKeywords[key]] = key;\n\t\t}\n\n\t\tconst convert = {\n\t\t\trgb: {channels: 3, labels: 'rgb'},\n\t\t\thsl: {channels: 3, labels: 'hsl'},\n\t\t\thsv: {channels: 3, labels: 'hsv'},\n\t\t\thwb: {channels: 3, labels: 'hwb'},\n\t\t\tcmyk: {channels: 4, labels: 'cmyk'},\n\t\t\txyz: {channels: 3, labels: 'xyz'},\n\t\t\tlab: {channels: 3, labels: 'lab'},\n\t\t\tlch: {channels: 3, labels: 'lch'},\n\t\t\thex: {channels: 1, labels: ['hex']},\n\t\t\tkeyword: {channels: 1, labels: ['keyword']},\n\t\t\tansi16: {channels: 1, labels: ['ansi16']},\n\t\t\tansi256: {channels: 1, labels: ['ansi256']},\n\t\t\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\t\t\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\t\t\tgray: {channels: 1, labels: ['gray']}\n\t\t};\n\n\t\tconversions = convert;\n\n\t\t// Hide .channels and .labels properties\n\t\tfor (const model of Object.keys(convert)) {\n\t\t\tif (!('channels' in convert[model])) {\n\t\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t\t}\n\n\t\t\tif (!('labels' in convert[model])) {\n\t\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t\t}\n\n\t\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t\t}\n\n\t\t\tconst {channels, labels} = convert[model];\n\t\t\tdelete convert[model].channels;\n\t\t\tdelete convert[model].labels;\n\t\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t\t}\n\n\t\tconvert.rgb.hsl = function (rgb) {\n\t\t\tconst r = rgb[0] / 255;\n\t\t\tconst g = rgb[1] / 255;\n\t\t\tconst b = rgb[2] / 255;\n\t\t\tconst min = Math.min(r, g, b);\n\t\t\tconst max = Math.max(r, g, b);\n\t\t\tconst delta = max - min;\n\t\t\tlet h;\n\t\t\tlet s;\n\n\t\t\tif (max === min) {\n\t\t\t\th = 0;\n\t\t\t} else if (r === max) {\n\t\t\t\th = (g - b) / delta;\n\t\t\t} else if (g === max) {\n\t\t\t\th = 2 + (b - r) / delta;\n\t\t\t} else if (b === max) {\n\t\t\t\th = 4 + (r - g) / delta;\n\t\t\t}\n\n\t\t\th = Math.min(h * 60, 360);\n\n\t\t\tif (h < 0) {\n\t\t\t\th += 360;\n\t\t\t}\n\n\t\t\tconst l = (min + max) / 2;\n\n\t\t\tif (max === min) {\n\t\t\t\ts = 0;\n\t\t\t} else if (l <= 0.5) {\n\t\t\t\ts = delta / (max + min);\n\t\t\t} else {\n\t\t\t\ts = delta / (2 - max - min);\n\t\t\t}\n\n\t\t\treturn [h, s * 100, l * 100];\n\t\t};\n\n\t\tconvert.rgb.hsv = function (rgb) {\n\t\t\tlet rdif;\n\t\t\tlet gdif;\n\t\t\tlet bdif;\n\t\t\tlet h;\n\t\t\tlet s;\n\n\t\t\tconst r = rgb[0] / 255;\n\t\t\tconst g = rgb[1] / 255;\n\t\t\tconst b = rgb[2] / 255;\n\t\t\tconst v = Math.max(r, g, b);\n\t\t\tconst diff = v - Math.min(r, g, b);\n\t\t\tconst diffc = function (c) {\n\t\t\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t\t\t};\n\n\t\t\tif (diff === 0) {\n\t\t\t\th = 0;\n\t\t\t\ts = 0;\n\t\t\t} else {\n\t\t\t\ts = diff / v;\n\t\t\t\trdif = diffc(r);\n\t\t\t\tgdif = diffc(g);\n\t\t\t\tbdif = diffc(b);\n\n\t\t\t\tif (r === v) {\n\t\t\t\t\th = bdif - gdif;\n\t\t\t\t} else if (g === v) {\n\t\t\t\t\th = (1 / 3) + rdif - bdif;\n\t\t\t\t} else if (b === v) {\n\t\t\t\t\th = (2 / 3) + gdif - rdif;\n\t\t\t\t}\n\n\t\t\t\tif (h < 0) {\n\t\t\t\t\th += 1;\n\t\t\t\t} else if (h > 1) {\n\t\t\t\t\th -= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\th * 360,\n\t\t\t\ts * 100,\n\t\t\t\tv * 100\n\t\t\t];\n\t\t};\n\n\t\tconvert.rgb.hwb = function (rgb) {\n\t\t\tconst r = rgb[0];\n\t\t\tconst g = rgb[1];\n\t\t\tlet b = rgb[2];\n\t\t\tconst h = convert.rgb.hsl(rgb)[0];\n\t\t\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\t\t\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\t\t\treturn [h, w * 100, b * 100];\n\t\t};\n\n\t\tconvert.rgb.cmyk = function (rgb) {\n\t\t\tconst r = rgb[0] / 255;\n\t\t\tconst g = rgb[1] / 255;\n\t\t\tconst b = rgb[2] / 255;\n\n\t\t\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\t\t\tconst c = (1 - r - k) / (1 - k) || 0;\n\t\t\tconst m = (1 - g - k) / (1 - k) || 0;\n\t\t\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\t\t\treturn [c * 100, m * 100, y * 100, k * 100];\n\t\t};\n\n\t\tfunction comparativeDistance(x, y) {\n\t\t\t/*\n\t\t\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t\t\t*/\n\t\t\treturn (\n\t\t\t\t((x[0] - y[0]) ** 2) +\n\t\t\t\t((x[1] - y[1]) ** 2) +\n\t\t\t\t((x[2] - y[2]) ** 2)\n\t\t\t);\n\t\t}\n\n\t\tconvert.rgb.keyword = function (rgb) {\n\t\t\tconst reversed = reverseKeywords[rgb];\n\t\t\tif (reversed) {\n\t\t\t\treturn reversed;\n\t\t\t}\n\n\t\t\tlet currentClosestDistance = Infinity;\n\t\t\tlet currentClosestKeyword;\n\n\t\t\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\t\t\tconst value = cssKeywords[keyword];\n\n\t\t\t\t// Compute comparative distance\n\t\t\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t\t\t// Check if its less, if so set as closest\n\t\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentClosestKeyword;\n\t\t};\n\n\t\tconvert.keyword.rgb = function (keyword) {\n\t\t\treturn cssKeywords[keyword];\n\t\t};\n\n\t\tconvert.rgb.xyz = function (rgb) {\n\t\t\tlet r = rgb[0] / 255;\n\t\t\tlet g = rgb[1] / 255;\n\t\t\tlet b = rgb[2] / 255;\n\n\t\t\t// Assume sRGB\n\t\t\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\t\t\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\t\t\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\t\t\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\t\t\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\t\t\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\t\t\treturn [x * 100, y * 100, z * 100];\n\t\t};\n\n\t\tconvert.rgb.lab = function (rgb) {\n\t\t\tconst xyz = convert.rgb.xyz(rgb);\n\t\t\tlet x = xyz[0];\n\t\t\tlet y = xyz[1];\n\t\t\tlet z = xyz[2];\n\n\t\t\tx /= 95.047;\n\t\t\ty /= 100;\n\t\t\tz /= 108.883;\n\n\t\t\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\t\t\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\t\t\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\t\t\tconst l = (116 * y) - 16;\n\t\t\tconst a = 500 * (x - y);\n\t\t\tconst b = 200 * (y - z);\n\n\t\t\treturn [l, a, b];\n\t\t};\n\n\t\tconvert.hsl.rgb = function (hsl) {\n\t\t\tconst h = hsl[0] / 360;\n\t\t\tconst s = hsl[1] / 100;\n\t\t\tconst l = hsl[2] / 100;\n\t\t\tlet t2;\n\t\t\tlet t3;\n\t\t\tlet val;\n\n\t\t\tif (s === 0) {\n\t\t\t\tval = l * 255;\n\t\t\t\treturn [val, val, val];\n\t\t\t}\n\n\t\t\tif (l < 0.5) {\n\t\t\t\tt2 = l * (1 + s);\n\t\t\t} else {\n\t\t\t\tt2 = l + s - l * s;\n\t\t\t}\n\n\t\t\tconst t1 = 2 * l - t2;\n\n\t\t\tconst rgb = [0, 0, 0];\n\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\t\t\tif (t3 < 0) {\n\t\t\t\t\tt3++;\n\t\t\t\t}\n\n\t\t\t\tif (t3 > 1) {\n\t\t\t\t\tt3--;\n\t\t\t\t}\n\n\t\t\t\tif (6 * t3 < 1) {\n\t\t\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t\t\t} else if (2 * t3 < 1) {\n\t\t\t\t\tval = t2;\n\t\t\t\t} else if (3 * t3 < 2) {\n\t\t\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t\t\t} else {\n\t\t\t\t\tval = t1;\n\t\t\t\t}\n\n\t\t\t\trgb[i] = val * 255;\n\t\t\t}\n\n\t\t\treturn rgb;\n\t\t};\n\n\t\tconvert.hsl.hsv = function (hsl) {\n\t\t\tconst h = hsl[0];\n\t\t\tlet s = hsl[1] / 100;\n\t\t\tlet l = hsl[2] / 100;\n\t\t\tlet smin = s;\n\t\t\tconst lmin = Math.max(l, 0.01);\n\n\t\t\tl *= 2;\n\t\t\ts *= (l <= 1) ? l : 2 - l;\n\t\t\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\t\t\tconst v = (l + s) / 2;\n\t\t\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\t\t\treturn [h, sv * 100, v * 100];\n\t\t};\n\n\t\tconvert.hsv.rgb = function (hsv) {\n\t\t\tconst h = hsv[0] / 60;\n\t\t\tconst s = hsv[1] / 100;\n\t\t\tlet v = hsv[2] / 100;\n\t\t\tconst hi = Math.floor(h) % 6;\n\n\t\t\tconst f = h - Math.floor(h);\n\t\t\tconst p = 255 * v * (1 - s);\n\t\t\tconst q = 255 * v * (1 - (s * f));\n\t\t\tconst t = 255 * v * (1 - (s * (1 - f)));\n\t\t\tv *= 255;\n\n\t\t\tswitch (hi) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn [v, t, p];\n\t\t\t\tcase 1:\n\t\t\t\t\treturn [q, v, p];\n\t\t\t\tcase 2:\n\t\t\t\t\treturn [p, v, t];\n\t\t\t\tcase 3:\n\t\t\t\t\treturn [p, q, v];\n\t\t\t\tcase 4:\n\t\t\t\t\treturn [t, p, v];\n\t\t\t\tcase 5:\n\t\t\t\t\treturn [v, p, q];\n\t\t\t}\n\t\t};\n\n\t\tconvert.hsv.hsl = function (hsv) {\n\t\t\tconst h = hsv[0];\n\t\t\tconst s = hsv[1] / 100;\n\t\t\tconst v = hsv[2] / 100;\n\t\t\tconst vmin = Math.max(v, 0.01);\n\t\t\tlet sl;\n\t\t\tlet l;\n\n\t\t\tl = (2 - s) * v;\n\t\t\tconst lmin = (2 - s) * vmin;\n\t\t\tsl = s * vmin;\n\t\t\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\t\t\tsl = sl || 0;\n\t\t\tl /= 2;\n\n\t\t\treturn [h, sl * 100, l * 100];\n\t\t};\n\n\t\t// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n\t\tconvert.hwb.rgb = function (hwb) {\n\t\t\tconst h = hwb[0] / 360;\n\t\t\tlet wh = hwb[1] / 100;\n\t\t\tlet bl = hwb[2] / 100;\n\t\t\tconst ratio = wh + bl;\n\t\t\tlet f;\n\n\t\t\t// Wh + bl cant be > 1\n\t\t\tif (ratio > 1) {\n\t\t\t\twh /= ratio;\n\t\t\t\tbl /= ratio;\n\t\t\t}\n\n\t\t\tconst i = Math.floor(6 * h);\n\t\t\tconst v = 1 - bl;\n\t\t\tf = 6 * h - i;\n\n\t\t\tif ((i & 0x01) !== 0) {\n\t\t\t\tf = 1 - f;\n\t\t\t}\n\n\t\t\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\t\t\tlet r;\n\t\t\tlet g;\n\t\t\tlet b;\n\t\t\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\t\t\tswitch (i) {\n\t\t\t\tdefault:\n\t\t\t\tcase 6:\n\t\t\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\t\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\t\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\t\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\t\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\t\t\tcase 5: r = v;  g = wh; b = n; break;\n\t\t\t}\n\t\t\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\t\t\treturn [r * 255, g * 255, b * 255];\n\t\t};\n\n\t\tconvert.cmyk.rgb = function (cmyk) {\n\t\t\tconst c = cmyk[0] / 100;\n\t\t\tconst m = cmyk[1] / 100;\n\t\t\tconst y = cmyk[2] / 100;\n\t\t\tconst k = cmyk[3] / 100;\n\n\t\t\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\t\t\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\t\t\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\t\t\treturn [r * 255, g * 255, b * 255];\n\t\t};\n\n\t\tconvert.xyz.rgb = function (xyz) {\n\t\t\tconst x = xyz[0] / 100;\n\t\t\tconst y = xyz[1] / 100;\n\t\t\tconst z = xyz[2] / 100;\n\t\t\tlet r;\n\t\t\tlet g;\n\t\t\tlet b;\n\n\t\t\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\t\t\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\t\t\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t\t\t// Assume sRGB\n\t\t\tr = r > 0.0031308\n\t\t\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t\t\t: r * 12.92;\n\n\t\t\tg = g > 0.0031308\n\t\t\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t\t\t: g * 12.92;\n\n\t\t\tb = b > 0.0031308\n\t\t\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t\t\t: b * 12.92;\n\n\t\t\tr = Math.min(Math.max(0, r), 1);\n\t\t\tg = Math.min(Math.max(0, g), 1);\n\t\t\tb = Math.min(Math.max(0, b), 1);\n\n\t\t\treturn [r * 255, g * 255, b * 255];\n\t\t};\n\n\t\tconvert.xyz.lab = function (xyz) {\n\t\t\tlet x = xyz[0];\n\t\t\tlet y = xyz[1];\n\t\t\tlet z = xyz[2];\n\n\t\t\tx /= 95.047;\n\t\t\ty /= 100;\n\t\t\tz /= 108.883;\n\n\t\t\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\t\t\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\t\t\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\t\t\tconst l = (116 * y) - 16;\n\t\t\tconst a = 500 * (x - y);\n\t\t\tconst b = 200 * (y - z);\n\n\t\t\treturn [l, a, b];\n\t\t};\n\n\t\tconvert.lab.xyz = function (lab) {\n\t\t\tconst l = lab[0];\n\t\t\tconst a = lab[1];\n\t\t\tconst b = lab[2];\n\t\t\tlet x;\n\t\t\tlet y;\n\t\t\tlet z;\n\n\t\t\ty = (l + 16) / 116;\n\t\t\tx = a / 500 + y;\n\t\t\tz = y - b / 200;\n\n\t\t\tconst y2 = y ** 3;\n\t\t\tconst x2 = x ** 3;\n\t\t\tconst z2 = z ** 3;\n\t\t\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\t\t\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\t\t\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\t\t\tx *= 95.047;\n\t\t\ty *= 100;\n\t\t\tz *= 108.883;\n\n\t\t\treturn [x, y, z];\n\t\t};\n\n\t\tconvert.lab.lch = function (lab) {\n\t\t\tconst l = lab[0];\n\t\t\tconst a = lab[1];\n\t\t\tconst b = lab[2];\n\t\t\tlet h;\n\n\t\t\tconst hr = Math.atan2(b, a);\n\t\t\th = hr * 360 / 2 / Math.PI;\n\n\t\t\tif (h < 0) {\n\t\t\t\th += 360;\n\t\t\t}\n\n\t\t\tconst c = Math.sqrt(a * a + b * b);\n\n\t\t\treturn [l, c, h];\n\t\t};\n\n\t\tconvert.lch.lab = function (lch) {\n\t\t\tconst l = lch[0];\n\t\t\tconst c = lch[1];\n\t\t\tconst h = lch[2];\n\n\t\t\tconst hr = h / 360 * 2 * Math.PI;\n\t\t\tconst a = c * Math.cos(hr);\n\t\t\tconst b = c * Math.sin(hr);\n\n\t\t\treturn [l, a, b];\n\t\t};\n\n\t\tconvert.rgb.ansi16 = function (args, saturation = null) {\n\t\t\tconst [r, g, b] = args;\n\t\t\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\t\t\tvalue = Math.round(value / 50);\n\n\t\t\tif (value === 0) {\n\t\t\t\treturn 30;\n\t\t\t}\n\n\t\t\tlet ansi = 30\n\t\t\t\t+ ((Math.round(b / 255) << 2)\n\t\t\t\t| (Math.round(g / 255) << 1)\n\t\t\t\t| Math.round(r / 255));\n\n\t\t\tif (value === 2) {\n\t\t\t\tansi += 60;\n\t\t\t}\n\n\t\t\treturn ansi;\n\t\t};\n\n\t\tconvert.hsv.ansi16 = function (args) {\n\t\t\t// Optimization here; we already know the value and don't need to get\n\t\t\t// it converted for us.\n\t\t\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n\t\t};\n\n\t\tconvert.rgb.ansi256 = function (args) {\n\t\t\tconst r = args[0];\n\t\t\tconst g = args[1];\n\t\t\tconst b = args[2];\n\n\t\t\t// We use the extended greyscale palette here, with the exception of\n\t\t\t// black and white. normal palette only has 4 greyscale shades.\n\t\t\tif (r === g && g === b) {\n\t\t\t\tif (r < 8) {\n\t\t\t\t\treturn 16;\n\t\t\t\t}\n\n\t\t\t\tif (r > 248) {\n\t\t\t\t\treturn 231;\n\t\t\t\t}\n\n\t\t\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t\t\t}\n\n\t\t\tconst ansi = 16\n\t\t\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t\t\t+ Math.round(b / 255 * 5);\n\n\t\t\treturn ansi;\n\t\t};\n\n\t\tconvert.ansi16.rgb = function (args) {\n\t\t\tlet color = args % 10;\n\n\t\t\t// Handle greyscale\n\t\t\tif (color === 0 || color === 7) {\n\t\t\t\tif (args > 50) {\n\t\t\t\t\tcolor += 3.5;\n\t\t\t\t}\n\n\t\t\t\tcolor = color / 10.5 * 255;\n\n\t\t\t\treturn [color, color, color];\n\t\t\t}\n\n\t\t\tconst mult = (~~(args > 50) + 1) * 0.5;\n\t\t\tconst r = ((color & 1) * mult) * 255;\n\t\t\tconst g = (((color >> 1) & 1) * mult) * 255;\n\t\t\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\t\t\treturn [r, g, b];\n\t\t};\n\n\t\tconvert.ansi256.rgb = function (args) {\n\t\t\t// Handle greyscale\n\t\t\tif (args >= 232) {\n\t\t\t\tconst c = (args - 232) * 10 + 8;\n\t\t\t\treturn [c, c, c];\n\t\t\t}\n\n\t\t\targs -= 16;\n\n\t\t\tlet rem;\n\t\t\tconst r = Math.floor(args / 36) / 5 * 255;\n\t\t\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\t\t\tconst b = (rem % 6) / 5 * 255;\n\n\t\t\treturn [r, g, b];\n\t\t};\n\n\t\tconvert.rgb.hex = function (args) {\n\t\t\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t\t\t+ (Math.round(args[2]) & 0xFF);\n\n\t\t\tconst string = integer.toString(16).toUpperCase();\n\t\t\treturn '000000'.substring(string.length) + string;\n\t\t};\n\n\t\tconvert.hex.rgb = function (args) {\n\t\t\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\t\t\tif (!match) {\n\t\t\t\treturn [0, 0, 0];\n\t\t\t}\n\n\t\t\tlet colorString = match[0];\n\n\t\t\tif (match[0].length === 3) {\n\t\t\t\tcolorString = colorString.split('').map(char => {\n\t\t\t\t\treturn char + char;\n\t\t\t\t}).join('');\n\t\t\t}\n\n\t\t\tconst integer = parseInt(colorString, 16);\n\t\t\tconst r = (integer >> 16) & 0xFF;\n\t\t\tconst g = (integer >> 8) & 0xFF;\n\t\t\tconst b = integer & 0xFF;\n\n\t\t\treturn [r, g, b];\n\t\t};\n\n\t\tconvert.rgb.hcg = function (rgb) {\n\t\t\tconst r = rgb[0] / 255;\n\t\t\tconst g = rgb[1] / 255;\n\t\t\tconst b = rgb[2] / 255;\n\t\t\tconst max = Math.max(Math.max(r, g), b);\n\t\t\tconst min = Math.min(Math.min(r, g), b);\n\t\t\tconst chroma = (max - min);\n\t\t\tlet grayscale;\n\t\t\tlet hue;\n\n\t\t\tif (chroma < 1) {\n\t\t\t\tgrayscale = min / (1 - chroma);\n\t\t\t} else {\n\t\t\t\tgrayscale = 0;\n\t\t\t}\n\n\t\t\tif (chroma <= 0) {\n\t\t\t\thue = 0;\n\t\t\t} else\n\t\t\tif (max === r) {\n\t\t\t\thue = ((g - b) / chroma) % 6;\n\t\t\t} else\n\t\t\tif (max === g) {\n\t\t\t\thue = 2 + (b - r) / chroma;\n\t\t\t} else {\n\t\t\t\thue = 4 + (r - g) / chroma;\n\t\t\t}\n\n\t\t\thue /= 6;\n\t\t\thue %= 1;\n\n\t\t\treturn [hue * 360, chroma * 100, grayscale * 100];\n\t\t};\n\n\t\tconvert.hsl.hcg = function (hsl) {\n\t\t\tconst s = hsl[1] / 100;\n\t\t\tconst l = hsl[2] / 100;\n\n\t\t\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\t\t\tlet f = 0;\n\t\t\tif (c < 1.0) {\n\t\t\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t\t\t}\n\n\t\t\treturn [hsl[0], c * 100, f * 100];\n\t\t};\n\n\t\tconvert.hsv.hcg = function (hsv) {\n\t\t\tconst s = hsv[1] / 100;\n\t\t\tconst v = hsv[2] / 100;\n\n\t\t\tconst c = s * v;\n\t\t\tlet f = 0;\n\n\t\t\tif (c < 1.0) {\n\t\t\t\tf = (v - c) / (1 - c);\n\t\t\t}\n\n\t\t\treturn [hsv[0], c * 100, f * 100];\n\t\t};\n\n\t\tconvert.hcg.rgb = function (hcg) {\n\t\t\tconst h = hcg[0] / 360;\n\t\t\tconst c = hcg[1] / 100;\n\t\t\tconst g = hcg[2] / 100;\n\n\t\t\tif (c === 0.0) {\n\t\t\t\treturn [g * 255, g * 255, g * 255];\n\t\t\t}\n\n\t\t\tconst pure = [0, 0, 0];\n\t\t\tconst hi = (h % 1) * 6;\n\t\t\tconst v = hi % 1;\n\t\t\tconst w = 1 - v;\n\t\t\tlet mg = 0;\n\n\t\t\t/* eslint-disable max-statements-per-line */\n\t\t\tswitch (Math.floor(hi)) {\n\t\t\t\tcase 0:\n\t\t\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\t\t\tcase 2:\n\t\t\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\t\t\tcase 3:\n\t\t\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\t\t\tcase 4:\n\t\t\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\t\t\tdefault:\n\t\t\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t\t\t}\n\t\t\t/* eslint-enable max-statements-per-line */\n\n\t\t\tmg = (1.0 - c) * g;\n\n\t\t\treturn [\n\t\t\t\t(c * pure[0] + mg) * 255,\n\t\t\t\t(c * pure[1] + mg) * 255,\n\t\t\t\t(c * pure[2] + mg) * 255\n\t\t\t];\n\t\t};\n\n\t\tconvert.hcg.hsv = function (hcg) {\n\t\t\tconst c = hcg[1] / 100;\n\t\t\tconst g = hcg[2] / 100;\n\n\t\t\tconst v = c + g * (1.0 - c);\n\t\t\tlet f = 0;\n\n\t\t\tif (v > 0.0) {\n\t\t\t\tf = c / v;\n\t\t\t}\n\n\t\t\treturn [hcg[0], f * 100, v * 100];\n\t\t};\n\n\t\tconvert.hcg.hsl = function (hcg) {\n\t\t\tconst c = hcg[1] / 100;\n\t\t\tconst g = hcg[2] / 100;\n\n\t\t\tconst l = g * (1.0 - c) + 0.5 * c;\n\t\t\tlet s = 0;\n\n\t\t\tif (l > 0.0 && l < 0.5) {\n\t\t\t\ts = c / (2 * l);\n\t\t\t} else\n\t\t\tif (l >= 0.5 && l < 1.0) {\n\t\t\t\ts = c / (2 * (1 - l));\n\t\t\t}\n\n\t\t\treturn [hcg[0], s * 100, l * 100];\n\t\t};\n\n\t\tconvert.hcg.hwb = function (hcg) {\n\t\t\tconst c = hcg[1] / 100;\n\t\t\tconst g = hcg[2] / 100;\n\t\t\tconst v = c + g * (1.0 - c);\n\t\t\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n\t\t};\n\n\t\tconvert.hwb.hcg = function (hwb) {\n\t\t\tconst w = hwb[1] / 100;\n\t\t\tconst b = hwb[2] / 100;\n\t\t\tconst v = 1 - b;\n\t\t\tconst c = v - w;\n\t\t\tlet g = 0;\n\n\t\t\tif (c < 1) {\n\t\t\t\tg = (v - c) / (1 - c);\n\t\t\t}\n\n\t\t\treturn [hwb[0], c * 100, g * 100];\n\t\t};\n\n\t\tconvert.apple.rgb = function (apple) {\n\t\t\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n\t\t};\n\n\t\tconvert.rgb.apple = function (rgb) {\n\t\t\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n\t\t};\n\n\t\tconvert.gray.rgb = function (args) {\n\t\t\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n\t\t};\n\n\t\tconvert.gray.hsl = function (args) {\n\t\t\treturn [0, 0, args[0]];\n\t\t};\n\n\t\tconvert.gray.hsv = convert.gray.hsl;\n\n\t\tconvert.gray.hwb = function (gray) {\n\t\t\treturn [0, 100, gray[0]];\n\t\t};\n\n\t\tconvert.gray.cmyk = function (gray) {\n\t\t\treturn [0, 0, 0, gray[0]];\n\t\t};\n\n\t\tconvert.gray.lab = function (gray) {\n\t\t\treturn [gray[0], 0, 0];\n\t\t};\n\n\t\tconvert.gray.hex = function (gray) {\n\t\t\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\t\t\tconst integer = (val << 16) + (val << 8) + val;\n\n\t\t\tconst string = integer.toString(16).toUpperCase();\n\t\t\treturn '000000'.substring(string.length) + string;\n\t\t};\n\n\t\tconvert.rgb.gray = function (rgb) {\n\t\t\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\t\t\treturn [val / 255 * 100];\n\t\t};\n\t\treturn conversions;\n\t}\n\n\tvar route;\n\tvar hasRequiredRoute;\n\n\tfunction requireRoute () {\n\t\tif (hasRequiredRoute) return route;\n\t\thasRequiredRoute = 1;\n\t\tconst conversions = requireConversions();\n\n\t\t/*\n\t\t\tThis function routes a model to all other models.\n\n\t\t\tall functions that are routed have a property `.conversion` attached\n\t\t\tto the returned synthetic function. This property is an array\n\t\t\tof strings, each with the steps in between the 'from' and 'to'\n\t\t\tcolor models (inclusive).\n\n\t\t\tconversions that are not possible simply are not included.\n\t\t*/\n\n\t\tfunction buildGraph() {\n\t\t\tconst graph = {};\n\t\t\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\t\t\tconst models = Object.keys(conversions);\n\n\t\t\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\t\t\tgraph[models[i]] = {\n\t\t\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t\t\t// micro-opt, but this is simple.\n\t\t\t\t\tdistance: -1,\n\t\t\t\t\tparent: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn graph;\n\t\t}\n\n\t\t// https://en.wikipedia.org/wiki/Breadth-first_search\n\t\tfunction deriveBFS(fromModel) {\n\t\t\tconst graph = buildGraph();\n\t\t\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\t\t\tgraph[fromModel].distance = 0;\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst current = queue.pop();\n\t\t\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\t\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\t\t\tconst adjacent = adjacents[i];\n\t\t\t\t\tconst node = graph[adjacent];\n\n\t\t\t\t\tif (node.distance === -1) {\n\t\t\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\t\t\tnode.parent = current;\n\t\t\t\t\t\tqueue.unshift(adjacent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn graph;\n\t\t}\n\n\t\tfunction link(from, to) {\n\t\t\treturn function (args) {\n\t\t\t\treturn to(from(args));\n\t\t\t};\n\t\t}\n\n\t\tfunction wrapConversion(toModel, graph) {\n\t\t\tconst path = [graph[toModel].parent, toModel];\n\t\t\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\t\t\tlet cur = graph[toModel].parent;\n\t\t\twhile (graph[cur].parent) {\n\t\t\t\tpath.unshift(graph[cur].parent);\n\t\t\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\t\t\tcur = graph[cur].parent;\n\t\t\t}\n\n\t\t\tfn.conversion = path;\n\t\t\treturn fn;\n\t\t}\n\n\t\troute = function (fromModel) {\n\t\t\tconst graph = deriveBFS(fromModel);\n\t\t\tconst conversion = {};\n\n\t\t\tconst models = Object.keys(graph);\n\t\t\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\t\t\tconst toModel = models[i];\n\t\t\t\tconst node = graph[toModel];\n\n\t\t\t\tif (node.parent === null) {\n\t\t\t\t\t// No possible conversion, or this node is the source model.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t\t\t}\n\n\t\t\treturn conversion;\n\t\t};\n\t\treturn route;\n\t}\n\n\tvar colorConvert;\n\tvar hasRequiredColorConvert;\n\n\tfunction requireColorConvert () {\n\t\tif (hasRequiredColorConvert) return colorConvert;\n\t\thasRequiredColorConvert = 1;\n\t\tconst conversions = requireConversions();\n\t\tconst route = requireRoute();\n\n\t\tconst convert = {};\n\n\t\tconst models = Object.keys(conversions);\n\n\t\tfunction wrapRaw(fn) {\n\t\t\tconst wrappedFn = function (...args) {\n\t\t\t\tconst arg0 = args[0];\n\t\t\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\t\t\treturn arg0;\n\t\t\t\t}\n\n\t\t\t\tif (arg0.length > 1) {\n\t\t\t\t\targs = arg0;\n\t\t\t\t}\n\n\t\t\t\treturn fn(args);\n\t\t\t};\n\n\t\t\t// Preserve .conversion property if there is one\n\t\t\tif ('conversion' in fn) {\n\t\t\t\twrappedFn.conversion = fn.conversion;\n\t\t\t}\n\n\t\t\treturn wrappedFn;\n\t\t}\n\n\t\tfunction wrapRounded(fn) {\n\t\t\tconst wrappedFn = function (...args) {\n\t\t\t\tconst arg0 = args[0];\n\n\t\t\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\t\t\treturn arg0;\n\t\t\t\t}\n\n\t\t\t\tif (arg0.length > 1) {\n\t\t\t\t\targs = arg0;\n\t\t\t\t}\n\n\t\t\t\tconst result = fn(args);\n\n\t\t\t\t// We're assuming the result is an array here.\n\t\t\t\t// see notice in conversions.js; don't use box types\n\t\t\t\t// in conversion functions.\n\t\t\t\tif (typeof result === 'object') {\n\t\t\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\t// Preserve .conversion property if there is one\n\t\t\tif ('conversion' in fn) {\n\t\t\t\twrappedFn.conversion = fn.conversion;\n\t\t\t}\n\n\t\t\treturn wrappedFn;\n\t\t}\n\n\t\tmodels.forEach(fromModel => {\n\t\t\tconvert[fromModel] = {};\n\n\t\t\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\t\t\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\t\t\tconst routes = route(fromModel);\n\t\t\tconst routeModels = Object.keys(routes);\n\n\t\t\trouteModels.forEach(toModel => {\n\t\t\t\tconst fn = routes[toModel];\n\n\t\t\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\t\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t\t\t});\n\t\t});\n\n\t\tcolorConvert = convert;\n\t\treturn colorConvert;\n\t}\n\n\tansiStyles.exports;\n\n\t(function (module) {\n\n\t\tconst wrapAnsi16 = (fn, offset) => (...args) => {\n\t\t\tconst code = fn(...args);\n\t\t\treturn `\\u001B[${code + offset}m`;\n\t\t};\n\n\t\tconst wrapAnsi256 = (fn, offset) => (...args) => {\n\t\t\tconst code = fn(...args);\n\t\t\treturn `\\u001B[${38 + offset};5;${code}m`;\n\t\t};\n\n\t\tconst wrapAnsi16m = (fn, offset) => (...args) => {\n\t\t\tconst rgb = fn(...args);\n\t\t\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n\t\t};\n\n\t\tconst ansi2ansi = n => n;\n\t\tconst rgb2rgb = (r, g, b) => [r, g, b];\n\n\t\tconst setLazyProperty = (object, property, get) => {\n\t\t\tObject.defineProperty(object, property, {\n\t\t\t\tget: () => {\n\t\t\t\t\tconst value = get();\n\n\t\t\t\t\tObject.defineProperty(object, property, {\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t};\n\n\t\t/** @type {typeof import('color-convert')} */\n\t\tlet colorConvert;\n\t\tconst makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {\n\t\t\tif (colorConvert === undefined) {\n\t\t\t\tcolorConvert = requireColorConvert();\n\t\t\t}\n\n\t\t\tconst offset = isBackground ? 10 : 0;\n\t\t\tconst styles = {};\n\n\t\t\tfor (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n\t\t\t\tconst name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;\n\t\t\t\tif (sourceSpace === targetSpace) {\n\t\t\t\t\tstyles[name] = wrap(identity, offset);\n\t\t\t\t} else if (typeof suite === 'object') {\n\t\t\t\t\tstyles[name] = wrap(suite[targetSpace], offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn styles;\n\t\t};\n\n\t\tfunction assembleStyles() {\n\t\t\tconst codes = new Map();\n\t\t\tconst styles = {\n\t\t\t\tmodifier: {\n\t\t\t\t\treset: [0, 0],\n\t\t\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\t\t\tbold: [1, 22],\n\t\t\t\t\tdim: [2, 22],\n\t\t\t\t\titalic: [3, 23],\n\t\t\t\t\tunderline: [4, 24],\n\t\t\t\t\tinverse: [7, 27],\n\t\t\t\t\thidden: [8, 28],\n\t\t\t\t\tstrikethrough: [9, 29]\n\t\t\t\t},\n\t\t\t\tcolor: {\n\t\t\t\t\tblack: [30, 39],\n\t\t\t\t\tred: [31, 39],\n\t\t\t\t\tgreen: [32, 39],\n\t\t\t\t\tyellow: [33, 39],\n\t\t\t\t\tblue: [34, 39],\n\t\t\t\t\tmagenta: [35, 39],\n\t\t\t\t\tcyan: [36, 39],\n\t\t\t\t\twhite: [37, 39],\n\n\t\t\t\t\t// Bright color\n\t\t\t\t\tblackBright: [90, 39],\n\t\t\t\t\tredBright: [91, 39],\n\t\t\t\t\tgreenBright: [92, 39],\n\t\t\t\t\tyellowBright: [93, 39],\n\t\t\t\t\tblueBright: [94, 39],\n\t\t\t\t\tmagentaBright: [95, 39],\n\t\t\t\t\tcyanBright: [96, 39],\n\t\t\t\t\twhiteBright: [97, 39]\n\t\t\t\t},\n\t\t\t\tbgColor: {\n\t\t\t\t\tbgBlack: [40, 49],\n\t\t\t\t\tbgRed: [41, 49],\n\t\t\t\t\tbgGreen: [42, 49],\n\t\t\t\t\tbgYellow: [43, 49],\n\t\t\t\t\tbgBlue: [44, 49],\n\t\t\t\t\tbgMagenta: [45, 49],\n\t\t\t\t\tbgCyan: [46, 49],\n\t\t\t\t\tbgWhite: [47, 49],\n\n\t\t\t\t\t// Bright color\n\t\t\t\t\tbgBlackBright: [100, 49],\n\t\t\t\t\tbgRedBright: [101, 49],\n\t\t\t\t\tbgGreenBright: [102, 49],\n\t\t\t\t\tbgYellowBright: [103, 49],\n\t\t\t\t\tbgBlueBright: [104, 49],\n\t\t\t\t\tbgMagentaBright: [105, 49],\n\t\t\t\t\tbgCyanBright: [106, 49],\n\t\t\t\t\tbgWhiteBright: [107, 49]\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Alias bright black as gray (and grey)\n\t\t\tstyles.color.gray = styles.color.blackBright;\n\t\t\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\t\t\tstyles.color.grey = styles.color.blackBright;\n\t\t\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\t\t\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\t\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\t\t\tstyles[styleName] = {\n\t\t\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t\t\t};\n\n\t\t\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\t\t\tcodes.set(style[0], style[1]);\n\t\t\t\t}\n\n\t\t\t\tObject.defineProperty(styles, groupName, {\n\t\t\t\t\tvalue: group,\n\t\t\t\t\tenumerable: false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tObject.defineProperty(styles, 'codes', {\n\t\t\t\tvalue: codes,\n\t\t\t\tenumerable: false\n\t\t\t});\n\n\t\t\tstyles.color.close = '\\u001B[39m';\n\t\t\tstyles.bgColor.close = '\\u001B[49m';\n\n\t\t\tsetLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));\n\t\t\tsetLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));\n\t\t\tsetLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));\n\t\t\tsetLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));\n\t\t\tsetLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));\n\t\t\tsetLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));\n\n\t\t\treturn styles;\n\t\t}\n\n\t\t// Make the export immutable\n\t\tObject.defineProperty(module, 'exports', {\n\t\t\tenumerable: true,\n\t\t\tget: assembleStyles\n\t\t}); \n\t} (ansiStyles));\n\n\tvar ansiStylesExports = ansiStyles.exports;\n\n\tvar __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(console$1, \"__esModule\", { value: true });\n\tconsole$1.ConsoleCallbackHandler = void 0;\n\tconst ansi_styles_1 = __importDefault$3(ansiStylesExports);\n\tconst base_js_1$7 = base$1;\n\tfunction wrap(style, text) {\n\t    return `${style.open}${text}${style.close}`;\n\t}\n\tfunction tryJsonStringify(obj, fallback) {\n\t    try {\n\t        return JSON.stringify(obj, null, 2);\n\t    }\n\t    catch (err) {\n\t        return fallback;\n\t    }\n\t}\n\tfunction formatKVMapItem(value) {\n\t    if (typeof value === \"string\") {\n\t        return value.trim();\n\t    }\n\t    if (value === null || value === undefined) {\n\t        return value;\n\t    }\n\t    return tryJsonStringify(value, value.toString());\n\t}\n\tfunction elapsed(run) {\n\t    if (!run.end_time)\n\t        return \"\";\n\t    const elapsed = run.end_time - run.start_time;\n\t    if (elapsed < 1000) {\n\t        return `${elapsed}ms`;\n\t    }\n\t    return `${(elapsed / 1000).toFixed(2)}s`;\n\t}\n\tconst { color } = ansi_styles_1.default;\n\t/**\n\t * A tracer that logs all events to the console. It extends from the\n\t * `BaseTracer` class and overrides its methods to provide custom logging\n\t * functionality.\n\t * @example\n\t * ```typescript\n\t *\n\t * const llm = new ChatAnthropic({\n\t *   temperature: 0,\n\t *   tags: [\"example\", \"callbacks\", \"constructor\"],\n\t *   callbacks: [new ConsoleCallbackHandler()],\n\t * });\n\t *\n\t * ```\n\t */\n\tclass ConsoleCallbackHandler extends base_js_1$7.BaseTracer {\n\t    constructor() {\n\t        super(...arguments);\n\t        Object.defineProperty(this, \"name\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: \"console_callback_handler\"\n\t        });\n\t    }\n\t    /**\n\t     * Method used to persist the run. In this case, it simply returns a\n\t     * resolved promise as there's no persistence logic.\n\t     * @param _run The run to persist.\n\t     * @returns A resolved promise.\n\t     */\n\t    persistRun(_run) {\n\t        return Promise.resolve();\n\t    }\n\t    // utility methods\n\t    /**\n\t     * Method used to get all the parent runs of a given run.\n\t     * @param run The run whose parents are to be retrieved.\n\t     * @returns An array of parent runs.\n\t     */\n\t    getParents(run) {\n\t        const parents = [];\n\t        let currentRun = run;\n\t        while (currentRun.parent_run_id) {\n\t            const parent = this.runMap.get(currentRun.parent_run_id);\n\t            if (parent) {\n\t                parents.push(parent);\n\t                currentRun = parent;\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        return parents;\n\t    }\n\t    /**\n\t     * Method used to get a string representation of the run's lineage, which\n\t     * is used in logging.\n\t     * @param run The run whose lineage is to be retrieved.\n\t     * @returns A string representation of the run's lineage.\n\t     */\n\t    getBreadcrumbs(run) {\n\t        const parents = this.getParents(run).reverse();\n\t        const string = [...parents, run]\n\t            .map((parent, i, arr) => {\n\t            const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n\t            return i === arr.length - 1 ? wrap(ansi_styles_1.default.bold, name) : name;\n\t        })\n\t            .join(\" > \");\n\t        return wrap(color.grey, string);\n\t    }\n\t    // logging methods\n\t    /**\n\t     * Method used to log the start of a chain run.\n\t     * @param run The chain run that has started.\n\t     * @returns void\n\t     */\n\t    onChainStart(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.green, \"[chain/start]\")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log the end of a chain run.\n\t     * @param run The chain run that has ended.\n\t     * @returns void\n\t     */\n\t    onChainEnd(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log any errors of a chain run.\n\t     * @param run The chain run that has errored.\n\t     * @returns void\n\t     */\n\t    onChainError(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log the start of an LLM run.\n\t     * @param run The LLM run that has started.\n\t     * @returns void\n\t     */\n\t    onLLMStart(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        const inputs = \"prompts\" in run.inputs\n\t            ? { prompts: run.inputs.prompts.map((p) => p.trim()) }\n\t            : run.inputs;\n\t        console.log(`${wrap(color.green, \"[llm/start]\")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, \"[inputs]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log the end of an LLM run.\n\t     * @param run The LLM run that has ended.\n\t     * @returns void\n\t     */\n\t    onLLMEnd(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, \"[response]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log any errors of an LLM run.\n\t     * @param run The LLM run that has errored.\n\t     * @returns void\n\t     */\n\t    onLLMError(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log the start of a tool run.\n\t     * @param run The tool run that has started.\n\t     * @returns void\n\t     */\n\t    onToolStart(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.green, \"[tool/start]\")} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(run.inputs.input)}\"`);\n\t    }\n\t    /**\n\t     * Method used to log the end of a tool run.\n\t     * @param run The tool run that has ended.\n\t     * @returns void\n\t     */\n\t    onToolEnd(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: \"${formatKVMapItem(run.outputs?.output)}\"`);\n\t    }\n\t    /**\n\t     * Method used to log any errors of a tool run.\n\t     * @param run The tool run that has errored.\n\t     * @returns void\n\t     */\n\t    onToolError(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log the start of a retriever run.\n\t     * @param run The retriever run that has started.\n\t     * @returns void\n\t     */\n\t    onRetrieverStart(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.green, \"[retriever/start]\")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log the end of a retriever run.\n\t     * @param run The retriever run that has ended.\n\t     * @returns void\n\t     */\n\t    onRetrieverEnd(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log any errors of a retriever run.\n\t     * @param run The retriever run that has errored.\n\t     * @returns void\n\t     */\n\t    onRetrieverError(run) {\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n\t    }\n\t    /**\n\t     * Method used to log the action selected by the agent.\n\t     * @param run The run in which the agent action occurred.\n\t     * @returns void\n\t     */\n\t    onAgentAction(run) {\n\t        const agentRun = run;\n\t        const crumbs = this.getBreadcrumbs(run);\n\t        console.log(`${wrap(color.blue, \"[agent/action]\")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], \"[action]\")}`);\n\t    }\n\t}\n\tconsole$1.ConsoleCallbackHandler = ConsoleCallbackHandler;\n\n\tvar tracer_langchain = {};\n\n\tvar run_trees = requireRun_trees();\n\n\tObject.defineProperty(tracer_langchain, \"__esModule\", { value: true });\n\ttracer_langchain.LangChainTracer = void 0;\n\tconst langsmith_1$1 = langsmith;\n\tconst run_trees_1 = run_trees;\n\tconst traceable_1$1 = traceable;\n\tconst env_js_1$2 = env$2;\n\tconst base_js_1$6 = base$1;\n\tclass LangChainTracer extends base_js_1$6.BaseTracer {\n\t    constructor(fields = {}) {\n\t        super(fields);\n\t        Object.defineProperty(this, \"name\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: \"langchain_tracer\"\n\t        });\n\t        Object.defineProperty(this, \"projectName\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"exampleId\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"client\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        const { exampleId, projectName, client } = fields;\n\t        this.projectName =\n\t            projectName ??\n\t                (0, env_js_1$2.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ??\n\t                (0, env_js_1$2.getEnvironmentVariable)(\"LANGCHAIN_SESSION\");\n\t        this.exampleId = exampleId;\n\t        this.client = client ?? new langsmith_1$1.Client({});\n\t        const traceableTree = LangChainTracer.getTraceableRunTree();\n\t        if (traceableTree) {\n\t            this.updateFromRunTree(traceableTree);\n\t        }\n\t    }\n\t    async _convertToCreate(run, example_id = undefined) {\n\t        return {\n\t            ...run,\n\t            extra: {\n\t                ...run.extra,\n\t                runtime: await (0, env_js_1$2.getRuntimeEnvironment)(),\n\t            },\n\t            child_runs: undefined,\n\t            session_name: this.projectName,\n\t            reference_example_id: run.parent_run_id ? undefined : example_id,\n\t        };\n\t    }\n\t    async persistRun(_run) { }\n\t    async onRunCreate(run) {\n\t        const persistedRun = await this._convertToCreate(run, this.exampleId);\n\t        await this.client.createRun(persistedRun);\n\t    }\n\t    async onRunUpdate(run) {\n\t        const runUpdate = {\n\t            end_time: run.end_time,\n\t            error: run.error,\n\t            outputs: run.outputs,\n\t            events: run.events,\n\t            inputs: run.inputs,\n\t            trace_id: run.trace_id,\n\t            dotted_order: run.dotted_order,\n\t            parent_run_id: run.parent_run_id,\n\t        };\n\t        await this.client.updateRun(run.id, runUpdate);\n\t    }\n\t    getRun(id) {\n\t        return this.runMap.get(id);\n\t    }\n\t    updateFromRunTree(runTree) {\n\t        let rootRun = runTree;\n\t        const visited = new Set();\n\t        while (rootRun.parent_run) {\n\t            if (visited.has(rootRun.id))\n\t                break;\n\t            visited.add(rootRun.id);\n\t            if (!rootRun.parent_run)\n\t                break;\n\t            rootRun = rootRun.parent_run;\n\t        }\n\t        visited.clear();\n\t        const queue = [rootRun];\n\t        while (queue.length > 0) {\n\t            const current = queue.shift();\n\t            if (!current || visited.has(current.id))\n\t                continue;\n\t            visited.add(current.id);\n\t            // @ts-expect-error Types of property 'events' are incompatible.\n\t            this.runMap.set(current.id, current);\n\t            if (current.child_runs) {\n\t                queue.push(...current.child_runs);\n\t            }\n\t        }\n\t        this.client = runTree.client ?? this.client;\n\t        this.projectName = runTree.project_name ?? this.projectName;\n\t        this.exampleId = runTree.reference_example_id ?? this.exampleId;\n\t    }\n\t    convertToRunTree(id) {\n\t        const runTreeMap = {};\n\t        const runTreeList = [];\n\t        for (const [id, run] of this.runMap) {\n\t            // by converting the run map to a run tree, we are doing a copy\n\t            // thus, any mutation performed on the run tree will not be reflected\n\t            // back in the run map\n\t            // TODO: Stop using `this.runMap` in favour of LangSmith's `RunTree`\n\t            const runTree = new run_trees_1.RunTree({\n\t                ...run,\n\t                child_runs: [],\n\t                parent_run: undefined,\n\t                // inherited properties\n\t                client: this.client,\n\t                project_name: this.projectName,\n\t                reference_example_id: this.exampleId,\n\t                tracingEnabled: true,\n\t            });\n\t            runTreeMap[id] = runTree;\n\t            runTreeList.push([id, run.dotted_order]);\n\t        }\n\t        runTreeList.sort((a, b) => {\n\t            if (!a[1] || !b[1])\n\t                return 0;\n\t            return a[1].localeCompare(b[1]);\n\t        });\n\t        for (const [id] of runTreeList) {\n\t            const run = this.runMap.get(id);\n\t            const runTree = runTreeMap[id];\n\t            if (!run || !runTree)\n\t                continue;\n\t            if (run.parent_run_id) {\n\t                const parentRunTree = runTreeMap[run.parent_run_id];\n\t                if (parentRunTree) {\n\t                    parentRunTree.child_runs.push(runTree);\n\t                    runTree.parent_run = parentRunTree;\n\t                }\n\t            }\n\t        }\n\t        return runTreeMap[id];\n\t    }\n\t    static getTraceableRunTree() {\n\t        try {\n\t            return (0, traceable_1$1.getCurrentRunTree)();\n\t        }\n\t        catch {\n\t            return undefined;\n\t        }\n\t    }\n\t}\n\ttracer_langchain.LangChainTracer = LangChainTracer;\n\n\tvar promises = {};\n\n\tvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(promises, \"__esModule\", { value: true });\n\tpromises.awaitAllCallbacks = promises.consumeCallback = void 0;\n\tconst p_queue_1$1 = __importDefault$2(dist);\n\tlet queue;\n\t/**\n\t * Creates a queue using the p-queue library. The queue is configured to\n\t * auto-start and has a concurrency of 1, meaning it will process tasks\n\t * one at a time.\n\t */\n\tfunction createQueue() {\n\t    const PQueue = \"default\" in p_queue_1$1.default ? p_queue_1$1.default.default : p_queue_1$1.default;\n\t    return new PQueue({\n\t        autoStart: true,\n\t        concurrency: 1,\n\t    });\n\t}\n\t/**\n\t * Consume a promise, either adding it to the queue or waiting for it to resolve\n\t * @param promiseFn Promise to consume\n\t * @param wait Whether to wait for the promise to resolve or resolve immediately\n\t */\n\tasync function consumeCallback(promiseFn, wait) {\n\t    if (wait === true) {\n\t        await promiseFn();\n\t    }\n\t    else {\n\t        if (typeof queue === \"undefined\") {\n\t            queue = createQueue();\n\t        }\n\t        void queue.add(promiseFn);\n\t    }\n\t}\n\tpromises.consumeCallback = consumeCallback;\n\t/**\n\t * Waits for all promises in the queue to resolve. If the queue is\n\t * undefined, it immediately resolves a promise.\n\t */\n\tfunction awaitAllCallbacks() {\n\t    return typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve();\n\t}\n\tpromises.awaitAllCallbacks = awaitAllCallbacks;\n\n\tvar callbacks = {};\n\n\tObject.defineProperty(callbacks, \"__esModule\", { value: true });\n\tcallbacks.isTracingEnabled = void 0;\n\tconst env_js_1$1 = env$2;\n\tconst isTracingEnabled = (tracingEnabled) => {\n\t    if (tracingEnabled !== undefined) {\n\t        return tracingEnabled;\n\t    }\n\t    const envVars = [\n\t        \"LANGSMITH_TRACING_V2\",\n\t        \"LANGCHAIN_TRACING_V2\",\n\t        \"LANGSMITH_TRACING\",\n\t        \"LANGCHAIN_TRACING\",\n\t    ];\n\t    return !!envVars.find((envVar) => (0, env_js_1$1.getEnvironmentVariable)(envVar) === \"true\");\n\t};\n\tcallbacks.isTracingEnabled = isTracingEnabled;\n\n\tObject.defineProperty(manager, \"__esModule\", {\n\t  value: true\n\t});\n\tmanager.traceAsGroup = manager.TraceGroup = manager.ensureHandler = manager.CallbackManager = manager.CallbackManagerForToolRun = manager.CallbackManagerForChainRun = manager.CallbackManagerForLLMRun = manager.CallbackManagerForRetrieverRun = manager.BaseRunManager = manager.BaseCallbackManager = manager.parseCallbackConfigArg = void 0;\n\tconst uuid_1$2 = require$$2;\n\tconst base_js_1$5 = base;\n\tconst console_js_1 = console$1;\n\tconst utils_js_1$3 = utils$2;\n\tconst env_js_1 = env$2;\n\tconst tracer_langchain_js_1 = tracer_langchain;\n\tconst promises_js_1 = promises;\n\tconst callbacks_js_1 = callbacks;\n\tconst base_js_2 = base$1;\n\tfunction parseCallbackConfigArg(arg) {\n\t  if (!arg) {\n\t    return {};\n\t  } else if (Array.isArray(arg) || (\"name\" in arg)) {\n\t    return {\n\t      callbacks: arg\n\t    };\n\t  } else {\n\t    return arg;\n\t  }\n\t}\n\tmanager.parseCallbackConfigArg = parseCallbackConfigArg;\n\tclass BaseCallbackManager {\n\t  setHandler(handler) {\n\t    return this.setHandlers([handler]);\n\t  }\n\t}\n\tmanager.BaseCallbackManager = BaseCallbackManager;\n\tclass BaseRunManager {\n\t  constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n\t    Object.defineProperty(this, \"runId\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: runId\n\t    });\n\t    Object.defineProperty(this, \"handlers\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: handlers\n\t    });\n\t    Object.defineProperty(this, \"inheritableHandlers\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: inheritableHandlers\n\t    });\n\t    Object.defineProperty(this, \"tags\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: tags\n\t    });\n\t    Object.defineProperty(this, \"inheritableTags\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: inheritableTags\n\t    });\n\t    Object.defineProperty(this, \"metadata\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: metadata\n\t    });\n\t    Object.defineProperty(this, \"inheritableMetadata\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: inheritableMetadata\n\t    });\n\t    Object.defineProperty(this, \"_parentRunId\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: _parentRunId\n\t    });\n\t  }\n\t  get parentRunId() {\n\t    return this._parentRunId;\n\t  }\n\t  async handleText(text) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      try {\n\t        await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n\t      } catch (err) {\n\t        const logFunction = handler.raiseError ? console.error : console.warn;\n\t        logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n\t        if (handler.raiseError) {\n\t          throw err;\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      try {\n\t        await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n\t      } catch (err) {\n\t        const logFunction = handler.raiseError ? console.error : console.warn;\n\t        logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n\t        if (handler.raiseError) {\n\t          throw err;\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t}\n\tmanager.BaseRunManager = BaseRunManager;\n\tclass CallbackManagerForRetrieverRun extends BaseRunManager {\n\t  getChild(tag) {\n\t    const manager = new CallbackManager(this.runId);\n\t    manager.setHandlers(this.inheritableHandlers);\n\t    manager.addTags(this.inheritableTags);\n\t    manager.addMetadata(this.inheritableMetadata);\n\t    if (tag) {\n\t      manager.addTags([tag], false);\n\t    }\n\t    return manager;\n\t  }\n\t  async handleRetrieverEnd(documents) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreRetriever) {\n\t        try {\n\t          await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleRetrieverError(err) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreRetriever) {\n\t        try {\n\t          await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n\t        } catch (error) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t}\n\tmanager.CallbackManagerForRetrieverRun = CallbackManagerForRetrieverRun;\n\tclass CallbackManagerForLLMRun extends BaseRunManager {\n\t  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreLLM) {\n\t        try {\n\t          await handler.handleLLMNewToken?.(token, idx ?? ({\n\t            prompt: 0,\n\t            completion: 0\n\t          }), this.runId, this._parentRunId, this.tags, fields);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleLLMError(err) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreLLM) {\n\t        try {\n\t          await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleLLMEnd(output) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreLLM) {\n\t        try {\n\t          await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t}\n\tmanager.CallbackManagerForLLMRun = CallbackManagerForLLMRun;\n\tclass CallbackManagerForChainRun extends BaseRunManager {\n\t  getChild(tag) {\n\t    const manager = new CallbackManager(this.runId);\n\t    manager.setHandlers(this.inheritableHandlers);\n\t    manager.addTags(this.inheritableTags);\n\t    manager.addMetadata(this.inheritableMetadata);\n\t    if (tag) {\n\t      manager.addTags([tag], false);\n\t    }\n\t    return manager;\n\t  }\n\t  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreChain) {\n\t        try {\n\t          await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreChain) {\n\t        try {\n\t          await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleAgentAction(action) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreAgent) {\n\t        try {\n\t          await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleAgentEnd(action) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreAgent) {\n\t        try {\n\t          await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t}\n\tmanager.CallbackManagerForChainRun = CallbackManagerForChainRun;\n\tclass CallbackManagerForToolRun extends BaseRunManager {\n\t  getChild(tag) {\n\t    const manager = new CallbackManager(this.runId);\n\t    manager.setHandlers(this.inheritableHandlers);\n\t    manager.addTags(this.inheritableTags);\n\t    manager.addMetadata(this.inheritableMetadata);\n\t    if (tag) {\n\t      manager.addTags([tag], false);\n\t    }\n\t    return manager;\n\t  }\n\t  async handleToolError(err) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreAgent) {\n\t        try {\n\t          await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  async handleToolEnd(output) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreAgent) {\n\t        try {\n\t          await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t}\n\tmanager.CallbackManagerForToolRun = CallbackManagerForToolRun;\n\tclass CallbackManager extends BaseCallbackManager {\n\t  constructor(parentRunId, options) {\n\t    super();\n\t    Object.defineProperty(this, \"handlers\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: []\n\t    });\n\t    Object.defineProperty(this, \"inheritableHandlers\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: []\n\t    });\n\t    Object.defineProperty(this, \"tags\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: []\n\t    });\n\t    Object.defineProperty(this, \"inheritableTags\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: []\n\t    });\n\t    Object.defineProperty(this, \"metadata\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: {}\n\t    });\n\t    Object.defineProperty(this, \"inheritableMetadata\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: {}\n\t    });\n\t    Object.defineProperty(this, \"name\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: \"callback_manager\"\n\t    });\n\t    Object.defineProperty(this, \"_parentRunId\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.handlers = options?.handlers ?? this.handlers;\n\t    this.inheritableHandlers = options?.inheritableHandlers ?? this.inheritableHandlers;\n\t    this.tags = options?.tags ?? this.tags;\n\t    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n\t    this.metadata = options?.metadata ?? this.metadata;\n\t    this.inheritableMetadata = options?.inheritableMetadata ?? this.inheritableMetadata;\n\t    this._parentRunId = parentRunId;\n\t  }\n\t  getParentRunId() {\n\t    return this._parentRunId;\n\t  }\n\t  async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n\t    return Promise.all(prompts.map(async (prompt, idx) => {\n\t      const runId_ = idx === 0 && runId ? runId : (0, uuid_1$2.v4)();\n\t      await Promise.all(this.handlers.map(handler => {\n\t        if (handler.ignoreLLM) {\n\t          return;\n\t        }\n\t        if ((0, base_js_2.isBaseTracer)(handler)) {\n\t          handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n\t        }\n\t        return (0, promises_js_1.consumeCallback)(async () => {\n\t          try {\n\t            await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n\t          } catch (err) {\n\t            const logFunction = handler.raiseError ? console.error : console.warn;\n\t            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n\t            if (handler.raiseError) {\n\t              throw err;\n\t            }\n\t          }\n\t        }, handler.awaitHandlers);\n\t      }));\n\t      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n\t    }));\n\t  }\n\t  async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n\t    return Promise.all(messages.map(async (messageGroup, idx) => {\n\t      const runId_ = idx === 0 && runId ? runId : (0, uuid_1$2.v4)();\n\t      await Promise.all(this.handlers.map(handler => {\n\t        if (handler.ignoreLLM) {\n\t          return;\n\t        }\n\t        if ((0, base_js_2.isBaseTracer)(handler)) {\n\t          handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n\t        }\n\t        return (0, promises_js_1.consumeCallback)(async () => {\n\t          try {\n\t            if (handler.handleChatModelStart) {\n\t              await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n\t            } else if (handler.handleLLMStart) {\n\t              const messageString = (0, utils_js_1$3.getBufferString)(messageGroup);\n\t              await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n\t            }\n\t          } catch (err) {\n\t            const logFunction = handler.raiseError ? console.error : console.warn;\n\t            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n\t            if (handler.raiseError) {\n\t              throw err;\n\t            }\n\t          }\n\t        }, handler.awaitHandlers);\n\t      }));\n\t      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n\t    }));\n\t  }\n\t  async handleChainStart(chain, inputs, runId = (0, uuid_1$2.v4)(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n\t    await Promise.all(this.handlers.map(handler => {\n\t      if (handler.ignoreChain) {\n\t        return;\n\t      }\n\t      if ((0, base_js_2.isBaseTracer)(handler)) {\n\t        handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n\t      }\n\t      return (0, promises_js_1.consumeCallback)(async () => {\n\t        try {\n\t          await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }, handler.awaitHandlers);\n\t    }));\n\t    return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n\t  }\n\t  async handleToolStart(tool, input, runId = (0, uuid_1$2.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n\t    await Promise.all(this.handlers.map(handler => {\n\t      if (handler.ignoreAgent) {\n\t        return;\n\t      }\n\t      if ((0, base_js_2.isBaseTracer)(handler)) {\n\t        handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n\t      }\n\t      return (0, promises_js_1.consumeCallback)(async () => {\n\t        try {\n\t          await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }, handler.awaitHandlers);\n\t    }));\n\t    return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n\t  }\n\t  async handleRetrieverStart(retriever, query, runId = (0, uuid_1$2.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n\t    await Promise.all(this.handlers.map(handler => {\n\t      if (handler.ignoreRetriever) {\n\t        return;\n\t      }\n\t      if ((0, base_js_2.isBaseTracer)(handler)) {\n\t        handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n\t      }\n\t      return (0, promises_js_1.consumeCallback)(async () => {\n\t        try {\n\t          await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }, handler.awaitHandlers);\n\t    }));\n\t    return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n\t  }\n\t  async handleCustomEvent(eventName, data, runId, _tags, _metadata) {\n\t    await Promise.all(this.handlers.map(handler => (0, promises_js_1.consumeCallback)(async () => {\n\t      if (!handler.ignoreCustomEvent) {\n\t        try {\n\t          await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n\t        } catch (err) {\n\t          const logFunction = handler.raiseError ? console.error : console.warn;\n\t          logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n\t          if (handler.raiseError) {\n\t            throw err;\n\t          }\n\t        }\n\t      }\n\t    }, handler.awaitHandlers)));\n\t  }\n\t  addHandler(handler, inherit = true) {\n\t    this.handlers.push(handler);\n\t    if (inherit) {\n\t      this.inheritableHandlers.push(handler);\n\t    }\n\t  }\n\t  removeHandler(handler) {\n\t    this.handlers = this.handlers.filter(_handler => _handler !== handler);\n\t    this.inheritableHandlers = this.inheritableHandlers.filter(_handler => _handler !== handler);\n\t  }\n\t  setHandlers(handlers, inherit = true) {\n\t    this.handlers = [];\n\t    this.inheritableHandlers = [];\n\t    for (const handler of handlers) {\n\t      this.addHandler(handler, inherit);\n\t    }\n\t  }\n\t  addTags(tags, inherit = true) {\n\t    this.removeTags(tags);\n\t    this.tags.push(...tags);\n\t    if (inherit) {\n\t      this.inheritableTags.push(...tags);\n\t    }\n\t  }\n\t  removeTags(tags) {\n\t    this.tags = this.tags.filter(tag => !tags.includes(tag));\n\t    this.inheritableTags = this.inheritableTags.filter(tag => !tags.includes(tag));\n\t  }\n\t  addMetadata(metadata, inherit = true) {\n\t    this.metadata = {\n\t      ...this.metadata,\n\t      ...metadata\n\t    };\n\t    if (inherit) {\n\t      this.inheritableMetadata = {\n\t        ...this.inheritableMetadata,\n\t        ...metadata\n\t      };\n\t    }\n\t  }\n\t  removeMetadata(metadata) {\n\t    for (const key of Object.keys(metadata)) {\n\t      delete this.metadata[key];\n\t      delete this.inheritableMetadata[key];\n\t    }\n\t  }\n\t  copy(additionalHandlers = [], inherit = true) {\n\t    const manager = new CallbackManager(this._parentRunId);\n\t    for (const handler of this.handlers) {\n\t      const inheritable = this.inheritableHandlers.includes(handler);\n\t      manager.addHandler(handler, inheritable);\n\t    }\n\t    for (const tag of this.tags) {\n\t      const inheritable = this.inheritableTags.includes(tag);\n\t      manager.addTags([tag], inheritable);\n\t    }\n\t    for (const key of Object.keys(this.metadata)) {\n\t      const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n\t      manager.addMetadata({\n\t        [key]: this.metadata[key]\n\t      }, inheritable);\n\t    }\n\t    for (const handler of additionalHandlers) {\n\t      if (manager.handlers.filter(h => h.name === \"console_callback_handler\").some(h => h.name === handler.name)) {\n\t        continue;\n\t      }\n\t      manager.addHandler(handler, inherit);\n\t    }\n\t    return manager;\n\t  }\n\t  static fromHandlers(handlers) {\n\t    class Handler extends base_js_1$5.BaseCallbackHandler {\n\t      constructor() {\n\t        super();\n\t        Object.defineProperty(this, \"name\", {\n\t          enumerable: true,\n\t          configurable: true,\n\t          writable: true,\n\t          value: (0, uuid_1$2.v4)()\n\t        });\n\t        Object.assign(this, handlers);\n\t      }\n\t    }\n\t    const manager = new this();\n\t    manager.addHandler(new Handler());\n\t    return manager;\n\t  }\n\t  static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n\t    return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n\t  }\n\t  static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n\t    let callbackManager;\n\t    if (inheritableHandlers || localHandlers) {\n\t      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n\t        callbackManager = new CallbackManager();\n\t        callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n\t      } else {\n\t        callbackManager = inheritableHandlers;\n\t      }\n\t      callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers?.handlers, false);\n\t    }\n\t    const verboseEnabled = (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_VERBOSE\") === \"true\" || options?.verbose;\n\t    const tracingV2Enabled = tracer_langchain_js_1.LangChainTracer.getTraceableRunTree()?.tracingEnabled || (0, callbacks_js_1.isTracingEnabled)();\n\t    const tracingEnabled = tracingV2Enabled || ((0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_TRACING\") ?? false);\n\t    if (verboseEnabled || tracingEnabled) {\n\t      if (!callbackManager) {\n\t        callbackManager = new CallbackManager();\n\t      }\n\t      if (verboseEnabled && !callbackManager.handlers.some(handler => handler.name === console_js_1.ConsoleCallbackHandler.prototype.name)) {\n\t        const consoleHandler = new console_js_1.ConsoleCallbackHandler();\n\t        callbackManager.addHandler(consoleHandler, true);\n\t      }\n\t      if (tracingEnabled && !callbackManager.handlers.some(handler => handler.name === \"langchain_tracer\")) {\n\t        if (tracingV2Enabled) {\n\t          const tracerV2 = new tracer_langchain_js_1.LangChainTracer();\n\t          callbackManager.addHandler(tracerV2, true);\n\t          callbackManager._parentRunId = tracer_langchain_js_1.LangChainTracer.getTraceableRunTree()?.id ?? callbackManager._parentRunId;\n\t        }\n\t      }\n\t    }\n\t    if (inheritableTags || localTags) {\n\t      if (callbackManager) {\n\t        callbackManager.addTags(inheritableTags ?? []);\n\t        callbackManager.addTags(localTags ?? [], false);\n\t      }\n\t    }\n\t    if (inheritableMetadata || localMetadata) {\n\t      if (callbackManager) {\n\t        callbackManager.addMetadata(inheritableMetadata ?? ({}));\n\t        callbackManager.addMetadata(localMetadata ?? ({}), false);\n\t      }\n\t    }\n\t    return callbackManager;\n\t  }\n\t}\n\tmanager.CallbackManager = CallbackManager;\n\tfunction ensureHandler(handler) {\n\t  if ((\"name\" in handler)) {\n\t    return handler;\n\t  }\n\t  return base_js_1$5.BaseCallbackHandler.fromMethods(handler);\n\t}\n\tmanager.ensureHandler = ensureHandler;\n\tclass TraceGroup {\n\t  constructor(groupName, options) {\n\t    Object.defineProperty(this, \"groupName\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: groupName\n\t    });\n\t    Object.defineProperty(this, \"options\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: options\n\t    });\n\t    Object.defineProperty(this, \"runManager\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t  }\n\t  async getTraceGroupCallbackManager(group_name, inputs, options) {\n\t    const cb = new tracer_langchain_js_1.LangChainTracer(options);\n\t    const cm = await CallbackManager.configure([cb]);\n\t    const runManager = await cm?.handleChainStart({\n\t      lc: 1,\n\t      type: \"not_implemented\",\n\t      id: [\"langchain\", \"callbacks\", \"groups\", group_name]\n\t    }, inputs ?? ({}));\n\t    if (!runManager) {\n\t      throw new Error(\"Failed to create run group callback manager.\");\n\t    }\n\t    return runManager;\n\t  }\n\t  async start(inputs) {\n\t    if (!this.runManager) {\n\t      this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n\t    }\n\t    return this.runManager.getChild();\n\t  }\n\t  async error(err) {\n\t    if (this.runManager) {\n\t      await this.runManager.handleChainError(err);\n\t      this.runManager = undefined;\n\t    }\n\t  }\n\t  async end(output) {\n\t    if (this.runManager) {\n\t      await this.runManager.handleChainEnd(output ?? ({}));\n\t      this.runManager = undefined;\n\t    }\n\t  }\n\t}\n\tmanager.TraceGroup = TraceGroup;\n\tfunction _coerceToDict$1(value, defaultKey) {\n\t  return value && !Array.isArray(value) && typeof value === \"object\" ? value : {\n\t    [defaultKey]: value\n\t  };\n\t}\n\tasync function traceAsGroup(groupOptions, enclosedCode, ...args) {\n\t  const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n\t  const callbackManager = await traceGroup.start({\n\t    ...args\n\t  });\n\t  try {\n\t    const result = await enclosedCode(callbackManager, ...args);\n\t    await traceGroup.end(_coerceToDict$1(result, \"output\"));\n\t    return result;\n\t  } catch (err) {\n\t    await traceGroup.error(err);\n\t    throw err;\n\t  }\n\t}\n\tmanager.traceAsGroup = traceAsGroup;\n\n\tObject.defineProperty(singletons, \"__esModule\", { value: true });\n\tsingletons.AsyncLocalStorageProviderSingleton = singletons.MockAsyncLocalStorage = void 0;\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\tconst langsmith_1 = langsmith;\n\tconst manager_js_1$1 = manager;\n\tclass MockAsyncLocalStorage {\n\t    getStore() {\n\t        return undefined;\n\t    }\n\t    run(_store, callback) {\n\t        return callback();\n\t    }\n\t}\n\tsingletons.MockAsyncLocalStorage = MockAsyncLocalStorage;\n\tconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\n\tconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\n\tconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\n\tclass AsyncLocalStorageProvider {\n\t    getInstance() {\n\t        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n\t    }\n\t    getRunnableConfig() {\n\t        const storage = this.getInstance();\n\t        // this has the runnable config\n\t        // which means that we should also have an instance of a LangChainTracer\n\t        // with the run map prepopulated\n\t        return storage.getStore()?.extra?.[LC_CHILD_KEY];\n\t    }\n\t    runWithConfig(config, callback, avoidCreatingRootRunTree) {\n\t        const callbackManager = manager_js_1$1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n\t        const storage = this.getInstance();\n\t        const parentRunId = callbackManager?.getParentRunId();\n\t        const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === \"langchain_tracer\");\n\t        let runTree;\n\t        if (langChainTracer && parentRunId) {\n\t            runTree = langChainTracer.convertToRunTree(parentRunId);\n\t        }\n\t        else if (!avoidCreatingRootRunTree) {\n\t            runTree = new langsmith_1.RunTree({\n\t                name: \"<runnable_lambda>\",\n\t                tracingEnabled: false,\n\t            });\n\t        }\n\t        if (runTree) {\n\t            runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n\t        }\n\t        return storage.run(runTree, callback);\n\t    }\n\t    initializeGlobalInstance(instance) {\n\t        if (globalThis[TRACING_ALS_KEY] === undefined) {\n\t            globalThis[TRACING_ALS_KEY] = instance;\n\t        }\n\t    }\n\t}\n\tconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\tsingletons.AsyncLocalStorageProviderSingleton = AsyncLocalStorageProviderSingleton;\n\n\tvar signal = {};\n\n\tObject.defineProperty(signal, \"__esModule\", { value: true });\n\tsignal.raceWithSignal = void 0;\n\tasync function raceWithSignal(promise, signal) {\n\t    if (signal === undefined) {\n\t        return promise;\n\t    }\n\t    let listener;\n\t    return Promise.race([\n\t        promise.catch((err) => {\n\t            if (!signal?.aborted) {\n\t                throw err;\n\t            }\n\t            else {\n\t                return undefined;\n\t            }\n\t        }),\n\t        new Promise((_, reject) => {\n\t            listener = () => {\n\t                reject(new Error(\"Aborted\"));\n\t            };\n\t            signal.addEventListener(\"abort\", listener);\n\t            // Must be here inside the promise to avoid a race condition\n\t            if (signal.aborted) {\n\t                reject(new Error(\"Aborted\"));\n\t            }\n\t        }),\n\t    ]).finally(() => signal.removeEventListener(\"abort\", listener));\n\t}\n\tsignal.raceWithSignal = raceWithSignal;\n\n\tObject.defineProperty(stream, \"__esModule\", { value: true });\n\tstream.pipeGeneratorWithSetup = stream.AsyncGeneratorWithSetup = stream.concat = stream.atee = stream.IterableReadableStream = void 0;\n\tconst index_js_1$4 = singletons;\n\tconst signal_js_1$1 = signal;\n\t/*\n\t * Support async iterator syntax for ReadableStreams in all environments.\n\t * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n\t */\n\tclass IterableReadableStream extends ReadableStream {\n\t    constructor() {\n\t        super(...arguments);\n\t        Object.defineProperty(this, \"reader\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t    }\n\t    ensureReader() {\n\t        if (!this.reader) {\n\t            this.reader = this.getReader();\n\t        }\n\t    }\n\t    async next() {\n\t        this.ensureReader();\n\t        try {\n\t            const result = await this.reader.read();\n\t            if (result.done) {\n\t                this.reader.releaseLock(); // release lock when stream becomes closed\n\t                return {\n\t                    done: true,\n\t                    value: undefined,\n\t                };\n\t            }\n\t            else {\n\t                return {\n\t                    done: false,\n\t                    value: result.value,\n\t                };\n\t            }\n\t        }\n\t        catch (e) {\n\t            this.reader.releaseLock(); // release lock when stream becomes errored\n\t            throw e;\n\t        }\n\t    }\n\t    async return() {\n\t        this.ensureReader();\n\t        // If wrapped in a Node stream, cancel is already called.\n\t        if (this.locked) {\n\t            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n\t            this.reader.releaseLock(); // release lock first\n\t            await cancelPromise; // now await it\n\t        }\n\t        return { done: true, value: undefined };\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    async throw(e) {\n\t        this.ensureReader();\n\t        if (this.locked) {\n\t            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n\t            this.reader.releaseLock(); // release lock first\n\t            await cancelPromise; // now await it\n\t        }\n\t        throw e;\n\t    }\n\t    [Symbol.asyncIterator]() {\n\t        return this;\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n\t    async [Symbol.asyncDispose]() {\n\t        await this.return();\n\t    }\n\t    static fromReadableStream(stream) {\n\t        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n\t        const reader = stream.getReader();\n\t        return new IterableReadableStream({\n\t            start(controller) {\n\t                return pump();\n\t                function pump() {\n\t                    return reader.read().then(({ done, value }) => {\n\t                        // When no more data needs to be consumed, close the stream\n\t                        if (done) {\n\t                            controller.close();\n\t                            return;\n\t                        }\n\t                        // Enqueue the next data chunk into our target stream\n\t                        controller.enqueue(value);\n\t                        return pump();\n\t                    });\n\t                }\n\t            },\n\t            cancel() {\n\t                reader.releaseLock();\n\t            },\n\t        });\n\t    }\n\t    static fromAsyncGenerator(generator) {\n\t        return new IterableReadableStream({\n\t            async pull(controller) {\n\t                const { value, done } = await generator.next();\n\t                // When no more data needs to be consumed, close the stream\n\t                if (done) {\n\t                    controller.close();\n\t                }\n\t                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n\t                controller.enqueue(value);\n\t            },\n\t            async cancel(reason) {\n\t                await generator.return(reason);\n\t            },\n\t        });\n\t    }\n\t}\n\tstream.IterableReadableStream = IterableReadableStream;\n\tfunction atee(iter, length = 2) {\n\t    const buffers = Array.from({ length }, () => []);\n\t    return buffers.map(async function* makeIter(buffer) {\n\t        while (true) {\n\t            if (buffer.length === 0) {\n\t                const result = await iter.next();\n\t                for (const buffer of buffers) {\n\t                    buffer.push(result);\n\t                }\n\t            }\n\t            else if (buffer[0].done) {\n\t                return;\n\t            }\n\t            else {\n\t                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t                yield buffer.shift().value;\n\t            }\n\t        }\n\t    });\n\t}\n\tstream.atee = atee;\n\tfunction concat(first, second) {\n\t    if (Array.isArray(first) && Array.isArray(second)) {\n\t        return first.concat(second);\n\t    }\n\t    else if (typeof first === \"string\" && typeof second === \"string\") {\n\t        return (first + second);\n\t    }\n\t    else if (typeof first === \"number\" && typeof second === \"number\") {\n\t        return (first + second);\n\t    }\n\t    else if (\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    \"concat\" in first &&\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        typeof first.concat === \"function\") {\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        return first.concat(second);\n\t    }\n\t    else if (typeof first === \"object\" && typeof second === \"object\") {\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        const chunk = { ...first };\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        for (const [key, value] of Object.entries(second)) {\n\t            if (key in chunk && !Array.isArray(chunk[key])) {\n\t                chunk[key] = concat(chunk[key], value);\n\t            }\n\t            else {\n\t                chunk[key] = value;\n\t            }\n\t        }\n\t        return chunk;\n\t    }\n\t    else {\n\t        throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n\t    }\n\t}\n\tstream.concat = concat;\n\tclass AsyncGeneratorWithSetup {\n\t    constructor(params) {\n\t        Object.defineProperty(this, \"generator\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"setup\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"config\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"signal\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"firstResult\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"firstResultUsed\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: false\n\t        });\n\t        this.generator = params.generator;\n\t        this.config = params.config;\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        this.signal = params.signal ?? this.config?.signal;\n\t        // setup is a promise that resolves only after the first iterator value\n\t        // is available. this is useful when setup of several piped generators\n\t        // needs to happen in logical order, ie. in the order in which input to\n\t        // to each generator is available.\n\t        this.setup = new Promise((resolve, reject) => {\n\t            void index_js_1$4.AsyncLocalStorageProviderSingleton.runWithConfig(params.config, async () => {\n\t                this.firstResult = params.generator.next();\n\t                if (params.startSetup) {\n\t                    this.firstResult.then(params.startSetup).then(resolve, reject);\n\t                }\n\t                else {\n\t                    this.firstResult.then((_result) => resolve(undefined), reject);\n\t                }\n\t            }, true);\n\t        });\n\t    }\n\t    async next(...args) {\n\t        this.signal?.throwIfAborted();\n\t        if (!this.firstResultUsed) {\n\t            this.firstResultUsed = true;\n\t            return this.firstResult;\n\t        }\n\t        return index_js_1$4.AsyncLocalStorageProviderSingleton.runWithConfig(this.config, this.signal\n\t            ? async () => {\n\t                return (0, signal_js_1$1.raceWithSignal)(this.generator.next(...args), this.signal);\n\t            }\n\t            : async () => {\n\t                return this.generator.next(...args);\n\t            }, true);\n\t    }\n\t    async return(value) {\n\t        return this.generator.return(value);\n\t    }\n\t    async throw(e) {\n\t        return this.generator.throw(e);\n\t    }\n\t    [Symbol.asyncIterator]() {\n\t        return this;\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n\t    async [Symbol.asyncDispose]() {\n\t        await this.return();\n\t    }\n\t}\n\tstream.AsyncGeneratorWithSetup = AsyncGeneratorWithSetup;\n\tasync function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {\n\t    const gen = new AsyncGeneratorWithSetup({\n\t        generator,\n\t        startSetup,\n\t        signal,\n\t    });\n\t    const setup = await gen.setup;\n\t    return { output: to(gen, setup, ...args), setup };\n\t}\n\tstream.pipeGeneratorWithSetup = pipeGeneratorWithSetup;\n\n\tObject.defineProperty(log_stream, \"__esModule\", {\n\t  value: true\n\t});\n\tlog_stream.LogStreamCallbackHandler = log_stream.isLogStreamHandler = log_stream.RunLog = log_stream.RunLogPatch = void 0;\n\tconst index_js_1$3 = fastJsonPatch;\n\tconst base_js_1$4 = base$1;\n\tconst stream_js_1$3 = stream;\n\tconst ai_js_1$2 = ai;\n\tclass RunLogPatch {\n\t  constructor(fields) {\n\t    Object.defineProperty(this, \"ops\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.ops = fields.ops ?? [];\n\t  }\n\t  concat(other) {\n\t    const ops = this.ops.concat(other.ops);\n\t    const states = (0, index_js_1$3.applyPatch)({}, ops);\n\t    return new RunLog({\n\t      ops,\n\t      state: states[states.length - 1].newDocument\n\t    });\n\t  }\n\t}\n\tlog_stream.RunLogPatch = RunLogPatch;\n\tclass RunLog extends RunLogPatch {\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"state\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.state = fields.state;\n\t  }\n\t  concat(other) {\n\t    const ops = this.ops.concat(other.ops);\n\t    const states = (0, index_js_1$3.applyPatch)(this.state, other.ops);\n\t    return new RunLog({\n\t      ops,\n\t      state: states[states.length - 1].newDocument\n\t    });\n\t  }\n\t  static fromRunLogPatch(patch) {\n\t    const states = (0, index_js_1$3.applyPatch)({}, patch.ops);\n\t    return new RunLog({\n\t      ops: patch.ops,\n\t      state: states[states.length - 1].newDocument\n\t    });\n\t  }\n\t}\n\tlog_stream.RunLog = RunLog;\n\tconst isLogStreamHandler = handler => handler.name === \"log_stream_tracer\";\n\tlog_stream.isLogStreamHandler = isLogStreamHandler;\n\tasync function _getStandardizedInputs(run, schemaFormat) {\n\t  if (schemaFormat === \"original\") {\n\t    throw new Error(\"Do not assign inputs with original schema drop the key for now. \" + \"When inputs are added to streamLog they should be added with \" + \"standardized schema for streaming events.\");\n\t  }\n\t  const {inputs} = run;\n\t  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n\t    return inputs;\n\t  }\n\t  if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n\t    return undefined;\n\t  }\n\t  return inputs.input;\n\t}\n\tasync function _getStandardizedOutputs(run, schemaFormat) {\n\t  const {outputs} = run;\n\t  if (schemaFormat === \"original\") {\n\t    return outputs;\n\t  }\n\t  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n\t    return outputs;\n\t  }\n\t  if (outputs !== undefined && Object.keys(outputs).length === 1 && outputs?.output !== undefined) {\n\t    return outputs.output;\n\t  }\n\t  return outputs;\n\t}\n\tfunction isChatGenerationChunk(x) {\n\t  return x !== undefined && x.message !== undefined;\n\t}\n\tclass LogStreamCallbackHandler extends base_js_1$4.BaseTracer {\n\t  constructor(fields) {\n\t    super({\n\t      _awaitHandler: true,\n\t      ...fields\n\t    });\n\t    Object.defineProperty(this, \"autoClose\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"includeNames\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"includeTypes\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"includeTags\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"excludeNames\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"excludeTypes\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"excludeTags\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"_schemaFormat\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: \"original\"\n\t    });\n\t    Object.defineProperty(this, \"rootId\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"keyMapByRunId\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: {}\n\t    });\n\t    Object.defineProperty(this, \"counterMapByRunName\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: {}\n\t    });\n\t    Object.defineProperty(this, \"transformStream\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"writer\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"receiveStream\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"name\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: \"log_stream_tracer\"\n\t    });\n\t    this.autoClose = fields?.autoClose ?? true;\n\t    this.includeNames = fields?.includeNames;\n\t    this.includeTypes = fields?.includeTypes;\n\t    this.includeTags = fields?.includeTags;\n\t    this.excludeNames = fields?.excludeNames;\n\t    this.excludeTypes = fields?.excludeTypes;\n\t    this.excludeTags = fields?.excludeTags;\n\t    this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n\t    this.transformStream = new TransformStream();\n\t    this.writer = this.transformStream.writable.getWriter();\n\t    this.receiveStream = stream_js_1$3.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n\t  }\n\t  [Symbol.asyncIterator]() {\n\t    return this.receiveStream;\n\t  }\n\t  async persistRun(_run) {}\n\t  _includeRun(run) {\n\t    if (run.id === this.rootId) {\n\t      return false;\n\t    }\n\t    const runTags = run.tags ?? [];\n\t    let include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;\n\t    if (this.includeNames !== undefined) {\n\t      include = include || this.includeNames.includes(run.name);\n\t    }\n\t    if (this.includeTypes !== undefined) {\n\t      include = include || this.includeTypes.includes(run.run_type);\n\t    }\n\t    if (this.includeTags !== undefined) {\n\t      include = include || runTags.find(tag => this.includeTags?.includes(tag)) !== undefined;\n\t    }\n\t    if (this.excludeNames !== undefined) {\n\t      include = include && !this.excludeNames.includes(run.name);\n\t    }\n\t    if (this.excludeTypes !== undefined) {\n\t      include = include && !this.excludeTypes.includes(run.run_type);\n\t    }\n\t    if (this.excludeTags !== undefined) {\n\t      include = include && runTags.every(tag => !this.excludeTags?.includes(tag));\n\t    }\n\t    return include;\n\t  }\n\t  async *tapOutputIterable(runId, output) {\n\t    for await (const chunk of output) {\n\t      if (runId !== this.rootId) {\n\t        const key = this.keyMapByRunId[runId];\n\t        if (key) {\n\t          await this.writer.write(new RunLogPatch({\n\t            ops: [{\n\t              op: \"add\",\n\t              path: `/logs/${key}/streamed_output/-`,\n\t              value: chunk\n\t            }]\n\t          }));\n\t        }\n\t      }\n\t      yield chunk;\n\t    }\n\t  }\n\t  async onRunCreate(run) {\n\t    if (this.rootId === undefined) {\n\t      this.rootId = run.id;\n\t      await this.writer.write(new RunLogPatch({\n\t        ops: [{\n\t          op: \"replace\",\n\t          path: \"\",\n\t          value: {\n\t            id: run.id,\n\t            name: run.name,\n\t            type: run.run_type,\n\t            streamed_output: [],\n\t            final_output: undefined,\n\t            logs: {}\n\t          }\n\t        }]\n\t      }));\n\t    }\n\t    if (!this._includeRun(run)) {\n\t      return;\n\t    }\n\t    if (this.counterMapByRunName[run.name] === undefined) {\n\t      this.counterMapByRunName[run.name] = 0;\n\t    }\n\t    this.counterMapByRunName[run.name] += 1;\n\t    const count = this.counterMapByRunName[run.name];\n\t    this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;\n\t    const logEntry = {\n\t      id: run.id,\n\t      name: run.name,\n\t      type: run.run_type,\n\t      tags: run.tags ?? [],\n\t      metadata: run.extra?.metadata ?? ({}),\n\t      start_time: new Date(run.start_time).toISOString(),\n\t      streamed_output: [],\n\t      streamed_output_str: [],\n\t      final_output: undefined,\n\t      end_time: undefined\n\t    };\n\t    if (this._schemaFormat === \"streaming_events\") {\n\t      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n\t    }\n\t    await this.writer.write(new RunLogPatch({\n\t      ops: [{\n\t        op: \"add\",\n\t        path: `/logs/${this.keyMapByRunId[run.id]}`,\n\t        value: logEntry\n\t      }]\n\t    }));\n\t  }\n\t  async onRunUpdate(run) {\n\t    try {\n\t      const runName = this.keyMapByRunId[run.id];\n\t      if (runName === undefined) {\n\t        return;\n\t      }\n\t      const ops = [];\n\t      if (this._schemaFormat === \"streaming_events\") {\n\t        ops.push({\n\t          op: \"replace\",\n\t          path: `/logs/${runName}/inputs`,\n\t          value: await _getStandardizedInputs(run, this._schemaFormat)\n\t        });\n\t      }\n\t      ops.push({\n\t        op: \"add\",\n\t        path: `/logs/${runName}/final_output`,\n\t        value: await _getStandardizedOutputs(run, this._schemaFormat)\n\t      });\n\t      if (run.end_time !== undefined) {\n\t        ops.push({\n\t          op: \"add\",\n\t          path: `/logs/${runName}/end_time`,\n\t          value: new Date(run.end_time).toISOString()\n\t        });\n\t      }\n\t      const patch = new RunLogPatch({\n\t        ops\n\t      });\n\t      await this.writer.write(patch);\n\t    } finally {\n\t      if (run.id === this.rootId) {\n\t        const patch = new RunLogPatch({\n\t          ops: [{\n\t            op: \"replace\",\n\t            path: \"/final_output\",\n\t            value: await _getStandardizedOutputs(run, this._schemaFormat)\n\t          }]\n\t        });\n\t        await this.writer.write(patch);\n\t        if (this.autoClose) {\n\t          await this.writer.close();\n\t        }\n\t      }\n\t    }\n\t  }\n\t  async onLLMNewToken(run, token, kwargs) {\n\t    const runName = this.keyMapByRunId[run.id];\n\t    if (runName === undefined) {\n\t      return;\n\t    }\n\t    const isChatModel = run.inputs.messages !== undefined;\n\t    let streamedOutputValue;\n\t    if (isChatModel) {\n\t      if (isChatGenerationChunk(kwargs?.chunk)) {\n\t        streamedOutputValue = kwargs?.chunk;\n\t      } else {\n\t        streamedOutputValue = new ai_js_1$2.AIMessageChunk({\n\t          id: `run-${run.id}`,\n\t          content: token\n\t        });\n\t      }\n\t    } else {\n\t      streamedOutputValue = token;\n\t    }\n\t    const patch = new RunLogPatch({\n\t      ops: [{\n\t        op: \"add\",\n\t        path: `/logs/${runName}/streamed_output_str/-`,\n\t        value: token\n\t      }, {\n\t        op: \"add\",\n\t        path: `/logs/${runName}/streamed_output/-`,\n\t        value: streamedOutputValue\n\t      }]\n\t    });\n\t    await this.writer.write(patch);\n\t  }\n\t}\n\tlog_stream.LogStreamCallbackHandler = LogStreamCallbackHandler;\n\n\tvar event_stream = {};\n\n\tvar outputs = {};\n\n\tObject.defineProperty(outputs, \"__esModule\", { value: true });\n\toutputs.ChatGenerationChunk = outputs.GenerationChunk = outputs.RUN_KEY = void 0;\n\toutputs.RUN_KEY = \"__run\";\n\t/**\n\t * Chunk of a single generation. Used for streaming.\n\t */\n\tclass GenerationChunk {\n\t    constructor(fields) {\n\t        Object.defineProperty(this, \"text\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        Object.defineProperty(this, \"generationInfo\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.text = fields.text;\n\t        this.generationInfo = fields.generationInfo;\n\t    }\n\t    concat(chunk) {\n\t        return new GenerationChunk({\n\t            text: this.text + chunk.text,\n\t            generationInfo: {\n\t                ...this.generationInfo,\n\t                ...chunk.generationInfo,\n\t            },\n\t        });\n\t    }\n\t}\n\toutputs.GenerationChunk = GenerationChunk;\n\tclass ChatGenerationChunk extends GenerationChunk {\n\t    constructor(fields) {\n\t        super(fields);\n\t        Object.defineProperty(this, \"message\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.message = fields.message;\n\t    }\n\t    concat(chunk) {\n\t        return new ChatGenerationChunk({\n\t            text: this.text + chunk.text,\n\t            generationInfo: {\n\t                ...this.generationInfo,\n\t                ...chunk.generationInfo,\n\t            },\n\t            message: this.message.concat(chunk.message),\n\t        });\n\t    }\n\t}\n\toutputs.ChatGenerationChunk = ChatGenerationChunk;\n\n\tObject.defineProperty(event_stream, \"__esModule\", { value: true });\n\tevent_stream.EventStreamCallbackHandler = event_stream.isStreamEventsHandler = void 0;\n\tconst base_js_1$3 = base$1;\n\tconst stream_js_1$2 = stream;\n\tconst ai_js_1$1 = ai;\n\tconst outputs_js_1 = outputs;\n\tfunction assignName({ name, serialized, }) {\n\t    if (name !== undefined) {\n\t        return name;\n\t    }\n\t    if (serialized?.name !== undefined) {\n\t        return serialized.name;\n\t    }\n\t    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n\t        return serialized.id[serialized.id.length - 1];\n\t    }\n\t    return \"Unnamed\";\n\t}\n\tconst isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\n\tevent_stream.isStreamEventsHandler = isStreamEventsHandler;\n\t/**\n\t * Class that extends the `BaseTracer` class from the\n\t * `langchain.callbacks.tracers.base` module. It represents a callback\n\t * handler that logs the execution of runs and emits `RunLog` instances to a\n\t * `RunLogStream`.\n\t */\n\tclass EventStreamCallbackHandler extends base_js_1$3.BaseTracer {\n\t    constructor(fields) {\n\t        super({ _awaitHandler: true, ...fields });\n\t        Object.defineProperty(this, \"autoClose\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: true\n\t        });\n\t        Object.defineProperty(this, \"includeNames\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"includeTypes\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"includeTags\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"excludeNames\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"excludeTypes\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"excludeTags\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"runInfoMap\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: new Map()\n\t        });\n\t        Object.defineProperty(this, \"tappedPromises\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: new Map()\n\t        });\n\t        Object.defineProperty(this, \"transformStream\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"writer\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"receiveStream\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"name\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: \"event_stream_tracer\"\n\t        });\n\t        this.autoClose = fields?.autoClose ?? true;\n\t        this.includeNames = fields?.includeNames;\n\t        this.includeTypes = fields?.includeTypes;\n\t        this.includeTags = fields?.includeTags;\n\t        this.excludeNames = fields?.excludeNames;\n\t        this.excludeTypes = fields?.excludeTypes;\n\t        this.excludeTags = fields?.excludeTags;\n\t        this.transformStream = new TransformStream();\n\t        this.writer = this.transformStream.writable.getWriter();\n\t        this.receiveStream = stream_js_1$2.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n\t    }\n\t    [Symbol.asyncIterator]() {\n\t        return this.receiveStream;\n\t    }\n\t    async persistRun(_run) {\n\t        // This is a legacy method only called once for an entire run tree\n\t        // and is therefore not useful here\n\t    }\n\t    _includeRun(run) {\n\t        const runTags = run.tags ?? [];\n\t        let include = this.includeNames === undefined &&\n\t            this.includeTags === undefined &&\n\t            this.includeTypes === undefined;\n\t        if (this.includeNames !== undefined) {\n\t            include = include || this.includeNames.includes(run.name);\n\t        }\n\t        if (this.includeTypes !== undefined) {\n\t            include = include || this.includeTypes.includes(run.runType);\n\t        }\n\t        if (this.includeTags !== undefined) {\n\t            include =\n\t                include ||\n\t                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n\t        }\n\t        if (this.excludeNames !== undefined) {\n\t            include = include && !this.excludeNames.includes(run.name);\n\t        }\n\t        if (this.excludeTypes !== undefined) {\n\t            include = include && !this.excludeTypes.includes(run.runType);\n\t        }\n\t        if (this.excludeTags !== undefined) {\n\t            include =\n\t                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n\t        }\n\t        return include;\n\t    }\n\t    async *tapOutputIterable(runId, outputStream) {\n\t        const firstChunk = await outputStream.next();\n\t        if (firstChunk.done) {\n\t            return;\n\t        }\n\t        const runInfo = this.runInfoMap.get(runId);\n\t        // Run has finished, don't issue any stream events.\n\t        // An example of this is for runnables that use the default\n\t        // implementation of .stream(), which delegates to .invoke()\n\t        // and calls .onChainEnd() before passing it to the iterator.\n\t        if (runInfo === undefined) {\n\t            yield firstChunk.value;\n\t            return;\n\t        }\n\t        // Match format from handlers below\n\t        function _formatOutputChunk(eventType, data) {\n\t            if (eventType === \"llm\" && typeof data === \"string\") {\n\t                return new outputs_js_1.GenerationChunk({ text: data });\n\t            }\n\t            return data;\n\t        }\n\t        let tappedPromise = this.tappedPromises.get(runId);\n\t        // if we are the first to tap, issue stream events\n\t        if (tappedPromise === undefined) {\n\t            let tappedPromiseResolver;\n\t            tappedPromise = new Promise((resolve) => {\n\t                tappedPromiseResolver = resolve;\n\t            });\n\t            this.tappedPromises.set(runId, tappedPromise);\n\t            try {\n\t                const event = {\n\t                    event: `on_${runInfo.runType}_stream`,\n\t                    run_id: runId,\n\t                    name: runInfo.name,\n\t                    tags: runInfo.tags,\n\t                    metadata: runInfo.metadata,\n\t                    data: {},\n\t                };\n\t                await this.send({\n\t                    ...event,\n\t                    data: {\n\t                        chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n\t                    },\n\t                }, runInfo);\n\t                yield firstChunk.value;\n\t                for await (const chunk of outputStream) {\n\t                    // Don't yield tool and retriever stream events\n\t                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n\t                        await this.send({\n\t                            ...event,\n\t                            data: {\n\t                                chunk: _formatOutputChunk(runInfo.runType, chunk),\n\t                            },\n\t                        }, runInfo);\n\t                    }\n\t                    yield chunk;\n\t                }\n\t            }\n\t            finally {\n\t                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t                tappedPromiseResolver();\n\t                // Don't delete from the promises map to keep track of which runs have been tapped.\n\t            }\n\t        }\n\t        else {\n\t            // otherwise just pass through\n\t            yield firstChunk.value;\n\t            for await (const chunk of outputStream) {\n\t                yield chunk;\n\t            }\n\t        }\n\t    }\n\t    async send(payload, run) {\n\t        if (this._includeRun(run)) {\n\t            await this.writer.write(payload);\n\t        }\n\t    }\n\t    async sendEndEvent(payload, run) {\n\t        const tappedPromise = this.tappedPromises.get(payload.run_id);\n\t        if (tappedPromise !== undefined) {\n\t            void tappedPromise.then(() => {\n\t                void this.send(payload, run);\n\t            });\n\t        }\n\t        else {\n\t            await this.send(payload, run);\n\t        }\n\t    }\n\t    async onLLMStart(run) {\n\t        const runName = assignName(run);\n\t        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n\t        const runInfo = {\n\t            tags: run.tags ?? [],\n\t            metadata: run.extra?.metadata ?? {},\n\t            name: runName,\n\t            runType,\n\t            inputs: run.inputs,\n\t        };\n\t        this.runInfoMap.set(run.id, runInfo);\n\t        const eventName = `on_${runType}_start`;\n\t        await this.send({\n\t            event: eventName,\n\t            data: {\n\t                input: run.inputs,\n\t            },\n\t            name: runName,\n\t            tags: run.tags ?? [],\n\t            run_id: run.id,\n\t            metadata: run.extra?.metadata ?? {},\n\t        }, runInfo);\n\t    }\n\t    async onLLMNewToken(run, token, \n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    kwargs) {\n\t        const runInfo = this.runInfoMap.get(run.id);\n\t        let chunk;\n\t        let eventName;\n\t        if (runInfo === undefined) {\n\t            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n\t        }\n\t        // Top-level streaming events are covered by tapOutputIterable\n\t        if (this.runInfoMap.size === 1) {\n\t            return;\n\t        }\n\t        if (runInfo.runType === \"chat_model\") {\n\t            eventName = \"on_chat_model_stream\";\n\t            if (kwargs?.chunk === undefined) {\n\t                chunk = new ai_js_1$1.AIMessageChunk({ content: token, id: `run-${run.id}` });\n\t            }\n\t            else {\n\t                chunk = kwargs.chunk.message;\n\t            }\n\t        }\n\t        else if (runInfo.runType === \"llm\") {\n\t            eventName = \"on_llm_stream\";\n\t            if (kwargs?.chunk === undefined) {\n\t                chunk = new outputs_js_1.GenerationChunk({ text: token });\n\t            }\n\t            else {\n\t                chunk = kwargs.chunk;\n\t            }\n\t        }\n\t        else {\n\t            throw new Error(`Unexpected run type ${runInfo.runType}`);\n\t        }\n\t        await this.send({\n\t            event: eventName,\n\t            data: {\n\t                chunk,\n\t            },\n\t            run_id: run.id,\n\t            name: runInfo.name,\n\t            tags: runInfo.tags,\n\t            metadata: runInfo.metadata,\n\t        }, runInfo);\n\t    }\n\t    async onLLMEnd(run) {\n\t        const runInfo = this.runInfoMap.get(run.id);\n\t        this.runInfoMap.delete(run.id);\n\t        let eventName;\n\t        if (runInfo === undefined) {\n\t            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n\t        }\n\t        const generations = run.outputs?.generations;\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        let output;\n\t        if (runInfo.runType === \"chat_model\") {\n\t            for (const generation of generations ?? []) {\n\t                if (output !== undefined) {\n\t                    break;\n\t                }\n\t                output = generation[0]?.message;\n\t            }\n\t            eventName = \"on_chat_model_end\";\n\t        }\n\t        else if (runInfo.runType === \"llm\") {\n\t            output = {\n\t                generations: generations?.map((generation) => {\n\t                    return generation.map((chunk) => {\n\t                        return {\n\t                            text: chunk.text,\n\t                            generationInfo: chunk.generationInfo,\n\t                        };\n\t                    });\n\t                }),\n\t                llmOutput: run.outputs?.llmOutput ?? {},\n\t            };\n\t            eventName = \"on_llm_end\";\n\t        }\n\t        else {\n\t            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n\t        }\n\t        await this.sendEndEvent({\n\t            event: eventName,\n\t            data: {\n\t                output,\n\t                input: runInfo.inputs,\n\t            },\n\t            run_id: run.id,\n\t            name: runInfo.name,\n\t            tags: runInfo.tags,\n\t            metadata: runInfo.metadata,\n\t        }, runInfo);\n\t    }\n\t    async onChainStart(run) {\n\t        const runName = assignName(run);\n\t        const runType = run.run_type ?? \"chain\";\n\t        const runInfo = {\n\t            tags: run.tags ?? [],\n\t            metadata: run.extra?.metadata ?? {},\n\t            name: runName,\n\t            runType: run.run_type,\n\t        };\n\t        let eventData = {};\n\t        // Workaround Runnable core code not sending input when transform streaming.\n\t        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n\t            eventData = {};\n\t            runInfo.inputs = {};\n\t        }\n\t        else if (run.inputs.input !== undefined) {\n\t            eventData.input = run.inputs.input;\n\t            runInfo.inputs = run.inputs.input;\n\t        }\n\t        else {\n\t            eventData.input = run.inputs;\n\t            runInfo.inputs = run.inputs;\n\t        }\n\t        this.runInfoMap.set(run.id, runInfo);\n\t        await this.send({\n\t            event: `on_${runType}_start`,\n\t            data: eventData,\n\t            name: runName,\n\t            tags: run.tags ?? [],\n\t            run_id: run.id,\n\t            metadata: run.extra?.metadata ?? {},\n\t        }, runInfo);\n\t    }\n\t    async onChainEnd(run) {\n\t        const runInfo = this.runInfoMap.get(run.id);\n\t        this.runInfoMap.delete(run.id);\n\t        if (runInfo === undefined) {\n\t            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n\t        }\n\t        const eventName = `on_${run.run_type}_end`;\n\t        const inputs = run.inputs ?? runInfo.inputs ?? {};\n\t        const outputs = run.outputs?.output ?? run.outputs;\n\t        const data = {\n\t            output: outputs,\n\t            input: inputs,\n\t        };\n\t        if (inputs.input && Object.keys(inputs).length === 1) {\n\t            data.input = inputs.input;\n\t            runInfo.inputs = inputs.input;\n\t        }\n\t        await this.sendEndEvent({\n\t            event: eventName,\n\t            data,\n\t            run_id: run.id,\n\t            name: runInfo.name,\n\t            tags: runInfo.tags,\n\t            metadata: runInfo.metadata ?? {},\n\t        }, runInfo);\n\t    }\n\t    async onToolStart(run) {\n\t        const runName = assignName(run);\n\t        const runInfo = {\n\t            tags: run.tags ?? [],\n\t            metadata: run.extra?.metadata ?? {},\n\t            name: runName,\n\t            runType: \"tool\",\n\t            inputs: run.inputs ?? {},\n\t        };\n\t        this.runInfoMap.set(run.id, runInfo);\n\t        await this.send({\n\t            event: \"on_tool_start\",\n\t            data: {\n\t                input: run.inputs ?? {},\n\t            },\n\t            name: runName,\n\t            run_id: run.id,\n\t            tags: run.tags ?? [],\n\t            metadata: run.extra?.metadata ?? {},\n\t        }, runInfo);\n\t    }\n\t    async onToolEnd(run) {\n\t        const runInfo = this.runInfoMap.get(run.id);\n\t        this.runInfoMap.delete(run.id);\n\t        if (runInfo === undefined) {\n\t            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n\t        }\n\t        if (runInfo.inputs === undefined) {\n\t            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n\t        }\n\t        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n\t        await this.sendEndEvent({\n\t            event: \"on_tool_end\",\n\t            data: {\n\t                output,\n\t                input: runInfo.inputs,\n\t            },\n\t            run_id: run.id,\n\t            name: runInfo.name,\n\t            tags: runInfo.tags,\n\t            metadata: runInfo.metadata,\n\t        }, runInfo);\n\t    }\n\t    async onRetrieverStart(run) {\n\t        const runName = assignName(run);\n\t        const runType = \"retriever\";\n\t        const runInfo = {\n\t            tags: run.tags ?? [],\n\t            metadata: run.extra?.metadata ?? {},\n\t            name: runName,\n\t            runType,\n\t            inputs: {\n\t                query: run.inputs.query,\n\t            },\n\t        };\n\t        this.runInfoMap.set(run.id, runInfo);\n\t        await this.send({\n\t            event: \"on_retriever_start\",\n\t            data: {\n\t                input: {\n\t                    query: run.inputs.query,\n\t                },\n\t            },\n\t            name: runName,\n\t            tags: run.tags ?? [],\n\t            run_id: run.id,\n\t            metadata: run.extra?.metadata ?? {},\n\t        }, runInfo);\n\t    }\n\t    async onRetrieverEnd(run) {\n\t        const runInfo = this.runInfoMap.get(run.id);\n\t        this.runInfoMap.delete(run.id);\n\t        if (runInfo === undefined) {\n\t            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n\t        }\n\t        await this.sendEndEvent({\n\t            event: \"on_retriever_end\",\n\t            data: {\n\t                output: run.outputs?.documents ?? run.outputs,\n\t                input: runInfo.inputs,\n\t            },\n\t            run_id: run.id,\n\t            name: runInfo.name,\n\t            tags: runInfo.tags,\n\t            metadata: runInfo.metadata,\n\t        }, runInfo);\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    async handleCustomEvent(eventName, data, runId) {\n\t        const runInfo = this.runInfoMap.get(runId);\n\t        if (runInfo === undefined) {\n\t            throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n\t        }\n\t        await this.send({\n\t            event: \"on_custom_event\",\n\t            run_id: runId,\n\t            name: eventName,\n\t            tags: runInfo.tags,\n\t            metadata: runInfo.metadata,\n\t            data,\n\t        }, runInfo);\n\t    }\n\t    async finish() {\n\t        const pendingPromises = [...this.tappedPromises.values()];\n\t        void Promise.all(pendingPromises).finally(() => {\n\t            void this.writer.close();\n\t        });\n\t    }\n\t}\n\tevent_stream.EventStreamCallbackHandler = EventStreamCallbackHandler;\n\n\tvar config = {};\n\n\tObject.defineProperty(config, \"__esModule\", { value: true });\n\tconfig.patchConfig = config.ensureConfig = config.mergeConfigs = config.getCallbackManagerForConfig = config.DEFAULT_RECURSION_LIMIT = void 0;\n\tconst manager_js_1 = manager;\n\tconst index_js_1$2 = singletons;\n\tconfig.DEFAULT_RECURSION_LIMIT = 25;\n\tasync function getCallbackManagerForConfig(config) {\n\t    return manager_js_1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n\t}\n\tconfig.getCallbackManagerForConfig = getCallbackManagerForConfig;\n\tfunction mergeConfigs(...configs) {\n\t    // We do not want to call ensureConfig on the empty state here as this may cause\n\t    // double loading of callbacks if async local storage is being used.\n\t    const copy = {};\n\t    for (const options of configs.filter((c) => !!c)) {\n\t        for (const key of Object.keys(options)) {\n\t            if (key === \"metadata\") {\n\t                copy[key] = { ...copy[key], ...options[key] };\n\t            }\n\t            else if (key === \"tags\") {\n\t                const baseKeys = copy[key] ?? [];\n\t                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n\t            }\n\t            else if (key === \"configurable\") {\n\t                copy[key] = { ...copy[key], ...options[key] };\n\t            }\n\t            else if (key === \"timeout\") {\n\t                if (copy.timeout === undefined) {\n\t                    copy.timeout = options.timeout;\n\t                }\n\t                else if (options.timeout !== undefined) {\n\t                    copy.timeout = Math.min(copy.timeout, options.timeout);\n\t                }\n\t            }\n\t            else if (key === \"signal\") {\n\t                if (copy.signal === undefined) {\n\t                    copy.signal = options.signal;\n\t                }\n\t                else if (options.signal !== undefined) {\n\t                    if (\"any\" in AbortSignal) {\n\t                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t                        copy.signal = AbortSignal.any([\n\t                            copy.signal,\n\t                            options.signal,\n\t                        ]);\n\t                    }\n\t                    else {\n\t                        copy.signal = options.signal;\n\t                    }\n\t                }\n\t            }\n\t            else if (key === \"callbacks\") {\n\t                const baseCallbacks = copy.callbacks;\n\t                const providedCallbacks = options.callbacks;\n\t                // callbacks can be either undefined, Array<handler> or manager\n\t                // so merging two callbacks values has 6 cases\n\t                if (Array.isArray(providedCallbacks)) {\n\t                    if (!baseCallbacks) {\n\t                        copy.callbacks = providedCallbacks;\n\t                    }\n\t                    else if (Array.isArray(baseCallbacks)) {\n\t                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n\t                    }\n\t                    else {\n\t                        // baseCallbacks is a manager\n\t                        const manager = baseCallbacks.copy();\n\t                        for (const callback of providedCallbacks) {\n\t                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n\t                        }\n\t                        copy.callbacks = manager;\n\t                    }\n\t                }\n\t                else if (providedCallbacks) {\n\t                    // providedCallbacks is a manager\n\t                    if (!baseCallbacks) {\n\t                        copy.callbacks = providedCallbacks;\n\t                    }\n\t                    else if (Array.isArray(baseCallbacks)) {\n\t                        const manager = providedCallbacks.copy();\n\t                        for (const callback of baseCallbacks) {\n\t                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n\t                        }\n\t                        copy.callbacks = manager;\n\t                    }\n\t                    else {\n\t                        // baseCallbacks is also a manager\n\t                        copy.callbacks = new manager_js_1.CallbackManager(providedCallbacks._parentRunId, {\n\t                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n\t                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n\t                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n\t                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n\t                            metadata: {\n\t                                ...baseCallbacks.metadata,\n\t                                ...providedCallbacks.metadata,\n\t                            },\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                const typedKey = key;\n\t                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n\t            }\n\t        }\n\t    }\n\t    return copy;\n\t}\n\tconfig.mergeConfigs = mergeConfigs;\n\tconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n\t/**\n\t * Ensure that a passed config is an object with all required keys present.\n\t */\n\tfunction ensureConfig(config) {\n\t    const implicitConfig = index_js_1$2.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n\t    let empty = {\n\t        tags: [],\n\t        metadata: {},\n\t        recursionLimit: 25,\n\t        runId: undefined,\n\t    };\n\t    if (implicitConfig) {\n\t        // Don't allow runId and runName to be loaded implicitly, as this can cause\n\t        // child runs to improperly inherit their parents' run ids.\n\t        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t        const { runId, runName, ...rest } = implicitConfig;\n\t        empty = Object.entries(rest).reduce(\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        (currentConfig, [key, value]) => {\n\t            if (value !== undefined) {\n\t                // eslint-disable-next-line no-param-reassign\n\t                currentConfig[key] = value;\n\t            }\n\t            return currentConfig;\n\t        }, empty);\n\t    }\n\t    if (config) {\n\t        empty = Object.entries(config).reduce(\n\t        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t        (currentConfig, [key, value]) => {\n\t            if (value !== undefined) {\n\t                // eslint-disable-next-line no-param-reassign\n\t                currentConfig[key] = value;\n\t            }\n\t            return currentConfig;\n\t        }, empty);\n\t    }\n\t    if (empty?.configurable) {\n\t        for (const key of Object.keys(empty.configurable)) {\n\t            if (PRIMITIVES.has(typeof empty.configurable[key]) &&\n\t                !empty.metadata?.[key]) {\n\t                if (!empty.metadata) {\n\t                    empty.metadata = {};\n\t                }\n\t                empty.metadata[key] = empty.configurable[key];\n\t            }\n\t        }\n\t    }\n\t    if (empty.timeout !== undefined) {\n\t        if (empty.timeout <= 0) {\n\t            throw new Error(\"Timeout must be a positive number\");\n\t        }\n\t        const timeoutSignal = AbortSignal.timeout(empty.timeout);\n\t        if (empty.signal !== undefined) {\n\t            if (\"any\" in AbortSignal) {\n\t                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t                empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n\t            }\n\t        }\n\t        else {\n\t            empty.signal = timeoutSignal;\n\t        }\n\t        delete empty.timeout;\n\t    }\n\t    return empty;\n\t}\n\tconfig.ensureConfig = ensureConfig;\n\t/**\n\t * Helper function that patches runnable configs with updated properties.\n\t */\n\tfunction patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n\t    const newConfig = ensureConfig(config);\n\t    if (callbacks !== undefined) {\n\t        /**\n\t         * If we're replacing callbacks we need to unset runName\n\t         * since that should apply only to the same run as the original callbacks\n\t         */\n\t        delete newConfig.runName;\n\t        newConfig.callbacks = callbacks;\n\t    }\n\t    if (recursionLimit !== undefined) {\n\t        newConfig.recursionLimit = recursionLimit;\n\t    }\n\t    if (maxConcurrency !== undefined) {\n\t        newConfig.maxConcurrency = maxConcurrency;\n\t    }\n\t    if (runName !== undefined) {\n\t        newConfig.runName = runName;\n\t    }\n\t    if (configurable !== undefined) {\n\t        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n\t    }\n\t    if (runId !== undefined) {\n\t        delete newConfig.runId;\n\t    }\n\t    return newConfig;\n\t}\n\tconfig.patchConfig = patchConfig;\n\n\tvar async_caller = {};\n\n\tvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(async_caller, \"__esModule\", { value: true });\n\tasync_caller.AsyncCaller = void 0;\n\tconst p_retry_1$1 = __importDefault$1(pRetryExports);\n\tconst p_queue_1 = __importDefault$1(dist);\n\tconst STATUS_NO_RETRY = [\n\t    400,\n\t    401,\n\t    402,\n\t    403,\n\t    404,\n\t    405,\n\t    406,\n\t    407,\n\t    409, // Conflict\n\t];\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tconst defaultFailedAttemptHandler = (error) => {\n\t    if (error.message.startsWith(\"Cancel\") ||\n\t        error.message.startsWith(\"AbortError\") ||\n\t        error.name === \"AbortError\") {\n\t        throw error;\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    if (error?.code === \"ECONNABORTED\") {\n\t        throw error;\n\t    }\n\t    const status = \n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    error?.response?.status ?? error?.status;\n\t    if (status && STATUS_NO_RETRY.includes(+status)) {\n\t        throw error;\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    if (error?.error?.code === \"insufficient_quota\") {\n\t        const err = new Error(error?.message);\n\t        err.name = \"InsufficientQuotaError\";\n\t        throw err;\n\t    }\n\t};\n\t/**\n\t * A class that can be used to make async calls with concurrency and retry logic.\n\t *\n\t * This is useful for making calls to any kind of \"expensive\" external resource,\n\t * be it because it's rate-limited, subject to network issues, etc.\n\t *\n\t * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n\t * to `Infinity`. This means that by default, all calls will be made in parallel.\n\t *\n\t * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n\t * means that by default, each call will be retried up to 6 times, with an\n\t * exponential backoff between each attempt.\n\t */\n\tclass AsyncCaller {\n\t    constructor(params) {\n\t        Object.defineProperty(this, \"maxConcurrency\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"maxRetries\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"onFailedAttempt\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"queue\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n\t        this.maxRetries = params.maxRetries ?? 6;\n\t        this.onFailedAttempt =\n\t            params.onFailedAttempt ?? defaultFailedAttemptHandler;\n\t        const PQueue = \"default\" in p_queue_1.default ? p_queue_1.default.default : p_queue_1.default;\n\t        this.queue = new PQueue({ concurrency: this.maxConcurrency });\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    call(callable, ...args) {\n\t        return this.queue.add(() => (0, p_retry_1$1.default)(() => callable(...args).catch((error) => {\n\t            // eslint-disable-next-line no-instanceof/no-instanceof\n\t            if (error instanceof Error) {\n\t                throw error;\n\t            }\n\t            else {\n\t                throw new Error(error);\n\t            }\n\t        }), {\n\t            onFailedAttempt: this.onFailedAttempt,\n\t            retries: this.maxRetries,\n\t            randomize: true,\n\t            // If needed we can change some of the defaults here,\n\t            // but they're quite sensible.\n\t        }), { throwOnTimeout: true });\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    callWithOptions(options, callable, ...args) {\n\t        // Note this doesn't cancel the underlying request,\n\t        // when available prefer to use the signal option of the underlying call\n\t        if (options.signal) {\n\t            return Promise.race([\n\t                this.call(callable, ...args),\n\t                new Promise((_, reject) => {\n\t                    options.signal?.addEventListener(\"abort\", () => {\n\t                        reject(new Error(\"AbortError\"));\n\t                    });\n\t                }),\n\t            ]);\n\t        }\n\t        return this.call(callable, ...args);\n\t    }\n\t    fetch(...args) {\n\t        return this.call(() => fetch(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n\t    }\n\t}\n\tasync_caller.AsyncCaller = AsyncCaller;\n\n\tvar root_listener = {};\n\n\tObject.defineProperty(root_listener, \"__esModule\", { value: true });\n\troot_listener.RootListenersTracer = void 0;\n\tconst base_js_1$2 = base$1;\n\tclass RootListenersTracer extends base_js_1$2.BaseTracer {\n\t    constructor({ config, onStart, onEnd, onError, }) {\n\t        super({ _awaitHandler: true });\n\t        Object.defineProperty(this, \"name\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: \"RootListenersTracer\"\n\t        });\n\t        /** The Run's ID. Type UUID */\n\t        Object.defineProperty(this, \"rootId\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"config\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"argOnStart\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"argOnEnd\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"argOnError\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.config = config;\n\t        this.argOnStart = onStart;\n\t        this.argOnEnd = onEnd;\n\t        this.argOnError = onError;\n\t    }\n\t    /**\n\t     * This is a legacy method only called once for an entire run tree\n\t     * therefore not useful here\n\t     * @param {Run} _ Not used\n\t     */\n\t    persistRun(_) {\n\t        return Promise.resolve();\n\t    }\n\t    async onRunCreate(run) {\n\t        if (this.rootId) {\n\t            return;\n\t        }\n\t        this.rootId = run.id;\n\t        if (this.argOnStart) {\n\t            await this.argOnStart(run, this.config);\n\t        }\n\t    }\n\t    async onRunUpdate(run) {\n\t        if (run.id !== this.rootId) {\n\t            return;\n\t        }\n\t        if (!run.error) {\n\t            if (this.argOnEnd) {\n\t                await this.argOnEnd(run, this.config);\n\t            }\n\t        }\n\t        else if (this.argOnError) {\n\t            await this.argOnError(run, this.config);\n\t        }\n\t    }\n\t}\n\troot_listener.RootListenersTracer = RootListenersTracer;\n\n\tvar utils = {};\n\n\tObject.defineProperty(utils, \"__esModule\", { value: true });\n\tutils._RootEventFilter = utils.isRunnableInterface = void 0;\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tfunction isRunnableInterface(thing) {\n\t    return thing ? thing.lc_runnable : false;\n\t}\n\tutils.isRunnableInterface = isRunnableInterface;\n\t/**\n\t * Utility to filter the root event in the streamEvents implementation.\n\t * This is simply binding the arguments to the namespace to make save on\n\t * a bit of typing in the streamEvents implementation.\n\t *\n\t * TODO: Refactor and remove.\n\t */\n\tclass _RootEventFilter {\n\t    constructor(fields) {\n\t        Object.defineProperty(this, \"includeNames\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"includeTypes\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"includeTags\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"excludeNames\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"excludeTypes\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        Object.defineProperty(this, \"excludeTags\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.includeNames = fields.includeNames;\n\t        this.includeTypes = fields.includeTypes;\n\t        this.includeTags = fields.includeTags;\n\t        this.excludeNames = fields.excludeNames;\n\t        this.excludeTypes = fields.excludeTypes;\n\t        this.excludeTags = fields.excludeTags;\n\t    }\n\t    includeEvent(event, rootType) {\n\t        let include = this.includeNames === undefined &&\n\t            this.includeTypes === undefined &&\n\t            this.includeTags === undefined;\n\t        const eventTags = event.tags ?? [];\n\t        if (this.includeNames !== undefined) {\n\t            include = include || this.includeNames.includes(event.name);\n\t        }\n\t        if (this.includeTypes !== undefined) {\n\t            include = include || this.includeTypes.includes(rootType);\n\t        }\n\t        if (this.includeTags !== undefined) {\n\t            include =\n\t                include || eventTags.some((tag) => this.includeTags?.includes(tag));\n\t        }\n\t        if (this.excludeNames !== undefined) {\n\t            include = include && !this.excludeNames.includes(event.name);\n\t        }\n\t        if (this.excludeTypes !== undefined) {\n\t            include = include && !this.excludeTypes.includes(rootType);\n\t        }\n\t        if (this.excludeTags !== undefined) {\n\t            include =\n\t                include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n\t        }\n\t        return include;\n\t    }\n\t}\n\tutils._RootEventFilter = _RootEventFilter;\n\n\tvar graph = {};\n\n\tvar cjs = {};\n\n\tvar Options = {};\n\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.getDefaultOptions = exports.defaultOptions = exports.ignoreOverride = void 0;\n\t\texports.ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\n\t\texports.defaultOptions = {\n\t\t    name: undefined,\n\t\t    $refStrategy: \"root\",\n\t\t    basePath: [\"#\"],\n\t\t    effectStrategy: \"input\",\n\t\t    pipeStrategy: \"all\",\n\t\t    dateStrategy: \"format:date-time\",\n\t\t    mapStrategy: \"entries\",\n\t\t    removeAdditionalStrategy: \"passthrough\",\n\t\t    definitionPath: \"definitions\",\n\t\t    target: \"jsonSchema7\",\n\t\t    strictUnions: false,\n\t\t    definitions: {},\n\t\t    errorMessages: false,\n\t\t    markdownDescription: false,\n\t\t    patternStrategy: \"escape\",\n\t\t    applyRegexFlags: false,\n\t\t    emailStrategy: \"format:email\",\n\t\t    base64Strategy: \"contentEncoding:base64\",\n\t\t    nameStrategy: \"ref\"\n\t\t};\n\t\tconst getDefaultOptions = (options) => (typeof options === \"string\"\n\t\t    ? {\n\t\t        ...exports.defaultOptions,\n\t\t        name: options,\n\t\t    }\n\t\t    : {\n\t\t        ...exports.defaultOptions,\n\t\t        ...options,\n\t\t    });\n\t\texports.getDefaultOptions = getDefaultOptions; \n\t} (Options));\n\n\tvar Refs = {};\n\n\tObject.defineProperty(Refs, \"__esModule\", { value: true });\n\tRefs.getRefs = void 0;\n\tconst Options_js_1 = Options;\n\tconst getRefs = (options) => {\n\t    const _options = (0, Options_js_1.getDefaultOptions)(options);\n\t    const currentPath = _options.name !== undefined\n\t        ? [..._options.basePath, _options.definitionPath, _options.name]\n\t        : _options.basePath;\n\t    return {\n\t        ..._options,\n\t        currentPath: currentPath,\n\t        propertyPath: undefined,\n\t        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n\t            def._def,\n\t            {\n\t                def: def._def,\n\t                path: [..._options.basePath, _options.definitionPath, name],\n\t                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n\t                jsonSchema: undefined,\n\t            },\n\t        ])),\n\t    };\n\t};\n\tRefs.getRefs = getRefs;\n\n\tvar errorMessages = {};\n\n\tObject.defineProperty(errorMessages, \"__esModule\", { value: true });\n\terrorMessages.setResponseValueAndErrors = errorMessages.addErrorMessage = void 0;\n\tfunction addErrorMessage(res, key, errorMessage, refs) {\n\t    if (!refs?.errorMessages)\n\t        return;\n\t    if (errorMessage) {\n\t        res.errorMessage = {\n\t            ...res.errorMessage,\n\t            [key]: errorMessage,\n\t        };\n\t    }\n\t}\n\terrorMessages.addErrorMessage = addErrorMessage;\n\tfunction setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n\t    res[key] = value;\n\t    addErrorMessage(res, key, errorMessage, refs);\n\t}\n\terrorMessages.setResponseValueAndErrors = setResponseValueAndErrors;\n\n\tvar parseDef = {};\n\n\tvar any = {};\n\n\tObject.defineProperty(any, \"__esModule\", { value: true });\n\tany.parseAnyDef = void 0;\n\tfunction parseAnyDef() {\n\t    return {};\n\t}\n\tany.parseAnyDef = parseAnyDef;\n\n\tvar array = {};\n\n\tvar hasRequiredArray;\n\n\tfunction requireArray () {\n\t\tif (hasRequiredArray) return array;\n\t\thasRequiredArray = 1;\n\t\tObject.defineProperty(array, \"__esModule\", { value: true });\n\t\tarray.parseArrayDef = void 0;\n\t\tconst zod_1 = lib;\n\t\tconst errorMessages_js_1 = errorMessages;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction parseArrayDef(def, refs) {\n\t\t    const res = {\n\t\t        type: \"array\",\n\t\t    };\n\t\t    if (def.type?._def?.typeName !== zod_1.ZodFirstPartyTypeKind.ZodAny) {\n\t\t        res.items = (0, parseDef_js_1.parseDef)(def.type._def, {\n\t\t            ...refs,\n\t\t            currentPath: [...refs.currentPath, \"items\"],\n\t\t        });\n\t\t    }\n\t\t    if (def.minLength) {\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n\t\t    }\n\t\t    if (def.maxLength) {\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n\t\t    }\n\t\t    if (def.exactLength) {\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n\t\t    }\n\t\t    return res;\n\t\t}\n\t\tarray.parseArrayDef = parseArrayDef;\n\t\treturn array;\n\t}\n\n\tvar bigint = {};\n\n\tObject.defineProperty(bigint, \"__esModule\", { value: true });\n\tbigint.parseBigintDef = void 0;\n\tconst errorMessages_js_1$2 = errorMessages;\n\tfunction parseBigintDef(def, refs) {\n\t    const res = {\n\t        type: \"integer\",\n\t        format: \"int64\",\n\t    };\n\t    if (!def.checks)\n\t        return res;\n\t    for (const check of def.checks) {\n\t        switch (check.kind) {\n\t            case \"min\":\n\t                if (refs.target === \"jsonSchema7\") {\n\t                    if (check.inclusive) {\n\t                        (0, errorMessages_js_1$2.setResponseValueAndErrors)(res, \"minimum\", check.value, check.message, refs);\n\t                    }\n\t                    else {\n\t                        (0, errorMessages_js_1$2.setResponseValueAndErrors)(res, \"exclusiveMinimum\", check.value, check.message, refs);\n\t                    }\n\t                }\n\t                else {\n\t                    if (!check.inclusive) {\n\t                        res.exclusiveMinimum = true;\n\t                    }\n\t                    (0, errorMessages_js_1$2.setResponseValueAndErrors)(res, \"minimum\", check.value, check.message, refs);\n\t                }\n\t                break;\n\t            case \"max\":\n\t                if (refs.target === \"jsonSchema7\") {\n\t                    if (check.inclusive) {\n\t                        (0, errorMessages_js_1$2.setResponseValueAndErrors)(res, \"maximum\", check.value, check.message, refs);\n\t                    }\n\t                    else {\n\t                        (0, errorMessages_js_1$2.setResponseValueAndErrors)(res, \"exclusiveMaximum\", check.value, check.message, refs);\n\t                    }\n\t                }\n\t                else {\n\t                    if (!check.inclusive) {\n\t                        res.exclusiveMaximum = true;\n\t                    }\n\t                    (0, errorMessages_js_1$2.setResponseValueAndErrors)(res, \"maximum\", check.value, check.message, refs);\n\t                }\n\t                break;\n\t            case \"multipleOf\":\n\t                (0, errorMessages_js_1$2.setResponseValueAndErrors)(res, \"multipleOf\", check.value, check.message, refs);\n\t                break;\n\t        }\n\t    }\n\t    return res;\n\t}\n\tbigint.parseBigintDef = parseBigintDef;\n\n\tvar boolean = {};\n\n\tObject.defineProperty(boolean, \"__esModule\", { value: true });\n\tboolean.parseBooleanDef = void 0;\n\tfunction parseBooleanDef() {\n\t    return {\n\t        type: \"boolean\",\n\t    };\n\t}\n\tboolean.parseBooleanDef = parseBooleanDef;\n\n\tvar branded = {};\n\n\tvar hasRequiredBranded;\n\n\tfunction requireBranded () {\n\t\tif (hasRequiredBranded) return branded;\n\t\thasRequiredBranded = 1;\n\t\tObject.defineProperty(branded, \"__esModule\", { value: true });\n\t\tbranded.parseBrandedDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction parseBrandedDef(_def, refs) {\n\t\t    return (0, parseDef_js_1.parseDef)(_def.type._def, refs);\n\t\t}\n\t\tbranded.parseBrandedDef = parseBrandedDef;\n\t\treturn branded;\n\t}\n\n\tvar _catch = {};\n\n\tvar hasRequired_catch;\n\n\tfunction require_catch () {\n\t\tif (hasRequired_catch) return _catch;\n\t\thasRequired_catch = 1;\n\t\tObject.defineProperty(_catch, \"__esModule\", { value: true });\n\t\t_catch.parseCatchDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst parseCatchDef = (def, refs) => {\n\t\t    return (0, parseDef_js_1.parseDef)(def.innerType._def, refs);\n\t\t};\n\t\t_catch.parseCatchDef = parseCatchDef;\n\t\treturn _catch;\n\t}\n\n\tvar date = {};\n\n\tObject.defineProperty(date, \"__esModule\", { value: true });\n\tdate.parseDateDef = void 0;\n\tconst errorMessages_js_1$1 = errorMessages;\n\tfunction parseDateDef(def, refs, overrideDateStrategy) {\n\t    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n\t    if (Array.isArray(strategy)) {\n\t        return {\n\t            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n\t        };\n\t    }\n\t    switch (strategy) {\n\t        case \"string\":\n\t        case \"format:date-time\":\n\t            return {\n\t                type: \"string\",\n\t                format: \"date-time\",\n\t            };\n\t        case \"format:date\":\n\t            return {\n\t                type: \"string\",\n\t                format: \"date\",\n\t            };\n\t        case \"integer\":\n\t            return integerDateParser(def, refs);\n\t    }\n\t}\n\tdate.parseDateDef = parseDateDef;\n\tconst integerDateParser = (def, refs) => {\n\t    const res = {\n\t        type: \"integer\",\n\t        format: \"unix-time\",\n\t    };\n\t    if (refs.target === \"openApi3\") {\n\t        return res;\n\t    }\n\t    for (const check of def.checks) {\n\t        switch (check.kind) {\n\t            case \"min\":\n\t                (0, errorMessages_js_1$1.setResponseValueAndErrors)(res, \"minimum\", check.value, // This is in milliseconds\n\t                check.message, refs);\n\t                break;\n\t            case \"max\":\n\t                (0, errorMessages_js_1$1.setResponseValueAndErrors)(res, \"maximum\", check.value, // This is in milliseconds\n\t                check.message, refs);\n\t                break;\n\t        }\n\t    }\n\t    return res;\n\t};\n\n\tvar _default = {};\n\n\tvar hasRequired_default;\n\n\tfunction require_default () {\n\t\tif (hasRequired_default) return _default;\n\t\thasRequired_default = 1;\n\t\tObject.defineProperty(_default, \"__esModule\", { value: true });\n\t\t_default.parseDefaultDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction parseDefaultDef(_def, refs) {\n\t\t    return {\n\t\t        ...(0, parseDef_js_1.parseDef)(_def.innerType._def, refs),\n\t\t        default: _def.defaultValue(),\n\t\t    };\n\t\t}\n\t\t_default.parseDefaultDef = parseDefaultDef;\n\t\treturn _default;\n\t}\n\n\tvar effects = {};\n\n\tvar hasRequiredEffects;\n\n\tfunction requireEffects () {\n\t\tif (hasRequiredEffects) return effects;\n\t\thasRequiredEffects = 1;\n\t\tObject.defineProperty(effects, \"__esModule\", { value: true });\n\t\teffects.parseEffectsDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction parseEffectsDef(_def, refs) {\n\t\t    return refs.effectStrategy === \"input\"\n\t\t        ? (0, parseDef_js_1.parseDef)(_def.schema._def, refs)\n\t\t        : {};\n\t\t}\n\t\teffects.parseEffectsDef = parseEffectsDef;\n\t\treturn effects;\n\t}\n\n\tvar _enum = {};\n\n\tObject.defineProperty(_enum, \"__esModule\", { value: true });\n\t_enum.parseEnumDef = void 0;\n\tfunction parseEnumDef(def) {\n\t    return {\n\t        type: \"string\",\n\t        enum: def.values,\n\t    };\n\t}\n\t_enum.parseEnumDef = parseEnumDef;\n\n\tvar intersection = {};\n\n\tvar hasRequiredIntersection;\n\n\tfunction requireIntersection () {\n\t\tif (hasRequiredIntersection) return intersection;\n\t\thasRequiredIntersection = 1;\n\t\tObject.defineProperty(intersection, \"__esModule\", { value: true });\n\t\tintersection.parseIntersectionDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst isJsonSchema7AllOfType = (type) => {\n\t\t    if (\"type\" in type && type.type === \"string\")\n\t\t        return false;\n\t\t    return \"allOf\" in type;\n\t\t};\n\t\tfunction parseIntersectionDef(def, refs) {\n\t\t    const allOf = [\n\t\t        (0, parseDef_js_1.parseDef)(def.left._def, {\n\t\t            ...refs,\n\t\t            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n\t\t        }),\n\t\t        (0, parseDef_js_1.parseDef)(def.right._def, {\n\t\t            ...refs,\n\t\t            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n\t\t        }),\n\t\t    ].filter((x) => !!x);\n\t\t    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n\t\t        ? { unevaluatedProperties: false }\n\t\t        : undefined;\n\t\t    const mergedAllOf = [];\n\t\t    // If either of the schemas is an allOf, merge them into a single allOf\n\t\t    allOf.forEach((schema) => {\n\t\t        if (isJsonSchema7AllOfType(schema)) {\n\t\t            mergedAllOf.push(...schema.allOf);\n\t\t            if (schema.unevaluatedProperties === undefined) {\n\t\t                // If one of the schemas has no unevaluatedProperties set,\n\t\t                // the merged schema should also have no unevaluatedProperties set\n\t\t                unevaluatedProperties = undefined;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            let nestedSchema = schema;\n\t\t            if (\"additionalProperties\" in schema &&\n\t\t                schema.additionalProperties === false) {\n\t\t                const { additionalProperties, ...rest } = schema;\n\t\t                nestedSchema = rest;\n\t\t            }\n\t\t            else {\n\t\t                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n\t\t                unevaluatedProperties = undefined;\n\t\t            }\n\t\t            mergedAllOf.push(nestedSchema);\n\t\t        }\n\t\t    });\n\t\t    return mergedAllOf.length\n\t\t        ? {\n\t\t            allOf: mergedAllOf,\n\t\t            ...unevaluatedProperties,\n\t\t        }\n\t\t        : undefined;\n\t\t}\n\t\tintersection.parseIntersectionDef = parseIntersectionDef;\n\t\treturn intersection;\n\t}\n\n\tvar literal = {};\n\n\tObject.defineProperty(literal, \"__esModule\", { value: true });\n\tliteral.parseLiteralDef = void 0;\n\tfunction parseLiteralDef(def, refs) {\n\t    const parsedType = typeof def.value;\n\t    if (parsedType !== \"bigint\" &&\n\t        parsedType !== \"number\" &&\n\t        parsedType !== \"boolean\" &&\n\t        parsedType !== \"string\") {\n\t        return {\n\t            type: Array.isArray(def.value) ? \"array\" : \"object\",\n\t        };\n\t    }\n\t    if (refs.target === \"openApi3\") {\n\t        return {\n\t            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n\t            enum: [def.value],\n\t        };\n\t    }\n\t    return {\n\t        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n\t        const: def.value,\n\t    };\n\t}\n\tliteral.parseLiteralDef = parseLiteralDef;\n\n\tvar map = {};\n\n\tvar record = {};\n\n\tvar string = {};\n\n\t(function (exports) {\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.parseStringDef = exports.zodPatterns = void 0;\n\t\tconst errorMessages_js_1 = errorMessages;\n\t\tlet emojiRegex;\n\t\t/**\n\t\t * Generated from the regular expressions found here as of 2024-05-22:\n\t\t * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n\t\t *\n\t\t * Expressions with /i flag have been changed accordingly.\n\t\t */\n\t\texports.zodPatterns = {\n\t\t    /**\n\t\t     * `c` was changed to `[cC]` to replicate /i flag\n\t\t     */\n\t\t    cuid: /^[cC][^\\s-]{8,}$/,\n\t\t    cuid2: /^[0-9a-z]+$/,\n\t\t    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n\t\t    /**\n\t\t     * `a-z` was added to replicate /i flag\n\t\t     */\n\t\t    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n\t\t    /**\n\t\t     * Constructed a valid Unicode RegExp\n\t\t     *\n\t\t     * Lazily instantiate since this type of regex isn't supported\n\t\t     * in all envs (e.g. React Native).\n\t\t     *\n\t\t     * See:\n\t\t     * https://github.com/colinhacks/zod/issues/2433\n\t\t     * Fix in Zod:\n\t\t     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n\t\t     */\n\t\t    emoji: () => {\n\t\t        if (emojiRegex === undefined) {\n\t\t            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n\t\t        }\n\t\t        return emojiRegex;\n\t\t    },\n\t\t    /**\n\t\t     * Unused\n\t\t     */\n\t\t    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n\t\t    /**\n\t\t     * Unused\n\t\t     */\n\t\t    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n\t\t    /**\n\t\t     * Unused\n\t\t     */\n\t\t    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n\t\t    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n\t\t    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n\t\t};\n\t\tfunction parseStringDef(def, refs) {\n\t\t    const res = {\n\t\t        type: \"string\",\n\t\t    };\n\t\t    function processPattern(value) {\n\t\t        return refs.patternStrategy === \"escape\"\n\t\t            ? escapeNonAlphaNumeric(value)\n\t\t            : value;\n\t\t    }\n\t\t    if (def.checks) {\n\t\t        for (const check of def.checks) {\n\t\t            switch (check.kind) {\n\t\t                case \"min\":\n\t\t                    (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"minLength\", typeof res.minLength === \"number\"\n\t\t                        ? Math.max(res.minLength, check.value)\n\t\t                        : check.value, check.message, refs);\n\t\t                    break;\n\t\t                case \"max\":\n\t\t                    (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"maxLength\", typeof res.maxLength === \"number\"\n\t\t                        ? Math.min(res.maxLength, check.value)\n\t\t                        : check.value, check.message, refs);\n\t\t                    break;\n\t\t                case \"email\":\n\t\t                    switch (refs.emailStrategy) {\n\t\t                        case \"format:email\":\n\t\t                            addFormat(res, \"email\", check.message, refs);\n\t\t                            break;\n\t\t                        case \"format:idn-email\":\n\t\t                            addFormat(res, \"idn-email\", check.message, refs);\n\t\t                            break;\n\t\t                        case \"pattern:zod\":\n\t\t                            addPattern(res, exports.zodPatterns.email, check.message, refs);\n\t\t                            break;\n\t\t                    }\n\t\t                    break;\n\t\t                case \"url\":\n\t\t                    addFormat(res, \"uri\", check.message, refs);\n\t\t                    break;\n\t\t                case \"uuid\":\n\t\t                    addFormat(res, \"uuid\", check.message, refs);\n\t\t                    break;\n\t\t                case \"regex\":\n\t\t                    addPattern(res, check.regex, check.message, refs);\n\t\t                    break;\n\t\t                case \"cuid\":\n\t\t                    addPattern(res, exports.zodPatterns.cuid, check.message, refs);\n\t\t                    break;\n\t\t                case \"cuid2\":\n\t\t                    addPattern(res, exports.zodPatterns.cuid2, check.message, refs);\n\t\t                    break;\n\t\t                case \"startsWith\":\n\t\t                    addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);\n\t\t                    break;\n\t\t                case \"endsWith\":\n\t\t                    addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);\n\t\t                    break;\n\t\t                case \"datetime\":\n\t\t                    addFormat(res, \"date-time\", check.message, refs);\n\t\t                    break;\n\t\t                case \"date\":\n\t\t                    addFormat(res, \"date\", check.message, refs);\n\t\t                    break;\n\t\t                case \"time\":\n\t\t                    addFormat(res, \"time\", check.message, refs);\n\t\t                    break;\n\t\t                case \"duration\":\n\t\t                    addFormat(res, \"duration\", check.message, refs);\n\t\t                    break;\n\t\t                case \"length\":\n\t\t                    (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"minLength\", typeof res.minLength === \"number\"\n\t\t                        ? Math.max(res.minLength, check.value)\n\t\t                        : check.value, check.message, refs);\n\t\t                    (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"maxLength\", typeof res.maxLength === \"number\"\n\t\t                        ? Math.min(res.maxLength, check.value)\n\t\t                        : check.value, check.message, refs);\n\t\t                    break;\n\t\t                case \"includes\": {\n\t\t                    addPattern(res, RegExp(processPattern(check.value)), check.message, refs);\n\t\t                    break;\n\t\t                }\n\t\t                case \"ip\": {\n\t\t                    if (check.version !== \"v6\") {\n\t\t                        addFormat(res, \"ipv4\", check.message, refs);\n\t\t                    }\n\t\t                    if (check.version !== \"v4\") {\n\t\t                        addFormat(res, \"ipv6\", check.message, refs);\n\t\t                    }\n\t\t                    break;\n\t\t                }\n\t\t                case \"emoji\":\n\t\t                    addPattern(res, exports.zodPatterns.emoji, check.message, refs);\n\t\t                    break;\n\t\t                case \"ulid\": {\n\t\t                    addPattern(res, exports.zodPatterns.ulid, check.message, refs);\n\t\t                    break;\n\t\t                }\n\t\t                case \"base64\": {\n\t\t                    switch (refs.base64Strategy) {\n\t\t                        case \"format:binary\": {\n\t\t                            addFormat(res, \"binary\", check.message, refs);\n\t\t                            break;\n\t\t                        }\n\t\t                        case \"contentEncoding:base64\": {\n\t\t                            (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"contentEncoding\", \"base64\", check.message, refs);\n\t\t                            break;\n\t\t                        }\n\t\t                        case \"pattern:zod\": {\n\t\t                            addPattern(res, exports.zodPatterns.base64, check.message, refs);\n\t\t                            break;\n\t\t                        }\n\t\t                    }\n\t\t                    break;\n\t\t                }\n\t\t                case \"nanoid\": {\n\t\t                    addPattern(res, exports.zodPatterns.nanoid, check.message, refs);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    return res;\n\t\t}\n\t\texports.parseStringDef = parseStringDef;\n\t\tconst escapeNonAlphaNumeric = (value) => Array.from(value)\n\t\t    .map((c) => (/[a-zA-Z0-9]/.test(c) ? c : `\\\\${c}`))\n\t\t    .join(\"\");\n\t\tconst addFormat = (schema, value, message, refs) => {\n\t\t    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n\t\t        if (!schema.anyOf) {\n\t\t            schema.anyOf = [];\n\t\t        }\n\t\t        if (schema.format) {\n\t\t            schema.anyOf.push({\n\t\t                format: schema.format,\n\t\t                ...(schema.errorMessage &&\n\t\t                    refs.errorMessages && {\n\t\t                    errorMessage: { format: schema.errorMessage.format },\n\t\t                }),\n\t\t            });\n\t\t            delete schema.format;\n\t\t            if (schema.errorMessage) {\n\t\t                delete schema.errorMessage.format;\n\t\t                if (Object.keys(schema.errorMessage).length === 0) {\n\t\t                    delete schema.errorMessage;\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        schema.anyOf.push({\n\t\t            format: value,\n\t\t            ...(message &&\n\t\t                refs.errorMessages && { errorMessage: { format: message } }),\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, \"format\", value, message, refs);\n\t\t    }\n\t\t};\n\t\tconst addPattern = (schema, regex, message, refs) => {\n\t\t    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n\t\t        if (!schema.allOf) {\n\t\t            schema.allOf = [];\n\t\t        }\n\t\t        if (schema.pattern) {\n\t\t            schema.allOf.push({\n\t\t                pattern: schema.pattern,\n\t\t                ...(schema.errorMessage &&\n\t\t                    refs.errorMessages && {\n\t\t                    errorMessage: { pattern: schema.errorMessage.pattern },\n\t\t                }),\n\t\t            });\n\t\t            delete schema.pattern;\n\t\t            if (schema.errorMessage) {\n\t\t                delete schema.errorMessage.pattern;\n\t\t                if (Object.keys(schema.errorMessage).length === 0) {\n\t\t                    delete schema.errorMessage;\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        schema.allOf.push({\n\t\t            pattern: processRegExp(regex, refs),\n\t\t            ...(message &&\n\t\t                refs.errorMessages && { errorMessage: { pattern: message } }),\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, \"pattern\", processRegExp(regex, refs), message, refs);\n\t\t    }\n\t\t};\n\t\t// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\n\t\tconst processRegExp = (regexOrFunction, refs) => {\n\t\t    const regex = typeof regexOrFunction === \"function\" ? regexOrFunction() : regexOrFunction;\n\t\t    if (!refs.applyRegexFlags || !regex.flags)\n\t\t        return regex.source;\n\t\t    // Currently handled flags\n\t\t    const flags = {\n\t\t        i: regex.flags.includes(\"i\"),\n\t\t        m: regex.flags.includes(\"m\"),\n\t\t        s: regex.flags.includes(\"s\"), // `.` matches newlines\n\t\t    };\n\t\t    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n\t\t    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n\t\t    let pattern = \"\";\n\t\t    let isEscaped = false;\n\t\t    let inCharGroup = false;\n\t\t    let inCharRange = false;\n\t\t    for (let i = 0; i < source.length; i++) {\n\t\t        if (isEscaped) {\n\t\t            pattern += source[i];\n\t\t            isEscaped = false;\n\t\t            continue;\n\t\t        }\n\t\t        if (flags.i) {\n\t\t            if (inCharGroup) {\n\t\t                if (source[i].match(/[a-z]/)) {\n\t\t                    if (inCharRange) {\n\t\t                        pattern += source[i];\n\t\t                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n\t\t                        inCharRange = false;\n\t\t                    }\n\t\t                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n\t\t                        pattern += source[i];\n\t\t                        inCharRange = true;\n\t\t                    }\n\t\t                    else {\n\t\t                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n\t\t                    }\n\t\t                    continue;\n\t\t                }\n\t\t            }\n\t\t            else if (source[i].match(/[a-z]/)) {\n\t\t                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n\t\t                continue;\n\t\t            }\n\t\t        }\n\t\t        if (flags.m) {\n\t\t            if (source[i] === \"^\") {\n\t\t                pattern += `(^|(?<=[\\r\\n]))`;\n\t\t                continue;\n\t\t            }\n\t\t            else if (source[i] === \"$\") {\n\t\t                pattern += `($|(?=[\\r\\n]))`;\n\t\t                continue;\n\t\t            }\n\t\t        }\n\t\t        if (flags.s && source[i] === \".\") {\n\t\t            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n\t\t            continue;\n\t\t        }\n\t\t        pattern += source[i];\n\t\t        if (source[i] === \"\\\\\") {\n\t\t            isEscaped = true;\n\t\t        }\n\t\t        else if (inCharGroup && source[i] === \"]\") {\n\t\t            inCharGroup = false;\n\t\t        }\n\t\t        else if (!inCharGroup && source[i] === \"[\") {\n\t\t            inCharGroup = true;\n\t\t        }\n\t\t    }\n\t\t    try {\n\t\t        const regexTest = new RegExp(pattern);\n\t\t    }\n\t\t    catch {\n\t\t        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n\t\t        return regex.source;\n\t\t    }\n\t\t    return pattern;\n\t\t}; \n\t} (string));\n\n\tvar hasRequiredRecord;\n\n\tfunction requireRecord () {\n\t\tif (hasRequiredRecord) return record;\n\t\thasRequiredRecord = 1;\n\t\tObject.defineProperty(record, \"__esModule\", { value: true });\n\t\trecord.parseRecordDef = void 0;\n\t\tconst zod_1 = lib;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst string_js_1 = string;\n\t\tfunction parseRecordDef(def, refs) {\n\t\t    if (refs.target === \"openApi3\" &&\n\t\t        def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodEnum) {\n\t\t        return {\n\t\t            type: \"object\",\n\t\t            required: def.keyType._def.values,\n\t\t            properties: def.keyType._def.values.reduce((acc, key) => ({\n\t\t                ...acc,\n\t\t                [key]: (0, parseDef_js_1.parseDef)(def.valueType._def, {\n\t\t                    ...refs,\n\t\t                    currentPath: [...refs.currentPath, \"properties\", key],\n\t\t                }) ?? {},\n\t\t            }), {}),\n\t\t            additionalProperties: false,\n\t\t        };\n\t\t    }\n\t\t    const schema = {\n\t\t        type: \"object\",\n\t\t        additionalProperties: (0, parseDef_js_1.parseDef)(def.valueType._def, {\n\t\t            ...refs,\n\t\t            currentPath: [...refs.currentPath, \"additionalProperties\"],\n\t\t        }) ?? {},\n\t\t    };\n\t\t    if (refs.target === \"openApi3\") {\n\t\t        return schema;\n\t\t    }\n\t\t    if (def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodString &&\n\t\t        def.keyType._def.checks?.length) {\n\t\t        const keyType = Object.entries((0, string_js_1.parseStringDef)(def.keyType._def, refs)).reduce((acc, [key, value]) => (key === \"type\" ? acc : { ...acc, [key]: value }), {});\n\t\t        return {\n\t\t            ...schema,\n\t\t            propertyNames: keyType,\n\t\t        };\n\t\t    }\n\t\t    else if (def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodEnum) {\n\t\t        return {\n\t\t            ...schema,\n\t\t            propertyNames: {\n\t\t                enum: def.keyType._def.values,\n\t\t            },\n\t\t        };\n\t\t    }\n\t\t    return schema;\n\t\t}\n\t\trecord.parseRecordDef = parseRecordDef;\n\t\treturn record;\n\t}\n\n\tvar hasRequiredMap;\n\n\tfunction requireMap () {\n\t\tif (hasRequiredMap) return map;\n\t\thasRequiredMap = 1;\n\t\tObject.defineProperty(map, \"__esModule\", { value: true });\n\t\tmap.parseMapDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst record_js_1 = requireRecord();\n\t\tfunction parseMapDef(def, refs) {\n\t\t    if (refs.mapStrategy === \"record\") {\n\t\t        return (0, record_js_1.parseRecordDef)(def, refs);\n\t\t    }\n\t\t    const keys = (0, parseDef_js_1.parseDef)(def.keyType._def, {\n\t\t        ...refs,\n\t\t        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n\t\t    }) || {};\n\t\t    const values = (0, parseDef_js_1.parseDef)(def.valueType._def, {\n\t\t        ...refs,\n\t\t        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n\t\t    }) || {};\n\t\t    return {\n\t\t        type: \"array\",\n\t\t        maxItems: 125,\n\t\t        items: {\n\t\t            type: \"array\",\n\t\t            items: [keys, values],\n\t\t            minItems: 2,\n\t\t            maxItems: 2,\n\t\t        },\n\t\t    };\n\t\t}\n\t\tmap.parseMapDef = parseMapDef;\n\t\treturn map;\n\t}\n\n\tvar nativeEnum = {};\n\n\tObject.defineProperty(nativeEnum, \"__esModule\", { value: true });\n\tnativeEnum.parseNativeEnumDef = void 0;\n\tfunction parseNativeEnumDef(def) {\n\t    const object = def.values;\n\t    const actualKeys = Object.keys(def.values).filter((key) => {\n\t        return typeof object[object[key]] !== \"number\";\n\t    });\n\t    const actualValues = actualKeys.map((key) => object[key]);\n\t    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n\t    return {\n\t        type: parsedTypes.length === 1\n\t            ? parsedTypes[0] === \"string\"\n\t                ? \"string\"\n\t                : \"number\"\n\t            : [\"string\", \"number\"],\n\t        enum: actualValues,\n\t    };\n\t}\n\tnativeEnum.parseNativeEnumDef = parseNativeEnumDef;\n\n\tvar never = {};\n\n\tObject.defineProperty(never, \"__esModule\", { value: true });\n\tnever.parseNeverDef = void 0;\n\tfunction parseNeverDef() {\n\t    return {\n\t        not: {},\n\t    };\n\t}\n\tnever.parseNeverDef = parseNeverDef;\n\n\tvar _null = {};\n\n\tObject.defineProperty(_null, \"__esModule\", { value: true });\n\t_null.parseNullDef = void 0;\n\tfunction parseNullDef(refs) {\n\t    return refs.target === \"openApi3\"\n\t        ? {\n\t            enum: [\"null\"],\n\t            nullable: true,\n\t        }\n\t        : {\n\t            type: \"null\",\n\t        };\n\t}\n\t_null.parseNullDef = parseNullDef;\n\n\tvar nullable = {};\n\n\tvar union = {};\n\n\tvar hasRequiredUnion;\n\n\tfunction requireUnion () {\n\t\tif (hasRequiredUnion) return union;\n\t\thasRequiredUnion = 1;\n\t\t(function (exports) {\n\t\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\t\texports.parseUnionDef = exports.primitiveMappings = void 0;\n\t\t\tconst parseDef_js_1 = requireParseDef();\n\t\t\texports.primitiveMappings = {\n\t\t\t    ZodString: \"string\",\n\t\t\t    ZodNumber: \"number\",\n\t\t\t    ZodBigInt: \"integer\",\n\t\t\t    ZodBoolean: \"boolean\",\n\t\t\t    ZodNull: \"null\",\n\t\t\t};\n\t\t\tfunction parseUnionDef(def, refs) {\n\t\t\t    if (refs.target === \"openApi3\")\n\t\t\t        return asAnyOf(def, refs);\n\t\t\t    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n\t\t\t    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n\t\t\t    if (options.every((x) => x._def.typeName in exports.primitiveMappings &&\n\t\t\t        (!x._def.checks || !x._def.checks.length))) {\n\t\t\t        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n\t\t\t        const types = options.reduce((types, x) => {\n\t\t\t            const type = exports.primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n\t\t\t            return type && !types.includes(type) ? [...types, type] : types;\n\t\t\t        }, []);\n\t\t\t        return {\n\t\t\t            type: types.length > 1 ? types : types[0],\n\t\t\t        };\n\t\t\t    }\n\t\t\t    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n\t\t\t        // all options literals\n\t\t\t        const types = options.reduce((acc, x) => {\n\t\t\t            const type = typeof x._def.value;\n\t\t\t            switch (type) {\n\t\t\t                case \"string\":\n\t\t\t                case \"number\":\n\t\t\t                case \"boolean\":\n\t\t\t                    return [...acc, type];\n\t\t\t                case \"bigint\":\n\t\t\t                    return [...acc, \"integer\"];\n\t\t\t                case \"object\":\n\t\t\t                    if (x._def.value === null)\n\t\t\t                        return [...acc, \"null\"];\n\t\t\t                case \"symbol\":\n\t\t\t                case \"undefined\":\n\t\t\t                case \"function\":\n\t\t\t                default:\n\t\t\t                    return acc;\n\t\t\t            }\n\t\t\t        }, []);\n\t\t\t        if (types.length === options.length) {\n\t\t\t            // all the literals are primitive, as far as null can be considered primitive\n\t\t\t            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n\t\t\t            return {\n\t\t\t                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n\t\t\t                enum: options.reduce((acc, x) => {\n\t\t\t                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n\t\t\t                }, []),\n\t\t\t            };\n\t\t\t        }\n\t\t\t    }\n\t\t\t    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n\t\t\t        return {\n\t\t\t            type: \"string\",\n\t\t\t            enum: options.reduce((acc, x) => [\n\t\t\t                ...acc,\n\t\t\t                ...x._def.values.filter((x) => !acc.includes(x)),\n\t\t\t            ], []),\n\t\t\t        };\n\t\t\t    }\n\t\t\t    return asAnyOf(def, refs);\n\t\t\t}\n\t\t\texports.parseUnionDef = parseUnionDef;\n\t\t\tconst asAnyOf = (def, refs) => {\n\t\t\t    const anyOf = (def.options instanceof Map\n\t\t\t        ? Array.from(def.options.values())\n\t\t\t        : def.options)\n\t\t\t        .map((x, i) => (0, parseDef_js_1.parseDef)(x._def, {\n\t\t\t        ...refs,\n\t\t\t        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n\t\t\t    }))\n\t\t\t        .filter((x) => !!x &&\n\t\t\t        (!refs.strictUnions ||\n\t\t\t            (typeof x === \"object\" && Object.keys(x).length > 0)));\n\t\t\t    return anyOf.length ? { anyOf } : undefined;\n\t\t\t}; \n\t\t} (union));\n\t\treturn union;\n\t}\n\n\tvar hasRequiredNullable;\n\n\tfunction requireNullable () {\n\t\tif (hasRequiredNullable) return nullable;\n\t\thasRequiredNullable = 1;\n\t\tObject.defineProperty(nullable, \"__esModule\", { value: true });\n\t\tnullable.parseNullableDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst union_js_1 = requireUnion();\n\t\tfunction parseNullableDef(def, refs) {\n\t\t    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n\t\t        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n\t\t        if (refs.target === \"openApi3\") {\n\t\t            return {\n\t\t                type: union_js_1.primitiveMappings[def.innerType._def.typeName],\n\t\t                nullable: true,\n\t\t            };\n\t\t        }\n\t\t        return {\n\t\t            type: [\n\t\t                union_js_1.primitiveMappings[def.innerType._def.typeName],\n\t\t                \"null\",\n\t\t            ],\n\t\t        };\n\t\t    }\n\t\t    if (refs.target === \"openApi3\") {\n\t\t        const base = (0, parseDef_js_1.parseDef)(def.innerType._def, {\n\t\t            ...refs,\n\t\t            currentPath: [...refs.currentPath],\n\t\t        });\n\t\t        if (base && '$ref' in base)\n\t\t            return { allOf: [base], nullable: true };\n\t\t        return base && { ...base, nullable: true };\n\t\t    }\n\t\t    const base = (0, parseDef_js_1.parseDef)(def.innerType._def, {\n\t\t        ...refs,\n\t\t        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n\t\t    });\n\t\t    return base && { anyOf: [base, { type: \"null\" }] };\n\t\t}\n\t\tnullable.parseNullableDef = parseNullableDef;\n\t\treturn nullable;\n\t}\n\n\tvar number = {};\n\n\tObject.defineProperty(number, \"__esModule\", { value: true });\n\tnumber.parseNumberDef = void 0;\n\tconst errorMessages_js_1 = errorMessages;\n\tfunction parseNumberDef(def, refs) {\n\t    const res = {\n\t        type: \"number\",\n\t    };\n\t    if (!def.checks)\n\t        return res;\n\t    for (const check of def.checks) {\n\t        switch (check.kind) {\n\t            case \"int\":\n\t                res.type = \"integer\";\n\t                (0, errorMessages_js_1.addErrorMessage)(res, \"type\", check.message, refs);\n\t                break;\n\t            case \"min\":\n\t                if (refs.target === \"jsonSchema7\") {\n\t                    if (check.inclusive) {\n\t                        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"minimum\", check.value, check.message, refs);\n\t                    }\n\t                    else {\n\t                        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"exclusiveMinimum\", check.value, check.message, refs);\n\t                    }\n\t                }\n\t                else {\n\t                    if (!check.inclusive) {\n\t                        res.exclusiveMinimum = true;\n\t                    }\n\t                    (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"minimum\", check.value, check.message, refs);\n\t                }\n\t                break;\n\t            case \"max\":\n\t                if (refs.target === \"jsonSchema7\") {\n\t                    if (check.inclusive) {\n\t                        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"maximum\", check.value, check.message, refs);\n\t                    }\n\t                    else {\n\t                        (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"exclusiveMaximum\", check.value, check.message, refs);\n\t                    }\n\t                }\n\t                else {\n\t                    if (!check.inclusive) {\n\t                        res.exclusiveMaximum = true;\n\t                    }\n\t                    (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"maximum\", check.value, check.message, refs);\n\t                }\n\t                break;\n\t            case \"multipleOf\":\n\t                (0, errorMessages_js_1.setResponseValueAndErrors)(res, \"multipleOf\", check.value, check.message, refs);\n\t                break;\n\t        }\n\t    }\n\t    return res;\n\t}\n\tnumber.parseNumberDef = parseNumberDef;\n\n\tvar object = {};\n\n\tvar hasRequiredObject;\n\n\tfunction requireObject () {\n\t\tif (hasRequiredObject) return object;\n\t\thasRequiredObject = 1;\n\t\tObject.defineProperty(object, \"__esModule\", { value: true });\n\t\tobject.parseObjectDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction decideAdditionalProperties(def, refs) {\n\t\t    if (refs.removeAdditionalStrategy === \"strict\") {\n\t\t        return def.catchall._def.typeName === \"ZodNever\"\n\t\t            ? def.unknownKeys !== \"strict\"\n\t\t            : (0, parseDef_js_1.parseDef)(def.catchall._def, {\n\t\t                ...refs,\n\t\t                currentPath: [...refs.currentPath, \"additionalProperties\"],\n\t\t            }) ?? true;\n\t\t    }\n\t\t    else {\n\t\t        return def.catchall._def.typeName === \"ZodNever\"\n\t\t            ? def.unknownKeys === \"passthrough\"\n\t\t            : (0, parseDef_js_1.parseDef)(def.catchall._def, {\n\t\t                ...refs,\n\t\t                currentPath: [...refs.currentPath, \"additionalProperties\"],\n\t\t            }) ?? true;\n\t\t    }\n\t\t}\n\t\tfunction parseObjectDef(def, refs) {\n\t\t    const result = {\n\t\t        type: \"object\",\n\t\t        ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {\n\t\t            if (propDef === undefined || propDef._def === undefined)\n\t\t                return acc;\n\t\t            const parsedDef = (0, parseDef_js_1.parseDef)(propDef._def, {\n\t\t                ...refs,\n\t\t                currentPath: [...refs.currentPath, \"properties\", propName],\n\t\t                propertyPath: [...refs.currentPath, \"properties\", propName],\n\t\t            });\n\t\t            if (parsedDef === undefined)\n\t\t                return acc;\n\t\t            return {\n\t\t                properties: { ...acc.properties, [propName]: parsedDef },\n\t\t                required: propDef.isOptional()\n\t\t                    ? acc.required\n\t\t                    : [...acc.required, propName],\n\t\t            };\n\t\t        }, { properties: {}, required: [] }),\n\t\t        additionalProperties: decideAdditionalProperties(def, refs),\n\t\t    };\n\t\t    if (!result.required.length)\n\t\t        delete result.required;\n\t\t    return result;\n\t\t}\n\t\tobject.parseObjectDef = parseObjectDef;\n\t\treturn object;\n\t}\n\n\tvar optional = {};\n\n\tvar hasRequiredOptional;\n\n\tfunction requireOptional () {\n\t\tif (hasRequiredOptional) return optional;\n\t\thasRequiredOptional = 1;\n\t\tObject.defineProperty(optional, \"__esModule\", { value: true });\n\t\toptional.parseOptionalDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst parseOptionalDef = (def, refs) => {\n\t\t    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n\t\t        return (0, parseDef_js_1.parseDef)(def.innerType._def, refs);\n\t\t    }\n\t\t    const innerSchema = (0, parseDef_js_1.parseDef)(def.innerType._def, {\n\t\t        ...refs,\n\t\t        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n\t\t    });\n\t\t    return innerSchema\n\t\t        ? {\n\t\t            anyOf: [\n\t\t                {\n\t\t                    not: {},\n\t\t                },\n\t\t                innerSchema,\n\t\t            ],\n\t\t        }\n\t\t        : {};\n\t\t};\n\t\toptional.parseOptionalDef = parseOptionalDef;\n\t\treturn optional;\n\t}\n\n\tvar pipeline = {};\n\n\tvar hasRequiredPipeline;\n\n\tfunction requirePipeline () {\n\t\tif (hasRequiredPipeline) return pipeline;\n\t\thasRequiredPipeline = 1;\n\t\tObject.defineProperty(pipeline, \"__esModule\", { value: true });\n\t\tpipeline.parsePipelineDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst parsePipelineDef = (def, refs) => {\n\t\t    if (refs.pipeStrategy === \"input\") {\n\t\t        return (0, parseDef_js_1.parseDef)(def.in._def, refs);\n\t\t    }\n\t\t    else if (refs.pipeStrategy === \"output\") {\n\t\t        return (0, parseDef_js_1.parseDef)(def.out._def, refs);\n\t\t    }\n\t\t    const a = (0, parseDef_js_1.parseDef)(def.in._def, {\n\t\t        ...refs,\n\t\t        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n\t\t    });\n\t\t    const b = (0, parseDef_js_1.parseDef)(def.out._def, {\n\t\t        ...refs,\n\t\t        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n\t\t    });\n\t\t    return {\n\t\t        allOf: [a, b].filter((x) => x !== undefined),\n\t\t    };\n\t\t};\n\t\tpipeline.parsePipelineDef = parsePipelineDef;\n\t\treturn pipeline;\n\t}\n\n\tvar promise = {};\n\n\tvar hasRequiredPromise;\n\n\tfunction requirePromise () {\n\t\tif (hasRequiredPromise) return promise;\n\t\thasRequiredPromise = 1;\n\t\tObject.defineProperty(promise, \"__esModule\", { value: true });\n\t\tpromise.parsePromiseDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction parsePromiseDef(def, refs) {\n\t\t    return (0, parseDef_js_1.parseDef)(def.type._def, refs);\n\t\t}\n\t\tpromise.parsePromiseDef = parsePromiseDef;\n\t\treturn promise;\n\t}\n\n\tvar set = {};\n\n\tvar hasRequiredSet;\n\n\tfunction requireSet () {\n\t\tif (hasRequiredSet) return set;\n\t\thasRequiredSet = 1;\n\t\tObject.defineProperty(set, \"__esModule\", { value: true });\n\t\tset.parseSetDef = void 0;\n\t\tconst errorMessages_js_1 = errorMessages;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction parseSetDef(def, refs) {\n\t\t    const items = (0, parseDef_js_1.parseDef)(def.valueType._def, {\n\t\t        ...refs,\n\t\t        currentPath: [...refs.currentPath, \"items\"],\n\t\t    });\n\t\t    const schema = {\n\t\t        type: \"array\",\n\t\t        uniqueItems: true,\n\t\t        items,\n\t\t    };\n\t\t    if (def.minSize) {\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n\t\t    }\n\t\t    if (def.maxSize) {\n\t\t        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n\t\t    }\n\t\t    return schema;\n\t\t}\n\t\tset.parseSetDef = parseSetDef;\n\t\treturn set;\n\t}\n\n\tvar tuple = {};\n\n\tvar hasRequiredTuple;\n\n\tfunction requireTuple () {\n\t\tif (hasRequiredTuple) return tuple;\n\t\thasRequiredTuple = 1;\n\t\tObject.defineProperty(tuple, \"__esModule\", { value: true });\n\t\ttuple.parseTupleDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tfunction parseTupleDef(def, refs) {\n\t\t    if (def.rest) {\n\t\t        return {\n\t\t            type: \"array\",\n\t\t            minItems: def.items.length,\n\t\t            items: def.items\n\t\t                .map((x, i) => (0, parseDef_js_1.parseDef)(x._def, {\n\t\t                ...refs,\n\t\t                currentPath: [...refs.currentPath, \"items\", `${i}`],\n\t\t            }))\n\t\t                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n\t\t            additionalItems: (0, parseDef_js_1.parseDef)(def.rest._def, {\n\t\t                ...refs,\n\t\t                currentPath: [...refs.currentPath, \"additionalItems\"],\n\t\t            }),\n\t\t        };\n\t\t    }\n\t\t    else {\n\t\t        return {\n\t\t            type: \"array\",\n\t\t            minItems: def.items.length,\n\t\t            maxItems: def.items.length,\n\t\t            items: def.items\n\t\t                .map((x, i) => (0, parseDef_js_1.parseDef)(x._def, {\n\t\t                ...refs,\n\t\t                currentPath: [...refs.currentPath, \"items\", `${i}`],\n\t\t            }))\n\t\t                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n\t\t        };\n\t\t    }\n\t\t}\n\t\ttuple.parseTupleDef = parseTupleDef;\n\t\treturn tuple;\n\t}\n\n\tvar _undefined = {};\n\n\tObject.defineProperty(_undefined, \"__esModule\", { value: true });\n\t_undefined.parseUndefinedDef = void 0;\n\tfunction parseUndefinedDef() {\n\t    return {\n\t        not: {},\n\t    };\n\t}\n\t_undefined.parseUndefinedDef = parseUndefinedDef;\n\n\tvar unknown = {};\n\n\tObject.defineProperty(unknown, \"__esModule\", { value: true });\n\tunknown.parseUnknownDef = void 0;\n\tfunction parseUnknownDef() {\n\t    return {};\n\t}\n\tunknown.parseUnknownDef = parseUnknownDef;\n\n\tvar readonly = {};\n\n\tvar hasRequiredReadonly;\n\n\tfunction requireReadonly () {\n\t\tif (hasRequiredReadonly) return readonly;\n\t\thasRequiredReadonly = 1;\n\t\tObject.defineProperty(readonly, \"__esModule\", { value: true });\n\t\treadonly.parseReadonlyDef = void 0;\n\t\tconst parseDef_js_1 = requireParseDef();\n\t\tconst parseReadonlyDef = (def, refs) => {\n\t\t    return (0, parseDef_js_1.parseDef)(def.innerType._def, refs);\n\t\t};\n\t\treadonly.parseReadonlyDef = parseReadonlyDef;\n\t\treturn readonly;\n\t}\n\n\tvar hasRequiredParseDef;\n\n\tfunction requireParseDef () {\n\t\tif (hasRequiredParseDef) return parseDef;\n\t\thasRequiredParseDef = 1;\n\t\tObject.defineProperty(parseDef, \"__esModule\", { value: true });\n\t\tparseDef.parseDef = void 0;\n\t\tconst zod_1 = lib;\n\t\tconst any_js_1 = any;\n\t\tconst array_js_1 = requireArray();\n\t\tconst bigint_js_1 = bigint;\n\t\tconst boolean_js_1 = boolean;\n\t\tconst branded_js_1 = requireBranded();\n\t\tconst catch_js_1 = require_catch();\n\t\tconst date_js_1 = date;\n\t\tconst default_js_1 = require_default();\n\t\tconst effects_js_1 = requireEffects();\n\t\tconst enum_js_1 = _enum;\n\t\tconst intersection_js_1 = requireIntersection();\n\t\tconst literal_js_1 = literal;\n\t\tconst map_js_1 = requireMap();\n\t\tconst nativeEnum_js_1 = nativeEnum;\n\t\tconst never_js_1 = never;\n\t\tconst null_js_1 = _null;\n\t\tconst nullable_js_1 = requireNullable();\n\t\tconst number_js_1 = number;\n\t\tconst object_js_1 = requireObject();\n\t\tconst optional_js_1 = requireOptional();\n\t\tconst pipeline_js_1 = requirePipeline();\n\t\tconst promise_js_1 = requirePromise();\n\t\tconst record_js_1 = requireRecord();\n\t\tconst set_js_1 = requireSet();\n\t\tconst string_js_1 = string;\n\t\tconst tuple_js_1 = requireTuple();\n\t\tconst undefined_js_1 = _undefined;\n\t\tconst union_js_1 = requireUnion();\n\t\tconst unknown_js_1 = unknown;\n\t\tconst readonly_js_1 = requireReadonly();\n\t\tconst Options_js_1 = Options;\n\t\tfunction parseDef$1(def, refs, forceResolution = false) {\n\t\t    const seenItem = refs.seen.get(def);\n\t\t    if (refs.override) {\n\t\t        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n\t\t        if (overrideResult !== Options_js_1.ignoreOverride) {\n\t\t            return overrideResult;\n\t\t        }\n\t\t    }\n\t\t    if (seenItem && !forceResolution) {\n\t\t        const seenSchema = get$ref(seenItem, refs);\n\t\t        if (seenSchema !== undefined) {\n\t\t            return seenSchema;\n\t\t        }\n\t\t    }\n\t\t    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n\t\t    refs.seen.set(def, newItem);\n\t\t    const jsonSchema = selectParser(def, def.typeName, refs);\n\t\t    if (jsonSchema) {\n\t\t        addMeta(def, refs, jsonSchema);\n\t\t    }\n\t\t    newItem.jsonSchema = jsonSchema;\n\t\t    return jsonSchema;\n\t\t}\n\t\tparseDef.parseDef = parseDef$1;\n\t\tconst get$ref = (item, refs) => {\n\t\t    switch (refs.$refStrategy) {\n\t\t        case \"root\":\n\t\t            return { $ref: item.path.join(\"/\") };\n\t\t        case \"relative\":\n\t\t            return { $ref: getRelativePath(refs.currentPath, item.path) };\n\t\t        case \"none\":\n\t\t        case \"seen\": {\n\t\t            if (item.path.length < refs.currentPath.length &&\n\t\t                item.path.every((value, index) => refs.currentPath[index] === value)) {\n\t\t                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n\t\t                return {};\n\t\t            }\n\t\t            return refs.$refStrategy === \"seen\" ? {} : undefined;\n\t\t        }\n\t\t    }\n\t\t};\n\t\tconst getRelativePath = (pathA, pathB) => {\n\t\t    let i = 0;\n\t\t    for (; i < pathA.length && i < pathB.length; i++) {\n\t\t        if (pathA[i] !== pathB[i])\n\t\t            break;\n\t\t    }\n\t\t    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n\t\t};\n\t\tconst selectParser = (def, typeName, refs) => {\n\t\t    switch (typeName) {\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodString:\n\t\t            return (0, string_js_1.parseStringDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodNumber:\n\t\t            return (0, number_js_1.parseNumberDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodObject:\n\t\t            return (0, object_js_1.parseObjectDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodBigInt:\n\t\t            return (0, bigint_js_1.parseBigintDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodBoolean:\n\t\t            return (0, boolean_js_1.parseBooleanDef)();\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodDate:\n\t\t            return (0, date_js_1.parseDateDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodUndefined:\n\t\t            return (0, undefined_js_1.parseUndefinedDef)();\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodNull:\n\t\t            return (0, null_js_1.parseNullDef)(refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodArray:\n\t\t            return (0, array_js_1.parseArrayDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodUnion:\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n\t\t            return (0, union_js_1.parseUnionDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodIntersection:\n\t\t            return (0, intersection_js_1.parseIntersectionDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodTuple:\n\t\t            return (0, tuple_js_1.parseTupleDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodRecord:\n\t\t            return (0, record_js_1.parseRecordDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodLiteral:\n\t\t            return (0, literal_js_1.parseLiteralDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodEnum:\n\t\t            return (0, enum_js_1.parseEnumDef)(def);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodNativeEnum:\n\t\t            return (0, nativeEnum_js_1.parseNativeEnumDef)(def);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodNullable:\n\t\t            return (0, nullable_js_1.parseNullableDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodOptional:\n\t\t            return (0, optional_js_1.parseOptionalDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodMap:\n\t\t            return (0, map_js_1.parseMapDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodSet:\n\t\t            return (0, set_js_1.parseSetDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodLazy:\n\t\t            return parseDef$1(def.getter()._def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodPromise:\n\t\t            return (0, promise_js_1.parsePromiseDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodNaN:\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodNever:\n\t\t            return (0, never_js_1.parseNeverDef)();\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodEffects:\n\t\t            return (0, effects_js_1.parseEffectsDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodAny:\n\t\t            return (0, any_js_1.parseAnyDef)();\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodUnknown:\n\t\t            return (0, unknown_js_1.parseUnknownDef)();\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodDefault:\n\t\t            return (0, default_js_1.parseDefaultDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodBranded:\n\t\t            return (0, branded_js_1.parseBrandedDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodReadonly:\n\t\t            return (0, readonly_js_1.parseReadonlyDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodCatch:\n\t\t            return (0, catch_js_1.parseCatchDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodPipeline:\n\t\t            return (0, pipeline_js_1.parsePipelineDef)(def, refs);\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodFunction:\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodVoid:\n\t\t        case zod_1.ZodFirstPartyTypeKind.ZodSymbol:\n\t\t            return undefined;\n\t\t        default:\n\t\t            /* c8 ignore next */\n\t\t            return ((_) => undefined)();\n\t\t    }\n\t\t};\n\t\tconst addMeta = (def, refs, jsonSchema) => {\n\t\t    if (def.description) {\n\t\t        jsonSchema.description = def.description;\n\t\t        if (refs.markdownDescription) {\n\t\t            jsonSchema.markdownDescription = def.description;\n\t\t        }\n\t\t    }\n\t\t    return jsonSchema;\n\t\t};\n\t\treturn parseDef;\n\t}\n\n\tvar zodToJsonSchema$1 = {};\n\n\tObject.defineProperty(zodToJsonSchema$1, \"__esModule\", { value: true });\n\tzodToJsonSchema$1.zodToJsonSchema = void 0;\n\tconst parseDef_js_1 = requireParseDef();\n\tconst Refs_js_1 = Refs;\n\tconst zodToJsonSchema = (schema, options) => {\n\t    const refs = (0, Refs_js_1.getRefs)(options);\n\t    const definitions = typeof options === \"object\" && options.definitions\n\t        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n\t            ...acc,\n\t            [name]: (0, parseDef_js_1.parseDef)(schema._def, {\n\t                ...refs,\n\t                currentPath: [...refs.basePath, refs.definitionPath, name],\n\t            }, true) ?? {},\n\t        }), {})\n\t        : undefined;\n\t    const name = typeof options === \"string\"\n\t        ? options\n\t        : options?.nameStrategy === \"title\"\n\t            ? undefined\n\t            : options?.name;\n\t    const main = (0, parseDef_js_1.parseDef)(schema._def, name === undefined\n\t        ? refs\n\t        : {\n\t            ...refs,\n\t            currentPath: [...refs.basePath, refs.definitionPath, name],\n\t        }, false) ?? {};\n\t    const title = typeof options === \"object\" &&\n\t        options.name !== undefined &&\n\t        options.nameStrategy === \"title\"\n\t        ? options.name\n\t        : undefined;\n\t    if (title !== undefined) {\n\t        main.title = title;\n\t    }\n\t    const combined = name === undefined\n\t        ? definitions\n\t            ? {\n\t                ...main,\n\t                [refs.definitionPath]: definitions,\n\t            }\n\t            : main\n\t        : {\n\t            $ref: [\n\t                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n\t                refs.definitionPath,\n\t                name,\n\t            ].join(\"/\"),\n\t            [refs.definitionPath]: {\n\t                ...definitions,\n\t                [name]: main,\n\t            },\n\t        };\n\t    if (refs.target === \"jsonSchema7\") {\n\t        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n\t    }\n\t    else if (refs.target === \"jsonSchema2019-09\") {\n\t        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n\t    }\n\t    return combined;\n\t};\n\tzodToJsonSchema$1.zodToJsonSchema = zodToJsonSchema;\n\n\t(function (exports) {\n\t\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t\t    }\n\t\t    Object.defineProperty(o, k2, desc);\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {\n\t\t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\t__exportStar(Options, exports);\n\t\t__exportStar(Refs, exports);\n\t\t__exportStar(errorMessages, exports);\n\t\t__exportStar(requireParseDef(), exports);\n\t\t__exportStar(any, exports);\n\t\t__exportStar(requireArray(), exports);\n\t\t__exportStar(bigint, exports);\n\t\t__exportStar(boolean, exports);\n\t\t__exportStar(requireBranded(), exports);\n\t\t__exportStar(require_catch(), exports);\n\t\t__exportStar(date, exports);\n\t\t__exportStar(require_default(), exports);\n\t\t__exportStar(requireEffects(), exports);\n\t\t__exportStar(_enum, exports);\n\t\t__exportStar(requireIntersection(), exports);\n\t\t__exportStar(literal, exports);\n\t\t__exportStar(requireMap(), exports);\n\t\t__exportStar(nativeEnum, exports);\n\t\t__exportStar(never, exports);\n\t\t__exportStar(_null, exports);\n\t\t__exportStar(requireNullable(), exports);\n\t\t__exportStar(number, exports);\n\t\t__exportStar(requireObject(), exports);\n\t\t__exportStar(requireOptional(), exports);\n\t\t__exportStar(requirePipeline(), exports);\n\t\t__exportStar(requirePromise(), exports);\n\t\t__exportStar(requireReadonly(), exports);\n\t\t__exportStar(requireRecord(), exports);\n\t\t__exportStar(requireSet(), exports);\n\t\t__exportStar(string, exports);\n\t\t__exportStar(requireTuple(), exports);\n\t\t__exportStar(_undefined, exports);\n\t\t__exportStar(requireUnion(), exports);\n\t\t__exportStar(unknown, exports);\n\t\t__exportStar(zodToJsonSchema$1, exports);\n\t\tconst zodToJsonSchema_js_1 = zodToJsonSchema$1;\n\t\texports.default = zodToJsonSchema_js_1.zodToJsonSchema; \n\t} (cjs));\n\n\tvar graph_mermaid = {};\n\n\tObject.defineProperty(graph_mermaid, \"__esModule\", { value: true });\n\tgraph_mermaid.drawMermaidPng = graph_mermaid.drawMermaid = void 0;\n\tfunction _escapeNodeLabel(nodeLabel) {\n\t    // Escapes the node label for Mermaid syntax.\n\t    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n\t}\n\t// Adjusts Mermaid edge to map conditional nodes to pure nodes.\n\tfunction _adjustMermaidEdge(edge, nodes) {\n\t    const sourceNodeLabel = nodes[edge.source] ?? edge.source;\n\t    const targetNodeLabel = nodes[edge.target] ?? edge.target;\n\t    return [sourceNodeLabel, targetNodeLabel];\n\t}\n\tfunction _generateMermaidGraphStyles(nodeColors) {\n\t    let styles = \"\";\n\t    for (const [className, color] of Object.entries(nodeColors)) {\n\t        styles += `\\tclassDef ${className}class fill:${color};\\n`;\n\t    }\n\t    return styles;\n\t}\n\t/**\n\t * Draws a Mermaid graph using the provided graph data\n\t */\n\tfunction drawMermaid(nodes, edges, config) {\n\t    const { firstNodeLabel, lastNodeLabel, nodeColors, withStyles = true, curveStyle = \"linear\", wrapLabelNWords = 9, } = config ?? {};\n\t    // Initialize Mermaid graph configuration\n\t    let mermaidGraph = withStyles\n\t        ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n\t        : \"graph TD;\\n\";\n\t    if (withStyles) {\n\t        // Node formatting templates\n\t        const defaultClassLabel = \"default\";\n\t        const formatDict = {\n\t            [defaultClassLabel]: \"{0}([{1}]):::otherclass\",\n\t        };\n\t        if (firstNodeLabel !== undefined) {\n\t            formatDict[firstNodeLabel] = \"{0}[{0}]:::startclass\";\n\t        }\n\t        if (lastNodeLabel !== undefined) {\n\t            formatDict[lastNodeLabel] = \"{0}[{0}]:::endclass\";\n\t        }\n\t        // Add nodes to the graph\n\t        for (const node of Object.values(nodes)) {\n\t            const nodeLabel = formatDict[node] ?? formatDict[defaultClassLabel];\n\t            const escapedNodeLabel = _escapeNodeLabel(node);\n\t            const nodeParts = node.split(\":\");\n\t            const nodeSplit = nodeParts[nodeParts.length - 1];\n\t            mermaidGraph += `\\t${nodeLabel\n                .replace(/\\{0\\}/g, escapedNodeLabel)\n                .replace(/\\{1\\}/g, nodeSplit)};\\n`;\n\t        }\n\t    }\n\t    let subgraph = \"\";\n\t    // Add edges to the graph\n\t    for (const edge of edges) {\n\t        const sourcePrefix = edge.source.includes(\":\")\n\t            ? edge.source.split(\":\")[0]\n\t            : undefined;\n\t        const targetPrefix = edge.target.includes(\":\")\n\t            ? edge.target.split(\":\")[0]\n\t            : undefined;\n\t        // Exit subgraph if source or target is not in the same subgraph\n\t        if (subgraph !== \"\" &&\n\t            (subgraph !== sourcePrefix || subgraph !== targetPrefix)) {\n\t            mermaidGraph += \"\\tend\\n\";\n\t            subgraph = \"\";\n\t        }\n\t        // Enter subgraph if source and target are in the same subgraph\n\t        if (subgraph === \"\" &&\n\t            sourcePrefix !== undefined &&\n\t            sourcePrefix === targetPrefix) {\n\t            mermaidGraph = `\\tsubgraph ${sourcePrefix}\\n`;\n\t            subgraph = sourcePrefix;\n\t        }\n\t        const [source, target] = _adjustMermaidEdge(edge, nodes);\n\t        let edgeLabel = \"\";\n\t        // Add BR every wrapLabelNWords words\n\t        if (edge.data !== undefined) {\n\t            let edgeData = edge.data;\n\t            const words = edgeData.split(\" \");\n\t            // Group words into chunks of wrapLabelNWords size\n\t            if (words.length > wrapLabelNWords) {\n\t                edgeData = words\n\t                    .reduce((acc, word, i) => {\n\t                    if (i % wrapLabelNWords === 0)\n\t                        acc.push(\"\");\n\t                    acc[acc.length - 1] += ` ${word}`;\n\t                    return acc;\n\t                }, [])\n\t                    .join(\"<br>\");\n\t            }\n\t            if (edge.conditional) {\n\t                edgeLabel = ` -. ${edgeData} .-> `;\n\t            }\n\t            else {\n\t                edgeLabel = ` -- ${edgeData} --> `;\n\t            }\n\t        }\n\t        else {\n\t            if (edge.conditional) {\n\t                edgeLabel = ` -.-> `;\n\t            }\n\t            else {\n\t                edgeLabel = ` --> `;\n\t            }\n\t        }\n\t        mermaidGraph += `\\t${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n\t    }\n\t    if (subgraph !== \"\") {\n\t        mermaidGraph += \"end\\n\";\n\t    }\n\t    // Add custom styles for nodes\n\t    if (withStyles && nodeColors !== undefined) {\n\t        mermaidGraph += _generateMermaidGraphStyles(nodeColors);\n\t    }\n\t    return mermaidGraph;\n\t}\n\tgraph_mermaid.drawMermaid = drawMermaid;\n\t/**\n\t * Renders Mermaid graph using the Mermaid.INK API.\n\t */\n\tasync function drawMermaidPng(mermaidSyntax, config) {\n\t    let { backgroundColor = \"white\" } = config ?? {};\n\t    // Use btoa for compatibility, assume ASCII\n\t    const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n\t    // Check if the background color is a hexadecimal color code using regex\n\t    if (backgroundColor !== undefined) {\n\t        const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n\t        if (!hexColorPattern.test(backgroundColor)) {\n\t            backgroundColor = `!${backgroundColor}`;\n\t        }\n\t    }\n\t    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}`;\n\t    const res = await fetch(imageUrl);\n\t    if (!res.ok) {\n\t        throw new Error([\n\t            `Failed to render the graph using the Mermaid.INK API.`,\n\t            `Status code: ${res.status}`,\n\t            `Status text: ${res.statusText}`,\n\t        ].join(\"\\n\"));\n\t    }\n\t    const content = await res.blob();\n\t    return content;\n\t}\n\tgraph_mermaid.drawMermaidPng = drawMermaidPng;\n\n\tObject.defineProperty(graph, \"__esModule\", { value: true });\n\tgraph.Graph = void 0;\n\tconst zod_to_json_schema_1 = cjs;\n\tconst uuid_1$1 = require$$2;\n\tconst utils_js_1$2 = utils;\n\tconst graph_mermaid_js_1 = graph_mermaid;\n\tconst MAX_DATA_DISPLAY_NAME_LENGTH = 42;\n\tfunction nodeDataStr(node) {\n\t    if (!(0, uuid_1$1.validate)(node.id)) {\n\t        return node.id;\n\t    }\n\t    else if ((0, utils_js_1$2.isRunnableInterface)(node.data)) {\n\t        try {\n\t            let data = node.data.getName();\n\t            data = data.startsWith(\"Runnable\") ? data.slice(\"Runnable\".length) : data;\n\t            if (data.length > MAX_DATA_DISPLAY_NAME_LENGTH) {\n\t                data = `${data.substring(0, MAX_DATA_DISPLAY_NAME_LENGTH)}...`;\n\t            }\n\t            return data;\n\t        }\n\t        catch (error) {\n\t            return node.data.getName();\n\t        }\n\t    }\n\t    else {\n\t        return node.data.name ?? \"UnknownSchema\";\n\t    }\n\t}\n\tfunction nodeDataJson(node) {\n\t    // if node.data is implements Runnable\n\t    if ((0, utils_js_1$2.isRunnableInterface)(node.data)) {\n\t        return {\n\t            type: \"runnable\",\n\t            data: {\n\t                id: node.data.lc_id,\n\t                name: node.data.getName(),\n\t            },\n\t        };\n\t    }\n\t    else {\n\t        return {\n\t            type: \"schema\",\n\t            data: { ...(0, zod_to_json_schema_1.zodToJsonSchema)(node.data.schema), title: node.data.name },\n\t        };\n\t    }\n\t}\n\tclass Graph {\n\t    constructor() {\n\t        Object.defineProperty(this, \"nodes\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: {}\n\t        });\n\t        Object.defineProperty(this, \"edges\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: []\n\t        });\n\t    }\n\t    // Convert the graph to a JSON-serializable format.\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    toJSON() {\n\t        const stableNodeIds = {};\n\t        Object.values(this.nodes).forEach((node, i) => {\n\t            stableNodeIds[node.id] = (0, uuid_1$1.validate)(node.id) ? i : node.id;\n\t        });\n\t        return {\n\t            nodes: Object.values(this.nodes).map((node) => ({\n\t                id: stableNodeIds[node.id],\n\t                ...nodeDataJson(node),\n\t            })),\n\t            edges: this.edges.map((edge) => {\n\t                const item = {\n\t                    source: stableNodeIds[edge.source],\n\t                    target: stableNodeIds[edge.target],\n\t                };\n\t                if (typeof edge.data !== \"undefined\") {\n\t                    item.data = edge.data;\n\t                }\n\t                if (typeof edge.conditional !== \"undefined\") {\n\t                    item.conditional = edge.conditional;\n\t                }\n\t                return item;\n\t            }),\n\t        };\n\t    }\n\t    addNode(data, id) {\n\t        if (id !== undefined && this.nodes[id] !== undefined) {\n\t            throw new Error(`Node with id ${id} already exists`);\n\t        }\n\t        const nodeId = id || (0, uuid_1$1.v4)();\n\t        const node = { id: nodeId, data };\n\t        this.nodes[nodeId] = node;\n\t        return node;\n\t    }\n\t    removeNode(node) {\n\t        // Remove the node from the nodes map\n\t        delete this.nodes[node.id];\n\t        // Filter out edges connected to the node\n\t        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n\t    }\n\t    addEdge(source, target, data, conditional) {\n\t        if (this.nodes[source.id] === undefined) {\n\t            throw new Error(`Source node ${source.id} not in graph`);\n\t        }\n\t        if (this.nodes[target.id] === undefined) {\n\t            throw new Error(`Target node ${target.id} not in graph`);\n\t        }\n\t        const edge = {\n\t            source: source.id,\n\t            target: target.id,\n\t            data,\n\t            conditional,\n\t        };\n\t        this.edges.push(edge);\n\t        return edge;\n\t    }\n\t    firstNode() {\n\t        const targets = new Set(this.edges.map((edge) => edge.target));\n\t        const found = [];\n\t        Object.values(this.nodes).forEach((node) => {\n\t            if (!targets.has(node.id)) {\n\t                found.push(node);\n\t            }\n\t        });\n\t        return found[0];\n\t    }\n\t    lastNode() {\n\t        const sources = new Set(this.edges.map((edge) => edge.source));\n\t        const found = [];\n\t        Object.values(this.nodes).forEach((node) => {\n\t            if (!sources.has(node.id)) {\n\t                found.push(node);\n\t            }\n\t        });\n\t        return found[0];\n\t    }\n\t    /**\n\t     * Add all nodes and edges from another graph.\n\t     * Note this doesn't check for duplicates, nor does it connect the graphs.\n\t     */\n\t    extend(graph, prefix = \"\") {\n\t        let finalPrefix = prefix;\n\t        const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n\t        if (nodeIds.every(uuid_1$1.validate)) {\n\t            finalPrefix = \"\";\n\t        }\n\t        const prefixed = (id) => {\n\t            return finalPrefix ? `${finalPrefix}:${id}` : id;\n\t        };\n\t        Object.entries(graph.nodes).forEach(([key, value]) => {\n\t            this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n\t        });\n\t        const newEdges = graph.edges.map((edge) => {\n\t            return {\n\t                ...edge,\n\t                source: prefixed(edge.source),\n\t                target: prefixed(edge.target),\n\t            };\n\t        });\n\t        // Add all edges from the other graph\n\t        this.edges = [...this.edges, ...newEdges];\n\t        const first = graph.firstNode();\n\t        const last = graph.lastNode();\n\t        return [\n\t            first ? { id: prefixed(first.id), data: first.data } : undefined,\n\t            last ? { id: prefixed(last.id), data: last.data } : undefined,\n\t        ];\n\t    }\n\t    trimFirstNode() {\n\t        const firstNode = this.firstNode();\n\t        if (firstNode) {\n\t            const outgoingEdges = this.edges.filter((edge) => edge.source === firstNode.id);\n\t            if (Object.keys(this.nodes).length === 1 || outgoingEdges.length === 1) {\n\t                this.removeNode(firstNode);\n\t            }\n\t        }\n\t    }\n\t    trimLastNode() {\n\t        const lastNode = this.lastNode();\n\t        if (lastNode) {\n\t            const incomingEdges = this.edges.filter((edge) => edge.target === lastNode.id);\n\t            if (Object.keys(this.nodes).length === 1 || incomingEdges.length === 1) {\n\t                this.removeNode(lastNode);\n\t            }\n\t        }\n\t    }\n\t    drawMermaid(params) {\n\t        const { withStyles, curveStyle, nodeColors = { start: \"#ffdfba\", end: \"#baffc9\", other: \"#fad7de\" }, wrapLabelNWords, } = params ?? {};\n\t        const nodes = {};\n\t        for (const node of Object.values(this.nodes)) {\n\t            nodes[node.id] = nodeDataStr(node);\n\t        }\n\t        const firstNode = this.firstNode();\n\t        const firstNodeLabel = firstNode ? nodeDataStr(firstNode) : undefined;\n\t        const lastNode = this.lastNode();\n\t        const lastNodeLabel = lastNode ? nodeDataStr(lastNode) : undefined;\n\t        return (0, graph_mermaid_js_1.drawMermaid)(nodes, this.edges, {\n\t            firstNodeLabel,\n\t            lastNodeLabel,\n\t            withStyles,\n\t            curveStyle,\n\t            nodeColors,\n\t            wrapLabelNWords,\n\t        });\n\t    }\n\t    async drawMermaidPng(params) {\n\t        const mermaidSyntax = this.drawMermaid(params);\n\t        return (0, graph_mermaid_js_1.drawMermaidPng)(mermaidSyntax, {\n\t            backgroundColor: params?.backgroundColor,\n\t        });\n\t    }\n\t}\n\tgraph.Graph = Graph;\n\n\tvar wrappers = {};\n\n\tObject.defineProperty(wrappers, \"__esModule\", { value: true });\n\twrappers.convertToHttpEventStream = void 0;\n\tconst stream_js_1$1 = stream;\n\tfunction convertToHttpEventStream(stream) {\n\t    const encoder = new TextEncoder();\n\t    const finalStream = new ReadableStream({\n\t        async start(controller) {\n\t            for await (const chunk of stream) {\n\t                controller.enqueue(encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`));\n\t            }\n\t            controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n\t            controller.close();\n\t        },\n\t    });\n\t    return stream_js_1$1.IterableReadableStream.fromReadableStream(finalStream);\n\t}\n\twrappers.convertToHttpEventStream = convertToHttpEventStream;\n\n\tvar iter = {};\n\n\tObject.defineProperty(iter, \"__esModule\", { value: true });\n\titer.consumeAsyncIterableInContext = iter.consumeIteratorInContext = iter.isAsyncIterable = iter.isIterator = iter.isIterableIterator = void 0;\n\tconst index_js_1$1 = singletons;\n\tfunction isIterableIterator(thing) {\n\t    return (typeof thing === \"object\" &&\n\t        thing !== null &&\n\t        typeof thing[Symbol.iterator] === \"function\" &&\n\t        // avoid detecting array/set as iterator\n\t        typeof thing.next === \"function\");\n\t}\n\titer.isIterableIterator = isIterableIterator;\n\tconst isIterator = (x) => x != null &&\n\t    typeof x === \"object\" &&\n\t    \"next\" in x &&\n\t    typeof x.next === \"function\";\n\titer.isIterator = isIterator;\n\tfunction isAsyncIterable(thing) {\n\t    return (typeof thing === \"object\" &&\n\t        thing !== null &&\n\t        typeof thing[Symbol.asyncIterator] ===\n\t            \"function\");\n\t}\n\titer.isAsyncIterable = isAsyncIterable;\n\tfunction* consumeIteratorInContext(context, iter) {\n\t    while (true) {\n\t        const { value, done } = index_js_1$1.AsyncLocalStorageProviderSingleton.runWithConfig(context, iter.next.bind(iter), true);\n\t        if (done) {\n\t            break;\n\t        }\n\t        else {\n\t            yield value;\n\t        }\n\t    }\n\t}\n\titer.consumeIteratorInContext = consumeIteratorInContext;\n\tasync function* consumeAsyncIterableInContext(context, iter) {\n\t    const iterator = iter[Symbol.asyncIterator]();\n\t    while (true) {\n\t        const { value, done } = await index_js_1$1.AsyncLocalStorageProviderSingleton.runWithConfig(context, iterator.next.bind(iter), true);\n\t        if (done) {\n\t            break;\n\t        }\n\t        else {\n\t            yield value;\n\t        }\n\t    }\n\t}\n\titer.consumeAsyncIterableInContext = consumeAsyncIterableInContext;\n\n\tvar __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || (function (mod) {\n\t  return mod && mod.__esModule ? mod : {\n\t    \"default\": mod\n\t  };\n\t});\n\tObject.defineProperty(base$2, \"__esModule\", {\n\t  value: true\n\t});\n\tbase$2.convertRunnableToTool = base$2.RunnableToolLike = base$2.RunnablePick = base$2.RunnableAssign = base$2._coerceToRunnable = base$2.RunnableWithFallbacks = base$2.RunnableParallel = base$2.RunnableLambda = base$2.RunnableTraceable = base$2.RunnableMap = base$2.RunnableSequence = base$2.RunnableRetry = base$2.RunnableEach = base$2.RunnableBinding = base$2.Runnable = base$2._coerceToDict = void 0;\n\tconst zod_1 = lib;\n\tconst p_retry_1 = __importDefault(pRetryExports);\n\tconst uuid_1 = require$$2;\n\tconst traceable_1 = traceable;\n\tconst log_stream_js_1 = log_stream;\n\tconst event_stream_js_1 = event_stream;\n\tconst serializable_js_1 = serializable;\n\tconst stream_js_1 = stream;\n\tconst signal_js_1 = signal;\n\tconst config_js_1 = config;\n\tconst async_caller_js_1 = async_caller;\n\tconst root_listener_js_1 = root_listener;\n\tconst utils_js_1$1 = utils;\n\tconst index_js_1 = singletons;\n\tconst graph_js_1 = graph;\n\tconst wrappers_js_1 = wrappers;\n\tconst iter_js_1 = iter;\n\tconst utils_js_2 = utils$1;\n\tfunction _coerceToDict(value, defaultKey) {\n\t  return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === \"object\" ? value : {\n\t    [defaultKey]: value\n\t  };\n\t}\n\tbase$2._coerceToDict = _coerceToDict;\n\tclass Runnable extends serializable_js_1.Serializable {\n\t  constructor() {\n\t    super(...arguments);\n\t    Object.defineProperty(this, \"lc_runnable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"name\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t  }\n\t  getName(suffix) {\n\t    const name = (this.name ?? this.constructor.lc_name()) ?? this.constructor.name;\n\t    return suffix ? `${name}${suffix}` : name;\n\t  }\n\t  bind(kwargs) {\n\t    return new RunnableBinding({\n\t      bound: this,\n\t      kwargs,\n\t      config: {}\n\t    });\n\t  }\n\t  map() {\n\t    return new RunnableEach({\n\t      bound: this\n\t    });\n\t  }\n\t  withRetry(fields) {\n\t    return new RunnableRetry({\n\t      bound: this,\n\t      kwargs: {},\n\t      config: {},\n\t      maxAttemptNumber: fields?.stopAfterAttempt,\n\t      ...fields\n\t    });\n\t  }\n\t  withConfig(config) {\n\t    return new RunnableBinding({\n\t      bound: this,\n\t      config,\n\t      kwargs: {}\n\t    });\n\t  }\n\t  withFallbacks(fields) {\n\t    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n\t    return new RunnableWithFallbacks({\n\t      runnable: this,\n\t      fallbacks\n\t    });\n\t  }\n\t  _getOptionsList(options, length = 0) {\n\t    if (Array.isArray(options) && options.length !== length) {\n\t      throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n\t    }\n\t    if (Array.isArray(options)) {\n\t      return options.map(config_js_1.ensureConfig);\n\t    }\n\t    if (length > 1 && !Array.isArray(options) && options.runId) {\n\t      console.warn(\"Provided runId will be used only for the first element of the batch.\");\n\t      const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n\t      return Array.from({\n\t        length\n\t      }, (_, i) => (0, config_js_1.ensureConfig)(i === 0 ? options : subsequent));\n\t    }\n\t    return Array.from({\n\t      length\n\t    }, () => (0, config_js_1.ensureConfig)(options));\n\t  }\n\t  async batch(inputs, options, batchOptions) {\n\t    const configList = this._getOptionsList(options ?? ({}), inputs.length);\n\t    const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n\t    const caller = new async_caller_js_1.AsyncCaller({\n\t      maxConcurrency,\n\t      onFailedAttempt: e => {\n\t        throw e;\n\t      }\n\t    });\n\t    const batchCalls = inputs.map((input, i) => caller.call(async () => {\n\t      try {\n\t        const result = await this.invoke(input, configList[i]);\n\t        return result;\n\t      } catch (e) {\n\t        if (batchOptions?.returnExceptions) {\n\t          return e;\n\t        }\n\t        throw e;\n\t      }\n\t    }));\n\t    return Promise.all(batchCalls);\n\t  }\n\t  async *_streamIterator(input, options) {\n\t    yield this.invoke(input, options);\n\t  }\n\t  async stream(input, options) {\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n\t      generator: this._streamIterator(input, config),\n\t      config\n\t    });\n\t    await wrappedGenerator.setup;\n\t    return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n\t  }\n\t  _separateRunnableConfigFromCallOptions(options) {\n\t    let runnableConfig;\n\t    if (options === undefined) {\n\t      runnableConfig = (0, config_js_1.ensureConfig)(options);\n\t    } else {\n\t      runnableConfig = (0, config_js_1.ensureConfig)({\n\t        callbacks: options.callbacks,\n\t        tags: options.tags,\n\t        metadata: options.metadata,\n\t        runName: options.runName,\n\t        configurable: options.configurable,\n\t        recursionLimit: options.recursionLimit,\n\t        maxConcurrency: options.maxConcurrency,\n\t        runId: options.runId,\n\t        timeout: options.timeout,\n\t        signal: options.signal\n\t      });\n\t    }\n\t    const callOptions = {\n\t      ...options\n\t    };\n\t    delete callOptions.callbacks;\n\t    delete callOptions.tags;\n\t    delete callOptions.metadata;\n\t    delete callOptions.runName;\n\t    delete callOptions.configurable;\n\t    delete callOptions.recursionLimit;\n\t    delete callOptions.maxConcurrency;\n\t    delete callOptions.runId;\n\t    delete callOptions.timeout;\n\t    delete callOptions.signal;\n\t    return [runnableConfig, callOptions];\n\t  }\n\t  async _callWithConfig(func, input, options) {\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n\t    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n\t    delete config.runId;\n\t    let output;\n\t    try {\n\t      const promise = func.call(this, input, config, runManager);\n\t      output = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n\t    } catch (e) {\n\t      await runManager?.handleChainError(e);\n\t      throw e;\n\t    }\n\t    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n\t    return output;\n\t  }\n\t  async _batchWithConfig(func, inputs, options, batchOptions) {\n\t    const optionsList = this._getOptionsList(options ?? ({}), inputs.length);\n\t    const callbackManagers = await Promise.all(optionsList.map(config_js_1.getCallbackManagerForConfig));\n\t    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n\t      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n\t      delete optionsList[i].runId;\n\t      return handleStartRes;\n\t    }));\n\t    let outputs;\n\t    try {\n\t      const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n\t      outputs = await (0, signal_js_1.raceWithSignal)(promise, optionsList?.[0]?.signal);\n\t    } catch (e) {\n\t      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n\t      throw e;\n\t    }\n\t    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n\t    return outputs;\n\t  }\n\t  async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n\t    let finalInput;\n\t    let finalInputSupported = true;\n\t    let finalOutput;\n\t    let finalOutputSupported = true;\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n\t    async function* wrapInputForTracing() {\n\t      for await (const chunk of inputGenerator) {\n\t        if (finalInputSupported) {\n\t          if (finalInput === undefined) {\n\t            finalInput = chunk;\n\t          } else {\n\t            try {\n\t              finalInput = (0, stream_js_1.concat)(finalInput, chunk);\n\t            } catch {\n\t              finalInput = undefined;\n\t              finalInputSupported = false;\n\t            }\n\t          }\n\t        }\n\t        yield chunk;\n\t      }\n\t    }\n\t    let runManager;\n\t    try {\n\t      const pipe = await (0, stream_js_1.pipeGeneratorWithSetup)(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), {\n\t        input: \"\"\n\t      }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n\t      delete config.runId;\n\t      runManager = pipe.setup;\n\t      const streamEventsHandler = runManager?.handlers.find(event_stream_js_1.isStreamEventsHandler);\n\t      let iterator = pipe.output;\n\t      if (streamEventsHandler !== undefined && runManager !== undefined) {\n\t        iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n\t      }\n\t      const streamLogHandler = runManager?.handlers.find(log_stream_js_1.isLogStreamHandler);\n\t      if (streamLogHandler !== undefined && runManager !== undefined) {\n\t        iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n\t      }\n\t      for await (const chunk of iterator) {\n\t        yield chunk;\n\t        if (finalOutputSupported) {\n\t          if (finalOutput === undefined) {\n\t            finalOutput = chunk;\n\t          } else {\n\t            try {\n\t              finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n\t            } catch {\n\t              finalOutput = undefined;\n\t              finalOutputSupported = false;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    } catch (e) {\n\t      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n\t        inputs: _coerceToDict(finalInput, \"input\")\n\t      });\n\t      throw e;\n\t    }\n\t    await runManager?.handleChainEnd(finalOutput ?? ({}), undefined, undefined, undefined, {\n\t      inputs: _coerceToDict(finalInput, \"input\")\n\t    });\n\t  }\n\t  getGraph(_) {\n\t    const graph = new graph_js_1.Graph();\n\t    const inputNode = graph.addNode({\n\t      name: `${this.getName()}Input`,\n\t      schema: zod_1.z.any()\n\t    });\n\t    const runnableNode = graph.addNode(this);\n\t    const outputNode = graph.addNode({\n\t      name: `${this.getName()}Output`,\n\t      schema: zod_1.z.any()\n\t    });\n\t    graph.addEdge(inputNode, runnableNode);\n\t    graph.addEdge(runnableNode, outputNode);\n\t    return graph;\n\t  }\n\t  pipe(coerceable) {\n\t    return new RunnableSequence({\n\t      first: this,\n\t      last: _coerceToRunnable(coerceable)\n\t    });\n\t  }\n\t  pick(keys) {\n\t    return this.pipe(new RunnablePick(keys));\n\t  }\n\t  assign(mapping) {\n\t    return this.pipe(new RunnableAssign(new RunnableMap({\n\t      steps: mapping\n\t    })));\n\t  }\n\t  async *transform(generator, options) {\n\t    let finalChunk;\n\t    for await (const chunk of generator) {\n\t      if (finalChunk === undefined) {\n\t        finalChunk = chunk;\n\t      } else {\n\t        finalChunk = (0, stream_js_1.concat)(finalChunk, chunk);\n\t      }\n\t    }\n\t    yield* this._streamIterator(finalChunk, (0, config_js_1.ensureConfig)(options));\n\t  }\n\t  async *streamLog(input, options, streamOptions) {\n\t    const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n\t      ...streamOptions,\n\t      autoClose: false,\n\t      _schemaFormat: \"original\"\n\t    });\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    yield* this._streamLog(input, logStreamCallbackHandler, config);\n\t  }\n\t  async *_streamLog(input, logStreamCallbackHandler, config) {\n\t    const {callbacks} = config;\n\t    if (callbacks === undefined) {\n\t      config.callbacks = [logStreamCallbackHandler];\n\t    } else if (Array.isArray(callbacks)) {\n\t      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n\t    } else {\n\t      const copiedCallbacks = callbacks.copy();\n\t      copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n\t      config.callbacks = copiedCallbacks;\n\t    }\n\t    const runnableStreamPromise = this.stream(input, config);\n\t    async function consumeRunnableStream() {\n\t      try {\n\t        const runnableStream = await runnableStreamPromise;\n\t        for await (const chunk of runnableStream) {\n\t          const patch = new log_stream_js_1.RunLogPatch({\n\t            ops: [{\n\t              op: \"add\",\n\t              path: \"/streamed_output/-\",\n\t              value: chunk\n\t            }]\n\t          });\n\t          await logStreamCallbackHandler.writer.write(patch);\n\t        }\n\t      } finally {\n\t        await logStreamCallbackHandler.writer.close();\n\t      }\n\t    }\n\t    const runnableStreamConsumePromise = consumeRunnableStream();\n\t    try {\n\t      for await (const log of logStreamCallbackHandler) {\n\t        yield log;\n\t      }\n\t    } finally {\n\t      await runnableStreamConsumePromise;\n\t    }\n\t  }\n\t  streamEvents(input, options, streamOptions) {\n\t    let stream;\n\t    if (options.version === \"v1\") {\n\t      stream = this._streamEventsV1(input, options, streamOptions);\n\t    } else if (options.version === \"v2\") {\n\t      stream = this._streamEventsV2(input, options, streamOptions);\n\t    } else {\n\t      throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n\t    }\n\t    if (options.encoding === \"text/event-stream\") {\n\t      return (0, wrappers_js_1.convertToHttpEventStream)(stream);\n\t    } else {\n\t      return stream_js_1.IterableReadableStream.fromAsyncGenerator(stream);\n\t    }\n\t  }\n\t  async *_streamEventsV2(input, options, streamOptions) {\n\t    const eventStreamer = new event_stream_js_1.EventStreamCallbackHandler({\n\t      ...streamOptions,\n\t      autoClose: false\n\t    });\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const runId = config.runId ?? (0, uuid_1.v4)();\n\t    config.runId = runId;\n\t    const callbacks = config.callbacks;\n\t    if (callbacks === undefined) {\n\t      config.callbacks = [eventStreamer];\n\t    } else if (Array.isArray(callbacks)) {\n\t      config.callbacks = callbacks.concat(eventStreamer);\n\t    } else {\n\t      const copiedCallbacks = callbacks.copy();\n\t      copiedCallbacks.addHandler(eventStreamer, true);\n\t      config.callbacks = copiedCallbacks;\n\t    }\n\t    const outerThis = this;\n\t    async function consumeRunnableStream() {\n\t      try {\n\t        const runnableStream = await outerThis.stream(input, config);\n\t        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n\t        for await (const _ of tappedStream) {}\n\t      } finally {\n\t        await eventStreamer.finish();\n\t      }\n\t    }\n\t    const runnableStreamConsumePromise = consumeRunnableStream();\n\t    let firstEventSent = false;\n\t    let firstEventRunId;\n\t    try {\n\t      for await (const event of eventStreamer) {\n\t        if (!firstEventSent) {\n\t          event.data.input = input;\n\t          firstEventSent = true;\n\t          firstEventRunId = event.run_id;\n\t          yield event;\n\t          continue;\n\t        }\n\t        if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n\t          if (event.data?.input) {\n\t            delete event.data.input;\n\t          }\n\t        }\n\t        yield event;\n\t      }\n\t    } finally {\n\t      await runnableStreamConsumePromise;\n\t    }\n\t  }\n\t  async *_streamEventsV1(input, options, streamOptions) {\n\t    let runLog;\n\t    let hasEncounteredStartEvent = false;\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const rootTags = config.tags ?? [];\n\t    const rootMetadata = config.metadata ?? ({});\n\t    const rootName = config.runName ?? this.getName();\n\t    const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n\t      ...streamOptions,\n\t      autoClose: false,\n\t      _schemaFormat: \"streaming_events\"\n\t    });\n\t    const rootEventFilter = new utils_js_1$1._RootEventFilter({\n\t      ...streamOptions\n\t    });\n\t    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n\t    for await (const log of logStream) {\n\t      if (!runLog) {\n\t        runLog = log_stream_js_1.RunLog.fromRunLogPatch(log);\n\t      } else {\n\t        runLog = runLog.concat(log);\n\t      }\n\t      if (runLog.state === undefined) {\n\t        throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n\t      }\n\t      if (!hasEncounteredStartEvent) {\n\t        hasEncounteredStartEvent = true;\n\t        const state = {\n\t          ...runLog.state\n\t        };\n\t        const event = {\n\t          run_id: state.id,\n\t          event: `on_${state.type}_start`,\n\t          name: rootName,\n\t          tags: rootTags,\n\t          metadata: rootMetadata,\n\t          data: {\n\t            input\n\t          }\n\t        };\n\t        if (rootEventFilter.includeEvent(event, state.type)) {\n\t          yield event;\n\t        }\n\t      }\n\t      const paths = log.ops.filter(op => op.path.startsWith(\"/logs/\")).map(op => op.path.split(\"/\")[2]);\n\t      const dedupedPaths = [...new Set(paths)];\n\t      for (const path of dedupedPaths) {\n\t        let eventType;\n\t        let data = {};\n\t        const logEntry = runLog.state.logs[path];\n\t        if (logEntry.end_time === undefined) {\n\t          if (logEntry.streamed_output.length > 0) {\n\t            eventType = \"stream\";\n\t          } else {\n\t            eventType = \"start\";\n\t          }\n\t        } else {\n\t          eventType = \"end\";\n\t        }\n\t        if (eventType === \"start\") {\n\t          if (logEntry.inputs !== undefined) {\n\t            data.input = logEntry.inputs;\n\t          }\n\t        } else if (eventType === \"end\") {\n\t          if (logEntry.inputs !== undefined) {\n\t            data.input = logEntry.inputs;\n\t          }\n\t          data.output = logEntry.final_output;\n\t        } else if (eventType === \"stream\") {\n\t          const chunkCount = logEntry.streamed_output.length;\n\t          if (chunkCount !== 1) {\n\t            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n\t          }\n\t          data = {\n\t            chunk: logEntry.streamed_output[0]\n\t          };\n\t          logEntry.streamed_output = [];\n\t        }\n\t        yield {\n\t          event: `on_${logEntry.type}_${eventType}`,\n\t          name: logEntry.name,\n\t          run_id: logEntry.id,\n\t          tags: logEntry.tags,\n\t          metadata: logEntry.metadata,\n\t          data\n\t        };\n\t      }\n\t      const {state} = runLog;\n\t      if (state.streamed_output.length > 0) {\n\t        const chunkCount = state.streamed_output.length;\n\t        if (chunkCount !== 1) {\n\t          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n\t        }\n\t        const data = {\n\t          chunk: state.streamed_output[0]\n\t        };\n\t        state.streamed_output = [];\n\t        const event = {\n\t          event: `on_${state.type}_stream`,\n\t          run_id: state.id,\n\t          tags: rootTags,\n\t          metadata: rootMetadata,\n\t          name: rootName,\n\t          data\n\t        };\n\t        if (rootEventFilter.includeEvent(event, state.type)) {\n\t          yield event;\n\t        }\n\t      }\n\t    }\n\t    const state = runLog?.state;\n\t    if (state !== undefined) {\n\t      const event = {\n\t        event: `on_${state.type}_end`,\n\t        name: rootName,\n\t        run_id: state.id,\n\t        tags: rootTags,\n\t        metadata: rootMetadata,\n\t        data: {\n\t          output: state.final_output\n\t        }\n\t      };\n\t      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n\t    }\n\t  }\n\t  static isRunnable(thing) {\n\t    return (0, utils_js_1$1.isRunnableInterface)(thing);\n\t  }\n\t  withListeners({onStart, onEnd, onError}) {\n\t    return new RunnableBinding({\n\t      bound: this,\n\t      config: {},\n\t      configFactories: [config => ({\n\t        callbacks: [new root_listener_js_1.RootListenersTracer({\n\t          config,\n\t          onStart,\n\t          onEnd,\n\t          onError\n\t        })]\n\t      })]\n\t    });\n\t  }\n\t  asTool(fields) {\n\t    return convertRunnableToTool(this, fields);\n\t  }\n\t}\n\tbase$2.Runnable = Runnable;\n\tclass RunnableBinding extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnableBinding\";\n\t  }\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"bound\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"config\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"kwargs\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"configFactories\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.bound = fields.bound;\n\t    this.kwargs = fields.kwargs;\n\t    this.config = fields.config;\n\t    this.configFactories = fields.configFactories;\n\t  }\n\t  getName(suffix) {\n\t    return this.bound.getName(suffix);\n\t  }\n\t  async _mergeConfig(...options) {\n\t    const config = (0, config_js_1.mergeConfigs)(this.config, ...options);\n\t    return (0, config_js_1.mergeConfigs)(config, ...this.configFactories ? await Promise.all(this.configFactories.map(async configFactory => await configFactory(config))) : []);\n\t  }\n\t  bind(kwargs) {\n\t    return new this.constructor({\n\t      bound: this.bound,\n\t      kwargs: {\n\t        ...this.kwargs,\n\t        ...kwargs\n\t      },\n\t      config: this.config\n\t    });\n\t  }\n\t  withConfig(config) {\n\t    return new this.constructor({\n\t      bound: this.bound,\n\t      kwargs: this.kwargs,\n\t      config: {\n\t        ...this.config,\n\t        ...config\n\t      }\n\t    });\n\t  }\n\t  withRetry(fields) {\n\t    return new this.constructor({\n\t      bound: this.bound.withRetry(fields),\n\t      kwargs: this.kwargs,\n\t      config: this.config\n\t    });\n\t  }\n\t  async invoke(input, options) {\n\t    return this.bound.invoke(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n\t  }\n\t  async batch(inputs, options, batchOptions) {\n\t    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async individualOption => this._mergeConfig((0, config_js_1.ensureConfig)(individualOption), this.kwargs))) : await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs);\n\t    return this.bound.batch(inputs, mergedOptions, batchOptions);\n\t  }\n\t  async *_streamIterator(input, options) {\n\t    yield* this.bound._streamIterator(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n\t  }\n\t  async stream(input, options) {\n\t    return this.bound.stream(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n\t  }\n\t  async *transform(generator, options) {\n\t    yield* this.bound.transform(generator, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n\t  }\n\t  streamEvents(input, options, streamOptions) {\n\t    const outerThis = this;\n\t    const generator = async function* () {\n\t      yield* outerThis.bound.streamEvents(input, {\n\t        ...await outerThis._mergeConfig((0, config_js_1.ensureConfig)(options), outerThis.kwargs),\n\t        version: options.version\n\t      }, streamOptions);\n\t    };\n\t    return stream_js_1.IterableReadableStream.fromAsyncGenerator(generator());\n\t  }\n\t  static isRunnableBinding(thing) {\n\t    return thing.bound && Runnable.isRunnable(thing.bound);\n\t  }\n\t  withListeners({onStart, onEnd, onError}) {\n\t    return new RunnableBinding({\n\t      bound: this.bound,\n\t      kwargs: this.kwargs,\n\t      config: this.config,\n\t      configFactories: [config => ({\n\t        callbacks: [new root_listener_js_1.RootListenersTracer({\n\t          config,\n\t          onStart,\n\t          onEnd,\n\t          onError\n\t        })]\n\t      })]\n\t    });\n\t  }\n\t}\n\tbase$2.RunnableBinding = RunnableBinding;\n\tclass RunnableEach extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnableEach\";\n\t  }\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"bound\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.bound = fields.bound;\n\t  }\n\t  bind(kwargs) {\n\t    return new RunnableEach({\n\t      bound: this.bound.bind(kwargs)\n\t    });\n\t  }\n\t  async invoke(inputs, config) {\n\t    return this._callWithConfig(this._invoke.bind(this), inputs, config);\n\t  }\n\t  async _invoke(inputs, config, runManager) {\n\t    return this.bound.batch(inputs, (0, config_js_1.patchConfig)(config, {\n\t      callbacks: runManager?.getChild()\n\t    }));\n\t  }\n\t  withListeners({onStart, onEnd, onError}) {\n\t    return new RunnableEach({\n\t      bound: this.bound.withListeners({\n\t        onStart,\n\t        onEnd,\n\t        onError\n\t      })\n\t    });\n\t  }\n\t}\n\tbase$2.RunnableEach = RunnableEach;\n\tclass RunnableRetry extends RunnableBinding {\n\t  static lc_name() {\n\t    return \"RunnableRetry\";\n\t  }\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"maxAttemptNumber\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: 3\n\t    });\n\t    Object.defineProperty(this, \"onFailedAttempt\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: () => {}\n\t    });\n\t    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n\t    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n\t  }\n\t  _patchConfigForRetry(attempt, config, runManager) {\n\t    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n\t    return (0, config_js_1.patchConfig)(config, {\n\t      callbacks: runManager?.getChild(tag)\n\t    });\n\t  }\n\t  async _invoke(input, config, runManager) {\n\t    return (0, p_retry_1.default)(attemptNumber => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n\t      onFailedAttempt: error => this.onFailedAttempt(error, input),\n\t      retries: Math.max(this.maxAttemptNumber - 1, 0),\n\t      randomize: true\n\t    });\n\t  }\n\t  async invoke(input, config) {\n\t    return this._callWithConfig(this._invoke.bind(this), input, config);\n\t  }\n\t  async _batch(inputs, configs, runManagers, batchOptions) {\n\t    const resultsMap = {};\n\t    try {\n\t      await (0, p_retry_1.default)(async attemptNumber => {\n\t        const remainingIndexes = inputs.map((_, i) => i).filter(i => resultsMap[i.toString()] === undefined || resultsMap[i.toString()] instanceof Error);\n\t        const remainingInputs = remainingIndexes.map(i => inputs[i]);\n\t        const patchedConfigs = remainingIndexes.map(i => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n\t        const results = await super.batch(remainingInputs, patchedConfigs, {\n\t          ...batchOptions,\n\t          returnExceptions: true\n\t        });\n\t        let firstException;\n\t        for (let i = 0; i < results.length; i += 1) {\n\t          const result = results[i];\n\t          const resultMapIndex = remainingIndexes[i];\n\t          if (result instanceof Error) {\n\t            if (firstException === undefined) {\n\t              firstException = result;\n\t              firstException.input = remainingInputs[i];\n\t            }\n\t          }\n\t          resultsMap[resultMapIndex.toString()] = result;\n\t        }\n\t        if (firstException) {\n\t          throw firstException;\n\t        }\n\t        return results;\n\t      }, {\n\t        onFailedAttempt: error => this.onFailedAttempt(error, error.input),\n\t        retries: Math.max(this.maxAttemptNumber - 1, 0),\n\t        randomize: true\n\t      });\n\t    } catch (e) {\n\t      if (batchOptions?.returnExceptions !== true) {\n\t        throw e;\n\t      }\n\t    }\n\t    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map(key => resultsMap[parseInt(key, 10)]);\n\t  }\n\t  async batch(inputs, options, batchOptions) {\n\t    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n\t  }\n\t}\n\tbase$2.RunnableRetry = RunnableRetry;\n\tclass RunnableSequence extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnableSequence\";\n\t  }\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"first\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"middle\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: []\n\t    });\n\t    Object.defineProperty(this, \"last\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    this.first = fields.first;\n\t    this.middle = fields.middle ?? this.middle;\n\t    this.last = fields.last;\n\t    this.name = fields.name;\n\t  }\n\t  get steps() {\n\t    return [this.first, ...this.middle, this.last];\n\t  }\n\t  async invoke(input, options) {\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n\t    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n\t    delete config.runId;\n\t    let nextStepInput = input;\n\t    let finalOutput;\n\t    try {\n\t      const initialSteps = [this.first, ...this.middle];\n\t      for (let i = 0; i < initialSteps.length; i += 1) {\n\t        const step = initialSteps[i];\n\t        const promise = step.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n\t          callbacks: runManager?.getChild(`seq:step:${i + 1}`)\n\t        }));\n\t        nextStepInput = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n\t      }\n\t      if (options?.signal?.aborted) {\n\t        throw new Error(\"Aborted\");\n\t      }\n\t      finalOutput = await this.last.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n\t        callbacks: runManager?.getChild(`seq:step:${this.steps.length}`)\n\t      }));\n\t    } catch (e) {\n\t      await runManager?.handleChainError(e);\n\t      throw e;\n\t    }\n\t    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n\t    return finalOutput;\n\t  }\n\t  async batch(inputs, options, batchOptions) {\n\t    const configList = this._getOptionsList(options ?? ({}), inputs.length);\n\t    const callbackManagers = await Promise.all(configList.map(config_js_1.getCallbackManagerForConfig));\n\t    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n\t      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n\t      delete configList[i].runId;\n\t      return handleStartRes;\n\t    }));\n\t    let nextStepInputs = inputs;\n\t    try {\n\t      for (let i = 0; i < this.steps.length; i += 1) {\n\t        const step = this.steps[i];\n\t        const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n\t          const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n\t          return (0, config_js_1.patchConfig)(configList[j], {\n\t            callbacks: childRunManager\n\t          });\n\t        }), batchOptions);\n\t        nextStepInputs = await (0, signal_js_1.raceWithSignal)(promise, configList[0]?.signal);\n\t      }\n\t    } catch (e) {\n\t      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n\t      throw e;\n\t    }\n\t    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n\t    return nextStepInputs;\n\t  }\n\t  async *_streamIterator(input, options) {\n\t    const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n\t    const {runId, ...otherOptions} = options ?? ({});\n\t    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n\t    const steps = [this.first, ...this.middle, this.last];\n\t    let concatSupported = true;\n\t    let finalOutput;\n\t    async function* inputGenerator() {\n\t      yield input;\n\t    }\n\t    try {\n\t      let finalGenerator = steps[0].transform(inputGenerator(), (0, config_js_1.patchConfig)(otherOptions, {\n\t        callbacks: runManager?.getChild(`seq:step:1`)\n\t      }));\n\t      for (let i = 1; i < steps.length; i += 1) {\n\t        const step = steps[i];\n\t        finalGenerator = await step.transform(finalGenerator, (0, config_js_1.patchConfig)(otherOptions, {\n\t          callbacks: runManager?.getChild(`seq:step:${i + 1}`)\n\t        }));\n\t      }\n\t      for await (const chunk of finalGenerator) {\n\t        options?.signal?.throwIfAborted();\n\t        yield chunk;\n\t        if (concatSupported) {\n\t          if (finalOutput === undefined) {\n\t            finalOutput = chunk;\n\t          } else {\n\t            try {\n\t              finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n\t            } catch (e) {\n\t              finalOutput = undefined;\n\t              concatSupported = false;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    } catch (e) {\n\t      await runManager?.handleChainError(e);\n\t      throw e;\n\t    }\n\t    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n\t  }\n\t  getGraph(config) {\n\t    const graph = new graph_js_1.Graph();\n\t    let currentLastNode = null;\n\t    this.steps.forEach((step, index) => {\n\t      const stepGraph = step.getGraph(config);\n\t      if (index !== 0) {\n\t        stepGraph.trimFirstNode();\n\t      }\n\t      if (index !== this.steps.length - 1) {\n\t        stepGraph.trimLastNode();\n\t      }\n\t      graph.extend(stepGraph);\n\t      const stepFirstNode = stepGraph.firstNode();\n\t      if (!stepFirstNode) {\n\t        throw new Error(`Runnable ${step} has no first node`);\n\t      }\n\t      if (currentLastNode) {\n\t        graph.addEdge(currentLastNode, stepFirstNode);\n\t      }\n\t      currentLastNode = stepGraph.lastNode();\n\t    });\n\t    return graph;\n\t  }\n\t  pipe(coerceable) {\n\t    if (RunnableSequence.isRunnableSequence(coerceable)) {\n\t      return new RunnableSequence({\n\t        first: this.first,\n\t        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n\t        last: coerceable.last,\n\t        name: this.name ?? coerceable.name\n\t      });\n\t    } else {\n\t      return new RunnableSequence({\n\t        first: this.first,\n\t        middle: [...this.middle, this.last],\n\t        last: _coerceToRunnable(coerceable),\n\t        name: this.name\n\t      });\n\t    }\n\t  }\n\t  static isRunnableSequence(thing) {\n\t    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n\t  }\n\t  static from([first, ...runnables], name) {\n\t    return new RunnableSequence({\n\t      first: _coerceToRunnable(first),\n\t      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n\t      last: _coerceToRunnable(runnables[runnables.length - 1]),\n\t      name\n\t    });\n\t  }\n\t}\n\tbase$2.RunnableSequence = RunnableSequence;\n\tclass RunnableMap extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnableMap\";\n\t  }\n\t  getStepsKeys() {\n\t    return Object.keys(this.steps);\n\t  }\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"steps\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.steps = {};\n\t    for (const [key, value] of Object.entries(fields.steps)) {\n\t      this.steps[key] = _coerceToRunnable(value);\n\t    }\n\t  }\n\t  static from(steps) {\n\t    return new RunnableMap({\n\t      steps\n\t    });\n\t  }\n\t  async invoke(input, options) {\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n\t    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n\t      input\n\t    }, config.runId, undefined, undefined, undefined, config?.runName);\n\t    delete config.runId;\n\t    const output = {};\n\t    try {\n\t      const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n\t        output[key] = await runnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n\t          callbacks: runManager?.getChild(`map:key:${key}`)\n\t        }));\n\t      });\n\t      await (0, signal_js_1.raceWithSignal)(Promise.all(promises), options?.signal);\n\t    } catch (e) {\n\t      await runManager?.handleChainError(e);\n\t      throw e;\n\t    }\n\t    await runManager?.handleChainEnd(output);\n\t    return output;\n\t  }\n\t  async *_transform(generator, runManager, options) {\n\t    const steps = {\n\t      ...this.steps\n\t    };\n\t    const inputCopies = (0, stream_js_1.atee)(generator, Object.keys(steps).length);\n\t    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n\t      const gen = runnable.transform(inputCopies[i], (0, config_js_1.patchConfig)(options, {\n\t        callbacks: runManager?.getChild(`map:key:${key}`)\n\t      }));\n\t      return [key, gen.next().then(result => ({\n\t        key,\n\t        gen,\n\t        result\n\t      }))];\n\t    }));\n\t    while (tasks.size) {\n\t      const promise = Promise.race(tasks.values());\n\t      const {key, result, gen} = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n\t      tasks.delete(key);\n\t      if (!result.done) {\n\t        yield {\n\t          [key]: result.value\n\t        };\n\t        tasks.set(key, gen.next().then(result => ({\n\t          key,\n\t          gen,\n\t          result\n\t        })));\n\t      }\n\t    }\n\t  }\n\t  transform(generator, options) {\n\t    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n\t  }\n\t  async stream(input, options) {\n\t    async function* generator() {\n\t      yield input;\n\t    }\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n\t      generator: this.transform(generator(), config),\n\t      config\n\t    });\n\t    await wrappedGenerator.setup;\n\t    return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n\t  }\n\t}\n\tbase$2.RunnableMap = RunnableMap;\n\tclass RunnableTraceable extends Runnable {\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: false\n\t    });\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"func\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    if (!(0, traceable_1.isTraceableFunction)(fields.func)) {\n\t      throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n\t    }\n\t    this.func = fields.func;\n\t  }\n\t  async invoke(input, options) {\n\t    const [config] = this._getOptionsList(options ?? ({}), 1);\n\t    const callbacks = await (0, config_js_1.getCallbackManagerForConfig)(config);\n\t    const promise = this.func((0, config_js_1.patchConfig)(config, {\n\t      callbacks\n\t    }), input);\n\t    return (0, signal_js_1.raceWithSignal)(promise, config?.signal);\n\t  }\n\t  async *_streamIterator(input, options) {\n\t    const [config] = this._getOptionsList(options ?? ({}), 1);\n\t    const result = await this.invoke(input, options);\n\t    if ((0, iter_js_1.isAsyncIterable)(result)) {\n\t      for await (const item of result) {\n\t        config?.signal?.throwIfAborted();\n\t        yield item;\n\t      }\n\t      return;\n\t    }\n\t    if ((0, iter_js_1.isIterator)(result)) {\n\t      while (true) {\n\t        config?.signal?.throwIfAborted();\n\t        const state = result.next();\n\t        if (state.done) break;\n\t        yield state.value;\n\t      }\n\t      return;\n\t    }\n\t    yield result;\n\t  }\n\t  static from(func) {\n\t    return new RunnableTraceable({\n\t      func\n\t    });\n\t  }\n\t}\n\tbase$2.RunnableTraceable = RunnableTraceable;\n\tfunction assertNonTraceableFunction(func) {\n\t  if ((0, traceable_1.isTraceableFunction)(func)) {\n\t    throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n\t  }\n\t}\n\tclass RunnableLambda extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnableLambda\";\n\t  }\n\t  constructor(fields) {\n\t    if ((0, traceable_1.isTraceableFunction)(fields.func)) {\n\t      return RunnableTraceable.from(fields.func);\n\t    }\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"func\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    assertNonTraceableFunction(fields.func);\n\t    this.func = fields.func;\n\t  }\n\t  static from(func) {\n\t    return new RunnableLambda({\n\t      func\n\t    });\n\t  }\n\t  async _invoke(input, config, runManager) {\n\t    return new Promise((resolve, reject) => {\n\t      const childConfig = (0, config_js_1.patchConfig)(config, {\n\t        callbacks: runManager?.getChild(),\n\t        recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1\n\t      });\n\t      void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n\t        try {\n\t          let output = await this.func(input, {\n\t            ...childConfig\n\t          });\n\t          if (output && Runnable.isRunnable(output)) {\n\t            if (config?.recursionLimit === 0) {\n\t              throw new Error(\"Recursion limit reached.\");\n\t            }\n\t            output = await output.invoke(input, {\n\t              ...childConfig,\n\t              recursionLimit: (childConfig.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1\n\t            });\n\t          } else if ((0, iter_js_1.isAsyncIterable)(output)) {\n\t            let finalOutput;\n\t            for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n\t              config?.signal?.throwIfAborted();\n\t              if (finalOutput === undefined) {\n\t                finalOutput = chunk;\n\t              } else {\n\t                try {\n\t                  finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n\t                } catch (e) {\n\t                  finalOutput = chunk;\n\t                }\n\t              }\n\t            }\n\t            output = finalOutput;\n\t          } else if ((0, iter_js_1.isIterableIterator)(output)) {\n\t            let finalOutput;\n\t            for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n\t              config?.signal?.throwIfAborted();\n\t              if (finalOutput === undefined) {\n\t                finalOutput = chunk;\n\t              } else {\n\t                try {\n\t                  finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n\t                } catch (e) {\n\t                  finalOutput = chunk;\n\t                }\n\t              }\n\t            }\n\t            output = finalOutput;\n\t          }\n\t          resolve(output);\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      });\n\t    });\n\t  }\n\t  async invoke(input, options) {\n\t    return this._callWithConfig(this._invoke.bind(this), input, options);\n\t  }\n\t  async *_transform(generator, runManager, config) {\n\t    let finalChunk;\n\t    for await (const chunk of generator) {\n\t      if (finalChunk === undefined) {\n\t        finalChunk = chunk;\n\t      } else {\n\t        try {\n\t          finalChunk = (0, stream_js_1.concat)(finalChunk, chunk);\n\t        } catch (e) {\n\t          finalChunk = chunk;\n\t        }\n\t      }\n\t    }\n\t    const childConfig = (0, config_js_1.patchConfig)(config, {\n\t      callbacks: runManager?.getChild(),\n\t      recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1\n\t    });\n\t    const output = await new Promise((resolve, reject) => {\n\t      void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n\t        try {\n\t          const res = await this.func(finalChunk, {\n\t            ...childConfig,\n\t            config: childConfig\n\t          });\n\t          resolve(res);\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      });\n\t    });\n\t    if (output && Runnable.isRunnable(output)) {\n\t      if (config?.recursionLimit === 0) {\n\t        throw new Error(\"Recursion limit reached.\");\n\t      }\n\t      const stream = await output.stream(finalChunk, childConfig);\n\t      for await (const chunk of stream) {\n\t        yield chunk;\n\t      }\n\t    } else if ((0, iter_js_1.isAsyncIterable)(output)) {\n\t      for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n\t        config?.signal?.throwIfAborted();\n\t        yield chunk;\n\t      }\n\t    } else if ((0, iter_js_1.isIterableIterator)(output)) {\n\t      for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n\t        config?.signal?.throwIfAborted();\n\t        yield chunk;\n\t      }\n\t    } else {\n\t      yield output;\n\t    }\n\t  }\n\t  transform(generator, options) {\n\t    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n\t  }\n\t  async stream(input, options) {\n\t    async function* generator() {\n\t      yield input;\n\t    }\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n\t      generator: this.transform(generator(), config),\n\t      config\n\t    });\n\t    await wrappedGenerator.setup;\n\t    return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n\t  }\n\t}\n\tbase$2.RunnableLambda = RunnableLambda;\n\tclass RunnableParallel extends RunnableMap {}\n\tbase$2.RunnableParallel = RunnableParallel;\n\tclass RunnableWithFallbacks extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnableWithFallbacks\";\n\t  }\n\t  constructor(fields) {\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"runnable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"fallbacks\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.runnable = fields.runnable;\n\t    this.fallbacks = fields.fallbacks;\n\t  }\n\t  *runnables() {\n\t    yield this.runnable;\n\t    for (const fallback of this.fallbacks) {\n\t      yield fallback;\n\t    }\n\t  }\n\t  async invoke(input, options) {\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n\t    const {runId, ...otherConfigFields} = config;\n\t    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n\t    let firstError;\n\t    for (const runnable of this.runnables()) {\n\t      config?.signal?.throwIfAborted();\n\t      try {\n\t        const output = await runnable.invoke(input, (0, config_js_1.patchConfig)(otherConfigFields, {\n\t          callbacks: runManager?.getChild()\n\t        }));\n\t        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n\t        return output;\n\t      } catch (e) {\n\t        if (firstError === undefined) {\n\t          firstError = e;\n\t        }\n\t      }\n\t    }\n\t    if (firstError === undefined) {\n\t      throw new Error(\"No error stored at end of fallback.\");\n\t    }\n\t    await runManager?.handleChainError(firstError);\n\t    throw firstError;\n\t  }\n\t  async *_streamIterator(input, options) {\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n\t    const {runId, ...otherConfigFields} = config;\n\t    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n\t    let firstError;\n\t    let stream;\n\t    for (const runnable of this.runnables()) {\n\t      config?.signal?.throwIfAborted();\n\t      const childConfig = (0, config_js_1.patchConfig)(otherConfigFields, {\n\t        callbacks: runManager?.getChild()\n\t      });\n\t      try {\n\t        stream = await runnable.stream(input, childConfig);\n\t        break;\n\t      } catch (e) {\n\t        if (firstError === undefined) {\n\t          firstError = e;\n\t        }\n\t      }\n\t    }\n\t    if (stream === undefined) {\n\t      const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n\t      await runManager?.handleChainError(error);\n\t      throw error;\n\t    }\n\t    let output;\n\t    try {\n\t      for await (const chunk of stream) {\n\t        yield chunk;\n\t        try {\n\t          output = output === undefined ? output : (0, stream_js_1.concat)(output, chunk);\n\t        } catch (e) {\n\t          output = undefined;\n\t        }\n\t      }\n\t    } catch (e) {\n\t      await runManager?.handleChainError(e);\n\t      throw e;\n\t    }\n\t    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n\t  }\n\t  async batch(inputs, options, batchOptions) {\n\t    if (batchOptions?.returnExceptions) {\n\t      throw new Error(\"Not implemented.\");\n\t    }\n\t    const configList = this._getOptionsList(options ?? ({}), inputs.length);\n\t    const callbackManagers = await Promise.all(configList.map(config => (0, config_js_1.getCallbackManagerForConfig)(config)));\n\t    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n\t      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n\t      delete configList[i].runId;\n\t      return handleStartRes;\n\t    }));\n\t    let firstError;\n\t    for (const runnable of this.runnables()) {\n\t      configList[0].signal?.throwIfAborted();\n\t      try {\n\t        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => (0, config_js_1.patchConfig)(configList[j], {\n\t          callbacks: runManager?.getChild()\n\t        })), batchOptions);\n\t        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n\t        return outputs;\n\t      } catch (e) {\n\t        if (firstError === undefined) {\n\t          firstError = e;\n\t        }\n\t      }\n\t    }\n\t    if (!firstError) {\n\t      throw new Error(\"No error stored at end of fallbacks.\");\n\t    }\n\t    await Promise.all(runManagers.map(runManager => runManager?.handleChainError(firstError)));\n\t    throw firstError;\n\t  }\n\t}\n\tbase$2.RunnableWithFallbacks = RunnableWithFallbacks;\n\tfunction _coerceToRunnable(coerceable) {\n\t  if (typeof coerceable === \"function\") {\n\t    return new RunnableLambda({\n\t      func: coerceable\n\t    });\n\t  } else if (Runnable.isRunnable(coerceable)) {\n\t    return coerceable;\n\t  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n\t    const runnables = {};\n\t    for (const [key, value] of Object.entries(coerceable)) {\n\t      runnables[key] = _coerceToRunnable(value);\n\t    }\n\t    return new RunnableMap({\n\t      steps: runnables\n\t    });\n\t  } else {\n\t    throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n\t  }\n\t}\n\tbase$2._coerceToRunnable = _coerceToRunnable;\n\tclass RunnableAssign extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnableAssign\";\n\t  }\n\t  constructor(fields) {\n\t    if (fields instanceof RunnableMap) {\n\t      fields = {\n\t        mapper: fields\n\t      };\n\t    }\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"mapper\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.mapper = fields.mapper;\n\t  }\n\t  async invoke(input, options) {\n\t    const mapperResult = await this.mapper.invoke(input, options);\n\t    return {\n\t      ...input,\n\t      ...mapperResult\n\t    };\n\t  }\n\t  async *_transform(generator, runManager, options) {\n\t    const mapperKeys = this.mapper.getStepsKeys();\n\t    const [forPassthrough, forMapper] = (0, stream_js_1.atee)(generator);\n\t    const mapperOutput = this.mapper.transform(forMapper, (0, config_js_1.patchConfig)(options, {\n\t      callbacks: runManager?.getChild()\n\t    }));\n\t    const firstMapperChunkPromise = mapperOutput.next();\n\t    for await (const chunk of forPassthrough) {\n\t      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n\t        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n\t      }\n\t      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n\t      if (Object.keys(filtered).length > 0) {\n\t        yield filtered;\n\t      }\n\t    }\n\t    yield (await firstMapperChunkPromise).value;\n\t    for await (const chunk of mapperOutput) {\n\t      yield chunk;\n\t    }\n\t  }\n\t  transform(generator, options) {\n\t    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n\t  }\n\t  async stream(input, options) {\n\t    async function* generator() {\n\t      yield input;\n\t    }\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n\t      generator: this.transform(generator(), config),\n\t      config\n\t    });\n\t    await wrappedGenerator.setup;\n\t    return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n\t  }\n\t}\n\tbase$2.RunnableAssign = RunnableAssign;\n\tclass RunnablePick extends Runnable {\n\t  static lc_name() {\n\t    return \"RunnablePick\";\n\t  }\n\t  constructor(fields) {\n\t    if (typeof fields === \"string\" || Array.isArray(fields)) {\n\t      fields = {\n\t        keys: fields\n\t      };\n\t    }\n\t    super(fields);\n\t    Object.defineProperty(this, \"lc_namespace\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: [\"langchain_core\", \"runnables\"]\n\t    });\n\t    Object.defineProperty(this, \"lc_serializable\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: true\n\t    });\n\t    Object.defineProperty(this, \"keys\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.keys = fields.keys;\n\t  }\n\t  async _pick(input) {\n\t    if (typeof this.keys === \"string\") {\n\t      return input[this.keys];\n\t    } else {\n\t      const picked = this.keys.map(key => [key, input[key]]).filter(v => v[1] !== undefined);\n\t      return picked.length === 0 ? undefined : Object.fromEntries(picked);\n\t    }\n\t  }\n\t  async invoke(input, options) {\n\t    return this._callWithConfig(this._pick.bind(this), input, options);\n\t  }\n\t  async *_transform(generator) {\n\t    for await (const chunk of generator) {\n\t      const picked = await this._pick(chunk);\n\t      if (picked !== undefined) {\n\t        yield picked;\n\t      }\n\t    }\n\t  }\n\t  transform(generator, options) {\n\t    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n\t  }\n\t  async stream(input, options) {\n\t    async function* generator() {\n\t      yield input;\n\t    }\n\t    const config = (0, config_js_1.ensureConfig)(options);\n\t    const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n\t      generator: this.transform(generator(), config),\n\t      config\n\t    });\n\t    await wrappedGenerator.setup;\n\t    return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n\t  }\n\t}\n\tbase$2.RunnablePick = RunnablePick;\n\tclass RunnableToolLike extends RunnableBinding {\n\t  constructor(fields) {\n\t    const sequence = RunnableSequence.from([RunnableLambda.from(async input => {\n\t      let toolInput;\n\t      if ((0, utils_js_2._isToolCall)(input)) {\n\t        try {\n\t          toolInput = await this.schema.parseAsync(input.args);\n\t        } catch (e) {\n\t          throw new utils_js_2.ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n\t        }\n\t      } else {\n\t        toolInput = input;\n\t      }\n\t      return toolInput;\n\t    }).withConfig({\n\t      runName: `${fields.name}:parse_input`\n\t    }), fields.bound]).withConfig({\n\t      runName: fields.name\n\t    });\n\t    super({\n\t      bound: sequence,\n\t      config: fields.config ?? ({})\n\t    });\n\t    Object.defineProperty(this, \"name\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"description\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    Object.defineProperty(this, \"schema\", {\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true,\n\t      value: void 0\n\t    });\n\t    this.name = fields.name;\n\t    this.description = fields.description;\n\t    this.schema = fields.schema;\n\t  }\n\t  static lc_name() {\n\t    return \"RunnableToolLike\";\n\t  }\n\t}\n\tbase$2.RunnableToolLike = RunnableToolLike;\n\tfunction convertRunnableToTool(runnable, fields) {\n\t  const name = fields.name ?? runnable.getName();\n\t  const description = fields.description ?? fields.schema?.description;\n\t  if (fields.schema.constructor === zod_1.z.ZodString) {\n\t    return new RunnableToolLike({\n\t      name,\n\t      description,\n\t      schema: zod_1.z.object({\n\t        input: zod_1.z.string()\n\t      }).transform(input => input.input),\n\t      bound: runnable\n\t    });\n\t  }\n\t  return new RunnableToolLike({\n\t    name,\n\t    description,\n\t    schema: fields.schema,\n\t    bound: runnable\n\t  });\n\t}\n\tbase$2.convertRunnableToTool = convertRunnableToTool;\n\n\tvar modifier = {};\n\n\tObject.defineProperty(modifier, \"__esModule\", { value: true });\n\tmodifier.RemoveMessage = void 0;\n\tconst base_js_1$1 = base$3;\n\t/**\n\t * Message responsible for deleting other messages.\n\t */\n\tclass RemoveMessage extends base_js_1$1.BaseMessage {\n\t    constructor(fields) {\n\t        super({\n\t            ...fields,\n\t            content: \"\",\n\t        });\n\t        /**\n\t         * The ID of the message to remove.\n\t         */\n\t        Object.defineProperty(this, \"id\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: void 0\n\t        });\n\t        this.id = fields.id;\n\t    }\n\t    _getType() {\n\t        return \"remove\";\n\t    }\n\t    get _printableFields() {\n\t        return {\n\t            ...super._printableFields,\n\t            id: this.id,\n\t        };\n\t    }\n\t}\n\tmodifier.RemoveMessage = RemoveMessage;\n\n\tObject.defineProperty(transformers, \"__esModule\", { value: true });\n\ttransformers.defaultTextSplitter = transformers.trimMessages = transformers.mergeMessageRuns = transformers.filterMessages = void 0;\n\tconst base_js_1 = base$2;\n\tconst ai_js_1 = ai;\n\tconst chat_js_1 = chat;\n\tconst function_js_1 = _function;\n\tconst human_js_1 = human;\n\tconst modifier_js_1 = modifier;\n\tconst system_js_1 = system;\n\tconst tool_js_1 = tool;\n\tconst utils_js_1 = utils$2;\n\tconst _isMessageType = (msg, types) => {\n\t    const typesAsStrings = [\n\t        ...new Set(types?.map((t) => {\n\t            if (typeof t === \"string\") {\n\t                return t;\n\t            }\n\t            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t            const instantiatedMsgClass = new t({});\n\t            if (!(\"_getType\" in instantiatedMsgClass) ||\n\t                typeof instantiatedMsgClass._getType !== \"function\") {\n\t                throw new Error(\"Invalid type provided.\");\n\t            }\n\t            return instantiatedMsgClass._getType();\n\t        })),\n\t    ];\n\t    const msgType = msg._getType();\n\t    return typesAsStrings.some((t) => t === msgType);\n\t};\n\tfunction filterMessages(messagesOrOptions, options) {\n\t    if (Array.isArray(messagesOrOptions)) {\n\t        return _filterMessages(messagesOrOptions, options);\n\t    }\n\t    return base_js_1.RunnableLambda.from((input) => {\n\t        return _filterMessages(input, messagesOrOptions);\n\t    });\n\t}\n\ttransformers.filterMessages = filterMessages;\n\tfunction _filterMessages(messages, options = {}) {\n\t    const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds, } = options;\n\t    const filtered = [];\n\t    for (const msg of messages) {\n\t        if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n\t            continue;\n\t        }\n\t        else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n\t            continue;\n\t        }\n\t        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n\t            continue;\n\t        }\n\t        // default to inclusion when no inclusion criteria given.\n\t        if (!(includeTypes || includeIds || includeNames)) {\n\t            filtered.push(msg);\n\t        }\n\t        else if (includeNames &&\n\t            msg.name &&\n\t            includeNames.some((iName) => iName === msg.name)) {\n\t            filtered.push(msg);\n\t        }\n\t        else if (includeTypes && _isMessageType(msg, includeTypes)) {\n\t            filtered.push(msg);\n\t        }\n\t        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n\t            filtered.push(msg);\n\t        }\n\t    }\n\t    return filtered;\n\t}\n\tfunction mergeMessageRuns(messages) {\n\t    if (Array.isArray(messages)) {\n\t        return _mergeMessageRuns(messages);\n\t    }\n\t    return base_js_1.RunnableLambda.from(_mergeMessageRuns);\n\t}\n\ttransformers.mergeMessageRuns = mergeMessageRuns;\n\tfunction _mergeMessageRuns(messages) {\n\t    if (!messages.length) {\n\t        return [];\n\t    }\n\t    const merged = [];\n\t    for (const msg of messages) {\n\t        const curr = msg; // Create a shallow copy of the message\n\t        const last = merged.pop();\n\t        if (!last) {\n\t            merged.push(curr);\n\t        }\n\t        else if (curr._getType() === \"tool\" ||\n\t            !(curr._getType() === last._getType())) {\n\t            merged.push(last, curr);\n\t        }\n\t        else {\n\t            const lastChunk = (0, utils_js_1.convertToChunk)(last);\n\t            const currChunk = (0, utils_js_1.convertToChunk)(curr);\n\t            const mergedChunks = lastChunk.concat(currChunk);\n\t            if (typeof lastChunk.content === \"string\" &&\n\t                typeof currChunk.content === \"string\") {\n\t                mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n\t            }\n\t            merged.push(_chunkToMsg(mergedChunks));\n\t        }\n\t    }\n\t    return merged;\n\t}\n\tfunction trimMessages(messagesOrOptions, options) {\n\t    if (Array.isArray(messagesOrOptions)) {\n\t        const messages = messagesOrOptions;\n\t        if (!options) {\n\t            throw new Error(\"Options parameter is required when providing messages.\");\n\t        }\n\t        return _trimMessagesHelper(messages, options);\n\t    }\n\t    else {\n\t        const trimmerOptions = messagesOrOptions;\n\t        return base_js_1.RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions));\n\t    }\n\t}\n\ttransformers.trimMessages = trimMessages;\n\tasync function _trimMessagesHelper(messages, options) {\n\t    const { maxTokens, tokenCounter, strategy = \"last\", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter, } = options;\n\t    if (startOn && strategy === \"first\") {\n\t        throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n\t    }\n\t    if (includeSystem && strategy === \"first\") {\n\t        throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n\t    }\n\t    let listTokenCounter;\n\t    if (\"getNumTokens\" in tokenCounter) {\n\t        listTokenCounter = async (msgs) => {\n\t            const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));\n\t            return tokenCounts.reduce((sum, count) => sum + count, 0);\n\t        };\n\t    }\n\t    else {\n\t        listTokenCounter = async (msgs) => tokenCounter(msgs);\n\t    }\n\t    let textSplitterFunc = defaultTextSplitter;\n\t    if (textSplitter) {\n\t        if (\"splitText\" in textSplitter) {\n\t            textSplitterFunc = textSplitter.splitText;\n\t        }\n\t        else {\n\t            textSplitterFunc = async (text) => textSplitter(text);\n\t        }\n\t    }\n\t    if (strategy === \"first\") {\n\t        return _firstMaxTokens(messages, {\n\t            maxTokens,\n\t            tokenCounter: listTokenCounter,\n\t            textSplitter: textSplitterFunc,\n\t            partialStrategy: allowPartial ? \"first\" : undefined,\n\t            endOn,\n\t        });\n\t    }\n\t    else if (strategy === \"last\") {\n\t        return _lastMaxTokens(messages, {\n\t            maxTokens,\n\t            tokenCounter: listTokenCounter,\n\t            textSplitter: textSplitterFunc,\n\t            allowPartial,\n\t            includeSystem,\n\t            startOn,\n\t            endOn,\n\t        });\n\t    }\n\t    else {\n\t        throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n\t    }\n\t}\n\tasync function _firstMaxTokens(messages, options) {\n\t    const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;\n\t    let messagesCopy = [...messages];\n\t    let idx = 0;\n\t    for (let i = 0; i < messagesCopy.length; i += 1) {\n\t        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n\t        if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n\t            idx = messagesCopy.length - i;\n\t            break;\n\t        }\n\t    }\n\t    if (idx < messagesCopy.length - 1 && partialStrategy) {\n\t        let includedPartial = false;\n\t        if (Array.isArray(messagesCopy[idx].content)) {\n\t            const excluded = messagesCopy[idx];\n\t            if (typeof excluded.content === \"string\") {\n\t                throw new Error(\"Expected content to be an array.\");\n\t            }\n\t            const numBlock = excluded.content.length;\n\t            const reversedContent = partialStrategy === \"last\"\n\t                ? [...excluded.content].reverse()\n\t                : excluded.content;\n\t            for (let i = 1; i <= numBlock; i += 1) {\n\t                const partialContent = partialStrategy === \"first\"\n\t                    ? reversedContent.slice(0, i)\n\t                    : reversedContent.slice(-i);\n\t                const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n\t                const updatedMessage = _switchTypeToMessage(excluded._getType(), {\n\t                    ...fields,\n\t                    content: partialContent,\n\t                });\n\t                const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n\t                if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n\t                    messagesCopy = slicedMessages;\n\t                    idx += 1;\n\t                    includedPartial = true;\n\t                }\n\t                else {\n\t                    break;\n\t                }\n\t            }\n\t            if (includedPartial && partialStrategy === \"last\") {\n\t                excluded.content = [...reversedContent].reverse();\n\t            }\n\t        }\n\t        if (!includedPartial) {\n\t            const excluded = messagesCopy[idx];\n\t            let text;\n\t            if (Array.isArray(excluded.content) &&\n\t                excluded.content.some((block) => typeof block === \"string\" || block.type === \"text\")) {\n\t                const textBlock = excluded.content.find((block) => block.type === \"text\" && block.text);\n\t                text = textBlock?.text;\n\t            }\n\t            else if (typeof excluded.content === \"string\") {\n\t                text = excluded.content;\n\t            }\n\t            if (text) {\n\t                const splitTexts = await textSplitter(text);\n\t                const numSplits = splitTexts.length;\n\t                if (partialStrategy === \"last\") {\n\t                    splitTexts.reverse();\n\t                }\n\t                for (let _ = 0; _ < numSplits - 1; _ += 1) {\n\t                    splitTexts.pop();\n\t                    excluded.content = splitTexts.join(\"\");\n\t                    if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n\t                        maxTokens) {\n\t                        if (partialStrategy === \"last\") {\n\t                            excluded.content = [...splitTexts].reverse().join(\"\");\n\t                        }\n\t                        messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n\t                        idx += 1;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if (endOn) {\n\t        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n\t        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n\t            idx -= 1;\n\t        }\n\t    }\n\t    return messagesCopy.slice(0, idx);\n\t}\n\tasync function _lastMaxTokens(messages, options) {\n\t    const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;\n\t    if (endOn) {\n\t        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n\t        while (messages &&\n\t            !_isMessageType(messages[messages.length - 1], endOnArr)) {\n\t            messages.pop();\n\t        }\n\t    }\n\t    const swappedSystem = includeSystem && messages[0]._getType() === \"system\";\n\t    let reversed_ = swappedSystem\n\t        ? messages.slice(0, 1).concat(messages.slice(1).reverse())\n\t        : messages.reverse();\n\t    reversed_ = await _firstMaxTokens(reversed_, {\n\t        ...rest,\n\t        partialStrategy: allowPartial ? \"last\" : undefined,\n\t        endOn: startOn,\n\t    });\n\t    if (swappedSystem) {\n\t        return [reversed_[0], ...reversed_.slice(1).reverse()];\n\t    }\n\t    else {\n\t        return reversed_.reverse();\n\t    }\n\t}\n\tconst _MSG_CHUNK_MAP = {\n\t    human: {\n\t        message: human_js_1.HumanMessage,\n\t        messageChunk: human_js_1.HumanMessageChunk,\n\t    },\n\t    ai: {\n\t        message: ai_js_1.AIMessage,\n\t        messageChunk: ai_js_1.AIMessageChunk,\n\t    },\n\t    system: {\n\t        message: system_js_1.SystemMessage,\n\t        messageChunk: system_js_1.SystemMessageChunk,\n\t    },\n\t    tool: {\n\t        message: tool_js_1.ToolMessage,\n\t        messageChunk: tool_js_1.ToolMessageChunk,\n\t    },\n\t    function: {\n\t        message: function_js_1.FunctionMessage,\n\t        messageChunk: function_js_1.FunctionMessageChunk,\n\t    },\n\t    generic: {\n\t        message: chat_js_1.ChatMessage,\n\t        messageChunk: chat_js_1.ChatMessageChunk,\n\t    },\n\t    remove: {\n\t        message: modifier_js_1.RemoveMessage,\n\t        messageChunk: modifier_js_1.RemoveMessage, // RemoveMessage does not have a chunk class.\n\t    },\n\t};\n\tfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n\t    let msg;\n\t    switch (messageType) {\n\t        case \"human\":\n\t            {\n\t                msg = new human_js_1.HumanMessage(fields);\n\t            }\n\t            break;\n\t        case \"ai\":\n\t            {\n\t                msg = new ai_js_1.AIMessage(fields);\n\t            }\n\t            break;\n\t        case \"system\":\n\t            {\n\t                msg = new system_js_1.SystemMessage(fields);\n\t            }\n\t            break;\n\t        case \"tool\":\n\t            if (\"tool_call_id\" in fields) {\n\t                {\n\t                    msg = new tool_js_1.ToolMessage(fields);\n\t                }\n\t            }\n\t            else {\n\t                throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n\t            }\n\t            break;\n\t        case \"function\":\n\t            {\n\t                if (!fields.name) {\n\t                    throw new Error(\"FunctionMessage must have a 'name' field\");\n\t                }\n\t                msg = new function_js_1.FunctionMessage(fields);\n\t            }\n\t            break;\n\t        case \"generic\":\n\t            if (\"role\" in fields) {\n\t                {\n\t                    msg = new chat_js_1.ChatMessage(fields);\n\t                }\n\t            }\n\t            else {\n\t                throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n\t            }\n\t            break;\n\t        default:\n\t            throw new Error(`Unrecognized message type ${messageType}`);\n\t    }\n\t    if (msg) {\n\t        return msg;\n\t    }\n\t    throw new Error(`Unrecognized message type ${messageType}`);\n\t}\n\tfunction _chunkToMsg(chunk) {\n\t    const chunkType = chunk._getType();\n\t    let msg;\n\t    const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n\t    if (chunkType in _MSG_CHUNK_MAP) {\n\t        msg = _switchTypeToMessage(chunkType, fields);\n\t    }\n\t    if (!msg) {\n\t        throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n\t    }\n\t    return msg;\n\t}\n\t/**\n\t * The default text splitter function that splits text by newlines.\n\t *\n\t * @param {string} text\n\t * @returns A promise that resolves to an array of strings split by newlines.\n\t */\n\tfunction defaultTextSplitter(text) {\n\t    const splits = text.split(\"\\n\");\n\t    return Promise.resolve([\n\t        ...splits.slice(0, -1).map((s) => `${s}\\n`),\n\t        splits[splits.length - 1],\n\t    ]);\n\t}\n\ttransformers.defaultTextSplitter = defaultTextSplitter;\n\n\t(function (exports) {\n\t\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t\t    }\n\t\t    Object.defineProperty(o, k2, desc);\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {\n\t\t    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.ToolMessageChunk = exports.ToolMessage = void 0;\n\t\t__exportStar(ai, exports);\n\t\t__exportStar(base$3, exports);\n\t\t__exportStar(chat, exports);\n\t\t__exportStar(_function, exports);\n\t\t__exportStar(human, exports);\n\t\t__exportStar(system, exports);\n\t\t__exportStar(utils$2, exports);\n\t\t__exportStar(transformers, exports);\n\t\t__exportStar(modifier, exports);\n\t\t// TODO: Use a star export when we deprecate the\n\t\t// existing \"ToolCall\" type in \"base.js\".\n\t\tvar tool_js_1 = tool;\n\t\tObject.defineProperty(exports, \"ToolMessage\", { enumerable: true, get: function () { return tool_js_1.ToolMessage; } });\n\t\tObject.defineProperty(exports, \"ToolMessageChunk\", { enumerable: true, get: function () { return tool_js_1.ToolMessageChunk; } }); \n\t} (messages$2));\n\n\tvar messages = messages$2;\n\n\texports.ai = ai;\n\texports.async_caller = async_caller;\n\texports.base = base$2;\n\texports.base$1 = base$3;\n\texports.browser$1 = browser$1;\n\texports.cjs = cjs;\n\texports.commonjsGlobal = commonjsGlobal;\n\texports.config = config;\n\texports.env = env$2;\n\texports.event_stream = event_stream;\n\texports.fastJsonPatch = fastJsonPatch;\n\texports.getAugmentedNamespace = getAugmentedNamespace;\n\texports.global = global$1;\n\texports.human = human;\n\texports.json = json;\n\texports.lib = lib;\n\texports.log_stream = log_stream;\n\texports.manager = manager;\n\texports.messages = messages;\n\texports.messages$1 = messages$2;\n\texports.nextTick = nextTick;\n\texports.outputs = outputs;\n\texports.serializable = serializable;\n\texports.singletons = singletons;\n\texports.stream = stream;\n\texports.tool = tool;\n\texports.utils = utils$2;\n\texports.utils$1 = utils$1;\n\n}));\n",
      "type": "chunk"
    }
  ]
}